#ifndef GATEWARE_H
#define GATEWARE_H

/* File created by GW Header Compiler version 1.2.0 */

/*
The MIT License (MIT)

Copyright (c) 2016-2021 7thGate Software .LLC

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

******************************************************************************

The MIT License (MIT)

Copyright (c) 1998-2019 Toni Ronkko

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

******************************************************************************

Copyright (c) 2017 The Khronos Group Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*******************************************************************************

Copyright (c) 2013-2017 The Khronos Group Inc.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and/or associated documentation files (the
"Materials"), to deal in the Materials without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Materials, and to
permit persons to whom the Materials are furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Materials.

THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.

*******************************************************************************

Copyright 2013-2020 The Khronos Group Inc.
SPDX-License-Identifier: MIT

This header is generated from the Khronos OpenGL / OpenGL ES XML
API Registry. The current version of the Registry, generator scripts
used to make the header, and the header can be found at
https://github.com/KhronosGroup/OpenGL-Registry

*******************************************************************************


*/
// This file is automatically generated by our CMake build scripts.
// Authors: Gerard Vega (original CMake build system) & Yangjie Yao(Wolfram auto-versioning)

#ifndef GVERSION_HPP
#define GVERSION_HPP

// Ensure developers are only building Gateware on x64 platforms.
static_assert(sizeof(void*) == 8, "Gateware supports x64 platforms only.");

// The Major version is increased when a new library is added.(minor & patch are reset)
#define GATEWARE_MAJOR 2
// The Minor version is increased whenever an interface is altered.(patch is reset)
#define GATEWARE_MINOR 0
// The Patch version is increased whenever a bug or leak is fixed.(nothing is reset)
#define GATEWARE_PATCH 'b'
// Pulled directly from GIT  
#define GATEWARE_BRANCH "master"
// Pulled directly from GIT
#define GATEWARE_COMMIT_HASH 0x96078a9
// Standard Window Title Bar
#define GATEWARE_VERSION_STRING "Gateware v2.0b"
// Window Title Bar displayed in DEBUG builds
#define GATEWARE_VERSION_STRING_LONG "Gateware v2.0b (master) [96078a9]"

#endif

/*---------------------------------
|	Begin of GGraphicsDefines.h
----------------------------------*/
#ifndef GGRAPHICSDEFINES_H
#define GGRAPHICSDEFINES_H


namespace GW
{
	namespace GRAPHICS
	{
		enum GGraphicsInitOptions
		{
			COLOR_10_BIT			= 0x1,		
			DEPTH_BUFFER_SUPPORT	= 0x2,		
			DEPTH_STENCIL_SUPPORT	= 0X4,		
			OPENGL_ES_SUPPORT		= 0x8,		
			DIRECT2D_SUPPORT		= 0x10,		
			TRIPLE_BUFFER			= 0x20,		
			MSAA_2X_SUPPORT			= 0x40,		
			MSAA_4X_SUPPORT			= 0x80,		
			MSAA_8X_SUPPORT			= 0x100,	
			MSAA_16X_SUPPORT		= 0x200,	
			MSAA_32X_SUPPORT		= 0x400,	
			MSAA_64X_SUPPORT		= 0x800,	
		};

		enum GRasterUpdateFlags
		{
			ALIGN_X_LEFT			= 0x1,		
			ALIGN_X_CENTER			= 0x2,		
			ALIGN_X_RIGHT			= 0x4,		
			ALIGN_Y_TOP				= 0x8,		
			ALIGN_Y_CENTER			= 0x10,		
			ALIGN_Y_BOTTOM			= 0x20,		
			UPSCALE_2X				= 0x40,		
			UPSCALE_3X				= 0x80,		
			UPSCALE_4X				= 0x100,	
			UPSCALE_8X				= 0x200,	
			UPSCALE_16X				= 0x400,	
			STRETCH_TO_FIT			= 0x800,	
			INTERPOLATE_NEAREST		= 0x1000,	
			INTERPOLATE_BILINEAR	= 0x2000,	
		};
	}
}

#endif // GGRAPHICSDEFINES_H

/*---------------------------------
|	End of GGraphicsDefines.h
----------------------------------*/


/*---------------------------------
|	Begin of GMathDefines.h
----------------------------------*/
#ifndef GMATHDEFINES_H
#define GMATHDEFINES_H


#define G_PI					3.14159265358979323846
#define G_PI_F					3.141592f

#define G_PI_R					0.318309886183790671538
#define G_PI_R_F				0.3183098f

#define G_TAU						(2.0 * G_PI)
#define G_TAU_F						(2.0f * G_PI_F)

#define G_TAU_R						(2.0 * G_PI_R)
#define G_TAU_R_F					(2.0f * G_PI_R_F)

#define G_EPSILON_F					1.192092896e-07F
#define G_EPSILON_D					2.2204460492503131e-016

#define G_ABS(num)					( ( (num) > 0 ) ? (num) : (-(num)) )				//RETURN THE ABSOLUTE VALUE OF THE INPUT NUMBER
#define G_LARGER(A, B)				( ( (A) > (B) ) ? (A) : (B) )						//RETURN THE LARGER INPUT NUMBER
#define G_SMALLER(A, B)				( ( (A) < (B) ) ? (A) : (B) )						//RETURN THE SMALLER INPUT NUMBER
#define G_ABS_LARGER(A, B)			( ( G_ABS(A) > G_ABS(B) ) ?  G_ABS(A) : G_ABS(B) )	//RETURN THE LARGER ABSOLUTE VALUE OF THE TWO INPUT NUMBERS

#define G_DEVIATION_EXACT			0
#define G_DEVIATION_PRECISE_F		G_EPSILON_F
#define G_DEVIATION_STANDARD_F		(G_EPSILON_F * 10)
#define G_DEVIATION_LOOSE_F			(G_EPSILON_F * 100)

#define G_DEVIATION_PRECISE_D		G_EPSILON_D
#define G_DEVIATION_STANDARD_D		(G_EPSILON_D * 10)
#define G_DEVIATION_LOOSE_D			(G_EPSILON_D * 100)

#define G_FIRST_COMPARISON_F(num1 , num2)		( G_ABS( (num1) - (num2) ) <= ( G_EPSILON_F ) ) //FIRST CHECK IF TWO INPUT FLOATS' DIFF ARE LESS THAN EPSILON
#define G_SECOND_COMPARISON_F(num1 , num2)		( G_ABS( (num1) - (num2) ) <= ( G_DEVIATION_STANDARD_F * G_ABS_LARGER(num1, num2)) ) //SECOND CHECK IF TWO INPUT FLOATS' DIFF ARE LESS THAN EPSILON MULTIPLY THE LARGER INPUT FLOAT
#define G_COMPARISON_STANDARD_F(num1 , num2)	( G_FIRST_COMPARISON_F( (num1), (num2) ) ? true : G_SECOND_COMPARISON_F( (num1) , (num2) ) )
#define G_COMPARISON_F(num1, num2, deviation)	( G_FIRST_COMPARISON_F( (num1), (num2) ) ? true : ( G_ABS( (num1) - (num2) ) <= ( deviation * G_ABS_LARGER(num1, num2)) ) )

#define G_FIRST_COMPARISON_D(num1 , num2)		( G_ABS( (num1) - (num2) ) <= ( G_EPSILON_D ) )	//FIRST CHECK IF TWO INPUT FLOATS' DIFF ARE LESS THAN EPSILON
#define G_SECOND_COMPARISON_D(num1 , num2)		( G_ABS( (num1) - (num2) ) <= ( G_DEVIATION_STANDARD_D * G_ABS_LARGER(num1, num2)) ) //SECOND CHECK IF TWO INPUT FLOATS' DIFF ARE LESS THAN EPSILON MULTIPLY THE LARGER INPUT FLOAT
#define G_COMPARISON_STANDARD_D(num1 , num2)	( G_FIRST_COMPARISON_D( (num1), (num2) ) ? true : G_SECOND_COMPARISON_D( (num1) , (num2) ) )
#define G_COMPARISON_D(num1, num2, deviation)	( G_FIRST_COMPARISON_D( (num1), (num2) ) ? true : ( G_ABS( (num1) - (num2) ) <= ( deviation * (G_ABS_LARGER(num1, num2))) ) )

#define G_LERP(start, end, ratio)			( (start) + (ratio) * ((end) - (start)) )				//LINEARLY INTERPOLATE BETWEEN TWO VALUES BY A RATIO
#define G_LERP_PRECISE(start, end, ratio)	( ((1.0 - (ratio)) * (start)) + ((ratio) * (end)) )		//LINEARLY INTERPOLATE BETWEEN TWO VALUES BY A RATIO, AVOIDING SOME RARE EDGE CASES

#define G_CLAMP(num, min, max)		( ((num) > (max)) ? (max) : ( ((num) < (min)) ? (min) : (num) ) )	//CLAMP THE NUMBER BETWEEN THE TOP NUMBER AND THE BOTTOM NUMBER
#define G_CLAMP_MIN(num, min)		( ((num) < (min)) ? (min) : (num) )									//CLAMP THE NUMBER BETWEEN ITSELF AND THE BOTTOM NUMBER
#define G_CLAMP_MAX(num, max)		( ((num) > (max)) ? (max) : (num) )									//CLAMP THE NUMBER BETWEEN ITSELF AND THE TOP NUMBER

#define G_DEGREE_TO_RADIAN(degree)	( (degree) * ( (G_PI) / (180.0) ) )
#define G_RADIAN_TO_DEGREE(radian)	( (radian) * ( (180.0) / (G_PI) ) )



namespace GW
{
	namespace MATH
	{

		// Ensure identical binary padding for structures on all platforms.
#pragma pack(push, 1)

		struct GVECTORF
		{
			union
			{
				struct
				{
					float x;
					float y;
					float z;
					float w;
				};
				float data[4];
			};

			inline const GVECTORF xy() const
			{
				return GVECTORF{{{this->x, this->y, 0.0f, 0.0f}}};
			}

			inline const GVECTORF xyz() const
			{
				return GVECTORF{{{this->x, this->y, this->z, 0.0f}}};
			}

			inline const GVECTORF xyzw() const
			{
				return *this;
			}
		};

		struct GVECTORD
		{
			union
			{
				struct
				{
					double x;
					double y;
					double z;
					double w;
				};
				double data[4];
			};

			inline const GVECTORD xy() const
			{
				return GVECTORD{{{this->x, this->y, 0.0, 0.0}}};
			}

			inline const GVECTORD xyz() const
			{
				return GVECTORD{{{this->x, this->y, this->z, 0.0}}};
			}

			inline const GVECTORD xyzw() const
			{
				return *this;
			}
		};
		struct GMATRIXF
		{
			union
			{
				struct
				{
					GVECTORF row1;
					GVECTORF row2;
					GVECTORF row3;
					GVECTORF row4;
				};

				float data[16];
			};
		};

		struct GMATRIXD
		{
			union
			{
				struct
				{
					GVECTORD row1;
					GVECTORD row2;
					GVECTORD row3;
					GVECTORD row4;
				};
				double data[16];
			};
		};

		struct GQUATERNIONF
		{
			union
			{
				struct
				{
					float x;
					float y;
					float z;
					float w;
				};
				float data[4];
			};
		};

		struct GQUATERNIOND
		{
			union
			{
				struct
				{
					double x;
					double y;
					double z;
					double w;
				};
				double data[4];
			};
		};

		struct GLINEF
		{
			union
			{
				struct
				{
					GVECTORF start;
					GVECTORF end;
				};
				GVECTORF data[2];
			};

			GVECTORF* operator&()
			{
				return data;
			}

			const GVECTORF* operator&() const
			{
				return data;
			}
		};

		struct GLINED
		{
			union
			{
				struct
				{
					GVECTORD start;
					GVECTORD end;
				};
				GVECTORD data[2];
			};

			GVECTORD* operator&()
			{
				return data;
			}

			const GVECTORD* operator&() const
			{
				return data;
			}
		};

		struct GRAYF
		{
			union
			{
				struct
				{
					GVECTORF position;
					GVECTORF direction;
				};
				GVECTORF data[2];
			};

			GVECTORF* operator&()
			{
				return data;
			}

			const GVECTORF* operator&() const
			{
				return data;
			}
		};

		struct GRAYD
		{
			union
			{
				struct
				{
					GVECTORD position;
					GVECTORD direction;
				};
				GVECTORD data[2];
			};

			GVECTORD* operator&()
			{
				return data;
			}

			const GVECTORD* operator&() const
			{
				return data;
			}
		};

		struct GTRIANGLEF
		{
			union
			{
				struct
				{
					GVECTORF a;
					GVECTORF b;
					GVECTORF c;
				};
				GVECTORF data[3];
			};

			GVECTORF* operator&()
			{
				return data;
			}

			const GVECTORF* operator&() const
			{
				return data;
			}
		};

		struct GTRIANGLED
		{
			union
			{
				struct
				{
					GVECTORD a;
					GVECTORD b;
					GVECTORD c;
				};
				GVECTORD data[3];
			};

			GVECTORD* operator&()
			{
				return data;
			}

			const GVECTORD* operator&() const
			{
				return data;
			}
		};

		struct GPLANEF
		{
			union
			{
				struct
				{
					float x;
					float y;
					float z;
					float distance;
				};
				GVECTORF data;
			};

			GVECTORF* operator&()
			{
				return &data;
			}

			const GVECTORF* operator&() const
			{
				return &data;
			}
		};

		struct GPLANED
		{
			union
			{
				struct
				{
					double x;
					double y;
					double z;
					double distance;
				};
				GVECTORD data;
			};

			GVECTORD* operator&()
			{
				return &data;
			}

			const GVECTORD* operator&() const
			{
				return &data;
			}
		};

		struct GSPHEREF
		{
			union
			{
				struct
				{
					float x;
					float y;
					float z;
					float radius;
				};
				GVECTORF data;
			};

			GVECTORF* operator&()
			{
				return &data;
			}

			const GVECTORF* operator&() const
			{
				return &data;
			}
		};

		struct GSPHERED
		{
			union
			{
				struct
				{
					double x;
					double y;
					double z;
					double radius;
				};
				GVECTORD data;
			};

			GVECTORD* operator&()
			{
				return &data;
			}

			const GVECTORD* operator&() const
			{
				return &data;
			}
		};

		struct GCAPSULEF
		{
			union
			{
				struct
				{
					float start_x;
					float start_y;
					float start_z;
					float radius;
					float end_x;
					float end_y;
					float end_z;
					float reserved;
				};
				GVECTORF data[2];
			};

			GVECTORF* operator&()
			{
				return data;
			}

			const GVECTORF* operator&() const
			{
				return data;
			}
		};

		struct GCAPSULED
		{
			union
			{
				struct
				{
					double start_x;
					double start_y;
					double start_z;
					double radius;
					double end_x;
					double end_y;
					double end_z;
					double reserved;
				};
				GVECTORD data[2];
			};

			GVECTORD* operator&()
			{
				return data;
			}

			const GVECTORD* operator&() const
			{
				return data;
			}
		};

		struct GAABBCEF
		{
			union
			{
				struct
				{
					GVECTORF center;
					GVECTORF extent;
				};
				GVECTORF data[2];
			};

			GVECTORF* operator&()
			{
				return data;
			}

			const GVECTORF* operator&() const
			{
				return data;
			}
		};

		struct GAABBCED
		{
			union
			{
				struct
				{
					GVECTORD center;
					GVECTORD extent;
				};
				GVECTORD data[2];
			};

			GVECTORD* operator&()
			{
				return data;
			}

			const GVECTORD* operator&() const
			{
				return data;
			}
		};

		struct GAABBMMF
		{
			union
			{
				struct
				{
					GVECTORF min;
					GVECTORF max;
				};
				GVECTORF data[2];
			};

			GVECTORF* operator&()
			{
				return data;
			}

			const GVECTORF* operator&() const
			{
				return data;
			}
		};

		struct GAABBMMD
		{
			union
			{
				struct
				{
					GVECTORD min;
					GVECTORD max;
				};
				GVECTORD data[2];
			};

			GVECTORD* operator&()
			{
				return data;
			}

			const GVECTORD* operator&() const
			{
				return data;
			}
		};

		struct GOBBF
		{
			union
			{
				struct
				{
					GVECTORF center;
					GVECTORF extent;
					GQUATERNIONF rotation;
				};
				GVECTORF data[3];
			};

			GVECTORF* operator&()
			{
				return data;
			}

			const GVECTORF* operator&() const
			{
				return data;
			}
		};

		struct GOBBD
		{
			union
			{
				struct
				{
					GVECTORD center;
					GVECTORD extent;
					GQUATERNIOND rotation;
				};
				GVECTORD data[3];
			};

			GVECTORD* operator&()
			{
				return data;
			}

			const GVECTORD* operator&() const
			{
				return data;
			}
		};
#pragma pack(pop)

		static const GVECTORF GIdentityVectorF{{{0,0,0,1}}};
		static const GVECTORD GIdentityVectorD{{{0,0,0,1}}};
		static const GVECTORF GZeroVectorF{{{0,0,0,0}}};
		static const GVECTORD GZeroVectorD{{{0,0,0,0}}};

		static const GMATRIXF GIdentityMatrixF{{{{{{1,0,0,0}}},{{{0,1,0,0}}},{{{0,0,1,0}}},{{{0,0,0,1}}}}}};
		static const GMATRIXD GIdentityMatrixD{{{{{{1,0,0,0}}},{{{0,1,0,0}}},{{{0,0,1,0}}},{{{0,0,0,1}}}}}};
		static const GMATRIXF GZeroMatrixF{{{{{{0,0,0,0}}},{{{0,0,0,0}}},{{{0,0,0,0}}},{{{0,0,0,0}}}}}};
		static const GMATRIXD GZeroMatrixD{{{{{{0,0,0,0}}},{{{0,0,0,0}}},{{{0,0,0,0}}},{{{0,0,0,0}}}}}};

		static const GQUATERNIONF GIdentityQuaternionF{{{0,0,0,1}}};
		static const GQUATERNIOND GIdentityQuaternionD{{{0,0,0,1}}};
		static const GQUATERNIONF GZeroQuaternionF{{{0,0,0,0}}};
		static const GQUATERNIOND GZeroQuaternionD{{{0,0,0,0}}};
	}
}
#endif // GMATHDEFINES_H


/*---------------------------------
|	End of GMathDefines.h
----------------------------------*/


/*---------------------------------
|	Begin of GInputDefines.h
----------------------------------*/
#ifndef GINPUTDEFINES_H
#define GINPUTDEFINES_H



// All GInput/GBufferedInput Key definitions follow
#define G_KEY_UNKNOWN			0		 
#define G_KEY_ESCAPE			1		 
#define G_KEY_MINUS				2		 
#define G_KEY_EQUALS			3		 
#define G_KEY_BACKSPACE			4		 
#define G_KEY_TAB				5		 
#define G_KEY_BRACKET_OPEN		6		 
#define G_KEY_BRACKET_CLOSE		7		 
#define G_KEY_ENTER				8		 
#define G_KEY_LEFTCONTROL		9		 
#define G_KEY_RIGHTCONTROL		10		 
#define G_KEY_SEMICOLON			11		 
#define G_KEY_QUOTE				12		 
#define G_KEY_TILDE				13		 
#define G_KEY_LEFTSHIFT			14		 
#define G_KEY_BACKSLASH			15		 
#define G_KEY_COMMA				16		 
#define G_KEY_PERIOD			17		 
#define G_KEY_FORWARDSLASH		18		 
#define G_KEY_RIGHTSHIFT		19		 
#define G_KEY_PRINTSCREEN		20		 
#define G_KEY_LEFTALT			21		 
#define G_KEY_RIGHTALT			22		 
#define G_KEY_SPACE				23		 
#define G_KEY_CAPSLOCK			24		 
#define G_KEY_NUMLOCK			25		 
#define G_KEY_SCROLL_LOCK		26		 
#define G_KEY_PAUSE				27		 
#define G_KEY_HOME				28		 
#define G_KEY_UP				29		 
#define G_KEY_PAGEUP			30		 
#define G_KEY_LEFT				31		 
#define G_KEY_RIGHT				32		 
#define G_KEY_END				33		 
#define G_KEY_DOWN				34		 
#define G_KEY_PAGEDOWN			35		 
#define G_KEY_INSERT			36		 
#define G_KEY_DELETE			37		 

// Characters
#define G_KEY_A					38		 
#define G_KEY_B					39		 
#define G_KEY_C					40		 
#define G_KEY_D					41		 
#define G_KEY_E					42		 
#define G_KEY_F					43		 
#define G_KEY_G					44		 
#define G_KEY_H					45		 
#define G_KEY_I					46		 
#define G_KEY_J					47		 
#define G_KEY_K					48		 
#define G_KEY_L					49		 
#define G_KEY_M					50		 
#define G_KEY_N					51		 
#define G_KEY_O					52		 
#define G_KEY_P					53		 
#define G_KEY_Q					54		 
#define G_KEY_R					55		 
#define G_KEY_S					56		 
#define G_KEY_T					57		 
#define G_KEY_U					58		 
#define G_KEY_V					59		 
#define G_KEY_W					60		 
#define G_KEY_X					61		 
#define G_KEY_Y					62		 
#define G_KEY_Z					63		 

// Numbers
#define G_KEY_0					64		 
#define G_KEY_1					65		 
#define G_KEY_2					66		 
#define G_KEY_3					67		 
#define G_KEY_4					68		 
#define G_KEY_5					69		 
#define G_KEY_6					70		 
#define G_KEY_7					71		 
#define G_KEY_8					72		 
#define G_KEY_9					73		 

// Function Keys
#define G_KEY_F1				74		 
#define G_KEY_F2				75		 
#define G_KEY_F3				76		 
#define G_KEY_F4				77		 
#define G_KEY_F5				78		 
#define G_KEY_F6				79		 
#define G_KEY_F7				80		 
#define G_KEY_F8				81		 
#define G_KEY_F9				82		 
#define G_KEY_F10				83		 
#define G_KEY_F11				84		 
#define G_KEY_F12				85		 

// Numpad
#define G_KEY_NUMPAD_ADD		86		 
#define G_KEY_NUMPAD_SUBTRACT	87		 
#define G_KEY_NUMPAD_MULTIPLY	88		 
#define G_KEY_NUMPAD_DIVIDE		89	 	 
#define G_KEY_NUMPAD_0			90 		 
#define G_KEY_NUMPAD_1		 	91	 	 
#define G_KEY_NUMPAD_2			92 		 
#define G_KEY_NUMPAD_3			93 		 
#define G_KEY_NUMPAD_4			94 		 
#define G_KEY_NUMPAD_5			95 		 
#define G_KEY_NUMPAD_6			96 		 
#define G_KEY_NUMPAD_7			97 		 
#define G_KEY_NUMPAD_8			98 		 
#define G_KEY_NUMPAD_9			99 	 	 
#define G_KEY_NUMPAD_PERIOD		100	 	 
#define G_KEY_NUMPAD_ENTER		101	 	 

// Special
#define G_KEY_COMMAND           102      
#define G_KEY_FUNCTION          103      

// Mouse 
#define G_BUTTON_LEFT			200		 
#define G_BUTTON_RIGHT			201		 
#define G_BUTTON_MIDDLE			202		 
#define G_MOUSE_SCROLL_UP		203		 
#define G_MOUSE_SCROLL_DOWN		204		 

// Key Masks 
#define G_MASK_SHIFT			0		 
#define G_MASK_CAPS_LOCK		1		 
#define G_MASK_CONTROL			2		 
#define G_MASK_SCROLL_LOCK		3		 
#define G_MASK_NUM_LOCK			4		 
#define G_MASK_COMMAND          5		 
#define G_MASK_ALT              6		 
#define G_MASK_FUNCTION         7		 



// All GController Input definitions follow
#define G_SOUTH_BTN						0 
#define G_EAST_BTN						1 
#define G_NORTH_BTN						2 
#define G_WEST_BTN						3 
#define G_LEFT_SHOULDER_BTN				4 
#define G_RIGHT_SHOULDER_BTN			5 
#define G_LEFT_TRIGGER_AXIS				6 
#define G_RIGHT_TRIGGER_AXIS			7 
#define G_DPAD_LEFT_BTN					8 
#define G_DPAD_RIGHT_BTN				9 
#define G_DPAD_UP_BTN					10 
#define G_DPAD_DOWN_BTN					11 
#define G_LEFT_THUMB_BTN				12 
#define G_RIGHT_THUMB_BTN				13 
#define G_START_BTN						14 
#define G_SELECT_BTN					15 
#define G_LX_AXIS						16 
#define G_LY_AXIS						17 
#define G_RX_AXIS						18 
#define G_RY_AXIS						19 
#define G_UNKNOWN_INPUT                 255 


// Bit-manip macros
#define G_CHECK_BIT(var,pos) ((var) & (1<<(pos)))
#define G_TURNON_BIT(var,pos) ((var) |=  (1<<(pos)))
#define G_TURNOFF_BIT(var,pos) ((var) &= ~(1<<(pos)))
#define G_TOGGLE_BIT(var, pos) (G_CHECK_BIT(var, pos) ? (G_TURNOFF_BIT(var,pos)) : (G_TURNON_BIT(var,pos)))

// The interval daemon operation will run at for GInput (Linux only)
#define G_INPUT_OPERATION_INTERVAL 4
// The interval daemon operation will run at for GBufferedInput (Linux only)
#define G_BUFFEREDINPUT_OPERATION_INTERVAL 6
// The interval daemon operation will run at for GController
#define G_CONTROLLER_DAEMON_OPERATION_INTERVAL 4
// The interval daemon operation will run at for GController notify daemon
#define G_CONTROLLER_NOTIFY_DAEMON_OPERATION_INTERVAL 2

namespace GW
{
	namespace INPUT
	{
		enum class GControllerType
		{
			GENERAL,	
			PS3,		
			PS4,		
			PS5,		
			STEAM,		
			SWITCHPRO,	
			XBOX360,	
			XBOXONE,	
			XBOXSERIES,	
		};
	}
}
#endif // #endif GINPUTDEFINES_H


/*---------------------------------
|	End of GInputDefines.h
----------------------------------*/


/*---------------------------------
|	Begin of GMath2DDefines.h
----------------------------------*/
#ifndef GMATH2DDEFINES_H
#define GMATH2DDEFINES_H


#define G2D_PI						3.14159265358979323846
#define G2D_PI_F					3.141592f

#define G2D_PI_R					0.318309886183790671538
#define G2D_PI_R_F					0.3183098f

#define G2D_EPSILON_F				1.192092896e-07F
#define G2D_EPSILON_D				2.2204460492503131e-016

#define G2D_ABS(num)				( ( (num) > 0 ) ?  (num) : (-(num)) )	//RETURN THE ABSOLUTE VALUE OF THE INPUT NUMBER
#define G2D_MAX(A, B)			( ( (A) > (B) ) ?  (A) : (B) )			//RETURN THE LARGER INPUT NUMBER
#define G2D_MIN(A, B)			( ( (A) < (B) ) ?  (A) : (B) )			//RETURN THE SMALLER INPUT NUMBER
#define G2D_ABS_MAX(A, B)		( ( G2D_ABS(A) > G2D_ABS(B) ) ?  G2D_ABS(A) : G2D_ABS(B) )

#define G2D_DEVIATION_EXACT 0
#define G2D_DEVIATION_PRECISE_F G2D_EPSILON_F
#define G2D_DEVIATION_STANDARD_F (G2D_EPSILON_F * 10)
#define G2D_DEVIATION_LOOSE_F (G2D_EPSILON_F * 100)

#define G2D_DEVIATION_PRECISE_D G2D_EPSILON_D
#define G2D_DEVIATION_STANDARD_D (G2D_EPSILON_D * 10)
#define G2D_DEVIATION_LOOSE_D (G2D_EPSILON_D * 100)

#define G2D_FIRST_COMPARISON_F(num1 , num2)   ( G2D_ABS( (num1) - (num2) ) <= ( G2D_EPSILON_F ) )	//FIRST CHECK IF TWO INPUT FLOATS' DIFF ARE LESS THAN EPSILON
#define G2D_SECOND_COMPARISON_F(num1 , num2)   ( G2D_ABS( (num1) - (num2) ) <= ( G2D_DEVIATION_STANDARD_F * G2D_ABS_MAX(num1, num2)) ) 	//SECOND CHECK IF TWO INPUT FLOATS' DIFF ARE LESS THAN EPSILON MULTIPLY THE LARGER INPUT FLOAT
#define G2D_COMPARISON_STANDARD_F(num1 , num2)   ( G2D_FIRST_COMPARISON_F( (num1), (num2) ) ? true : G2D_SECOND_COMPARISON_F( (num1) , (num2) ) )
#define G2D_COMPARISON_F(num1, num2, deviation) ( G2D_FIRST_COMPARISON_F( (num1), (num2) )	? true :  ( G2D_ABS( (num1) - (num2) ) <=  ( deviation * G2D_ABS_MAX(num1, num2)) )  )

#define G2D_FIRST_COMPARISON_D(num1 , num2)   ( G2D_ABS( (num1) - (num2) ) <= ( G2D_EPSILON_D ) )	//FIRST CHECK IF TWO INPUT FLOATS' DIFF ARE LESS THAN EPSILON
#define G2D_SECOND_COMPARISON_D(num1 , num2)   ( G2D_ABS( (num1) - (num2) ) <= ( G2D_DEVIATION_STANDARD_D * G2D_ABS_MAX(num1, num2)) ) //SECOND CHECK IF TWO INPUT FLOATS' DIFF ARE LESS THAN EPSILON MULTIPLY THE LARGER INPUT FLOAT
#define G2D_COMPARISON_STANDARD_D(num1 , num2)   ( G2D_FIRST_COMPARISON_D( (num1), (num2) ) ? true : G2D_SECOND_COMPARISON_D( (num1) , (num2) ) )
#define G2D_COMPARISON_D(num1 , num2, deviation)   ( G2D_FIRST_COMPARISON_D( (num1), (num2) ) ? true :( G2D_ABS( (num1) - (num2) ) <= ( deviation * (G2D_ABS_MAX(num1, num2))) )  )

#define G2D_LERP(start , end, ratio)  ( start + ratio * (end - start) )		//LINEAR INTERPOLATE TWO POINT WITH THE RATIO
#define G2D_CLAMP(num, min, max)  (((num) > (max)) ? (max) : (((num) < (min)) ? (min) : (num)))	//CLAMP THE NUMBER BETWEEN THE TOP NUMBER AND THE BOTTOM NUMBER

#define G2D_DEGREE_TO_RADIAN(degree) ( (degree) * ( (G2D_PI) / (180.0) ) )
#define G2D_RADIAN_TO_DEGREE(radian) ( (radian) * ( (180.0) / (G2D_PI) ) )



namespace GW
{
	namespace MATH2D
	{

		// Ensure identical byte alignment for structures on all platforms.
#pragma pack(push, 1)

		struct GVECTOR2F
		{
			union 
			{
				struct
				{
					float x;
					float y;
				};
				float data[2];
			};
		};

		struct GVECTOR2D
		{
			union
			{
				struct
				{
					double x;
					double y;
				};
				double data[2];
			};
		};

		struct GVECTOR3F
		{
			union
			{
				struct
				{
					float x;
					float y;
					float z;
				};
				float data[3];
			};

			inline const GVECTOR2F xy() const
			{
				return GVECTOR2F{{{this->x, this->y}}};
			}
		};

		struct GVECTOR3D
		{
			union
			{
				struct
				{
					double x;
					double y;
					double z;
				};
				double data[3];
			};

			inline const GVECTOR2D xy() const
			{
				return GVECTOR2D{ {{this->x, this->y}} };
			}
		};

		struct GMATRIX2F
		{
			union
			{
				struct
				{
					GVECTOR2F row1;
					GVECTOR2F row2;
				};
				float data[4];
			};
		};

		struct GMATRIX2D
		{
			union
			{
				struct
				{
					GVECTOR2D row1;
					GVECTOR2D row2;
				};
				double data[4];
			};
		};

		struct GMATRIX3F
		{
			union
			{
				struct
				{
					GVECTOR3F row1;
					GVECTOR3F row2;
					GVECTOR3F row3;
				};
				float data[9];
			};
		};

		struct GMATRIX3D
		{
			union
			{
				struct
				{
					GVECTOR3D row1;
					GVECTOR3D row2;
					GVECTOR3D row3;
				};
				double data[9];
			};
		};

		struct GLINE2F
		{
			GVECTOR2F start;
			GVECTOR2F end;
		};

		struct GLINE2D
		{
			GVECTOR2D start;
			GVECTOR2D end;
		};

		struct GRAY2F
		{
			GVECTOR2F pos;
			GVECTOR2F dir;
		};

		struct GRAY2D
		{
			GVECTOR2D pos;
			GVECTOR2D dir;
		};

		struct GCIRCLE2F
		{
			union 
			{
				struct 
				{
					GVECTOR2F pos;
					float radius;
				};
				GVECTOR3F data;
			};
		};

		struct GCIRCLE2D
		{
			union
			{
				struct
				{
					GVECTOR2D pos;
					double radius;
				};
				GVECTOR3D data;
			};
		};

		struct GCAPSULE2F
		{
			GVECTOR2F start;
			GVECTOR2F end;
			float radius;
		};
		
		struct GCAPSULE2D
		{
			GVECTOR2D start;
			GVECTOR2D end;
			double radius;
		};

		struct GRECTANGLE2F
		{
			GVECTOR2F min;
			GVECTOR2F max;
		};

		struct GRECTANGLE2D
		{
			GVECTOR2D min;
			GVECTOR2D max;
		};

		struct GBARYCENTRICF
		{
			union
			{
				struct
				{
					float alpha;
					float beta;
					float gamma;
				};
				float data[3];
			};
		};

		struct GBARYCENTRICD
		{
			union
			{
				struct
				{
					double alpha;
					double beta;
					double gamma;
				};
				double data[3];
			};
		};

#pragma pack(pop)
		static const GVECTOR2F GZeroVector2F{ {{0,0}} };
		static const GVECTOR2D GZeroVector2D{ {{0,0}} };
		static const GVECTOR3F GZeroVector3F{ {{0,0,0}} };
		static const GVECTOR3D GZeroVector3D{ {{0,0,0}} };

		static const GMATRIX2F GIdentityMatrix2F{ {{{{{1,0}}},{{{0,1}}}}} };
		static const GMATRIX2D GIdentityMatrix2D{ {{{{{1,0}}},{{{0,1}}}}} };
		static const GMATRIX3F GIdentityMatrix3F{ {{{{{1,0,0}}},{{{0,1,0}}},{{{0,0,1}}}}} };
		static const GMATRIX3D GIdentityMatrix3D{ {{{{{1,0,0}}},{{{0,1,0}}},{{{0,0,1}}}}} };

		static const GMATRIX2F GZeroMatrix2F{ {{{{{0,0}}},{{{0,0}}}}} };
		static const GMATRIX2D GZeroMatrix2D{ {{{{{0,0}}},{{{0,0}}}}} };
		static const GMATRIX3F GZeroMatrix3F{ {{{{{0,0,0}}},{{{0,0,0}}},{{{0,0,0}}}}} };
		static const GMATRIX3D GZeroMatrix3D{ {{{{{0,0,0}}},{{{0,0,0}}},{{{0,0,0}}}}} };
	}
}
#endif // GMATH2DDEFINES_H

/*---------------------------------
|	End of GMath2DDefines.h
----------------------------------*/


/*---------------------------------
|	Begin of GAudioDefines.h
----------------------------------*/
#ifndef GAUDIODEFINES_H
#define GAUDIODEFINES_H

// Count of implemented GATTENUATION
#define G_IMPLEMENTED_ATTENUATIONS 1

namespace GW
{
	namespace AUDIO
	{

		enum GATTENUATION
		{
			LINEAR,

			// LOGARITHMIC,

			// LOGREVERSE,

			// INVERSE,

			// NATURAL
		};

	}
}

#endif

/* Information from GAudioLinux.hpp
	PA_CHANNEL_POSITION_MONO

	PA_CHANNEL_POSITION_FRONT_LEFT
	Apple, Dolby call this 'Left'.

	PA_CHANNEL_POSITION_FRONT_RIGHT
	Apple, Dolby call this 'Right'.

	PA_CHANNEL_POSITION_FRONT_CENTER
	Apple, Dolby call this 'Center'.

	PA_CHANNEL_POSITION_REAR_CENTER
	Microsoft calls this 'Back Center', Apple calls this 'Center Surround', Dolby calls this 'Surround Rear Center'.

	PA_CHANNEL_POSITION_REAR_LEFT
	Microsoft calls this 'Back Left', Apple calls this 'Left Surround' (!), Dolby calls this 'Surround Rear Left'.

	PA_CHANNEL_POSITION_REAR_RIGHT
	Microsoft calls this 'Back Right', Apple calls this 'Right Surround' (!), Dolby calls this 'Surround Rear Right'.
*/

/*---------------------------------
|	End of GAudioDefines.h
----------------------------------*/


/*---------------------------------
|	Begin of GCoreDefines.h
----------------------------------*/
#ifndef GCOREDEFINES_H
#define GCOREDEFINES_H


// The Gateware proxy pattern is fundamentally built upon std::weak & std::shared
// Gateware Event communication is based on a type erasure observer pattern <typeinfo>
#include <memory>
#include <algorithm>

namespace GW
{

	enum class GReturn : int
	{
		// additional failure codes here
		FORMAT_UNSUPPORTED		= -17,	
		NO_IMPLEMENTATION		= -16,	
		HARDWARE_UNAVAILABLE	= -15,	
		DEADLOCK				= -14,	
		UNEXPECTED_RESULT		= -13,	
		RESOURCE_LOCKED			= -12,	
		DISCONNECTED			= -11,	
		PREMATURE_DEALLOCATION	= -10,	
		FUNCTION_DEPRECATED		= -9,	
		FEATURE_UNSUPPORTED		= -8,	
		FILE_NOT_FOUND			= -7,	
		INTERFACE_UNSUPPORTED	= -6,	
		MEMORY_CORRUPTION		= -5,	
		INVALID_ARGUMENT		= -4,	
		IGNORED					= -3,	
		EXPIRED_PROXY			= -2,	
		FAILURE					= -1,	
		EMPTY_PROXY				=  0,	
		// Here lies the split between success and failure codes
		SUCCESS					= +1,	
		REDUNDANT				= +2,	
		// additional success codes here

	}; // MOST COMMON: +1 == SUCCESS, +2 == REDUNDANT, -1 == FAILURE, -3 == IGNORED, 0 == EMPTY_PROXY, -2 == EXPIRED_PROXY (future)

};


#define G_PASS(_greturn_) (static_cast<int>(_greturn_) > 0)

#define G_FAIL(_greturn_) (static_cast<int>(_greturn_) < 1)



// Internal definition, how large a GEvent is in memory.
// Note to Gateware Developers: first 16bytes are reserved for basic type identification. Design event packets appropriately.
#define G_EVENT_BLOCK_SIZE 64u
#define G_RAW_DATA_PACKET_SIZE (((G_EVENT_BLOCK_SIZE) - ((sizeof(std::size_t) << 1)) + 2))

namespace GW
{
	inline bool operator+(const GReturn&& _rvalue) { return G_PASS(_rvalue); }
	inline bool operator-(const GReturn&& _rvalue) { return G_FAIL(_rvalue); }

	// Internal namespace for Gateware developers, Doxygen should be configured to ignore this namespace.
	namespace I {
		// Define the template class expander GProxy.
		// This is a core pillar used in the C++11 modernized version of Gateware.
		// A GProxy is a smart wrapper around a Gateware Interface & Implementation.
		// The proxy allows safe transfer and allocation/deallocation of interfaces as well as safe access.
		// Proxy rules: Copying creates safe handles but does not transfer ownership. Only moving r-values can transfer ownership.
		template<typename _Interface, typename _Implementation, typename... _CreationParams>
		class GProxy
		{
		protected:
			typedef _Interface forceRaw; // used to support the rare need of construction from raw pointers (prefer to avoid)
			typedef _Implementation forceStatic; // used to support static calls from proxy ops
			typedef std::shared_ptr<const _Interface> forceConst; // used to support const correctness in proxy ops
			typedef GProxy<_Interface, _Implementation, _CreationParams...> thisClass; // short hand for this type of class
			std::weak_ptr<_Interface> access; // most common way of access via proxy, does not require ownership
			std::shared_ptr<_Interface> storage; // Hard handle to data, not all instances use this, most are weak by default

		private:
			// All Proxys are friends of one another (required for casting)
			template<typename A, typename B, typename... C> friend class GProxy;
			// This function is what actually makes a GProxy "proxy" an interface & associated implementation.
			template<typename... _anyArgs>
			GReturn allocate(_anyArgs&&... _argTransfer)
			{
				GReturn result = GReturn::FAILURE;
				access.reset(); // clear any prior access, storage will be overwritten below
				storage = std::make_shared<_Implementation>(); // so we can write the below more safely...
				// *** A COMPILER ERROR HERE MEANS YOU ARE NOT PASSING ".Create(" A VALID SET OF ARGUMENTS ***
				// *** READ OUR INCLUDED DOCUMENTATION TO FIND THE PROPER ARGUMENTS TO ANY GATEWARE FUNCTION ***
				if (storage && G_PASS(result = dynamic_cast<_Implementation*>
					(storage.get())->Create(std::forward<_anyArgs>(_argTransfer)...)))
					access = storage; // used for primary access
				else // if we failed to create, destruct the interface immediately
					storage.reset();
				// return what happened
				return result;
			}

		public:
			// Creates an invalid but safe handle
			GProxy() = default;
			// Special constructor, allows creation from existing implementation.
			// This should only be used in conjunction with std::shared_from_this from inside an implementation.
			GProxy(const std::shared_ptr<_Interface>& _sharedFromThis)
			{
				access = storage = _sharedFromThis;
			}
			// copy constructor
			GProxy(const thisClass& _cpy)
			{
				if (this != &_cpy)
					access = _cpy.access;
			}
			// template version, attempts to convert incoming data to this class type using dynamic_pointer_cast if possible
			// We use SFINAE to ensure this is only called for non-derived types, those should use the standard overloads
			template<typename T, typename = std::enable_if<!std::is_convertible<T*, thisClass*>::value>>
			GProxy(const T& _cpy)
			{
				access = std::dynamic_pointer_cast<_Interface>(_cpy.access.lock());
			}
			// move constructor does a direct transfer since it is not considered a copy
			GProxy(thisClass&& _mov) noexcept //: storage(_mov.storage), access(_mov.access)
			{
				storage = std::move(_mov.storage);
				access = std::move(_mov.access);
			}
			// template version, attempts to convert incoming data to this class type using dynamic_pointer_cast if possible
			// We use SFINAE to ensure this is only called for non-derived types, those should use the standard overloads
			template<typename T, typename = std::enable_if<!std::is_convertible<T*, thisClass*>::value>>
			GProxy(T&& _mov) noexcept //: storage(std::dynamic_pointer_cast<_Interface>(std::move(_mov.storage))), access(storage)
			{
				storage = std::dynamic_pointer_cast<_Interface>(std::move(_mov.storage));
				access = (storage) ? storage : std::dynamic_pointer_cast<_Interface>(_mov.access.lock());
			}
			// Assignment operator
			virtual thisClass& operator=(const thisClass& _cpy) final
			{
				if (this != &_cpy)
				{
					access = _cpy.access;
					storage.reset(); // copy assignment may not transfer or retain any prior ownership
				}
				return *this;
			}
			// template version, attempts to convert incoming data to this class type using dynamic_pointer_cast if possible
			// We use SFINAE to ensure this is only called for non-derived types, those should use the standard overloads
			template<typename T, typename = std::enable_if<!std::is_convertible<T*, thisClass*>::value>>
			thisClass& operator=(const T& _cpy)
			{
				access = std::dynamic_pointer_cast<_Interface>(_cpy.access.lock());
				storage.reset(); // copy assignment may not transfer or retain any prior ownership
				return *this;
			}
			// move assignment
			virtual thisClass& operator=(thisClass&& _mov) noexcept final
			{
				storage = std::move(_mov.storage);
				access = std::move(_mov.access);
				return *this;
			}
			// template version, attempts to convert incoming data to this class type using dynamic_pointer_cast if possible
			// We use SFINAE to ensure this is only called for non-derived types, those should use the standard overloads
			template<typename T, typename = std::enable_if<!std::is_convertible<T*, thisClass*>::value>>
			thisClass& operator=(T&& _mov) noexcept
			{
				storage = std::dynamic_pointer_cast<_Interface>(std::move(_mov.storage));
				access = (storage) ? storage : std::dynamic_pointer_cast<_Interface>(_mov.access.lock());
				return *this;
			}
			// basic destructor
			~GProxy() = default;
			// Allows testing the class for validity
			virtual operator bool() const final { return !access.expired(); };
			// nullptr assignment is how to clear a proxy before waiting for it to fall out of scope
			virtual thisClass& operator =(std::nullptr_t) final { access.reset(); storage.reset(); return *this; };
			// The GProxy varadic template should match the main internal implementation "Create" function.
			// Though the templated variadic version of this function can support any set of arguments,
			// This version requires derived classes to define & support at least one specific Create variant.
			// This is required for API consistency. Alternate Create routines are supported by the next function.
			virtual GReturn Create(_CreationParams... _parameter) final
			{
				return allocate<_CreationParams...>(std::forward<_CreationParams>(_parameter)...);
			}
			// Provided for alternate Create function potential.(direct use by derived classes is optional)
			// This version is much more functional but cannot be virtual which is why the prior version exists.
			template<	typename... _AltArguments,
				typename = std::enable_if<!std::is_same< // SFINAE used to force virtual override in impl.
				std::tuple<_AltArguments...>, std::tuple<_CreationParams...> >::value>>
			GReturn Create(_AltArguments... _parameter)
			{
				return allocate<_AltArguments...>(std::forward<_AltArguments>(_parameter)...);
			}
			// Return a copy of the Proxy that allows for non-weak transfer of ownership
			// If direct ownership cannot be shared it will return an invalid handle
			virtual thisClass Share() const final
			{
				thisClass canShare;
				if (storage)
				{
					canShare.storage = storage;
					canShare.access = access;
				}
				return canShare; // r-value will invoke move to allow full transfer
			}
			// Surrenders strong ownership of your internal handle to another Proxy, weak ownership is maintained
			// If direct ownership cannot be surrendered it will return an invalid handle
			virtual thisClass Relinquish() final
			{
				thisClass canYield;
				if (storage)
				{
					canYield.storage = storage;
					canYield.access = access;
					storage.reset();
				}
				return canYield;
			}
			// Returns a direct copy of the Proxy with the current ownership status maintined
			// If direct ownership cannot be shared it will provide it's weak ownership
			virtual thisClass Mirror() const final
			{
				thisClass canReflect;
				canReflect.storage = storage;
				canReflect.access = access;
				return canReflect;
			}

			// *** BEGIN WARNING: The following operators & typedefs are provided only for advanced users, avoid unless needed. ***
			// Potentially unsafe (nullptr) access to underlying interface type, only use when a normal proxy call does not suffice
			virtual const std::shared_ptr<_Interface> operator*() noexcept final //std::move will handled by compiler
			{
				return (storage) ? storage : access.lock();
			}
			// Potentially unsafe (nullptr) access to underlying interface type, only use when a normal proxy call does not suffice
			virtual const std::shared_ptr<const _Interface> operator*() const noexcept final //std::move will handled by compiler
			{
				return (storage) ? storage : access.lock();
			}
			// Types that can be used to lock down the internal weak pointer in performance critcal areas.
			// Do not use these unless you are very familiar & comforatable with how shared & weak pointers function.
			// As a general rule of thumb only create these on the stack where you need multiple subsequent API calls.
			// These should only be in places like inner loops or code that is currently being bottlenecked by std::weak_ptr::lock.
			// If you are concerned about access performance it may make more sense to GProxy<>::Share() your proxies with systems
			// which need to constantly access them. However, for edge cases of required weak access in high-perf systems use below:
			typedef const std::shared_ptr<_Interface> burst_w; // use if you are about to author a burst of write (non-const) calls.
			typedef const std::shared_ptr<const _Interface> burst_r; // use if you are about to author a burst of read (const) calls.
			// *** END WARNING: using the above haphazzardly can & will invalidate the inherent safety of the Proxy pattern. ***
		};
		// Non-Member comparison operations allow a proxy to behave like a standard shared_ptr when compared against each other
		template<typename... L, typename... R>
		bool operator==(const GProxy<L...>& _lhs, const GProxy<R...>& _rhs) noexcept
		{
			return *_lhs == *_rhs;
		}
		template<typename... L, typename... R>
		bool operator!=(const GProxy<L...>& _lhs, const GProxy<R...>& _rhs) noexcept
		{
			return *_lhs != *_rhs;
		}
		template<typename... L, typename... R>
		bool operator<(const GProxy<L...>& _lhs, const GProxy<R...>& _rhs) noexcept
		{
			return *_lhs < *_rhs; // this operator required for associative container support
		}
		template<typename... L, typename... R>
		bool operator>(const GProxy<L...>& _lhs, const GProxy<R...>& _rhs) noexcept
		{
			return *_lhs > *_rhs;
		}
		template<typename... L, typename... R>
		bool operator<=(const GProxy<L...>& _lhs, const GProxy<R...>& _rhs) noexcept
		{
			return *_lhs <= *_rhs;
		}
		template<typename... L, typename... R>
		bool operator>=(const GProxy<L...>& _lhs, const GProxy<R...>& _rhs) noexcept
		{
			return *_lhs >= *_rhs;
		}
		// Nullptr comparison support
		template<typename... T>
		bool operator==(const GProxy<T...>& _lhs, std::nullptr_t _rhs) noexcept
		{
			return !(bool)_lhs;
		}
		template<typename... T>
		bool operator==(std::nullptr_t _lhs, const GProxy<T...>& _rhs) noexcept
		{
			return !(bool)_rhs;
		}
		template<typename... T>
		bool operator!=(const GProxy<T...>& _lhs, std::nullptr_t _rhs) noexcept
		{
			return (bool)_lhs;
		}
		template<typename... T>
		bool operator!=(std::nullptr_t _lhs, const GProxy<T...>& _rhs) noexcept
		{
			return (bool)_rhs;
		}
		template<typename... T>
		bool operator<(const GProxy<T...>& _lhs, std::nullptr_t _rhs) noexcept
		{
			return *_lhs < _rhs;
		}
		template<typename... T>
		bool operator<(std::nullptr_t _lhs, const GProxy<T...>& _rhs) noexcept
		{
			return _lhs < *_rhs;
		}
		template<typename... T>
		bool operator>(const GProxy<T...>& _lhs, std::nullptr_t _rhs) noexcept
		{
			return *_lhs > _rhs;
		}
		template<typename... T>
		bool operator>(std::nullptr_t _lhs, const GProxy<T...>& _rhs) noexcept
		{
			return _lhs > *_rhs;
		}
		template<typename... T>
		bool operator<=(const GProxy<T...>& _lhs, std::nullptr_t _rhs) noexcept
		{
			return *_lhs <= _rhs;
		}
		template<typename... T>
		bool operator<=(std::nullptr_t _lhs, const GProxy<T...>& _rhs) noexcept
		{
			return _lhs <= *_rhs;
		}
		template<typename... T>
		bool operator>=(const GProxy<T...>& _lhs, std::nullptr_t _rhs) noexcept
		{
			return *_lhs >= _rhs;
		}
		template<typename... T>
		bool operator>=(std::nullptr_t _lhs, const GProxy<T...>& _rhs) noexcept
		{
			return _lhs >= *_rhs;
		}
	} // end I internal namespace

	// Defines the simple type-erasure struct GEvent
	// This is a another core pillar used in the C++11 modernized version of Gateware.
	// A GEvent is a generic but type-safe way to communicate small-footprint event messages to listeners.
	// All sent messages must fit within G_MESSAGE_BLOCK_SIZE total including type_info hashes.
	// A GEvent only supports safe transfer of raw data blocks(C structs, POD) & enum class types.
	// (Copy)Constructors/Destructors/Assignment Operators etc... of stored types are NOT respected in any way!
	// Future versions (c++17+) of Gateware could replace some of this with the FAR more robust std::any if needed.

	struct GEvent
	{
	private:
		std::size_t enumType = 0; // identifies stored enumerator representing the event ID
		std::size_t dataType = 0; // identifies stored structure representing the associated data bundled with an event
		// raw data containing specific enum value & data packet.
		// The leading byte of each type-erased data block records the size of the embedded data.
		// This information is used for additional data integrity verification during reads and offset jumps when required.
		unsigned char rawData[G_RAW_DATA_PACKET_SIZE] = {0,};
		// due to odd include order issues across platforms regarding std::memcpy & std::copy
		// we provide a substitution here that copies a fixed amount of bytes
		static inline void memory_copy(void *_dst, const void* _src, unsigned int _byteCount)
		{
			std::size_t* write = static_cast<std::size_t*>(_dst);
			std::size_t const *read = static_cast<std::size_t const*>(_src);
			for (; _byteCount >= sizeof(std::size_t); _byteCount -= sizeof(std::size_t))
				*write++ = *read++;
			unsigned char* w = reinterpret_cast<unsigned char*>(write);
			unsigned char const* r = reinterpret_cast<unsigned char const*>(read);
			for (; _byteCount; --_byteCount)
				*w++ = *r++;
		}
		
	public:
		template<class enumT, typename dataT>
		GReturn Write(const enumT& _eventEnumValue, const dataT& _eventData)
		{
			// ensure developers stay within data size limits of storable data types
			static_assert(	sizeof(enumT) < 256, "Enum types stored by GEvent must be < 256 bytes!");
			static_assert(	sizeof(dataT) < 256, "Data types stored by GEvent must be < 256 bytes!");
			// ensure developers do not exceed internal storage limits
			static_assert(	(sizeof(enumT) + sizeof(dataT)) <= G_RAW_DATA_PACKET_SIZE,
							"Enum + Data combined size attempted to be stored by GEvent is too large!");
			// ensure developers do not send types other than an enum to identify their events
			static_assert(	std::is_enum<enumT>::value,
							"Gateware Events{} are required to use an \"enum class\" list to identify themselves!");
			// ensure developers use only C Style stuctures & basic enumerators for information transfer
			static_assert(	std::is_trivially_copyable<dataT>::value,
							"Enum & Data Types must be fully tranferable with std:memcpy only! Plain Old Data Only!");
			// Once we know the storable types are safe we record their type and transfer the data
			enumType = typeid(enumT).hash_code();
			dataType = typeid(dataT).hash_code();
			// Unlikely, but the standard doesn't say it can't happen, would interfere with error checking
			if (enumType == 0 || dataType == 0)
				return GReturn::UNEXPECTED_RESULT;
			// Store bit data for typeless transfer
			rawData[0] = sizeof(enumT); // encode size of enum
			memory_copy(rawData + 1, &_eventEnumValue, sizeof(enumT)); // store enum
			rawData[sizeof(enumT) + 1] = sizeof(dataT); // encode size of data
			memory_copy(rawData + sizeof(enumT) + 2, &_eventData, sizeof(dataT)); // store data
			// transfer to internal storage should now be successful
			return GReturn::SUCCESS;
		};
		template<class enumT, typename dataT>
		GReturn Read(enumT& _outEventID, dataT& _outEventData) const
		{
			// If you get this complier error you are providing Read() with an incompatible type.
			// Always use Gxxx::Events and Gxxx::EVENT_DATA to examine an event.
			static_assert((sizeof(enumT) + sizeof(dataT)) <= G_RAW_DATA_PACKET_SIZE &&
				std::is_enum<enumT>::value && std::is_trivially_copyable<enumT>::value &&
				std::is_trivially_copyable<dataT>::value,
				"Types provided to GEvent::Read() operation are not a compatible types!"
				"Use appropriate GEventGenerator derived G::Events enum and G::EVENT_DATA structure.");
			// Type hashes will ensure safe access of underlying data in 99.9% of situations
			// Not 100% perfect but much safer than a void* like it used to be.
			if (enumType == 0 || dataType == 0) return GReturn::FAILURE; // No event data present
			// Requested type does not match internal enum format (use proper G::Events)
			if (enumType != typeid(enumT).hash_code()) return GReturn::INVALID_ARGUMENT;
			// Requested type does not match internal data structure format (use proper G::EVENT_DATA)
			if (dataType != typeid(dataT).hash_code()) return GReturn::INVALID_ARGUMENT;
			// Once types have been safely checked we verify the byte sizes of types and copy data
			if (sizeof(enumT) == rawData[0])
				memory_copy(&_outEventID, rawData + 1, sizeof(enumT));
			else
				return GReturn::MEMORY_CORRUPTION; // data size verification failed
			// check that data type is also size verified before transfer
			if (sizeof(dataT) == rawData[sizeof(enumT) + 1])
				memory_copy(&_outEventData, rawData + sizeof(enumT) + 2, sizeof(dataT));
			else
				return GReturn::MEMORY_CORRUPTION; // data size verification failed
			// if we made it this far everything checked out and transfered successfully.
			return GReturn::SUCCESS;
		}
		template<class enumOrDataT>
		GReturn Read(enumOrDataT& _outEventOrData) const
		{
			// If you get this complier error you are providing Read() with an incompatible type.
			// Always use Gxxx::Events and Gxxx::EVENT_DATA to examine an event.
			static_assert(sizeof(enumOrDataT) <= G_RAW_DATA_PACKET_SIZE &&
				std::is_trivially_copyable<enumOrDataT>::value,
				"Type provided to GEvent::Read() operation is not a compatible type!"
				"Use appropriate GEventGenerator derived G::Events enum or G::EVENT_DATA structure.");
			// Type hashes will ensure safe access of underlying data in 99.9% of situations
			// Not 100% perfect but much safer than a void* like it used to be.
			if (enumType == 0 && dataType == 0)
				return GReturn::FAILURE; // No event data present
			// enum type identified
			else if (enumType == typeid(enumOrDataT).hash_code())
				if (sizeof(enumOrDataT) == rawData[0])
					memory_copy(&_outEventOrData, rawData + 1, sizeof(enumOrDataT)); // transfer enum bits
				else // data size verification failed
					return GReturn::MEMORY_CORRUPTION;
			// event data identified
			else if (dataType == typeid(enumOrDataT).hash_code())
				if (rawData[0] < (G_EVENT_BLOCK_SIZE - (sizeof(std::size_t) << 1)) && // enoded enum type integrity check
					sizeof(enumOrDataT) == rawData[rawData[0] + 1]) // jump to type size offset
					memory_copy(&_outEventOrData, rawData + rawData[0] + 2, sizeof(enumOrDataT)); // transfer enum bits
				else // data size verification failed
					return GReturn::MEMORY_CORRUPTION;
			else // Requested type does not match internal enum/data structure format (use proper G::Events/G::EVENT_DATA)
				return GReturn::INVALID_ARGUMENT;
			// with transfer complete notify success
			return GReturn::SUCCESS;
		}
	};
};

// Creates an identically named typedef in the proxy to represent a public type in the interface
// These are typically used by Event Generator Proxies for end user typing conveinence
#define GATEWARE_TYPEDEF(interface_type) typedef forceRaw::interface_type interface_type;
// Returns if a proxy is empty or it is expired if this detection functionality is supported
// In Visual Studio you can add "/std:c++17 /Zc:__cplusplus" to your C++ command line for partial c++17 support
#if __cplusplus >= 201703L // This requires c++17 support
// Determines if an invalid proxy has expired or was never intialized in the first place.
#define GATEWARE_EXPIRED(weak_pointer) \
(!(weak_pointer).owner_before(std::weak_ptr<forceRaw>{}) && \
!std::weak_ptr<forceRaw>{}.owner_before((weak_pointer))) \
? GW::GReturn::EMPTY_PROXY : GW::GReturn::EXPIRED_PROXY
#else
// if we don't have support for c++17 we can't detect an expired proxy and fallback to empty.
#define GATEWARE_EXPIRED(weak_pointer) GW::GReturn::EMPTY_PROXY
#endif
// Writes a wrapper function to wrap the internal implementation call
// Uses a variadic template & perfect forwarding of arguments for ease of development & performance
#define GATEWARE_PROXY_FUNCTION(function_name, access_type, lock_type, cast_type) \
template<typename... Args> \
GW::GReturn \
function_name \
(Args&&... parameter) access_type { \
if(storage) return (cast_type(storage.get()))->function_name(std::forward<Args>(parameter)...);\
lock_type _proxy = access.lock(); \
return (_proxy) ? (cast_type(_proxy.get()))->function_name(std::forward<Args>(parameter)...) \
: GATEWARE_EXPIRED(access); \
}
#define GATEWARE_FUNCTION(function_name) GATEWARE_PROXY_FUNCTION(function_name, ,auto, )
#define GATEWARE_CONST_FUNCTION(function_name) GATEWARE_PROXY_FUNCTION(function_name,const,forceConst, )
// Template Proxy functions convert the base class pointer to its known implementation before
// Passing the list of arguments to the appropriate routine, conveinent but not particluarly efficient
#define GATEWARE_TEMPLATE_FUNCTION(function_name) \
GATEWARE_PROXY_FUNCTION(function_name, ,auto,dynamic_cast<forceStatic*>)
#define GATEWARE_CONST_TEMPLATE_FUNCTION(function_name) \
GATEWARE_PROXY_FUNCTION(function_name,const,forceConst,dynamic_cast<forceStatic*>)
// Static functions allow high speed calls with no refrence juggling for things like math libraries.
// Yet they still allow such Proxys to operate like any other Proxy transparently
#define GATEWARE_STATIC_FUNCTION(function_name) \
template<typename... Args> \
static GW::GReturn \
function_name \
(Args&&... parameter) { \
return forceStatic::function_name(std::forward<Args>(parameter)...); \
}
// This macro ensures the derived proxy fully supports dynamic casting and transfer of proxy ownership
// ALL Gateware Proxy classes MUST have this in the public section of the derived proxy class.
#define GATEWARE_PROXY_CLASS(class_name) \
class_name() = default; \
class_name(std::shared_ptr<forceRaw> shr) : thisClass(shr) {} \
template<class Proxy> class_name(const Proxy& cpy) : thisClass(cpy) { } \
template<class Proxy> class_name(Proxy&& mov) noexcept : thisClass(std::forward<Proxy>(mov)) { } \
template<class Proxy> class_name& operator=(const Proxy& cpy) { thisClass::operator=(cpy); return *this; } \
template<class Proxy> class_name& operator=(Proxy&& mov) \
noexcept { thisClass::operator=(std::forward<Proxy>(mov)); return *this; } \
forceStatic* operator--(int) const { std::abort(); return nullptr; }; // The "--->" is ONLY for Intellisense Viewing

// Deprecates an entire class and displays a message recommending an alternative class.
// To use, replace: class Foo
// With: class GATEWARE_DEPRECATED(Foo, FoosReplacement) Foo
#if defined(_MSC_VER)
#define GATEWARE_DEPRECATED(deprecated_class, replacing_class) \
__declspec(deprecated(#deprecated_class " is deprecated: use " #replacing_class " instead."))
#elif defined(__GNUC__)
// XCode and CodeLite will prepend a message indicating the class is deprecated.
#define GATEWARE_DEPRECATED(deprecated_class, replacing_class) \
__attribute__ ((deprecated("use " #replacing_class " instead.")))
#else
#define GATEWARE_DEPRECATED(deprecated_class, replacing_class)
#endif

// NOTE: The GATEWARE_DEPRECATED macro was originally designed for deprecating a class, but it could be used
// to deprecated other things. For example:
//
// Structs: 
//    struct GATEWARE_DEPRECATED(Foo, FoosReplacement) Foo
// Typedefs: 
//    GATEWARE_DEPRECATED(Foo, FoosReplacement) GATEWARE_TYPEDEF(Foo)
//
// For deprecating functions, GATEWARE_DEPRECATED has to be placed inside the argument area of the function
// macro, before the function name. This is because GATEWARE_DEPRECATED has to be placed after the template<T>
// part of the function header. For example:
//
// Functions:
//    GATEWARE_FUNCTION(GATEWARE_DEPRECATED(Foo, FoosReplacement) Foo)
//    GATEWARE_CONST_FUNCTION(GATEWARE_DEPRECATED(Foo, FoosReplacement) Foo)
//    GATEWARE_PROXY_FUNCTION(GATEWARE_DEPRECATED(Foo, FoosReplacement) Foo)
//    GATEWARE_TEMPLATE_FUNCTION(GATEWARE_DEPRECATED(Foo, FoosReplacement) Foo)
//
// Currently, there is no way to use GATEWARE_DEPRECATED with the GATEWARE_STATIC_FUNCTION macro. This is
// because GATEWARE_DEPRECATED has to be placed after the 'static' keyword. One solution for this would be
// to create a new macro for this specific case.


// If you are looking for binary build support, it has been dropped from the late Beta version of Gateware.
// As much as I wanted to embrace Libs & DLLs... C++11 functional additions, ease of deployment considerations,
// and simplicity for student developers both internal & external have prompted this decision.
// Obviously binaries have many advantages, but their drawbacks simply don't fit the future of this project.
// I spent many weeks trying to have my cake & eat it too, and theoretically it remains possible to support.
// However, the additional complexity and support needed for them was deemed too costly. -L.Norri Gatekeeper
#endif // GCOREDEFINES_H


/*---------------------------------
|	End of GCoreDefines.h
----------------------------------*/


/*---------------------------------
|	Begin of GSystemDefines.h
----------------------------------*/
#ifndef GSYSTEMDEFINES_H
#define GSYSTEMDEFINES_H


// Maximum thread pool size allocated by thread pool. Only actual available hardware thread count is used.
#define G_MAX_THREAD_POOL_SIZE		64
// default amount of time in microseconds to nap threads that should release resources
#define G_THREAD_DEFAULT_SLEEP		5000
// amount of time in microseconds below which daemons are spinlocked for launch
#define G_DAEMON_LAUNCH_THRESHOLD	100
// amount of bytes gconcurrent uses to determine how many elements should be allocated per-thread in BranchParallel
#define G_CONCURRENT_AUTO_SECTION	131072

namespace GW
{
	namespace SYSTEM
	{

		struct UNIVERSAL_WINDOW_HANDLE
		{
			void* window;	
			void* display;	
		};

		enum class GWindowStyle
		{
			WINDOWEDBORDERED,		
			WINDOWEDBORDERLESS,		
			WINDOWEDLOCKED,			
			FULLSCREENBORDERED,		
			FULLSCREENBORDERLESS,	
			MINIMIZED				
		};

	}
}
#endif // GSYSTEMDEFINES_H

/*---------------------------------
|	End of GSystemDefines.h
----------------------------------*/


/*---------------------------------
|	Begin of ThreadPool.h
----------------------------------*/
#ifndef CONCURRENT_THREADPOOL_H
#define CONCURRENT_THREADPOOL_H

#include <atomic>
#include <thread>
#include <mutex>
#include <array>
#include <list>
#include <functional>
#include <condition_variable>

namespace nbsdx {
namespace concurrent {

// Global per-thread access to the current ActiveJob running
// This is used for internal detection of deadlocks
namespace internal {
    static unsigned long long& GetActiveJob() {
        // (Gateware specific) tracks the active job on this thread. (-1 if no job)
        static thread_local unsigned long long ActiveJob = -1;
        return ActiveJob; // used to detect potential deadlocks
    }
}

/**
 *  Simple ThreadPool that creates `MaxThreadCount` threads upon its creation or
 *  std::thread::hardware_concurrency() whichever is less 
 *  and pulls from a queue to get new jobs. The default is 32 threads.
 *  This class has been modified slightly for Gateware's needs, do not instantiate more than
 *  one of these classes. The class now uses thread_local vars for deadlock detection/prevention.
 *
 *  This class requires a number of c++11 features be present in your compiler.
 */
template <unsigned MaxThreadCount = 32>
class ThreadPool {

    // (Gateware custom) added this array for queries about running threadIds
    std::array<std::thread::id, MaxThreadCount> ids;
    std::array<std::thread, MaxThreadCount> threads;
    // each new job is assigned an increasing ID
    typedef std::pair<std::function<void(void)>, unsigned long long> JOB;
    std::list<JOB> queue; // all waiting jobs

    unsigned long long      JobCount;
    const unsigned          ThreadCount;
    std::atomic_int         jobs_left;
    std::atomic_bool        bailout;
    std::atomic_bool        finished;
    std::condition_variable job_available_var;
    std::condition_variable wait_var;
    std::mutex              wait_mutex;
    std::mutex              queue_mutex;
    /**
     *  Take the next job in the queue and run it.
     *  Notify the main thread that a job has completed.
     */
    void Task() {
        while( !bailout ) {
            next_job().first();
            // job has completed clear the thread local JobID var here
            internal::GetActiveJob() = -1; // no job is currently running on this thread
            --jobs_left;
            wait_var.notify_one();
        }
    }

    /**
     *  Get the next job; pop the first item in the queue, 
     *  otherwise wait for a signal from the main thread.
     */
    JOB next_job() {
        JOB res;
        std::unique_lock<std::mutex> job_lock( queue_mutex );

        // Wait for a job if we don't have any.
        job_available_var.wait( job_lock, [this]() ->bool { return queue.size() || bailout; } );
        
        // Get job from the queue
        if( !bailout ) {
            res = queue.front();
            queue.pop_front();
            // we about to run the next job...
            internal::GetActiveJob() = res.second;
        }
        else { // If we're bailing out, 'inject' a job into the queue to keep jobs_left accurate.
            res.first = []{};
            ++jobs_left;
        }
        return res;
    }

public:
   
    ThreadPool()
        : JobCount( 0 )
        , jobs_left( 0 )
        , bailout( false )
        , finished( false )
        , ThreadCount( // select all hardware threads or MaxThreads whichever is less
            (MaxThreadCount < std::thread::hardware_concurrency())
            ? MaxThreadCount : std::thread::hardware_concurrency())
    {
        for (unsigned i = 0; i < ThreadCount; ++i) {
            threads[i] = std::thread([this] { this->Task(); });
            // (Gateware custom) cache ids of running threads for fast queries
            ids[i] = threads[i].get_id();
        }
    }

    /**
     *  JoinAll on deconstruction
     */
    ~ThreadPool() {
        JoinAll();
    }

    /**
     *  Get the number of threads in this pool
     */
    inline unsigned Size() const {
        return ThreadCount;
    }

    /**
     *  Determine if a thread is one of the threads in the pool
     *  used to prevent possible deadlocks
     */
    inline bool Search(std::thread::id threadID) const {
        bool found = false;
        for (std::size_t i = 0; i < ThreadCount; ++i)
            if (ids[i] == threadID) {
                found = true;
                break;
            }
        return found;
    }

    /**
    *  Determine if the invoking thread is currently inside(actively running)
    *  the job identified by the provided JobID provided by "AddJob()"
    *  can be used to more accuratley detect/prevent possible deadlocks
    */
    inline bool InsideJob(unsigned long long jobID) const {
        return internal::GetActiveJob() == jobID;
    }

    /**
     *  Get the number of jobs left in the queue.
     */
    inline unsigned JobsRemaining() {
        std::lock_guard<std::mutex> guard( queue_mutex );
        return queue.size();
    }

    /**
     *  Add a new job to the pool. If there are no jobs in the queue,
     *  a thread is woken up to take the job. If all threads are busy,
     *  the job is added to the end of the queue
     *  *NEW* Function now returns an ID that can be used identify a running job on a thread.
     */
    unsigned long long AddJob( std::function<void(void)> job ) {
        std::lock_guard<std::mutex> guard( queue_mutex );
        queue.emplace_back( JOB(job, ++JobCount) );
        ++jobs_left;
        job_available_var.notify_one();
        return JobCount;
    }

    /**
     *  Variant of AddJob that allows you to supply your own JobID (don't use -1)
     *  to each job you add. You can then check against this ID using "InsideJob".
     */
    void AddJob(std::function<void(void)> job, unsigned long long jobID_override) {
        std::lock_guard<std::mutex> guard(queue_mutex);
        queue.emplace_back(JOB(job, jobID_override));
        ++JobCount; ++jobs_left;
        job_available_var.notify_one();
    }

    /**
     *  Join with all threads. Block until all threads have completed.
     *  Params: WaitForAll: If true, will wait for the queue to empty 
     *          before joining with threads. If false, will complete
     *          current jobs, then inform the threads to exit.
     *  The queue will be empty after this call, and the threads will
     *  be done. After invoking `ThreadPool::JoinAll`, the pool can no
     *  longer be used. If you need the pool to exist past completion
     *  of jobs, look to use `ThreadPool::WaitAll`.
     */
    void JoinAll( bool WaitForAll = true ) {
        if( !finished ) {
            if( WaitForAll ) {
                WaitAll();
            }

            // note that we're done, and wake up any thread that's
            // waiting for a new job
            bailout = true;
            job_available_var.notify_all();

            for( auto &x : threads )
                if( x.joinable() )
                    x.join();
            finished = true;
        }
    }

    /**
     *  Wait for the pool to empty before continuing. 
     *  This does not call `std::thread::join`, it only waits until
     *  all jobs have finshed executing.
     */
    void WaitAll() {
        if( jobs_left > 0 ) {
            std::unique_lock<std::mutex> lk( wait_mutex );
            wait_var.wait( lk, [this]{ return this->jobs_left == 0; } );
            lk.unlock();
        }
    }
};

} // namespace concurrent
} // namespace nbsdx

#endif // #endif CONCURRENT_THREADPOOL_H


/*---------------------------------
|	End of ThreadPool.h
----------------------------------*/


/*---------------------------------
|	Begin of macutils.h
----------------------------------*/
#ifndef GATEWARE_MACUTILS_H
#define GATEWARE_MACUTILS_H

#if defined(__APPLE__)
@import Foundation;
@import Cocoa;
#import <objc/objc-runtime.h>

// G_OBJC MACROS
//
// Author: Ozzie Mercado
// Purpose: These macros are designed to simplify the process of writing Objective-C classes using the Objective-C
//          Runtime Library. All Objective-C classes must be created at runtime. The implementation of Objective-C
//          classes cannot be implicitly inlined. By using the Objective-C Runtime Library, we can get around that
//          limitation. Using these macros will make writing and using the Objective-C Runtime Library classes easier.
// Copyright: 7thGate Software LLC.
// License : MIT
//
// For more information about the Objecti-C Runtime Library:
// https://developer.apple.com/documentation/objectivec/objective-c_runtime
//
// --- DIRECTIONS ---
// Below directions for writing a G_OBJC class interface, implementation, how to use call methods, and how to
// retrieve data members. Further clarification for what each G_OBJC macro does can be found below the instructions
// at each macro definition.
//
// Writing a G_OBJC Class Interface:
//
//    // This should be somewhere above the implementation of the C++ Gateware library.
//    namespace internal_gw // Keep all G_OBJC class interfaces inside the internal_gw namespace.
//    {
//        // OPTIONAL: All data members of your class should go inside the data members struct for simplicity sake.
//        //           This makes it much easier to access them later. If you don't need to include data members in
//        //           your class, then you can skip creating the data members struct.
//        G_OBJC_DATA_MEMBERS_STRUCT(YourClassNameHere)
//        {
//            // These data members are just for example.
//            NSObject* someObject;
//            bool active;
//            int values[5];
//        };
//
//        G_OBJC_HEADER_DATA_MEMBERS_PROPERTY_METHOD(YourClassNameHere); // OPTIONAL: Only required when using the G_OBJC_DATA_MEMBERS_STRUCT().
//
//        // Forward declare all member functions of your class. You could write implementation here, but this is cleaner.
//        // These functions are just for example.
//        G_OBJC_HEADER_STATIC_METHOD_WITH_ARGUMENTS(YourClassNameHere, void, clearValues, id classInstance);
//        G_OBJC_HEADER_INSTANCE_METHOD(YourClassNameHere, void, toggleActive);
//        G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(YourClassNameHere, unsigned int, windowWillResize, NSSize* size, int index);
//
//        // Create your class.
//        // Note: If 'YourObjectiveCParentClass' is NSObject, then you may not need to write your class in Objective-C.
//        //       Regardless, you can still create a G_OBJC class that subclasses NSObject.
//        G_OBJC_CLASS_BEGIN(YourClassNameHere, YourObjectiveCParentClass)
//        {
//            // Add the data members getter function to your class definition.
//            G_OBJC_CLASS_DATA_MEMBERS_PROPERTY(YourClassNameHere); // OPTIONAL: Only required when using the G_OBJC_DATA_MEMBERS_STRUCT().
//
//            // Add member functions to your class definition. These functions are just for example.
//            // Note: The 3rd argument is the type encoding for the function. Check the macro definition for more
//            //       information. The 4th argument in G_OBJC_CLASS_METHOD_WITH_ARGUMENTS() is a ':' for each
//            //       argument in the member function.
//            G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(YourClassNameHere, clearValues, "v@:@", :);
//            G_OBJC_CLASS_METHOD(YourClassNameHere, toggleActive, "v@:");
//            G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(YourClassNameHere, windowWillResize, "I@:@i", ::);
//        }
//        G_OBJC_CLASS_END(YourClassNameHere)
//    }
//
// Writing a G_OBJC Class Implementation:
//
//    // This should be somewhere below the implementation of the C++ Gateware library.
//    namespace internal_gw // Keep all G_OBJC class implementations inside the internal_gw namespace.
//    {
//        // Implementation for properties of your class.
//        G_OBJC_IMPLEMENTATION_DATA_MEMBERS_PROPERTY_METHOD(YourClassNameHere) // OPTIONAL: Only required when using the G_OBJC_DATA_MEMBERS_STRUCT().
//
//        // Implementation for all member functions of your class. These functions are just for example.
//        G_OBJC_HEADER_STATIC_METHOD_WITH_ARGUMENTS(YourClassNameHere, void, clearValues, id classInstance)
//        {
//            // Get the data members for 'classInstance'. We assume 'classInstance' is an instance of YourClassNameHere.
//            // Note: Member functions do not have direct access to member variables. G_OBJC_GET_DATA_MEMBERS() makes it easy
//            //       to get a reference to the data members of your class, use them, and make changes to them.
//            G_OBJC_DATA_MEMBERS_TYPE(YourClassNameHere)& dataMembers = G_OBJC_GET_DATA_MEMBERS(YourClassNameHere, classInstance);
//
//            for (int i = 0; i < 5; ++i)
//                dataMembers.values[i] = 0;
//        }
//
//        G_OBJC_HEADER_INSTANCE_METHOD(YourClassNameHere, void, toggleActive)
//        {
//            // Note: 'self' is available in all non-static member functions.
//            G_OBJC_DATA_MEMBERS_TYPE(YourClassNameHere)& dataMembers = G_OBJC_GET_DATA_MEMBERS(YourClassNameHere, self);
//
//            dataMembers.active = !dataMembers.active;
//        }
//
//        G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(YourClassNameHere, unsigned int, windowWillResize, NSSize* size, int index)
//        {
//            // This is a call to the above static member function 'clearValues'.
//            G_OBJC_CALL_METHOD_WITH_ARGUMENTS(YourClassNameHere, self, clearValues, self);
//
//            G_OBJC_DATA_MEMBERS_TYPE(YourClassNameHere)& dataMembers = G_OBJC_GET_DATA_MEMBERS(YourClassNameHere, self);
//            dataMembers.someObject = nullptr;
//            dataMembers.active = true;
//
//            return (unsigned int)index;
//        }
//    }
//
// Using a G_OBJC Class in a C++ Gateware library implementation:
//
//    // Allocating memory for a member of a G_OBJC class.
//    id classInstance = [internal_gw::G_OBJC_GET_CLASS(YourClassNameHere) alloc];
//
//    // Initializing a member of a G_OBJC class. Note: This example is after allocating 'classInstance'.
//    classInstance = [classInstance init];
//
//    // Both allocating and initializing a member of a G_OBJC class.
//    id classInstance = [[internal_gw::G_OBJC_GET_CLASS(YourClassNameHere) alloc] init];
//
//    // Cleaning up a member of a G_OBJC class.
//    [classInstance autorelease];
//    or
//    [classInstance release];
//
//    // Getting the data members of a G_OBJC class.
//    G_OBJC_DATA_MEMBERS_TYPE(YourClassNameHere)& dataMembers = G_OBJC_GET_DATA_MEMBERS(YourClassNameHere, classInstance);
//
//    // Getting a specific data member of a G_OBJC class. Note: This example is after getting the data members of the G_OBJC class.
//    dataMembers.specificDataMemberName
//
//    // Setting a specific data member of a G_OBJC class. Note: This example is after getting the data members of the G_OBJC class.
//    dataMembers.specificDataMemberName = 3.14f;
//
//    // Calling a member function of a G_OBJC class.
//    internal_gw::G_OBJC_CALL_METHOD(YourClassNameHere, classInstance, YourMemberFunctionNameHere);
//
//    // Calling a member function of a G_OBJC class with arguments.
//    internal_gw::G_OBJC_CALL_METHOD_WITH_ARGUMENTS(YourClassNameHere, classInstance, YourMemberFunctionNameHere, 3.14f, true);
//
// --- DIRECTIONS END ---

#define G_OBJC_GET_CLASS(class_name) Class##class_name()

// G_OBJC Class Creation:

#define G_OBJC_CLASS_DECLARE(class_name) static Class class_name

#define G_OBJC_CLASS_ALLOCATE(class_name, class_parent) class_name = objc_allocateClassPair([class_parent class], #class_name, 0)

#define G_OBJC_CLASS_REGISTER(class_name) objc_registerClassPair(class_name)

#define G_OBJC_CLASS_DEFINITION_HEADER(class_name) static Class& G_OBJC_GET_CLASS(class_name)

#define G_OBJC_CLASS_BEGIN(class_name, class_parent) G_OBJC_CLASS_DEFINITION_HEADER(class_name)\
{\
    G_OBJC_CLASS_DECLARE(class_name);\
    if (class_name == nil)\
    {\
        G_OBJC_CLASS_ALLOCATE(class_name, class_parent);\
        if (true) // Added to allow for a {code block}.

#define G_OBJC_CLASS_END(class_name) G_OBJC_CLASS_REGISTER(class_name);\
    }\
    return class_name; \
}

#define G_OBJC_CLASS_METHOD(class_name, method_name, method_types_string) class_addMethod(class_name, @selector(method_name), (IMP)class_name##Method##method_name, method_types_string)

#define G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(class_name, method_name, method_types_string, argument_colons) class_addMethod(class_name, @selector(method_name argument_colons), (IMP)class_name##Method##method_name, method_types_string)

#define G_OBJC_CLASS_ADD_PROPERTY(class_name, type_name, property_name) class_addIvar(class_name, "_"#property_name, sizeof(type_name), log2(sizeof(type_name)), @encode(type_name));\
{\
    objc_property_attribute_t instance_variable_type = { "T", "@\""#type_name"\"" };\
    objc_property_attribute_t instance_property_name = { "V", "_"#property_name };\
    objc_property_attribute_t instance_variable_attributes[2] = { instance_variable_type, instance_property_name };\
    class_addProperty(class_name, #property_name, instance_variable_attributes, 2);\
}

#define G_OBJC_CLASS_GET_PROPERTY_METHOD(class_name, property_name) G_OBJC_CLASS_METHOD(class_name, property_name, "@@:")

#define G_OBJC_CLASS_SET_PROPERTY_METHOD(class_name, property_name) G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(class_name, Set##property_name, "v@:@", :)

#define G_OBJC_CLASS_PROPERTY(class_name, type_name, property_name) G_OBJC_CLASS_ADD_PROPERTY(class_name, type_name, property_name);\
G_OBJC_CLASS_GET_PROPERTY_METHOD(class_name, property_name);\
G_OBJC_CLASS_SET_PROPERTY_METHOD(class_name, property_name)

// G_OBJC Class Interface:

#define G_OBJC_HEADER_STATIC_METHOD(class_name, method_return_type, method_name) static method_return_type class_name##Method##method_name(id self, SEL _cmd)

#define G_OBJC_HEADER_STATIC_METHOD_WITH_ARGUMENTS(class_name, method_return_type, method_name, ...) static method_return_type class_name##Method##method_name(id self, SEL _cmd, __VA_ARGS__)

#define G_OBJC_HEADER_INSTANCE_METHOD(class_name, method_return_type, method_name) inline method_return_type class_name##Method##method_name(id self, SEL _cmd)

#define G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(class_name, method_return_type, method_name, ...) inline method_return_type class_name##Method##method_name(id self, SEL _cmd, __VA_ARGS__)

#define G_OBJC_HEADER_GET_PROPERTY_METHOD(class_name, type_name, property_name) G_OBJC_HEADER_INSTANCE_METHOD(class_name, type_name&, property_name)

#define G_OBJC_HEADER_GET_PROPERTY_METHOD_FOR_POINTER(class_name, type_name, property_name) G_OBJC_HEADER_INSTANCE_METHOD(class_name, type_name, property_name)

#define G_OBJC_HEADER_SET_PROPERTY_METHOD(class_name, type_name, property_name) G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(class_name, void, Set##property_name, type_name newVal)

#define G_OBJC_HEADER_SET_PROPERTY_METHOD_FOR_POINTER(class_name, type_name, property_name) G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(class_name, void, Set##property_name, type_name newVal)

#define G_OBJC_IMPLEMENTATION_GET_PROPERTY_METHOD(class_name, type_name, property_name) G_OBJC_HEADER_GET_PROPERTY_METHOD(class_name, type_name, property_name)\
{\
    Ivar ivar = class_getInstanceVariable(G_OBJC_GET_CLASS(class_name), "_"#property_name);\
    CFTypeRef selfPtr = CFBridgingRetain(self);\
    type_name* varPtr = (type_name*)((uint8_t*)selfPtr + ivar_getOffset(ivar));\
    return *varPtr;\
}

#define G_OBJC_IMPLEMENTATION_GET_PROPERTY_METHOD_FOR_POINTER(class_name, type_name, property_name) G_OBJC_HEADER_GET_PROPERTY_METHOD_FOR_POINTER(class_name, type_name, property_name)\
{\
    Ivar ivar = class_getInstanceVariable(G_OBJC_GET_CLASS(class_name), "_"#property_name);\
    return (type_name)object_getIvar(self, ivar);\
}

#define G_OBJC_IMPLEMENTATION_SET_PROPERTY_METHOD(class_name, type_name, property_name) G_OBJC_HEADER_SET_PROPERTY_METHOD(class_name, type_name, property_name)\
{\
    Ivar ivar = class_getInstanceVariable(G_OBJC_GET_CLASS(class_name), "_"#property_name);\
    CFTypeRef selfPtr = CFBridgingRetain(self);\
    type_name* varPtr = (type_name*)((uint8_t*)selfPtr + ivar_getOffset(ivar));\
    *varPtr = newVal;\
}

#define G_OBJC_IMPLEMENTATION_SET_PROPERTY_METHOD_FOR_POINTER(class_name, type_name, property_name) G_OBJC_HEADER_SET_PROPERTY_METHOD_FOR_POINTER(class_name, type_name, property_name)\
{\
    Ivar ivar = class_getInstanceVariable(G_OBJC_GET_CLASS(class_name), "_"#property_name);\
    type_name oldVal = (type_name)object_getIvar(self, ivar);\
    if (oldVal != newVal)\
        object_setIvar(self, ivar, (id)newVal);\
}

#define G_OBJC_HEADER_PROPERTY_METHODS(class_name, type_name, property_name)\
G_OBJC_HEADER_GET_PROPERTY_METHOD(class_name, type_name, property_name);\
G_OBJC_HEADER_SET_PROPERTY_METHOD(class_name, type_name, property_name)

#define G_OBJC_HEADER_PROPERTY_METHODS_FOR_POINTER(class_name, type_name, property_name)\
G_OBJC_HEADER_GET_PROPERTY_METHOD_FOR_POINTER(class_name, type_name, property_name);\
G_OBJC_HEADER_SET_PROPERTY_METHOD_FOR_POINTER(class_name, type_name, property_name)

#define G_OBJC_IMPLEMENTATION_PROPERTY_METHODS(class_name, type_name, property_name)\
G_OBJC_IMPLEMENTATION_GET_PROPERTY_METHOD(class_name, type_name, property_name);\
G_OBJC_IMPLEMENTATION_SET_PROPERTY_METHOD(class_name, type_name, property_name)

#define G_OBJC_IMPLEMENTATION_PROPERTY_METHODS_FOR_POINTER(class_name, type_name, property_name)\
G_OBJC_IMPLEMENTATION_GET_PROPERTY_METHOD_FOR_POINTER(class_name, type_name, property_name);\
G_OBJC_IMPLEMENTATION_SET_PROPERTY_METHOD_FOR_POINTER(class_name, type_name, property_name)

// G_OBJC Class Usage:

#define G_OBJC_CALL_METHOD(class_name, class_instance, method_name) class_name##Method##method_name(class_instance, @selector(method_name))

#define G_OBJC_CALL_METHOD_WITH_ARGUMENTS(class_name, class_instance, method_name, ...) class_name##Method##method_name(class_instance, @selector(method_name), __VA_ARGS__)

#define G_OBJC_GET_PROPERTY(class_name, class_instance, property_name) class_name##Method##property_name(class_instance, @selector(property_name))

#define G_OBJC_SET_PROPERTY(class_name, class_instance, property_name, new_value) class_name##MethodSet##property_name(class_instance, @selector(property_name), new_value)

// G_OBJC Class Data Members:

#define G_OBJC_DATA_MEMBERS_TYPE(class_name) class_name##DataMembers

#define G_OBJC_DATA_MEMBERS_STRUCT(class_name) struct class_name##DataMembers

#define G_OBJC_CLASS_DATA_MEMBERS_PROPERTY(class_name) G_OBJC_CLASS_ADD_PROPERTY(class_name, G_OBJC_DATA_MEMBERS_TYPE(class_name), dataMembersOf##class_name);\
G_OBJC_CLASS_GET_PROPERTY_METHOD(class_name, dataMembersOf##class_name)

#define G_OBJC_HEADER_DATA_MEMBERS_PROPERTY_METHOD(class_name)\
G_OBJC_HEADER_GET_PROPERTY_METHOD(class_name, G_OBJC_DATA_MEMBERS_TYPE(class_name), dataMembersOf##class_name)

#define G_OBJC_IMPLEMENTATION_DATA_MEMBERS_PROPERTY_METHOD(class_name)\
G_OBJC_IMPLEMENTATION_GET_PROPERTY_METHOD(class_name, G_OBJC_DATA_MEMBERS_TYPE(class_name), dataMembersOf##class_name)

#define G_OBJC_GET_DATA_MEMBERS(class_name, class_instance) G_OBJC_GET_PROPERTY(class_name, class_instance, dataMembersOf##class_name)

// G_OBJC MACROS END

// Thanks to Chris for this little snippet and reminding everyone the proper way to interact with the apple UI layer
// https://chritto.wordpress.com/2012/12/20/updating-the-ui-from-another-thread/
inline void RUN_ON_UI_THREAD(dispatch_block_t block)
{
    if ([NSThread isMainThread])
        block();
    else
        dispatch_sync(dispatch_get_main_queue(), block);
}

inline void FlushMacEventLoop()
{
    while (TRUE)
    {
        if ([NSThread isMainThread])
        {
            NSEvent* event = [NSApp nextEventMatchingMask : NSEventMaskAny
                untilDate : [NSDate distantPast]
                inMode : NSDefaultRunLoopMode
                dequeue : YES];

            if (event == nil)
                break;

            [NSApp sendEvent : event] ;
            [NSApp updateWindows] ;
        }
    }
}
#endif // #endif __APPLE__
#endif // #endif GATEWARE_MACUTILS_H


/*---------------------------------
|	End of macutils.h
----------------------------------*/


/*---------------------------------
|	Begin of GUtility.h
----------------------------------*/
#ifndef GUTILITY_H
#define GUTILITY_H

#include <locale>
#include <codecvt>

namespace INTERNAL
{
	//UINT_MAX is not defined on Mac or Linux.
	//Internal #define for this.
#define G_UINT_MAX 0xFFFFFFFF

#if defined(_WIN32)
	//Macro to perform string conversions.
#define G_TO_UTF16(value) stringConverter.from_bytes(value)
#define G_TO_UTF8(value) stringConverter.to_bytes(value)
#elif defined(__APPLE__) || defined(__linux__)
	//These string conversions are not necessary on Linux/Apple.
	//They are designed to be replaced with just the value given to them.
#define G_TO_UTF16(value) value
#define G_TO_UTF8(value) value
	//Defined to replace instances of strcpy_s with strlcpy on Linux/Mac.
	//This is because strcpy_s is not supported on GCC.
#define strcpy_s(...) strlcpy(__VA_ARGS__)
#else

//If you get this error then we are currently on a platform not supported by Gateware.
#error Gateware Libraries are not built for your current system
#endif

	//All variables and functions below are macroed above. This is so the code wrote out
	//will be the exact same code no matter the system we are writing it for.


	//This is a utf8 to utf16 and utf16 to utf8 string converter.
	//Used like so...
	//to utf16: stringConverter.from_bytes(const char*)  //Is overloaded to accept string as well.
	//to utf8: stringConverter.to_bytes(const wchar_t*) //Is overloaded to accept wstring as well.
	static ::std::wstring_convert < ::std::codecvt_utf8_utf16<wchar_t>> stringConverter;

	//GCC does not support strcpy_s. This is a safe strcpy function for use on Linux.
#if defined(__linux__) || defined(__APPLE__)
#pragma GCC diagnostic ignored "-Wunused-function"
	static unsigned int strlcpy(char* destination, unsigned int strLen, const char* const source)
	{
		return snprintf(destination, strLen, "%s", source);
	}
#pragma GCC diagnostic warning "-Wunused-function"
#endif

}//end INTERNAL namespace

#endif // #endif GUTILITY_H


/*---------------------------------
|	End of GUtility.h
----------------------------------*/


/*---------------------------------
|	Begin of ld_vector.h
----------------------------------*/
/************************************************
	Lazy Delete Vector

	description :

	the lazy delete vector is a vector. or more to the point,
	it can emulate a vector's behavior. this however is not it's
	purpose, merely a side benefit. The ld_vector is a factory
	design pattern transparent to the user.	Use the ld_vector
	when the ordering of your data is unimportant, but speed is.

	Author : Lari H. Norri
	date started : 10/??/04
	last modified : 01/06/19 (in FINAL rev. 1.8)

	Use :	for exact "stl vector" behavior, do not use any of the following
			functions. "remove, or "set_valid".

			for "factory (FAST!!!)" behavior, do not use the following:
			"for loops with array indexing"(use the provided iterator instead),
			"erase", "insert", "collapse_left", or "collapse_right"

			you can mix these behaviors safely, but read the function comments to
			understand the reprucusions. I provide some vector mimicing operations
			for flexibility and easy code integration, however this class is designed
			for superfast random access + adding + deleteing. I do not recommend this
			class if the order of your data is very important to you.

	Licence :	This code is free to use/modify whatever.
				Just mention me as the original author.

	Thanks :	A very big THANK YOU goes out to Lee Wood,
				your knowledge and insight have been invaluable
				during the development of this ADT. I would	also
				like to thank Chris Ragland and Nelson Nievies
				for their input. Thanks to Jeff Jackowski for
				adding in-place constructors and destructors
				for better compatibility with complex classes. 
				finally Hewlet Packard for your amazing STL.

***********************************************/

#ifndef _LD_VECTOR_H_
#define _LD_VECTOR_H_

#include <assert.h>
#include <memory.h>
#include <new>   // needed for in-place new

namespace gtl
{

	// defines an signed/unsigned interger 32 bits in length
	// and a boolean value 8 bits in length
#define uInt32 unsigned int
#define Int32 signed int
#define Bool8 bool

// Levels of bit division for 32. 32^1, 32^2, 32^3...
#define LOW_SHIFT	>>5u
#define KI_SHIFT	>>10u
#define KI32_SHIFT	>>15u
#define MI_SHIFT	>>20u
#define MI32_SHIFT	>>25u

// the class is a little heavier now at 68 bytes pre-push_back.
// however, ld_vector will now retain maximum efficiency up to 33.5 million items
// after that, search time will increase by 1 cycle per every extra 33.5 million
	template< typename T >
	class ld_vector
	{
		// how much can you hold vs what your holding.
		uInt32 _capacity, _size, _last;	// last is defined as one past the end

		// bit maps	(used for fast adding/removal)
		uInt32* Mi32_map, Mi32_sz;    // 32 bits per 33554432 items, 32^5 bits tracked
		uInt32* Mi_map, Mi_sz;     // 32 bits per 1048576 items, 32^4 bits tracked
		uInt32* Ki32_map, Ki32_sz;  // 32 bits per 32768 items, 32^3 bits tracked
		uInt32* Ki_map, Ki_sz;   // 32 bits per 1024 items, 32^2 bits tracked
		uInt32* low_map, low_sz; // 32 bits per 32 items, 32^1 bits tracked

		// all the template data stored by the vector
		T* Data;

		// stores up to date accurate info about this ld_vector
		struct Arbitrator
		{
			uInt32* _end; // one past the last item
			uInt32* lmap; // pointer to the active lowmap (for iteration)
			T* dat;	// data vault access
		};
		Arbitrator arbiter;

		// Macros for enabling, disabling and testing bits in the maps (TEST_MAP_BIT is only used by the low_map)
#define TEST_MAP_BIT(map, index) (((map)[(index) >> 5u]) & (0x00000001u << ((index) & 31u)))
// map = map to shift, div = divisor for the index (these macros turn bits on & off in an array)
#define SHIFT_ENABLE(map,index) (map)[(index)>>5u] |= (0x00000001u << ((index) & 31u))
#define SHIFT_DISABLE(map,index) (map)[(index)>>5u] &= ~(0x00000001u << ((index) & 31u))
// enables a bit in the low map and any subsequent higher map
#define ENABLE_MAP_BIT(index) \
			SHIFT_ENABLE(low_map,(index));\
			if(0xFFFFFFFF == low_map[(index)LOW_SHIFT]){\
				SHIFT_ENABLE(Ki_map,(index)LOW_SHIFT);\
				if(0xFFFFFFFF == Ki_map[(index)KI_SHIFT]){\
					SHIFT_ENABLE(Ki32_map,(index)KI_SHIFT);\
					if(0xFFFFFFFF == Ki32_map[(index)KI32_SHIFT]){\
						SHIFT_ENABLE(Mi_map,(index)KI32_SHIFT);\
						if(0xFFFFFFFF == Mi_map[(index)MI_SHIFT]){\
							SHIFT_ENABLE(Mi32_map,(index)MI_SHIFT);}}}}

	// disables a bit in the low map and any subsequent higher map
#define DISABLE_MAP_BIT(index) \
			SHIFT_DISABLE(low_map,(index));\
			if(0xFFFFFFFF != low_map[(index)LOW_SHIFT]){\
				SHIFT_DISABLE(Ki_map,(index)LOW_SHIFT);\
				if(0xFFFFFFFF != Ki_map[(index)KI_SHIFT]){\
					SHIFT_DISABLE(Ki32_map,(index)KI_SHIFT);\
					if(0xFFFFFFFF != Ki32_map[(index)KI32_SHIFT]){\
						SHIFT_DISABLE(Mi_map,(index)KI32_SHIFT);\
						if(0xFFFFFFFF != Mi_map[(index)MI_SHIFT]){\
							SHIFT_DISABLE(Mi32_map,(index)MI_SHIFT);}}}}

	// the following macros are used to find an open bit quickly from a 32bit value
#define _TEST_IF(x, b32) if((x) & ~(b32)) {
#define _TEST_ELSE(x, b32) } else if((x) & ~(b32)) {
#define _SET_IF(x, b32, t, f, i) (i) = ((x) & ~(b32)) ? (t) : (f);
#define _SET_ELSE(x, b32, t, f, i) } else if((x) & ~(b32)) { (i) = (t); } else { (i) = (f); }

// finds an open bit(index) from a 32 bit value (using divide & conquer)
// btw... yes i know this is a flagrant abuse of macros,
// but you really dont want to see this unrolled.
#define FIND_OPEN_BIT(i, b32) \
			{	_TEST_IF(0x0000FFFFu, b32)\
					_TEST_IF(0x000000FFu, b32)\
						_TEST_IF(0x0000000Fu, b32)\
							_TEST_IF(0x00000003u, b32)\
								_SET_IF(0x00000001u, b32, 0u, 1u, i)\
							_SET_ELSE(0x00000004u, b32, 2u, 3u, i)\
						_TEST_ELSE(0x00000030u, b32)\
							_SET_IF(0x00000010u, b32, 4u, 5u, i)\
						_SET_ELSE(0x00000040u, b32, 6u, 7u, i)\
					_TEST_ELSE(0x00000F00u, b32)\
						_TEST_IF(0x00000300u, b32)\
							_SET_IF(0x00000100u, b32, 8u, 9u, i)\
						_SET_ELSE(0x00000400u, b32, 10u, 11u, i)\
					_TEST_ELSE(0x00003000u, b32)\
						_SET_IF(0x00001000u, b32, 12u, 13u, i)\
					_SET_ELSE(0x00004000u, b32, 14u, 15u, i)\
				_TEST_ELSE(0x00FF0000u, b32)\
					_TEST_IF(0x000F0000u, b32)\
						_TEST_IF(0x00030000u, b32)\
							_SET_IF(0x00010000u, b32, 16u, 17u, i)\
						_SET_ELSE(0x00040000u, b32, 18u, 19u, i)\
					_TEST_ELSE(0x00300000u, b32)\
						_SET_IF(0x00100000u, b32, 20u, 21u, i)\
					_SET_ELSE(0x00400000u, b32, 22u, 23u, i)\
				_TEST_ELSE(0x0F000000u, b32)\
					_TEST_IF(0x03000000u, b32)\
						_SET_IF(0x01000000u, b32, 24u, 25u, i)\
					_SET_ELSE(0x04000000u, b32, 26u, 27u, i)\
				_TEST_ELSE(0x30000000u, b32)\
					_SET_IF(0x10000000u, b32, 28u, 29u, i)\
				_SET_ELSE(0x40000000u, b32, 30u, 31u, i)\
			}

	// this is called by any constructor to initialize the vector
		void _create(void)
		{
			// the vector can hold nothing by default
			_capacity = _size =
				// all bit maps start with 0 bits
				Mi32_sz = Mi_sz = Ki32_sz = Ki_sz = low_sz = 0u;
			// all maps are safe to delete initially
			Mi32_map = Mi_map = Ki32_map = Ki_map = low_map = 0u;
			Data = 0u;	// clear all data
			_last = 0u;	// the index of the last element + 1
			// zero out the arbiter
			memset(&arbiter, 0u, sizeof(Arbitrator));
			arbiter._end = &_last; // fixes crashing when iterating on an empty list
		}

		// find all allocated objects and destroy them
		void _destruct(void) {
			iterator i = begin();
			while (i != end()) {
				(*i).~T();
				i++;
			}
		}

		// when the vector runs out of memory, this command doubles its capacity.
		// This function could be changed to expand in a single step to the required
		// capacity so that resizing from 0 to pow(2, n) doesn't take n calls of
		// this function.
		void _expand(void)
		{
			// double the capacity
			(_capacity) ? _capacity = _capacity << 1u : _capacity = 1u;
			T* old = Data;
			Data = (T*)malloc(sizeof(T) * _capacity);  // allocate new data array

			// macro will double & retain the contents of an uInt32 array
#define _GROW_ARRAY(arr,sz) \
				{	(sz) ? sz = sz << 1u : sz = 1u;\
					uInt32 * _narr = new uInt32[sz];\
					memset(_narr, 0u, sz << 2u);\
					if(sz > 1u) memcpy(_narr, arr, sz << 1u);\
					delete [] arr;\
					arr = _narr;\
				}

		// allocate the bit-maps if neccasary
			if (!low_sz || low_sz < (_capacity LOW_SHIFT)) _GROW_ARRAY(low_map, low_sz);
			if (!Ki_sz || Ki_sz < (_capacity KI_SHIFT)) _GROW_ARRAY(Ki_map, Ki_sz);
			if (!Ki32_sz || Ki32_sz < (_capacity KI32_SHIFT)) _GROW_ARRAY(Ki32_map, Ki32_sz);
			if (!Mi_sz || Mi_sz < (_capacity MI_SHIFT)) _GROW_ARRAY(Mi_map, Mi_sz);
			if (!Mi32_sz || Mi32_sz < (_capacity MI32_SHIFT)) _GROW_ARRAY(Mi32_map, Mi32_sz);

			// don't need the macro anymore
#undef _GROW_ARRAY

// update the arbiter (this is the only time we need do so)
			arbiter._end = &_last;
			arbiter.dat = Data;
			arbiter.lmap = low_map;

			// move data (v1.7 fixed some 64bit compatibility issues (more to come))
			iterator i = begin();
			while (i != end()) { // v1.8 returned old C style casts for compatibility
				new (Data + (uInt32)i) T(old[(uInt32)i]); // copy construct new data
				old[(uInt32)i].~T(); // destruct old data
				i++;
			}
			free(old);  // deallocate old data
		}

	public:

		// define the nested iterator class
		class iterator;
		friend class iterator;

		class iterator
		{
			uInt32 index; // our current index into the ld_vector
			const Arbitrator* envoy; // lets the iter stay informed about it's designated vector

		public:

			// creates an iterator with the proper values
			explicit iterator(uInt32 i = 0u, const Arbitrator* a = 0u) : index(i), envoy(a) { }

			T* operator->() const { return &envoy->dat[index]; }
			T& operator*() const { return envoy->dat[index]; }

			Bool8 operator==(const iterator& comp) const
			{
				return index == comp.index && envoy == comp.envoy;
			}

			Bool8 operator!=(const iterator& comp) const
			{
				return index != comp.index || envoy != comp.envoy;
			}

			// coverts an iterator directly to it's index
			operator uInt32() const { return index; }
			operator Int32() const { return (Int32)index; }
			// is false if the iterator is not at a valid location
			operator Bool8() const
			{
				// take range into account
				if (!envoy->_end || index >= *envoy->_end) return false;
				return (TEST_MAP_BIT(envoy->lmap, index)) ? true : false;
			}

			iterator& operator++()
			{
				if (index + 1u >= (*envoy->_end) + 1u) return (*this); // don't iterate after the end
				while (++index < (*envoy->_end) && !TEST_MAP_BIT(envoy->lmap, index))
					if (!(index & 31u) && 0x00000000u == envoy->lmap[index >> 5u])
						if (index + 32u < (*envoy->_end)) index += 31u; // skip 32 empty items if possible
				return (*this);
			}

			iterator& operator--()
			{
				// if you reverse iterate on begin(0) it will take you to end(_last)
				if (!index) { index = *envoy->_end; return (*this); }
				while (--index && !TEST_MAP_BIT(envoy->lmap, index)) // hmmm
					if (index > 31u && !((index - 32u) & 31u) && 0x00000000u == envoy->lmap[(index - 32u) >> 5u])
						index -= 31u; // skip 32 empty items if possible
				return (*this);
			}

			iterator operator++(Int32)
			{
				iterator tmp = *this;
				++* this;
				return tmp;
			}

			iterator operator--(Int32)
			{
				iterator tmp = *this;
				--* this;
				return tmp;
			}

			iterator operator+(Int32 mov) const { return iterator(index + mov, envoy); }
			iterator operator-(Int32 mov) const { return iterator(index - mov, envoy); }
			iterator operator+(uInt32 mov) const { return iterator(index + mov, envoy); }
			iterator operator-(uInt32 mov) const { return iterator(index - mov, envoy); }
		};

		// define the nested const_iterator class
		// exactly like the first one, but const
		class const_iterator;
		friend class const_iterator;
		// the only difference between the iterators, is that you may not edit the values of the const iter
		class const_iterator
		{
			uInt32 index; // our current index into the ld_vector
			const Arbitrator* envoy; // lets the iter stay informed about it's designated vector
		public:
			// creates an const_iterator with the proper values
			explicit const_iterator(uInt32 i = 0u, const Arbitrator* a = 0u) : index(i), envoy(a) { }
			// data accessors (const)
			const T* operator->() const { return &envoy->dat[index]; }
			const T& operator*() const { return envoy->dat[index]; }
			// comparison ops
			Bool8 operator==(const const_iterator& comp) const
			{
				return index == comp.index && envoy == comp.envoy;
			}
			Bool8 operator!=(const const_iterator& comp) const
			{
				return index != comp.index || envoy != comp.envoy;
			}
			// coverts an const_iterator directly to it's index
			operator uInt32() const { return index; }
			operator Int32() const { return (Int32)index; }
			// is false if the const_iterator is not at a valid location
			operator Bool8() const
			{
				// take range into account
				if (!envoy->_end || index >= *envoy->_end) return false;
				return (TEST_MAP_BIT(envoy->lmap, index)) ? true : false;
			}
			// increment op
			const_iterator& operator++()
			{
				if (index + 1u >= (*envoy->_end) + 1u) return (*this); // don't iterate after the end
				while (++index < (*envoy->_end) && !TEST_MAP_BIT(envoy->lmap, index))
					if (!(index & 31u) && 0x00000000u == envoy->lmap[index >> 5u])
						if (index + 32u < (*envoy->_end)) index += 31u; // skip 32 empty items if possible
				return (*this);
			}
			// decrement op
			const_iterator& operator--()
			{
				// if you reverse iterate on begin(0) it will take you to end(_last)
				if (!index) { index = *envoy->_end; return (*this); }
				while (--index && !TEST_MAP_BIT(envoy->lmap, index)) // hmmm
					if (index > 31u && !((index - 32u) & 31u) && 0x00000000u == envoy->lmap[(index - 32u) >> 5u])
						index -= 31u; // skip 32 empty items if possible
				return (*this);
			}
			// increment post
			const_iterator operator++(Int32)
			{
				const_iterator tmp = *this;
				++* this;
				return tmp;
			}
			// decrement post
			const_iterator operator--(Int32)
			{
				const_iterator tmp = *this;
				--* this;
				return tmp;
			}
			// jump by element amount
			const_iterator operator+(Int32 mov) const { return const_iterator(index + mov, envoy); }
			const_iterator operator-(Int32 mov) const { return const_iterator(index - mov, envoy); }
			const_iterator operator+(uInt32 mov) const { return const_iterator(index + mov, envoy); }
			const_iterator operator-(uInt32 mov) const { return const_iterator(index - mov, envoy); }
		};

		// constructor + trilogy of evil
		ld_vector(void) { _create(); } // default constructor
		ld_vector(uInt32 count) { _create(); reserve(count); } // this constructor reserves room
		ld_vector(uInt32 count, const T& val) // this reserves and sets all items to "val"
		{
			_create(); reserve(count);
			for (uInt32 i = 0; i < count; ++i)
			{
				new (Data + i) T(val); ENABLE_MAP_BIT(i);
			}
			_size = count;
		}

		// assigment operator
		ld_vector<T>& operator=(const ld_vector<T>& cpy)
		{
			// don't perform needless copy
			if (this == &cpy) return *this;
			// copy the valid contents of the incomming vector
			clear(); // empty this vector
			// reserve room	to copy to
			if (_capacity < cpy._capacity) reserve(cpy._capacity);
			// copy all valid items
			const_iterator copy = cpy.begin(), last = cpy.end();
			while (copy != last)
			{
				new (Data + (uInt32)copy) T(cpy.Data[(uInt32)copy]);
				ENABLE_MAP_BIT((uInt32)copy);
				++copy;
			}
			// match the sizes & the last item
			_size = cpy._size;
			_last = cpy._last;
			return *this;
		}

		// copy constructor
		ld_vector(const ld_vector<T>& copy) { _create(); *this = copy; }

		// destructor
		~ld_vector(void) { _destroy(); }

		// return an iterator to the front of the ld_vector
		iterator begin()
		{
			return (_capacity) ? ++iterator(0xFFFFFFFFu, &arbiter) : iterator(0u, &arbiter);
		}
		const_iterator begin() const // const iterator version
		{
			return (_capacity) ? ++const_iterator(0xFFFFFFFFu, &arbiter)
				: const_iterator(0u, &arbiter);
		}
		// return an iterator to one past the end of the ld_vector
		iterator end()
		{
			return iterator(_last, &arbiter);
		}
		const_iterator end() const // const iterator version
		{
			return const_iterator(_last, &arbiter);
		}

		// returns the number of items in the vector
		uInt32 size(void) const { return _size; }
		// returns the capacity of the vector
		uInt32 capacity(void) const { return _capacity; }

		// reserves at least r items in the vector (memory is always reserved in powers of two)
		// capacity	is garunteed to be >= to r
		void reserve(uInt32 r) { while (_capacity < r) _expand(); } // could be optimized

		// return an item from the array
		T& operator[](uInt32 index) {
			// the index must be within bounds
			assert(index < _capacity);
			// the item must be allocated
			assert(TEST_MAP_BIT(low_map, index));
			return Data[index];
		}
		// return an item from the array const
		const T& operator[](uInt32 index) const {
			// the index must be within bounds
			assert(index < _capacity);
			// the item must be allocated
			assert(TEST_MAP_BIT(low_map, index));
			return Data[index];
		}

		// tells you if an index in the array is in use
		Bool8 is_valid(uInt32 index) const
		{
			if (index >= _capacity) return false;
			return (TEST_MAP_BIT(low_map, index)) ? true : false;
		}

		// forces an index to make itself valid/Invalid
		// making an index Invalid is the same as calling remove on an iterator at the same index.
		void set_valid(uInt32 index, Bool8 valid = true)
		{
			if (valid && !TEST_MAP_BIT(low_map, index))
			{
				ENABLE_MAP_BIT(index); ++_size;
				if (index >= _last) _last = index + 1u; // possibly update last position
				new (Data + index) T;  // construct the item
			}
			else if (!valid && TEST_MAP_BIT(low_map, index))
			{
				if (index == _last - 1u) --_last; // possibly update last position
				Data[index].~T();   // destruct the item
				DISABLE_MAP_BIT(index); --_size;
			}
		}

		// returns an open slot in the vector, if none it will expand
		// this function is VOLATILE!
		// Meaning the vector may be in a different memory pool after you call it. (_expand)
		uInt32 find_open(void)
		{
			// if the vector is full, expand it
			if (_size >= _capacity) _expand();
			// now... an open slot is garunteed	so lets find it.
			uInt32 shift = 0u, _bit;
			while (Mi32_map[shift] == 0xFFFFFFFFu) ++shift; // move to an open 33.5 million
			// from here use divide & conquer to find an open location as fast as possible
			if (Mi32_map[shift]) { FIND_OPEN_BIT(_bit, Mi32_map[shift]); }
			else _bit = 0u;
			shift = (shift << 5u) + _bit; // first open million
			if (Mi_map[shift]) { FIND_OPEN_BIT(_bit, Mi_map[shift]); }
			else _bit = 0u;
			shift = (shift << 5u) + _bit; // first open 32 thousand
			if (Ki32_map[shift]) { FIND_OPEN_BIT(_bit, Ki32_map[shift]); }
			else _bit = 0u;
			shift = (shift << 5u) + _bit; // first open 1024
			if (Ki_map[shift]) { FIND_OPEN_BIT(_bit, Ki_map[shift]); }
			else _bit = 0u;
			shift = (shift << 5u) + _bit; // first open 32
			if (low_map[shift]) { FIND_OPEN_BIT(_bit, low_map[shift]); }
			else _bit = 0u;
			return (shift << 5u) + _bit; // the open item
		}

		// adds an item to the vector and returns its index (index is garunteed to stay valid)
		// the only operations that can effect indicies	are: collapse_left, collapse_right, insert, and erase.
		// keep in mind that push_back fills unused slots first, only then does it add to the end.
		// this function is VOLATILE!
		// Meaning the vector may be in a different memory pool after you call it. (_expand)
		uInt32 push_back(const T& val)
		{
			// IMPORTANT NOTE: Never use push_back in the following manner
			// "myvector[x].val = myvector.push_back( any )"
			// Instead use : "int loc = myvector.push_back( any ); myvector[x].val = loc;"
			// Although this usage is rare...
			// Keep in mind that a vector can and will switch internal memory banks as required.
			uInt32 _open = find_open();
			new (Data + _open) T(val);
			ENABLE_MAP_BIT(_open);
			++_size;
			if (_open >= _last) _last = _open + 1u; // update the _last spot
			return _open;
		}

		// Insert an element before a specific point
		// returns an iterator to the newly inserted element
		// this will distort indicies, use "push_back" if you want to maintain index intergrity.
		iterator insert(iterator point, const T& val)
		{
			// if the vector is full, or it cannot expand right, expand it
			iterator shift = --end();
			if (_size >= _capacity || ((uInt32)shift) == _capacity - 1u) _expand();
			// shift all items right one spot
			while (shift != point)
			{
				new (Data + (uInt32)shift + 1u) T(Data[(uInt32)shift]);
				Data[(uInt32)shift].~T();
				DISABLE_MAP_BIT((uInt32)shift);
				ENABLE_MAP_BIT(((uInt32)shift) + 1u);
				--shift;
			}
			// shift current item in point
			new (Data + (uInt32)point + 1u) T(Data[(uInt32)point]);
			Data[(uInt32)point].~T();
			ENABLE_MAP_BIT((uInt32)point + 1u);
			// add item
			new (Data + (uInt32)point) T(val); ++_size;
			// move the _last position, one to the right
			++_last;
			return point;
		}

		// removes the last valid item in the vector
		void pop_back(void)
		{
			if (!_size) return;
			set_valid((uInt32)--end(), false);
		}

		// return refrences to the first and last valid items.
		T& front(void) { return *begin(); }
		const T& front(void) const { return *begin(); }
		T& back(void) { return *(--end()); }
		const T& back(void) const { return *(--end()); }

		// removes an item from the vector (does not effect other items)
		// returns an iterator to the next valid item
		iterator remove(iterator rem) { set_valid(rem, false); return ++rem; }

		// removes all gaps from the vector, and lines data starting from the begining
		void collapse_left(void)
		{
			if (!_size || _size == _capacity) return;
			uInt32 track = 0u; // when track == _size, all items have been shifted left
			iterator find; // quickly find an item in use
			while (track < _size)
			{
				if (!TEST_MAP_BIT(low_map, track)) // determine if an empty spot must be filled
				{
					find = ++iterator(track, &arbiter); // find used item
					new (Data + track) T(Data[(uInt32)find]); // fill the open slot with a valid item
					Data[(uInt32)find].~T();
					// update the bitmaps
					DISABLE_MAP_BIT((uInt32)find)
						ENABLE_MAP_BIT(track)
				}
				++track; // move to the next item
			}
			// update the last point
			_last = ((uInt32)(--iterator(_capacity, &arbiter))) + 1u;
		}

		// removes all gaps from the vector, and lines data starting from the end
		void collapse_right(void)
		{
			if (!_size || _size == _capacity) return;
			uInt32 track = _capacity - 1u; // when track < _capacity - _size, all items have been shifted right
			iterator find; // quickly find an item in use
			while (track >= (_capacity - _size))
			{
				if (!TEST_MAP_BIT(low_map, track)) // determine if an empty spot must be filled
				{
					find = --iterator(track, &arbiter); // find used item
					new (Data + track) T(Data[(uInt32)find]); // fill the open slot with a valid item
					Data[(uInt32)find].~T();
					// update the bitmaps
					DISABLE_MAP_BIT((uInt32)find)
						ENABLE_MAP_BIT(track)
				}
				--track; // move to the prev item
			}
			// update the last point
			_last = _capacity;
		}

		// removes an item from the vector and collapses all items after it to the left
		// this will distort indicies, use "remove" if you want to maintain index intergrity.
		iterator erase(iterator ers)
		{
			// now collapse all following items
			if (!_size) return end();
			uInt32 track = (uInt32)ers;
			iterator find = ers; // quickly find an item in use
			iterator last = --end(); // last valid item in the list
			set_valid(ers, false); // gets rid of the item
			if (ers == last) return end();
			while (find != last)
			{
				if (!TEST_MAP_BIT(low_map, track)) // determine if an empty spot must be filled
				{
					++find;// = ++iterator(track, &arbiter); // find used item
					new (Data + track) T(Data[(uInt32)find]); // fill the open slot with a valid item
					Data[(uInt32)find].~T();
					// update the bitmaps
					DISABLE_MAP_BIT((uInt32)find)
						ENABLE_MAP_BIT(track)
				}
				++track; // move to the next item
			}
			// update last point
			_last = track;
			return ers;
		}

		// clear the vector of all elements but do not effect its capacity
		void clear(void)
		{
			if (!_size) return;
			_destruct();
			_size = 0u;
			_last = 0u;
			memset(low_map, 0u, low_sz << 2u);
			memset(Ki_map, 0u, Ki_sz << 2u);
			memset(Ki32_map, 0u, Ki32_sz << 2u);
			memset(Mi_map, 0u, Mi_sz << 2u);
			memset(Mi32_map, 0u, Mi32_sz << 2u);
		}

		// clean out the vector of all elements and capacity
		void _destroy(void)
		{
			_destruct();
			free(Data);
			delete[] low_map;
			delete[] Ki_map;
			delete[] Ki32_map;
			delete[] Mi_map;
			delete[] Mi32_map;
			_create();
		}

	};

	// remove macros & defines
#undef uInt32
#undef Int32
#undef Bool8
#undef LOW_SHIFT
#undef KI_SHIFT
#undef KI32_SHIFT
#undef MI_SHIFT
#undef MI32_SHIFT
#undef TEST_MAP_BIT
#undef SHIFT_ENABLE
#undef SHIFT_DISABLE
#undef ENABLE_MAP_BIT
#undef DISABLE_MAP_BIT
#undef _TEST_IF
#undef _TEST_ELSE
#undef _SET_IF
#undef _SET_ELSE
#undef FIND_OPEN_BIT
}
#endif // #endif _LD_VECTOR_H_

/*---------------------------------
|	End of ld_vector.h
----------------------------------*/


/*---------------------------------
|	Begin of GInterface.h
----------------------------------*/
#ifndef GINTERFACE_H
#define GINTERFACE_H


// Contains all defined elements shared among base interfaces.


namespace GW
{
	// The "I" namespace can be safely ignored by end users. I = ('I'nternal 'I'nterfaces & 'I'mplementations)
	namespace I // Doxygen ignores this namespace.
	{
		// Base interface all Gateware interfaces must support at a minimum.
		// The only purpose of this interface is to identify Gateware Objects, enable run-time polymorphisim.
		class GInterfaceInterface
		{
			// All Gateware API interfaces contain no variables & are pure virtual.
		public:
			virtual ~GInterfaceInterface() = 0; // all interfaces must support vtables & RTTI 
		};
		inline GInterfaceInterface::~GInterfaceInterface() = default;
	}
}

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GInterface.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_CORE) || defined(GATEWARE_DISABLE_GINTERFACE) || \
    (defined(GATEWARE_ENABLE_CORE) && !defined(GATEWARE_DISABLE_GINTERFACE) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	// dummy implementation of GInterface
namespace GW {
	namespace I {
	class GInterfaceImplementation : public virtual GInterfaceInterface
	{
	public:
		GReturn Create() { return GReturn::INTERFACE_UNSUPPORTED; }
	};
	} // end CORE
} // end GW


#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
	// Universal implementation of GInterface

// Make the implentation belong to the proper gateware namespace
// We cannot use "using" here as this is an HPP and supports header only deployments
namespace GW {
	namespace I {

	// Comments in these files are up to the developer but should not be part of doxygen
	class GInterfaceImplementation : public virtual GInterfaceInterface
	{
		// If we had any internal variables or functions we would define them here.
	public:
		// GInterface doesn't do anything... but you can make one as that is consitent with the API
		// ALL Implementations MUST have a "Create" function. You may pass any arguments you need.
		// ALL Implementations support only the default constructor, Use "Create" to actually intialize your class.
		GReturn Create()
		{
			return GReturn::SUCCESS;
		}

		// A pure virtual destructor requires an implementation in C++  
//		~GInterfaceImplementation() override {};
	};
	// End Gateware namespaces
	} // end CORE
} // end GW


#endif


namespace GW
{
	namespace CORE
	{
		class GInterface final // Note to developers: this is a Proxy, what end users actually interact with. 
		: public I::GProxy<I::GInterfaceInterface, I::GInterfaceImplementation>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GInterface)

		// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GINTERFACE_H

/*---------------------------------
|	End of GInterface.h
----------------------------------*/


/*---------------------------------
|	Begin of GThreadShared.h
----------------------------------*/
#ifndef GTHREADSHARED_H
#define GTHREADSHARED_H




namespace GW
{
	namespace I
	{
		// An interface which supports safe resource access from multiple threads.
		// Gateware Developers: Use private inheritance(containment) if you do not wish to allow external locks. (recommended)
		class GThreadSharedInterface : virtual public GInterfaceInterface
		{
		public:
			virtual GReturn LockAsyncRead() const = 0;
			virtual GReturn UnlockAsyncRead() const = 0;
			virtual GReturn LockSyncWrite() = 0;
			virtual GReturn UnlockSyncWrite() = 0;
		};
	}
}

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GThreadShared.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_CORE) || defined(GATEWARE_DISABLE_GTHREADSHARED) || \
    (defined(GATEWARE_ENABLE_CORE) && !defined(GATEWARE_DISABLE_GTHREADSHARED) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	namespace GW {
	namespace I {
		// dummy implementations allow for code compilation even when an interface is unsupported by a platform
		class GThreadSharedImplementation :	public virtual GThreadSharedInterface,
											protected GInterfaceImplementation
		{
		public:
			GReturn Create() {
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			GReturn LockAsyncRead() const override {
				return GReturn::FAILURE;
			}
			GReturn UnlockAsyncRead() const override {
				return GReturn::FAILURE;
			}
			GReturn LockSyncWrite() override {
				return GReturn::FAILURE;
			}
			GReturn UnlockSyncWrite() override {
				return GReturn::FAILURE;
			}
		};
	} // end CORE
} // end GW

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
	#ifdef NDEBUG
		#ifdef _WIN32
			// Windows specific version uses SRWLocks for highly optimized read/write access to resources
// This variant has NO safety mechanisms at all, only use it if you need every last shred of performance and
// are certain you have no threading logic errors of any kind.
#define WIN32_LEAN_AND_MEAN
#include <windows.h> // used for fast locks and synchronus reads
// Make the implentation belong to the proper gateware namespace
// We cannot use "using" here as this is an HPP and supports header only deployments
namespace GW {
	namespace I {

		// Comments in these files are up to the developer but should not be part of doxygen
		// The implementation of this class should use the fastest synchronization primitive per-platform
		// The private inheritance of "GInterfaceImplementation" is not strictly nessacary here but it
		// does demonstrate how to reuse Gateware implementation code in future interface implementations. 
		class GThreadSharedImplementation :	public virtual GThreadSharedInterface, // <-- Always inherit an interface this way
											private GInterfaceImplementation // <-- Always reuse implementation code like so
		{
			// Since we fully support C++11 you may inline intialize variables as needed.
			SRWLOCK sync = { nullptr }; // used to synchronize reads & writes, initializig this to something other than null/nothing causes issues
		public:
			// ALL Implementations MUST have a "Create" function. You may pass any arguments you need.
			// ALL Implementations support only the default constructor, Use "Create" to actually intialize your class.
			GReturn Create()
			{
				// Init anything you cannot or do not wish to init inline here (c++11)
				InitializeSRWLock(&sync); // The return of this may be null so we cannot use that for error checking
				return GReturn::SUCCESS;
			}
			// overload utility functions, these will be utilized by derived implmentations of the parent interface
			GReturn LockAsyncRead() const override
			{
				// enables const correctness for downstream interfaces
				// not ideal but forcing Zero const functions for later Asynchronus interfaces is a non-option
				AcquireSRWLockShared(const_cast<PSRWLOCK>(&sync));
				return GReturn::SUCCESS;
			}
			GReturn UnlockAsyncRead() const override
			{
				// enables const correctness for downstream interfaces
				// not ideal but forcing Zero const functions for later Asynchronus interfaces is a non-option
				ReleaseSRWLockShared(const_cast<PSRWLOCK>(&sync));
				return GReturn::SUCCESS;
			}
			GReturn LockSyncWrite() override
			{
				AcquireSRWLockExclusive(&sync);
				return GReturn::SUCCESS;
			}

			// it is the end-users resposibility to make sure they lock before they unlock
			// this disables the warning C26110 that is associated with this, so the end-user doesn't see it in Gateware.h
#pragma warning( push )
#pragma warning( disable : 26110 )
			GReturn UnlockSyncWrite() override
			{
				ReleaseSRWLockExclusive(&sync);
				return GReturn::SUCCESS;
			}
			// this returns the pragma to its previous state, effectively un-disabling C26110 for the rest of Gateware.h
#pragma warning( pop )
		};
		// End Gateware namespaces
	} // end CORE
} // end GW
 // fast unlimited asynchronus locking, ZERO safety
		#else	
			// This files implements read & write locks through a generic mutex.
// Ideally you should replace this implementation with an optmized platform specific one.
// No error checking is present in this variant to maximize performance in release.
// **NEW** Updated with c++14 shared mutex.(if available)
#if __cplusplus >= 201402L // shared_mutex requires c++14 support
	#include <shared_mutex>
	#define G_LOCK_OBJ std::shared_mutex
	#define G_LOCK_ASYNC lock_shared
	#define G_UNLOCK_ASYNC unlock_shared
#else
	#include <mutex>
	#define G_LOCK_OBJ std::mutex
	#define G_LOCK_ASYNC lock
	#define G_UNLOCK_ASYNC unlock
#endif
// Make the implentation belong to the proper gateware namespace
// We cannot use "using" here as this is an HPP and supports header only deployments
namespace GW {
	namespace I {

		// Comments in these files are up to the developer but should not be part of doxygen
		// The implementation of this class should use the fastest synchronization primitive per-platform
		// The private inheritance of "GInterfaceImplementation" is not strictly nessacary here but it
		// does demonstrate how to reuse Gateware implementation code in future interface implementations. 
		class GThreadSharedImplementation :	public virtual GThreadSharedInterface, // <-- Always inherit an interface this way
											protected GInterfaceImplementation // <-- Always reuse implementation code like so
		{
			// If C++14 support is detected we enable asynchronus reads for improved performance
			G_LOCK_OBJ async; // hopefully supports aynchronus reads and synchronus writes
		public:
			// ALL Implementations MUST have a "Create" function. You may pass any arguments you need.
			// ALL Implementations support only the default constructor, Use "Create" to actually intialize your class.
			GReturn Create()
			{
				// Init anything you cannot or do not wish to init inline here (c++11)
				return GReturn::SUCCESS;
			}
			// overload utility functions, these will be utilized by derived implmentations of the parent interface
			GReturn LockAsyncRead() const override
			{
				// enables const correctness for downstream interfaces
				// not ideal but forcing Zero const functions for later Asynchronus interfaces is a non-option
				const_cast<G_LOCK_OBJ*>(&async)->G_LOCK_ASYNC();
				// we have locked down this thread
				return GReturn::SUCCESS;
			}
			GReturn UnlockAsyncRead() const override
			{
				// enables const correctness for downstream interfaces
				// not ideal but forcing Zero const functions for later Asynchronus interfaces is a non-option
				const_cast<G_LOCK_OBJ*>(&async)->G_UNLOCK_ASYNC();
				return GReturn::SUCCESS;
			}
			GReturn LockSyncWrite() override
			{
				async.lock();
				// we have locked down this thread
				return GReturn::SUCCESS;
			}
			GReturn UnlockSyncWrite() override
			{
				async.unlock();
				return GReturn::SUCCESS;
			}
			// release any outstanding locks on destruction
			~GThreadSharedImplementation()
			{
				UnlockAsyncRead();
				UnlockSyncWrite();
			}
		};
		// End Gateware namespaces
	} // end CORE
} // end GW
#undef G_LOCK_OBJ
#undef G_LOCK_ASYNC
#undef G_UNLOCK_ASYNC
 // no error detection, much faster if c++14 compiler (coming soon)
		#endif
	#else
		// This files implements read & write locks through a generic mutex.
// Ideally you should replace this implementation with an optmized platform specific one.
// This version currently does not support asynchronus reads, may be updated with c++14 timed mutex.
#include <atomic>
#include <mutex>
#include <thread> // used for tracking thread ids to avoid deadlock
// Make the implentation belong to the proper gateware namespace
// We cannot use "using" here as this is an HPP and supports header only deployments
namespace GW {
	namespace I {

		// Comments in these files are up to the developer but should not be part of doxygen
		// The implementation of this class should use the fastest synchronization primitive per-platform
		// The private inheritance of "GInterfaceImplementation" is not strictly nessacary here but it
		// does demonstrate how to reuse Gateware implementation code in future interface implementations. 
		class GThreadSharedImplementation :	public virtual GThreadSharedInterface, // <-- Always inherit an interface this way
											protected GInterfaceImplementation // <-- Always reuse implementation code like so
		{
			// Since we fully support C++11 you may inline intialize variables as needed.
			std::mutex sync; // used to synchronize reads & writes
			std::atomic<std::thread::id> locker; // ID of the only thread that has a lock.(used to detect deadlocks)
			std::atomic_bool mode; // tracking of active mode. false = read, true = write
		public:
			// ALL Implementations MUST have a "Create" function. You may pass any arguments you need.
			// ALL Implementations support only the default constructor, Use "Create" to actually intialize your class.
			GReturn Create()
			{
				// Init anything you cannot or do not wish to init inline here (c++11)
				return GReturn::SUCCESS;
			}
			// overload utility functions, these will be utilized by derived implmentations of the parent interface
			GReturn LockAsyncRead() const override
			{
				// even though the function says async this implementation is synced for now
				if (locker == std::this_thread::get_id()) 
					return GReturn::DEADLOCK;
				// enables const correctness for downstream interfaces
				// not ideal but forcing Zero const functions for later Asynchronus interfaces is a non-option
				const_cast<std::mutex*>(&sync)->lock();
				*const_cast<std::atomic<std::thread::id>*>(&locker) = std::this_thread::get_id();
				*const_cast<std::atomic_bool*>(&mode) = false;
				// we have locked down this thread
				return GReturn::SUCCESS;
			}
			GReturn UnlockAsyncRead() const override
			{
				// even though the function says async this implementation is synced for now
				if (locker != std::this_thread::get_id() || mode == true) 
					return GReturn::FAILURE;
                // enables const correctness for downstream interfaces
				// not ideal but forcing Zero const functions for later Asynchronus interfaces is a non-option
				*const_cast<std::atomic<std::thread::id>*>(&locker) = std::thread::id();
				const_cast<std::mutex*>(&sync)->unlock();
				return GReturn::SUCCESS;
			}
			GReturn LockSyncWrite() override
			{
				// even though the function says async this implementation is synced for now
				if (locker == std::this_thread::get_id())
					return GReturn::DEADLOCK;
				sync.lock();
				locker = std::this_thread::get_id();
				mode = true;
				// we have locked down this thread
				return GReturn::SUCCESS;
			}
			GReturn UnlockSyncWrite() override
			{
				// even though the function says async this implementation is synced for now
				if (locker != std::this_thread::get_id() || mode == false)
					return GReturn::FAILURE;
				locker = std::thread::id();
				sync.unlock();
				return GReturn::SUCCESS;
			}
			// release any outstanding locks on destruction
			~GThreadSharedImplementation()
			{
				UnlockAsyncRead();
				UnlockSyncWrite();
			}
		};
		// End Gateware namespaces
	} // end CORE
} // end GW

 // not asyncronous at all but recursive deadlock and error checking
	#endif
#endif



namespace GW
{
	namespace CORE
	{
		class GThreadShared final
			: public I::GProxy<I::GThreadSharedInterface, I::GThreadSharedImplementation>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GThreadShared)
			GATEWARE_CONST_FUNCTION(LockAsyncRead)
			GATEWARE_CONST_FUNCTION(UnlockAsyncRead)
			GATEWARE_FUNCTION(LockSyncWrite)
			GATEWARE_FUNCTION(UnlockSyncWrite)

// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GTHREADSHARED_H

/*---------------------------------
|	End of GThreadShared.h
----------------------------------*/


/*---------------------------------
|	Begin of GLogic.h
----------------------------------*/
#ifndef GLOGIC_H
#define GLOGIC_H



#include <functional>

namespace GW
{
	namespace I
	{
		class GLogicInterface : public virtual GInterfaceInterface
		{
		public:
			virtual GReturn Assign(std::function<void()> _newLogic) = 0;
			virtual GReturn Invoke() const = 0;
		};
	}
};

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GLogic.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_CORE) || defined(GATEWARE_DISABLE_GLOGIC) || \
    (defined(GATEWARE_ENABLE_CORE) && !defined(GATEWARE_DISABLE_GLOGIC) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	namespace GW {
	namespace I {
		// dummy implementations allow for code compilation even when an interface is unsupported by a platform
		class GLogicImplementation : public virtual GLogicInterface,
									 protected GThreadSharedImplementation
		{
		public:
			GReturn Create(std::function<void()> _logic) {
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			GReturn Assign(std::function<void()> _newLogic) override {
				return GReturn::FAILURE;
			}
			GReturn Invoke() const override {
				return GReturn::FAILURE;
			}
		};
	} // end CORE
} // end GW

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
	// Make the implentation belong to the proper gateware namespace
// We cannot use "using" here as this is an HPP and supports header only deployments
namespace GW {
	namespace I {

		// Simply holds a std::function<void()> and allows it to be updated/invoked safely
		class GLogicImplementation :	public virtual GLogicInterface,
										protected GThreadSharedImplementation // resource locking
		{
			// internal data members
			std::function<void()> logic = nullptr;
		public:
			// Must match Proxy argument list
			GReturn Create(std::function<void()> _logic) {
				logic = _logic; // should move && in many cases
				return GReturn::SUCCESS;
			}
			GReturn Assign(std::function<void()> _newLogic) override {
				GReturn result;
				if (G_PASS(result = LockSyncWrite()))
				{
					logic = _newLogic; // routine updated
					return UnlockSyncWrite();
				}
				return result;
			}
			GReturn Invoke() const override {
				GReturn result = GReturn::IGNORED;
				thread_local bool recursing = false;
				if (recursing || G_PASS(result = LockAsyncRead()))
				{
					recursing = true; // recursion is allowed on this thread, bypass locks
					// run logic if available, allowing recurssion on this thread
					if (logic) logic(); // routine called
					// if this was a recursive call ignore the Unlock since the stack unwind will handle it
					if (result != GReturn::IGNORED)
					{
						recursing = false;
						UnlockAsyncRead();
					}
					// report the result of the function call
					result = (logic) ? GReturn::SUCCESS : GReturn::FAILURE;
				}
				return result;
			}
		};

	} // end CORE
} // end GW


#endif



namespace GW
{
	namespace CORE
	{
		class GLogic final
			: public I::GProxy<I::GLogicInterface, I::GLogicImplementation, std::function<void()>>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// procy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GLogic)
			GATEWARE_FUNCTION(Assign)
			GATEWARE_CONST_FUNCTION(Invoke)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GEVENTRECEIVER_H


/*---------------------------------
|	End of GLogic.h
----------------------------------*/


/*---------------------------------
|	Begin of GEventResponder.h
----------------------------------*/
#ifndef GEVENTRESPONDER_H
#define GEVENTRESPONDER_H




namespace GW
{
	namespace I
	{
		class GEventResponderInterface : public virtual GLogicInterface
		{
		public:
			// Let the compiler know that we intend to use the base class methods
			// and also override them with an additional parameters.
			using GLogicInterface::Assign; // enables "eventless" response if desired
			using GLogicInterface::Invoke; // A GResponder Invoke with no GEvent will have a dummy event provided.
			// new methods (overrides)
			virtual GReturn Assign(std::function<void(const GEvent&)> _newEventHandler) = 0;
			virtual GReturn Invoke(const GEvent& _incomingEvent) const = 0;
		};
	}
};

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GEventResponder.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_CORE) || defined(GATEWARE_DISABLE_GEVENTRESPONDER) || \
    (defined(GATEWARE_ENABLE_CORE) && !defined(GATEWARE_DISABLE_GEVENTRESPONDER) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	namespace GW {
	namespace I {
		// dummy implementations allow for code compilation even when an interface is unsupported by a platform
		class GEventResponderImplementation :	public virtual GEventResponderInterface,
												protected GThreadSharedImplementation
		{
		public:
			GReturn Create(std::function<void(const GEvent&)> _handler) {
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			GReturn Assign(std::function<void(const GEvent&)> _newEventHandler) override {
				return GReturn::FAILURE;
			}
			GReturn Invoke(const GEvent& _incomingEvent) const override {
				return GReturn::FAILURE;
			}
			GReturn Assign(std::function<void()> _newLogic) override {
				return GReturn::FAILURE;
			}
			GReturn Invoke() const override {
				return GReturn::FAILURE;
			}
		};
	} // end CORE
} // end GW

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
	// Make the implentation belong to the proper gateware namespace
// We cannot use "using" here as this is an HPP and supports header only deployments
namespace GW {
	namespace I {

		// Simply holds a std::function<void(const GEvent&)> and allows it to be updated/invoked safely
		class GEventResponderImplementation :	public virtual GEventResponderInterface,
												protected GThreadSharedImplementation // resource locking
		{
			// internal data members
			std::function<void(const GEvent&)> handler = nullptr;
		public:
			// Must match Proxy argument list
			GReturn Create(std::function<void(const GEvent&)> _handler) {
				handler = _handler; // nullptr is ok, optional.	
				return GReturn::SUCCESS;
			}
			// custom variants here
			GReturn Assign(std::function<void(const GEvent&)> _newEventHandler) override {
				GReturn result;
				if (G_PASS(result = LockSyncWrite()))
				{
					handler = _newEventHandler; // routine updated
					return UnlockSyncWrite();
				}
				return result;
			}
			GReturn Invoke(const GEvent& _incomingEvent) const override {
				GReturn result = GReturn::IGNORED;
				thread_local bool recursing = false;
				if (recursing || G_PASS(result = LockAsyncRead()))
				{
					recursing = true; // recursion is allowed on this thread, bypass locks
					// run logic if available, allowing recurssion on this thread
					if (handler) handler(_incomingEvent); // routine called with actual event
					// if this was a recursive call ignore the Unlock since the stack unwind will handle it
					if (result != GReturn::IGNORED)
					{
						recursing = false;
						UnlockAsyncRead();
					}
					// report the result of the function call
					result = (handler) ? GReturn::SUCCESS : GReturn::FAILURE;
				}
				return result;
			}
			// base interface variant internals overwritten below
			GReturn Assign(std::function<void()> _newLogic) override {
				GReturn result;
				if (G_PASS(result = LockSyncWrite()))
				{
					handler = std::bind(_newLogic); // routine updated to ignore GEvents
					return UnlockSyncWrite();
				}
				return result;
			}
			GReturn Invoke() const override {
				GReturn result = GReturn::IGNORED;
				thread_local bool recursing = false;
				if (recursing || G_PASS(result = LockAsyncRead()))
				{
					recursing = true; // recursion is allowed on this thread, bypass locks
					// run logic if available, allowing recurssion on this thread
					if (handler) handler(GEvent()); // routine called with non-event
					// if this was a recursive call ignore the Unlock since the stack unwind will handle it
					if (result != GReturn::IGNORED)
					{
						recursing = false;
						UnlockAsyncRead();
					}
					// report the result of the function call
					result = (handler) ? GReturn::SUCCESS : GReturn::FAILURE;
				}
				return result;
			}
		};

	} // end CORE
} // end GW


#endif



namespace GW
{
	namespace CORE
	{
		class GEventResponder final
			: public I::GProxy<I::GEventResponderInterface, I::GEventResponderImplementation, std::function<void(const GEvent&)>>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GEventResponder)
			GATEWARE_FUNCTION(Assign)
			GATEWARE_CONST_FUNCTION(Invoke)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GEVENTRESPONDER_H

/*---------------------------------
|	End of GEventResponder.h
----------------------------------*/


/*---------------------------------
|	Begin of GEventCache.h
----------------------------------*/
#ifndef GEVENTCACHE_H
#define GEVENTCACHE_H



namespace GW
{
	namespace I
	{
		class GEventCacheInterface : public virtual GInterfaceInterface
		{
		public:
			virtual GReturn Append(const GEvent& _inEvent) = 0;
			virtual GReturn Waiting(unsigned int& _outCount) const = 0;
			virtual GReturn Pop(GEvent& _outEvent) = 0;
			virtual GReturn Peek(GEvent& _outEvent) const = 0;
			virtual GReturn Peek(unsigned int _eventIndex, GEvent& _outEvent) const = 0;
			virtual GReturn Max(unsigned int& _outSize) const = 0;
			virtual GReturn Missed(unsigned int& _outCount) const = 0;
			virtual GReturn Clear() = 0;
			template<class eventType>
			GReturn Find(eventType _check, bool _remove);
			template<class eventType, typename eventData>
			GReturn Find(eventType _check, bool _remove, eventData& _outData);
		};
	}
};

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GEventCache.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_CORE) || defined(GATEWARE_DISABLE_GEVENTCACHE) || \
    (defined(GATEWARE_ENABLE_CORE) && !defined(GATEWARE_DISABLE_GEVENTCACHE) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	namespace GW {
	namespace I {
		// dummy implementations allow for code compilation even when an interface is unsupported by a platform
		class GEventCacheImplementation :	public virtual GEventCacheInterface,
											private GThreadSharedImplementation
		{
		public:
			// New operations
			GReturn Create(unsigned int _cacheSize) {
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			GReturn Peek(unsigned int _eventIndex, GEvent& _outEvent) const override {
				return GReturn::FAILURE;
			}
			GReturn Peek(GEvent& _outEvent) const override {
				return GReturn::FAILURE;
			}
			GReturn Max(unsigned int& _outSize) const override {
				return GReturn::FAILURE;
			}
			GReturn Append(const GEvent& _inEvent) override {
				return GReturn::FAILURE;
			}
			GReturn Waiting(unsigned int& _outCount) const override {
				return GReturn::FAILURE;
			}
			GReturn Pop(GEvent& _outEvent) override {
				return GReturn::FAILURE;
			}
			GReturn Missed(unsigned int& _outCount) const override {
				return GReturn::FAILURE;
			}
			GReturn Clear() override {
				return GReturn::FAILURE;
			}
			// Overload Find templates
			template<class eventType>
			GReturn Find(eventType _check, bool _remove) {
				return GReturn::FAILURE;
			}
			template<class eventType, typename eventData>
			GReturn Find(eventType _check, bool _remove, eventData& _outData) {
				return GReturn::FAILURE;
			}
		};
	} // end CORE
} // end GW

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
	// Make the implentation belong to the proper gateware namespace
// We cannot use "using" here as this is an HPP and supports header only deployments
namespace GW {
	namespace I {
		// Just like GEventReceiver except it can store multiple events in a queue so you can delay processing
		class GEventCacheImplementation :	public virtual GEventCacheInterface,
											private GThreadSharedImplementation // resource locking				
		{
			// internal data members
			int enque = 0; // where items are enqued
			int deque = 0; // where items are dequed
			unsigned int maxEvents = 0; // size of the queue
			unsigned int missedEvents = 0; // increases if the queue is at capacity during append
			unsigned int eventsWaiting = 0; // number of events currently queued
			GEvent* circularQueue = nullptr; // where events are stored (ring buffer)
			
			// functions for circular queue (since std does not seem to provide one)
			// NOTE: we may want to shift this into "key" as an ADT if it sees more widespread application
			
			// returns false if queue is full
			bool Enque(const GEvent& _push) 
			{
				if (eventsWaiting >= maxEvents)
					return false;
				circularQueue[enque] = _push;
				enque = (enque + 1) % maxEvents;
				++eventsWaiting;
				return true;
			}
			// returns false if queue is empty
			bool Deque(GEvent* _pop) // optional
			{
				if (eventsWaiting == 0)
					return false;
				if(_pop != nullptr)
					*_pop = circularQueue[deque];
				deque = (deque + 1) % maxEvents;
				--eventsWaiting;
				return true;
			}
			// required to fully implement the "Find" routines
			// while collapsing the queue is not optimal we go for the closest point to minimize copies
			bool Erase(unsigned int _offset) // offset from dequqe point
			{
				if (eventsWaiting == 0 || _offset >= eventsWaiting) // should we bother?
					return false;
				// which is closer enque or deque?
				int dir = (_offset < (eventsWaiting >> 1)) ? maxEvents - 1 : 1;
				int stop = (dir == 1) ? enque : (deque + dir) % maxEvents; // stop here
				_offset = (deque + _offset) % maxEvents; // this starting spot should be valid now
				for (int i = (_offset + dir) % maxEvents; i != stop; i = (i + dir) % maxEvents)
				{
					circularQueue[_offset] = circularQueue[i]; // copy & move
					_offset = i; // next
				}
				// update enque or deque based on which way we closed the gap
				(dir == 1) ? enque = _offset : deque = ((deque + 1) % maxEvents);
				--eventsWaiting; // reduce overall size of queue
				return true; // hopefully the logic above is good we will test it
			}
			// queue theory:
			// 0 1 2 3 4 5 6
			// - - D + + + E
			// + E - - D + +
			// + E - - - - D
			// D E - - - - -
			// - - - D E - -
			// + + E D + + +
			// - D + + E - -
			// + + + + + E D

		public:
			// with dynamic memory present we must free any allocated resources
			~GEventCacheImplementation()
			{
				delete[] circularQueue; // free allocated queue
			}
			// You must select a maximum size of the queue as for efficiency it is implemented as a circular array
			GReturn Create(unsigned int _cacheSize) 
			{
				if (_cacheSize < 1) // needs to be at least 1
					return GReturn::INVALID_ARGUMENT;
				// generate circular queue
				if ((circularQueue = new GEvent[_cacheSize]) == nullptr)
					return GReturn::FAILURE; // new[] failed
				maxEvents = _cacheSize; // store mamximum allowable event data
				return GReturn::SUCCESS;
			}
			GReturn Max(unsigned int& _outSize) const override 
			{
				LockAsyncRead();
				_outSize = maxEvents; // get maximum size of queue
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}
			// Override from GEventReceiver
			GReturn Append(const GEvent& _inEvent) override 
			{
				if (+LockSyncWrite()) // makin changes
				{
					if (eventsWaiting >= maxEvents) // are we are full?
					{
						Deque(nullptr); // remove an existing event so we have room
						++missedEvents; // notify we missed an event
					}
					// append new event (should always happen)
					if (Enque(_inEvent) && +UnlockSyncWrite()) // unlock 
						return GReturn::SUCCESS;
				}
				return GReturn::UNEXPECTED_RESULT; // should never get here
			}
			GReturn Waiting(unsigned int& _outCount) const override 
			{
				LockAsyncRead();
				_outCount = eventsWaiting; // get current size of queue
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}
			GReturn Pop(GEvent& _outEvent) override 
			{
				GReturn result = GReturn::FAILURE;
				if (+LockSyncWrite())
				{
					if (Deque(&_outEvent))
						result = GReturn::SUCCESS;
					UnlockSyncWrite();
				}
				return result;
			}
			GReturn Peek(GEvent& _outEvent) const override
			{
				GReturn result = GReturn::FAILURE;
				if (+LockAsyncRead())
				{
					if (eventsWaiting)
					{
						_outEvent = circularQueue[deque];
						result = GReturn::SUCCESS;
					}
					UnlockAsyncRead();
				}
				return result;
			}
			GReturn Peek(unsigned int _eventIndex, GEvent& _outEvent) const override
			{
				// Use deque + _eventIndex % maxEvents to find the right spot
				GReturn result = GReturn::FAILURE;
				if (+LockAsyncRead())
				{
					if (eventsWaiting)
					{
						if (_eventIndex < eventsWaiting) // must be a valid index
						{
							_outEvent = circularQueue[(deque + _eventIndex) % maxEvents];
							result = GReturn::SUCCESS;
						}
						else
							result = GReturn::INVALID_ARGUMENT; // out of range
					}
					UnlockAsyncRead();
				}
				return result;
			}
			GReturn Missed(unsigned int& _outCount) const override
			{
				LockAsyncRead();
				_outCount = missedEvents; // how many events were ignored
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}
			GReturn Clear() override 
			{
				GReturn result = GReturn::FAILURE;
				if (+LockSyncWrite())
				{
					if (eventsWaiting)
					{
						enque = deque = eventsWaiting = 0;
						result = GReturn::SUCCESS;
					}
					UnlockSyncWrite();
				}
				return result;
			}
			// Overload Find templates
			template<class eventType>
			GReturn Find(eventType _check, bool _remove) 
			{
				eventType event;
				GReturn result = GReturn::FAILURE;
				if ((_remove) ? +LockSyncWrite() : +LockAsyncRead())
				{
					if (eventsWaiting)
					{
						// loop looking for the event in question starting with the oldest
						int i = deque, x = 0;
						do // we use a do while because in a full queue enque and deque are equal
						{
							if (G_PASS(circularQueue[i].Read(event)))
							{
								if (event == _check) // found it?
								{
									result = GReturn::SUCCESS;
									if (_remove)
										result = (Erase(x)) ? GReturn::SUCCESS 
															: GReturn::MEMORY_CORRUPTION;
									break; // we found it!
								}
							}// move to the next item
							i = (i + 1) % maxEvents, ++x;
						}while (i != enque); // stop when we hit the enque
					}
					(_remove) ? UnlockSyncWrite() : UnlockAsyncRead();
				}
				return result;
			}
			template<class eventType, typename eventData>
			GReturn Find(eventType _check, bool _remove, eventData& _outData) 
			{
				eventType event;
				GReturn result = GReturn::FAILURE;
				if ((_remove) ? +LockSyncWrite() : +LockAsyncRead())
				{
					if (eventsWaiting)
					{
						// loop looking for the event in question starting with the oldest
						int i = deque, x = 0;
						do // we use a do while because in a full queue enque and deque are equal
						{
							if (G_PASS(circularQueue[i].Read(event, _outData)))
							{
								if (event == _check) // found it?
								{
									result = GReturn::SUCCESS;
									if (_remove)
										result = (Erase(x)) ? GReturn::SUCCESS
															: GReturn::MEMORY_CORRUPTION;
									break; // we found it!
								}
							}// move to the next item
							i = (i + 1) % maxEvents, ++x;
						} while (i != enque); // stop when we hit the enque
					}
					(_remove) ? UnlockSyncWrite() : UnlockAsyncRead();
				}
				return result;
			}
		};
	} // end CORE
} // end GW


#endif


namespace GW
{
	namespace CORE
	{
		class GEventCache final
			: public I::GProxy<I::GEventCacheInterface, I::GEventCacheImplementation, unsigned int> // cache size
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GEventCache)
			GATEWARE_FUNCTION(Append)
			GATEWARE_CONST_FUNCTION(Waiting)
			GATEWARE_FUNCTION(Pop)
			GATEWARE_CONST_FUNCTION(Peek)
			GATEWARE_CONST_FUNCTION(Max)
			GATEWARE_CONST_FUNCTION(Missed)
			GATEWARE_FUNCTION(Clear)
			GATEWARE_TEMPLATE_FUNCTION(Find)
			
			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GEVENTCACHE_H

/*---------------------------------
|	End of GEventCache.h
----------------------------------*/


/*---------------------------------
|	Begin of GEventGenerator.h
----------------------------------*/
#ifndef GEVENTGENERATOR_H
#define GEVENTGENERATOR_H


 // can store and examine GEvents for later processing  
 // contains user defined logic for handling a GEvent

namespace GW
{
	namespace I
	{
		// The GEventGenerator Interface is capable of notifying end users of various events that occur during runtime.
		// This interface supports asynchronus addition, removal & notification of observer interfaces
		class GEventGeneratorInterface : public virtual GInterfaceInterface
		{
			// All Gateware API interfaces contain no variables & are pure virtual.		
		public:
			// For API consistency all Gateware "Event Generators" must have an event list called "Events"
			// They can be values other than integer (eg: floats) but must be POD (plain old data)
			enum class Events
			{
				NON_EVENT
			};
			// For API consistency all Gateware "Event Generators" must have an event struct called "EVENT_DATA"
			// All contined values must be POD (plain old data) and fit within a GEvent data block
			struct EVENT_DATA
			{
				std::nullptr_t noData;
			};

			virtual GReturn Register(CORE::GEventCache _recorder) = 0; // Overloads registration for GEventCache
			virtual GReturn Register(CORE::GEventResponder _responder) = 0; // Overloads registration for GEventResponders
			virtual GReturn Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) = 0; // Linking to an event generator this way is very specific, use GEventResponder for a more flexible option
			virtual GReturn Deregister(CORE::GInterface _observer) = 0;
			virtual GReturn Observers(unsigned int& _outCount) const = 0;
			virtual GReturn Push(const GEvent& _newEvent) = 0;
		};
	}
};

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GEventGenerator.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_CORE) || defined(GATEWARE_DISABLE_GEVENTGENERATOR) || \
    (defined(GATEWARE_ENABLE_CORE) && !defined(GATEWARE_DISABLE_GEVENTGENERATOR) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	namespace GW {
	namespace I {
		// dummy implementations allow for code compilation even when an interface is unsupported by a platform
		class GEventGeneratorImplementation :	public virtual GEventGeneratorInterface,
												public GThreadSharedImplementation
		{
		public:
			GReturn Create() {
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			GReturn Register(CORE::GEventCache _recorder) override {
				return GReturn::FAILURE;
			}
			GReturn Register(CORE::GEventResponder _responder) override {
				return GReturn::FAILURE;
			}
			GReturn Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) override {
				return GReturn::FAILURE;
			}
			GReturn Deregister(CORE::GInterface _observer) override {
				return GReturn::FAILURE;
			}
			GReturn Observers(unsigned int& _outCount) const override {
				return GReturn::FAILURE;
			}
			GReturn Push(const GEvent& _newEvent) override {
				return GReturn::FAILURE;
			}
		};
	} // end CORE
} // end GW

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
	#include <vector> // used to track messagable objects

// define temporary internal defines (GWI = Gateware Internal)
#define GWI_MAX_TRAVERSAL_STACK 32 

// Make the implentation belong to the proper gateware namespace
// We cannot use "using" here as this is an HPP and supports header only deployments
namespace GW {
	namespace I {

		// Holds a vector of GEvents which it periodically cleans and sends new events to.
		class GEventGeneratorImplementation :	public virtual GEventGeneratorInterface,
												protected GThreadSharedImplementation // handles resource locking
		{
			// internal data members
			std::vector<std::pair<CORE::GInterface, void(*)(const GEvent&, CORE::GInterface&)>> listeners;

			// Ok we use a per-function cache & smart recursion to lock down the vector.
			// We populate the cache and then execute the callbacks.

			// This should be safe from multiple threads.

			void RecursivePush(const GEvent& _newEvent, unsigned int _offset)
			{
				unsigned int numToInvoke = 0;
				CORE::GEventCache isCache;
				CORE::GEventResponder isResponder;
				// Local stack of objects to visit, can grow with recursion.
				// We use a caching technique because we don't know what logic is present in the callbacks.
				// For example a callback could invoke a "Register" or "Push" from this very class leading to a deadlock.
				std::pair<CORE::GInterface, void(*)(const GEvent&, CORE::GInterface&)> toInvoke[GWI_MAX_TRAVERSAL_STACK];
				// if this is the root call, lock for editing
				if (_offset == 0) 
					LockSyncWrite();
				// traversing the container backwards should make removals a bit more efficient
				int current = static_cast<int>(listeners.size()) - 1 - _offset;
				// traverse contaniner, append to local array, remove dead proxies
				while (current >= 0 && numToInvoke < GWI_MAX_TRAVERSAL_STACK)
				{
					if (listeners[current].first) {
						toInvoke[numToInvoke] = listeners[current];
						numToInvoke++;
						current--;
					}
					else {
						listeners.erase(listeners.begin() + current);
						current--;
					}
				}
				// if we max local array then recurse with offset
				if (current >= 0) // still have some left?
					RecursivePush(_newEvent, _offset + GWI_MAX_TRAVERSAL_STACK);
				else // if you DON'T end up calling a recursive call, then unlock
					UnlockSyncWrite();
				// Traverse local array & Invoke each function & interface combo avaliable.
				while (numToInvoke)
				{	// traverse backwards so we get proper FIFO traversal with recursion
					numToInvoke--;
					if (*toInvoke[numToInvoke].second != nullptr) { // this is the normal behavior
						(*toInvoke[numToInvoke].second)(_newEvent, toInvoke[numToInvoke].first);
					} // if a static handler is not present we will try to use a first class type
					else if (isResponder = toInvoke[numToInvoke].first.Mirror()) { 
						isResponder.Invoke(_newEvent); // handle it now
						isResponder = nullptr; // release handle
					}
					else if (isCache = toInvoke[numToInvoke].first.Mirror()) {
						isCache.Append(_newEvent); // handle it later
						isCache = nullptr; // release handle
					}
					toInvoke[numToInvoke].first = nullptr; // no hanging counts plz...
				}
			}
			// study
			// Q R S T U V X Y Z
			// On recurse with size 3
			// Z Y X // full
				// V U T // full
					// S R Q // full

			// execute FIFO traversal!

		public:

			GReturn Create()
			{
				return GReturn::SUCCESS; // just works
			}

			GReturn Register(CORE::GEventCache _recorder) override
			{
				if (_recorder)
				{
					LockSyncWrite();
					listeners.push_back( 
						std::pair<CORE::GInterface, 
						void(*)(const GEvent&, CORE::GInterface&)>
						(_recorder.Mirror(), nullptr));
					UnlockSyncWrite();
					return GReturn::SUCCESS;
				}
				return GReturn::INVALID_ARGUMENT;
			}

			GReturn Register(CORE::GEventResponder _responder) override
			{
				if (_responder)
				{
					LockSyncWrite();
					listeners.push_back(
						std::pair<CORE::GInterface,
						void(*)(const GEvent&, CORE::GInterface&)>
						(_responder.Mirror(), nullptr));
					UnlockSyncWrite();
					return GReturn::SUCCESS;
				}
				return GReturn::INVALID_ARGUMENT;
			}

			GReturn Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) override
			{
				if (_observer && _callback != nullptr)
				{
					LockSyncWrite();
					listeners.push_back( /* THIS IS FINE, THE TRAVERSAL IS ALREADY BACKWARDS! TEST NEXT! */
						std::pair<CORE::GInterface, void(*)(const GEvent&, CORE::GInterface&)>(_observer.Mirror(),_callback) );
					UnlockSyncWrite();
					return GReturn::SUCCESS;
				}
				return GReturn::INVALID_ARGUMENT;
			}

			GReturn Deregister(CORE::GInterface _observer) override
			{
				GReturn result = GReturn::INVALID_ARGUMENT;
				if (_observer && +LockSyncWrite()) 
				{
					result = GReturn::FAILURE;
					auto iter = listeners.begin();
					while (	iter != listeners.end() && 
							result == GReturn::FAILURE)
					{
						if (iter->first == _observer) {
							listeners.erase(iter);
							result = GReturn::SUCCESS;
						}
						else {
							iter = std::next(iter);
						}
					}
					UnlockSyncWrite();
				}
				return result;
			}
			
			GReturn Observers(unsigned int& _outCount) const override
			{
				LockAsyncRead();
				_outCount = static_cast<unsigned int>(listeners.size());
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}

			GReturn Push(const GEvent& _newEvent) override
			{
				if (listeners.empty()) // empty() should be thread safe on vector
					return GReturn::REDUNDANT; 
				// traverse & remove dead proxies while notifying receivers
				RecursivePush(_newEvent, 0);
				return GReturn::SUCCESS;
			}
		};

	} // end CORE
} // end GW

// undefine temporary internal defines
#undef GWI_MAX_TRAVERSAL_STACK 


#endif 



namespace GW
{
	namespace CORE
	{
		class GEventGenerator final
			: public I::GProxy<I::GEventGeneratorInterface, I::GEventGeneratorImplementation>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
            GATEWARE_PROXY_CLASS(GEventGenerator)
			GATEWARE_TYPEDEF(Events)
			GATEWARE_TYPEDEF(EVENT_DATA)
			GATEWARE_FUNCTION(Register)
			GATEWARE_FUNCTION(Deregister)
			GATEWARE_CONST_FUNCTION(Observers)
			GATEWARE_FUNCTION(Push)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GEVENTGENERATOR_H

/*---------------------------------
|	End of GEventGenerator.h
----------------------------------*/


/*---------------------------------
|	Begin of GEventReceiver.h
----------------------------------*/
#ifndef GEVENTRECEIVER_H
#define GEVENTRECEIVER_H



#include <functional>

namespace GW
{
	namespace I
	{
		class GEventReceiverInterface : public virtual GInterfaceInterface
		{
		public:
			virtual GReturn Append(const GEvent& _inEvent) = 0;
			virtual GReturn Waiting(unsigned int& _outCount) const = 0;
			virtual GReturn Pop(GEvent& _outEvent) = 0;
			virtual GReturn Peek(GEvent& _outEvent) const = 0;
			virtual GReturn Missed(unsigned int& _outCount) const = 0;
			virtual GReturn Clear() = 0;
			virtual GReturn Invoke() const = 0;
			template<class eventType>
			GReturn Find(eventType _check, bool _remove);
			template<class eventType, typename eventData>
			GReturn Find(eventType _check, bool _remove, eventData& _outData);
		};
	}
};

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GEventReceiver.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_CORE) || defined(GATEWARE_DISABLE_GEVENTRECEIVER) || \
    (defined(GATEWARE_ENABLE_CORE) && !defined(GATEWARE_DISABLE_GEVENTRECEIVER) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	namespace GW {
	namespace I {
		// dummy implementations allow for code compilation even when an interface is unsupported by a platform
		class GEventReceiverImplementation :	public virtual GEventReceiverInterface,
												private GThreadSharedImplementation
		{
		public:
			GReturn Create(CORE::GEventGenerator _listenToMe, std::function<void()> _callback) {
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			GReturn Append(const GEvent& _inEvent) override {
				return GReturn::FAILURE;
			}
			GReturn Waiting(unsigned int& _outCount) const override {
				return GReturn::FAILURE;
			}
			GReturn Pop(GEvent& _outEvent) override {
				return GReturn::FAILURE;
			}
			GReturn Peek(GEvent& _outEvent) const override {
				return GReturn::FAILURE;
			}
			GReturn Missed(unsigned int& _outCount) const override {
				return GReturn::FAILURE;
			}
			GReturn Clear() override {
				return GReturn::FAILURE;
			}
			GReturn Invoke() const override {
				return GReturn::FAILURE;
			}
			template<class eventType>
			GReturn Find(eventType _check, bool _remove) {
				return GReturn::FAILURE;
			}
			template<class eventType, typename eventData>
			GReturn Find(eventType _check, bool _remove, eventData& _outData) {
				return GReturn::FAILURE;
			}
		};
	} // end CORE
} // end GW
// Required for dummy compilation but does nothing
namespace internal_gw {
	// makig this variable volatile should hopefully stop compilers from agressively removing its assigment
	static void(*volatile event_receiver_callback)(const GW::GEvent&, GW::CORE::GInterface&) = nullptr;
	template<class Proxy>
	static void event_receiver_logic(const GW::GEvent& _e, GW::CORE::GInterface& _i) {};
}

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
	// internal namespace used for global Gateware variables & callbacks  
namespace internal_gw 
{
	// internal call that forwards arguments to internal std::function
	// The logic for this operation is implemented later once the GEventReceiver Proxy is defined
	static void(*volatile event_receiver_callback)(const GW::GEvent&, GW::CORE::GInterface&) = nullptr;
	
	// Actual logic for above callback, will be defined after declaration of GEventReceiver
	template<class Proxy> // will be defined as GEventReceiver
	static void event_receiver_logic(const GW::GEvent& _e, GW::CORE::GInterface& _i)
	{
		Proxy r(_i.Mirror()); // mirror for speed where possible & appropriate
		r.Append(_e); // if an invalid Proxy is requested this will fail to be intialized
		r.Invoke();
	};
} // end internal_gw namespace

// Make the implentation belong to the proper gateware namespace
// We cannot use "using" here as this is an HPP and supports header only deployments
namespace GW {
	namespace I {

		// Simply holds a GEvent and allows it to be updated by a GEventGenerator
		// Also connects itself to said Generator during creation
		class GEventReceiverImplementation :	public virtual GEventReceiverInterface,
												protected GThreadSharedImplementation, // resource locking
												public std::enable_shared_from_this<GInterfaceInterface>
		{
			// internal data members
			unsigned int eventWaiting = 0;
			unsigned int missedEvents = 0;
			std::function<void()> callback = nullptr;
			GEvent lastEvent; // can be used to see what happened

		public:
			// Must match Proxy argument list
			GReturn Create(CORE::GEventGenerator _listenToMe, std::function<void()> _callback)
			{
				if (_listenToMe && internal_gw::event_receiver_callback)
				{
					callback = _callback; // nullptr is ok, optional.	
					// This is how to create a Proxy from "this", ideally we try and avoid doing this.
					CORE::GInterface me(shared_from_this()); // we create a temporary so only weak access is transfered
					// While weak access is not as fast, it grants lifetime control and flexibility to the user.
					// If you want the most efficiency you should consider calling "Register" directly with a fixed callback.
					return _listenToMe.Register(me, internal_gw::event_receiver_callback);
				}
				else if(internal_gw::event_receiver_callback)
					return GReturn::INVALID_ARGUMENT; // cannot be null EventGenerator
				else
					return GReturn::UNEXPECTED_RESULT; // global callback was not assigned!
			}
			GReturn Append(const GEvent& _inEvent) override
			{
				if (+LockSyncWrite()) // makin changes
				{
					if (eventWaiting) ++missedEvents; // did they miss the last one?
					lastEvent = _inEvent; // copy new event
					eventWaiting = 1; // let them know (we can only hold one)
					if (+UnlockSyncWrite()) // unlock 
						return GReturn::SUCCESS;
				}
				return GReturn::UNEXPECTED_RESULT; // should never get here
			}
			GReturn Waiting(unsigned int& _outCount) const override
			{
				LockAsyncRead();
				_outCount = eventWaiting;
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}
			GReturn Pop(GEvent& _outEvent) override
			{
				GReturn result = GReturn::FAILURE;
				if (+LockSyncWrite())
				{
					if (eventWaiting)
					{
						--eventWaiting;
						_outEvent = lastEvent;						
						result = GReturn::SUCCESS;
					}
					UnlockSyncWrite();
				}
				return result;
			}
			GReturn Peek(GEvent& _outEvent) const override
			{
				GReturn result = GReturn::FAILURE;
				if (+LockAsyncRead())
				{
					if (eventWaiting)
					{
						_outEvent = lastEvent;
						result = GReturn::SUCCESS;
					}
					UnlockAsyncRead();
				}
				return result;
			}
			GReturn Missed(unsigned int& _outCount) const override
			{
				LockAsyncRead();
				_outCount = missedEvents;
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}
			GReturn Clear() override
			{
				GReturn result = GReturn::FAILURE;
				if (+LockSyncWrite())
				{
					if (eventWaiting)
					{
						eventWaiting = 0;
						result = GReturn::SUCCESS;
					}
					UnlockSyncWrite();
				}
				return result;
			}
			GReturn Invoke() const override
			{
				if (callback)
				{					
					callback(); // Invoke internal callback (can be done from multiple threads)
					return GReturn::SUCCESS;
				}
				// No callback attatched, so it cannot be invoked
				return GReturn::FAILURE; 
			}
			template<class eventType>
			GReturn Find(eventType _check, bool _remove)
			{
				eventType event;
				GReturn result = GReturn::FAILURE;
				if ((_remove) ? +LockSyncWrite() : +LockAsyncRead())
				{
					if (eventWaiting)
					{
						if (G_PASS(result = lastEvent.Read(event)))
						{
							if (event == _check) // found it?
							{
								if (_remove) --eventWaiting; // clear found event
								result = GReturn::SUCCESS;
							}
							else
								result = GReturn::FAILURE;
						}
					}
					(_remove) ? UnlockSyncWrite() : UnlockAsyncRead();
				}
				return result;
			}
			template<class eventType, typename eventData>
			GReturn Find(eventType _check, bool _remove, eventData& _outData)
			{
				eventType event;
				GReturn result = GReturn::FAILURE;
				if ((_remove) ? +LockSyncWrite() : +LockAsyncRead())
				{
					if (eventWaiting)
					{
						if (G_PASS(result = lastEvent.Read(event, _outData)))
						{
							if (event == _check) // found it?
							{
								if (_remove) --eventWaiting; // clear found event
								result = GReturn::SUCCESS;
							}
							else
								result = GReturn::FAILURE;
						}
					}
					(_remove) ? UnlockSyncWrite() : UnlockAsyncRead();
				}
				return result;
			}
		};

	} // end CORE
} // end GW


#endif



namespace GW
{
	namespace CORE
	{
		class GEventReceiver final
			: public I::GProxy<I::GEventReceiverInterface, I::GEventReceiverImplementation, GEventGenerator, std::function<void()>>
		{
			// End users please feel free to ignore this struct, it is temporary and only used for internal API wiring.
			struct init_callback { init_callback() {
				internal_gw::event_receiver_callback = internal_gw::event_receiver_logic<GEventReceiver>;
			} }init; // hopefully your compiler will optimize this out
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GEventReceiver)
			GATEWARE_FUNCTION(Append)
			GATEWARE_CONST_FUNCTION(Waiting)
			GATEWARE_FUNCTION(Pop)
			GATEWARE_CONST_FUNCTION(Peek)
			GATEWARE_CONST_FUNCTION(Missed)
			GATEWARE_FUNCTION(Clear)
			GATEWARE_CONST_FUNCTION(Invoke)
			GATEWARE_TEMPLATE_FUNCTION(Find)
			
			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GEVENTRECEIVER_H

/*---------------------------------
|	End of GEventReceiver.h
----------------------------------*/


/*---------------------------------
|	Begin of GEventQueue.h
----------------------------------*/
#ifndef GEVENTQUEUE_H
#define GEVENTQUEUE_H




namespace GW
{
	namespace I
	{
		class GEventQueueInterface : public virtual GEventReceiverInterface
		{
		public:
			// Let the compiler know that we intend to use the base class method as well as an override with an additional parameter
			using GEventReceiverInterface::Peek;
			// new methods
			virtual GReturn Peek(unsigned int _eventIndex, GEvent& _outEvent) const = 0; // override
			virtual GReturn Max(unsigned int& _outSize) const = 0;

			// we internally override Queue template "Find" functions to search whole queue
		};
	}
};

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GEventQueue.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_CORE) || defined(GATEWARE_DISABLE_GEVENTQUEUE) || \
    (defined(GATEWARE_ENABLE_CORE) && !defined(GATEWARE_DISABLE_GEVENTQUEUE) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	namespace GW {
	namespace I {
		// dummy implementations allow for code compilation even when an interface is unsupported by a platform
		class GEventQueueImplementation :	public virtual GEventQueueInterface,
											private GThreadSharedImplementation
		{
		public:
			// New operations
			GReturn Create(unsigned int _maxSize, CORE::GEventGenerator _listenToMe, std::function<void()> _callback) {
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			GReturn Peek(unsigned int _eventIndex, GEvent& _outEvent) const override {
				return GReturn::FAILURE;
			}
			GReturn Max(unsigned int& _outSize) const override {
				return GReturn::FAILURE;
			}
			// Override from GEventReceiver
			GReturn Append(const GEvent& _inEvent) override {
				return GReturn::FAILURE;
			}
			GReturn Waiting(unsigned int& _outCount) const override {
				return GReturn::FAILURE;
			}
			GReturn Pop(GEvent& _outEvent) override {
				return GReturn::FAILURE;
			}
			GReturn Peek(GEvent& _outEvent) const override {
				return GReturn::FAILURE;
			}
			GReturn Missed(unsigned int& _outCount) const override {
				return GReturn::FAILURE;
			}
			GReturn Clear() override {
				return GReturn::FAILURE;
			}
			GReturn Invoke() const override {
				return GReturn::FAILURE;
			}
			// Overload Find templates
			template<class eventType>
			GReturn Find(eventType _check, bool _remove) {
				return GReturn::FAILURE;
			}
			template<class eventType, typename eventData>
			GReturn Find(eventType _check, bool _remove, eventData& _outData) {
				return GReturn::FAILURE;
			}
		};
	} // end CORE
} // end GW

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
	// Make the implentation belong to the proper gateware namespace
// We cannot use "using" here as this is an HPP and supports header only deployments
namespace GW {
	namespace I {
		// Just like GEventReceiver except it can store multiple events in a queue so you can delay processing
		class GEventQueueImplementation :	public virtual GEventQueueInterface,
											private GThreadSharedImplementation, // resource locking
											public std::enable_shared_from_this<GInterfaceInterface>
		{
			// internal data members
			int enque = 0; // where items are enqued
			int deque = 0; // where items are dequed
			unsigned int maxEvents = 0; // size of the queue
			unsigned int missedEvents = 0; // increases if the queue is at capacity during append
			unsigned int eventsWaiting = 0; // number of events currently queued
			GEvent* circularQueue = nullptr; // where events are stored (ring buffer)
			std::function<void()> callback = nullptr; // custom user invocation on new event (optional)

			// functions for circular queue (since std does not seem to provide one)
			// NOTE: we may want to shift this into "key" as an ADT if it sees more widespread application
			
			// returns false if queue is full
			bool Enque(const GEvent& _push) 
			{
				if (eventsWaiting >= maxEvents)
					return false;
				circularQueue[enque] = _push;
				enque = (enque + 1) % maxEvents;
				++eventsWaiting;
				return true;
			}
			// returns false if queue is empty
			bool Deque(GEvent* _pop) // optional
			{
				if (eventsWaiting == 0)
					return false;
				if(_pop != nullptr)
					*_pop = circularQueue[deque];
				deque = (deque + 1) % maxEvents;
				--eventsWaiting;
				return true;
			}
			// required to fully implement the "Find" routines
			// while collapsing the queue is not optimal we go for the closest point to minimize copies
			bool Erase(unsigned int _offset) // offset from dequqe point
			{
				if (eventsWaiting == 0 || _offset >= eventsWaiting) // should we bother?
					return false;
				// which is closer enque or deque?
				int dir = (_offset < (eventsWaiting >> 1)) ? maxEvents - 1 : 1;
				int stop = (dir == 1) ? enque : (deque + dir) % maxEvents; // stop here
				_offset = (deque + _offset) % maxEvents; // this starting spot should be valid now
				for (int i = (_offset + dir) % maxEvents; i != stop; i = (i + dir) % maxEvents)
				{
					circularQueue[_offset] = circularQueue[i]; // copy & move
					_offset = i; // next
				}
				// update enque or deque based on which way we closed the gap
				(dir == 1) ? enque = _offset : deque = ((deque + 1) % maxEvents);
				--eventsWaiting; // reduce overall size of queue
				return true; // hopefully the logic above is good we will test it
			}
			// queue theory:
			// 0 1 2 3 4 5 6
			// - - D + + + E
			// + E - - D + +
			// + E - - - - D
			// D E - - - - -
			// - - - D E - -
			// + + E D + + +
			// - D + + E - -
			// + + + + + E D

		
		public:
			// with dynamic memory present we must free any allocated resources
			~GEventQueueImplementation()
			{
				delete[] circularQueue; // free allocated queue
			}
			// You must select a maximum size of the queue as for efficiency it is implemented as a circular array
			GReturn Create(unsigned int _maxSize, CORE::GEventGenerator _listenToMe, std::function<void()> _callback) 
			{
				if (_maxSize && _listenToMe && internal_gw::event_receiver_callback)
				{	
					// generate circular queue
					circularQueue = new GEvent[_maxSize];
					maxEvents = _maxSize; // store mamximum allowable event data
					callback = _callback; // nullptr is ok, optional.	
					// This is how to create a Proxy from "this", ideally we try and avoid doing this.
					CORE::GInterface me(shared_from_this()); // we create a temporary so only weak access is transfered
					// While weak access is not as fast, it grants lifetime control and flexibility to the user.
					// If you want the most efficiency you should consider calling "Register" directly with a fixed callback.
					return _listenToMe.Register(me, internal_gw::event_receiver_callback);					
				}
				else if (internal_gw::event_receiver_callback)
					return GReturn::INVALID_ARGUMENT; // cannot be null EventGenerator or Zero Size Queue! 
				else
					return GReturn::UNEXPECTED_RESULT; // global callback was not assigned!
			}
			GReturn Max(unsigned int& _outSize) const override 
			{
				LockAsyncRead();
				_outSize = maxEvents; // get maximum size of queue
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}
			// Override from GEventReceiver
			GReturn Append(const GEvent& _inEvent) override 
			{
				if (+LockSyncWrite()) // makin changes
				{
					if (eventsWaiting >= maxEvents) // are we are full?
					{
						Deque(nullptr); // remove an existing event so we have room
						++missedEvents; // notify we missed an event
					}
					// append new event (should always happen)
					if (Enque(_inEvent) && +UnlockSyncWrite()) // unlock 
						return GReturn::SUCCESS;
				}
				return GReturn::UNEXPECTED_RESULT; // should never get here
			}
			GReturn Waiting(unsigned int& _outCount) const override 
			{
				LockAsyncRead();
				_outCount = eventsWaiting; // get current size of queue
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}
			GReturn Pop(GEvent& _outEvent) override 
			{
				GReturn result = GReturn::FAILURE;
				if (+LockSyncWrite())
				{
					if (Deque(&_outEvent))
						result = GReturn::SUCCESS;
					UnlockSyncWrite();
				}
				return result;
			}
			GReturn Peek(GEvent& _outEvent) const override
			{
				GReturn result = GReturn::FAILURE;
				if (+LockAsyncRead())
				{
					if (eventsWaiting)
					{
						_outEvent = circularQueue[deque];
						result = GReturn::SUCCESS;
					}
					UnlockAsyncRead();
				}
				return result;
			}
			GReturn Peek(unsigned int _eventIndex, GEvent& _outEvent) const override
			{
				// Use deque + _eventIndex % maxEvents to find the right spot
				GReturn result = GReturn::FAILURE;
				if (+LockAsyncRead())
				{
					if (eventsWaiting)
					{
						if (_eventIndex < eventsWaiting) // must be a valid index
						{
							_outEvent = circularQueue[(deque + _eventIndex) % maxEvents];
							result = GReturn::SUCCESS;
						}
						else
							result = GReturn::INVALID_ARGUMENT; // out of range
					}
					UnlockAsyncRead();
				}
				return result;
			}
			GReturn Missed(unsigned int& _outCount) const override
			{
				LockAsyncRead();
				_outCount = missedEvents; // how many events were ignored
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}
			GReturn Clear() override 
			{
				GReturn result = GReturn::FAILURE;
				if (+LockSyncWrite())
				{
					if (eventsWaiting)
					{
						enque = deque = eventsWaiting = 0;
						result = GReturn::SUCCESS;
					}
					UnlockSyncWrite();
				}
				return result;
			}
			GReturn Invoke() const override 
			{
				if (callback)
				{
					callback(); // Invoke internal callback (can be done from multiple threads)
					return GReturn::SUCCESS;
				}
				// No callback attatched, so it cannot be invoked
				return GReturn::FAILURE;
			}
			// Overload Find templates
			template<class eventType>
			GReturn Find(eventType _check, bool _remove) 
			{
				eventType event;
				GReturn result = GReturn::FAILURE;
				if ((_remove) ? +LockSyncWrite() : +LockAsyncRead())
				{
					if (eventsWaiting)
					{
						// loop looking for the event in question starting with the oldest
						int i = deque, x = 0;
						do // we use a do while because in a full queue enque and deque are equal
						{
							if (G_PASS(circularQueue[i].Read(event)))
							{
								if (event == _check) // found it?
								{
									result = GReturn::SUCCESS;
									if (_remove)
										result = (Erase(x)) ? GReturn::SUCCESS 
															: GReturn::MEMORY_CORRUPTION;
									break; // we found it!
								}
							}// move to the next item
							i = (i + 1) % maxEvents, ++x;
						}while (i != enque); // stop when we hit the enque
					}
					(_remove) ? UnlockSyncWrite() : UnlockAsyncRead();
				}
				return result;
			}
			template<class eventType, typename eventData>
			GReturn Find(eventType _check, bool _remove, eventData& _outData) 
			{
				eventType event;
				GReturn result = GReturn::FAILURE;
				if ((_remove) ? +LockSyncWrite() : +LockAsyncRead())
				{
					if (eventsWaiting)
					{
						// loop looking for the event in question starting with the oldest
						int i = deque, x = 0;
						do // we use a do while because in a full queue enque and deque are equal
						{
							if (G_PASS(circularQueue[i].Read(event, _outData)))
							{
								if (event == _check) // found it?
								{
									result = GReturn::SUCCESS;
									if (_remove)
										result = (Erase(x)) ? GReturn::SUCCESS
															: GReturn::MEMORY_CORRUPTION;
									break; // we found it!
								}
							}// move to the next item
							i = (i + 1) % maxEvents, ++x;
						} while (i != enque); // stop when we hit the enque
					}
					(_remove) ? UnlockSyncWrite() : UnlockAsyncRead();
				}
				return result;
			}
		};
	} // end CORE
} // end GW


#endif



namespace GW
{
	namespace CORE
	{
		class  GEventQueue final
			: public I::GProxy<I::GEventQueueInterface, I::GEventQueueImplementation, unsigned int, GEventGenerator, const std::function<void()>>
		{
			// End users please feel free to ignore this struct, it is temporary and only used for internal API wiring.
			struct init_callback {
				init_callback() {
					internal_gw::event_receiver_callback = internal_gw::event_receiver_logic<GEventReceiver>;
				}
			}init; // hopefully your compiler will optimize this out

		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GEventQueue)
			GATEWARE_CONST_FUNCTION(Peek)
			GATEWARE_CONST_FUNCTION(Max)
			
			// reimplemented 
			GATEWARE_FUNCTION(Append)
			GATEWARE_CONST_FUNCTION(Waiting)
			GATEWARE_FUNCTION(Pop)
			GATEWARE_CONST_FUNCTION(Missed)
			GATEWARE_FUNCTION(Clear)
			GATEWARE_CONST_FUNCTION(Invoke)
			GATEWARE_TEMPLATE_FUNCTION(Find)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GEVENTQUEUE_H


/*---------------------------------
|	End of GEventQueue.h
----------------------------------*/


/*---------------------------------
|	Begin of GFile.h
----------------------------------*/
#ifndef GFILE_H
#define GFILE_H




namespace GW
{
	namespace I
	{
		class GFileInterface : public virtual GInterfaceInterface
		{
		public:
			virtual GReturn OpenBinaryRead(const char* const _file) = 0;
			virtual GReturn OpenBinaryWrite(const char* const _file) = 0;
			virtual GReturn AppendBinaryWrite(const char* const _file) = 0;
			virtual GReturn OpenTextRead(const char* const _file) = 0;
			virtual GReturn OpenTextWrite(const char* const _file) = 0;
			virtual GReturn AppendTextWrite(const char* const _file) = 0;
			virtual GReturn Write(const char* const _inData, unsigned int _numBytes) = 0;
			virtual GReturn Read(char* _outData, unsigned int _numBytes) = 0;
			virtual GReturn WriteLine(const char* const _inData) = 0;
			virtual GReturn ReadLine(char* _outData, unsigned int _outDataSize, char _delimiter) = 0;
			virtual GReturn CloseFile() = 0;
			virtual GReturn FlushFile() = 0;
			virtual GReturn SetCurrentWorkingDirectory(const char* const _dir) = 0;
			virtual GReturn GetCurrentWorkingDirectory(char* _outDir, unsigned int _dirSize) = 0;
			virtual GReturn GetDirectorySize(unsigned int& _outSize) = 0;
			virtual GReturn GetSubDirectorySize(unsigned int& _outSize) = 0;
			virtual GReturn GetFilesFromDirectory(char* _outFiles[], unsigned int _numFiles, unsigned int _fileNameSize) = 0;
			virtual GReturn GetFoldersFromDirectory(unsigned int _numsubDir, unsigned int _subDirNameSize, char* _outsubDir[]) = 0;
			virtual GReturn GetFileSize(const char* const _file, unsigned int& _outSize) = 0;
			virtual GReturn Seek(unsigned int _seekFrom, int _amount, unsigned int& _outCurrPos) = 0;
		};
	}
};

// Implementaion for GFile.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.

// dirent.h is not native to Windows and is added to the project
// The " " are used for include so the compiler knows to look in the
// project folder first.
// dirent.h is native in Linux and Mac so the < > are used to include.
// Apple and Linux includes.
#if defined(__APPLE__) || defined(__linux__)
	#include <dirent.h>
#elif defined(_WIN32)
	/*
 * Dirent interface for Microsoft Visual Studio
 * Version 1.21
 *
 * Copyright (C) 2006-2012 Toni Ronkko
 * This file is part of dirent.  Dirent may be freely distributed
 * under the MIT license.  For all details and documentation, see
 * https://github.com/tronkko/dirent
 */
#ifndef DIRENT_H
#define DIRENT_H

/*
 * Define architecture flags so we don't need to include windows.h.
 * Avoiding windows.h makes it simpler to use windows sockets in conjunction
 * with dirent.h.
 */
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_IX86)
#   define _X86_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_AMD64)
#define _AMD64_
#endif

#include <stdio.h>
#include <stdarg.h>
#include <windef.h>
#include <winbase.h>
#include <wchar.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>

/* Indicates that d_type field is available in dirent structure */
#define _DIRENT_HAVE_D_TYPE

/* Indicates that d_namlen field is available in dirent structure */
#define _DIRENT_HAVE_D_NAMLEN

/* Entries missing from MSVC 6.0 */
#if !defined(FILE_ATTRIBUTE_DEVICE)
#   define FILE_ATTRIBUTE_DEVICE 0x40
#endif

/* File type and permission flags for stat(), general mask */
#if !defined(S_IFMT)
#   define S_IFMT _S_IFMT
#endif

/* Directory bit */
#if !defined(S_IFDIR)
#   define S_IFDIR _S_IFDIR
#endif

/* Character device bit */
#if !defined(S_IFCHR)
#   define S_IFCHR _S_IFCHR
#endif

/* Pipe bit */
#if !defined(S_IFFIFO)
#   define S_IFFIFO _S_IFFIFO
#endif

/* Regular file bit */
#if !defined(S_IFREG)
#   define S_IFREG _S_IFREG
#endif

/* Read permission */
#if !defined(S_IREAD)
#   define S_IREAD _S_IREAD
#endif

/* Write permission */
#if !defined(S_IWRITE)
#   define S_IWRITE _S_IWRITE
#endif

/* Execute permission */
#if !defined(S_IEXEC)
#   define S_IEXEC _S_IEXEC
#endif

/* Pipe */
#if !defined(S_IFIFO)
#   define S_IFIFO _S_IFIFO
#endif

/* Block device */
#if !defined(S_IFBLK)
#   define S_IFBLK 0
#endif

/* Link */
#if !defined(S_IFLNK)
#   define S_IFLNK 0
#endif

/* Socket */
#if !defined(S_IFSOCK)
#   define S_IFSOCK 0
#endif

/* Read user permission */
#if !defined(S_IRUSR)
#   define S_IRUSR S_IREAD
#endif

/* Write user permission */
#if !defined(S_IWUSR)
#   define S_IWUSR S_IWRITE
#endif

/* Execute user permission */
#if !defined(S_IXUSR)
#   define S_IXUSR 0
#endif

/* Read group permission */
#if !defined(S_IRGRP)
#   define S_IRGRP 0
#endif

/* Write group permission */
#if !defined(S_IWGRP)
#   define S_IWGRP 0
#endif

/* Execute group permission */
#if !defined(S_IXGRP)
#   define S_IXGRP 0
#endif

/* Read others permission */
#if !defined(S_IROTH)
#   define S_IROTH 0
#endif

/* Write others permission */
#if !defined(S_IWOTH)
#   define S_IWOTH 0
#endif

/* Execute others permission */
#if !defined(S_IXOTH)
#   define S_IXOTH 0
#endif

/* Maximum length of file name */
#if !defined(PATH_MAX)
#   define PATH_MAX MAX_PATH
#endif
#if !defined(FILENAME_MAX)
#   define FILENAME_MAX MAX_PATH
#endif
#if !defined(NAME_MAX)
#   define NAME_MAX FILENAME_MAX
#endif

/* File type flags for d_type */
#define DT_UNKNOWN 0
#define DT_REG S_IFREG
#define DT_DIR S_IFDIR
#define DT_FIFO S_IFIFO
#define DT_SOCK S_IFSOCK
#define DT_CHR S_IFCHR
#define DT_BLK S_IFBLK
#define DT_LNK S_IFLNK

/* Macros for converting between st_mode and d_type */
#define IFTODT(mode) ((mode) & S_IFMT)
#define DTTOIF(type) (type)

/*
 * File type macros.  Note that block devices, sockets and links cannot be
 * distinguished on Windows and the macros S_ISBLK, S_ISSOCK and S_ISLNK are
 * only defined for compatibility.  These macros should always return false
 * on Windows.
 */
#if !defined(S_ISFIFO)
#   define S_ISFIFO(mode) (((mode) & S_IFMT) == S_IFIFO)
#endif
#if !defined(S_ISDIR)
#   define S_ISDIR(mode) (((mode) & S_IFMT) == S_IFDIR)
#endif
#if !defined(S_ISREG)
#   define S_ISREG(mode) (((mode) & S_IFMT) == S_IFREG)
#endif
#if !defined(S_ISLNK)
#   define S_ISLNK(mode) (((mode) & S_IFMT) == S_IFLNK)
#endif
#if !defined(S_ISSOCK)
#   define S_ISSOCK(mode) (((mode) & S_IFMT) == S_IFSOCK)
#endif
#if !defined(S_ISCHR)
#   define S_ISCHR(mode) (((mode) & S_IFMT) == S_IFCHR)
#endif
#if !defined(S_ISBLK)
#   define S_ISBLK(mode) (((mode) & S_IFMT) == S_IFBLK)
#endif

/* Return the exact length of d_namlen without zero terminator */
#define _D_EXACT_NAMLEN(p) ((p)->d_namlen)

/* Return number of bytes needed to store d_namlen */
#define _D_ALLOC_NAMLEN(p) (PATH_MAX)


#ifdef __cplusplus
extern "C" {
#endif


/* Wide-character version */
struct _wdirent {
    /* Always zero */
    long d_ino;

    /* Structure size */
    unsigned short d_reclen;

    /* Length of name without \0 */
    size_t d_namlen;

    /* File type */
    int d_type;

    /* File name */
    wchar_t d_name[PATH_MAX];
};
typedef struct _wdirent _wdirent;

struct _WDIR {
    /* Current directory entry */
    struct _wdirent ent;

    /* Private file data */
    WIN32_FIND_DATAW data;

    /* True if data is valid */
    int cached;

    /* Win32 search handle */
    HANDLE handle;

    /* Initial directory name */
    wchar_t *patt;
};
typedef struct _WDIR _WDIR;

static _WDIR *_wopendir (const wchar_t *dirname);
static struct _wdirent *_wreaddir (_WDIR *dirp);
static int _wclosedir (_WDIR *dirp);
static void _wrewinddir (_WDIR* dirp);


/* For compatibility with Symbian */
#define wdirent _wdirent
#define WDIR _WDIR
#define wopendir _wopendir
#define wreaddir _wreaddir
#define wclosedir _wclosedir
#define wrewinddir _wrewinddir


/* Multi-byte character versions */
struct dirent {
    /* Always zero */
    long d_ino;

    /* Structure size */
    unsigned short d_reclen;

    /* Length of name without \0 */
    size_t d_namlen;

    /* File type */
    int d_type;

    /* File name */
    char d_name[PATH_MAX];
};
typedef struct dirent dirent;

struct DIR {
    struct dirent ent;
    struct _WDIR *wdirp;
};
typedef struct DIR DIR;

static DIR *opendir (const char *dirname);
static struct dirent *readdir (DIR *dirp);
static int closedir (DIR *dirp);
static void rewinddir (DIR* dirp);


/* Internal utility functions */
static WIN32_FIND_DATAW *dirent_first (_WDIR *dirp);
static WIN32_FIND_DATAW *dirent_next (_WDIR *dirp);

static int dirent_mbstowcs_s(
    size_t *pReturnValue,
    wchar_t *wcstr,
    size_t sizeInWords,
    const char *mbstr,
    size_t count);

static int dirent_wcstombs_s(
    size_t *pReturnValue,
    char *mbstr,
    size_t sizeInBytes,
    const wchar_t *wcstr,
    size_t count);

static void dirent_set_errno (int error);

/*
 * Open directory stream DIRNAME for read and return a pointer to the
 * internal working area that is used to retrieve individual directory
 * entries.
 */
static _WDIR*
_wopendir(
    const wchar_t *dirname)
{
    _WDIR *dirp = NULL;
    int error;

    /* Must have directory name */
    if (dirname == NULL  ||  dirname[0] == '\0') {
        dirent_set_errno (ENOENT);
        return NULL;
    }

    /* Allocate new _WDIR structure */
    dirp = (_WDIR*) malloc (sizeof (struct _WDIR));
    if (dirp != NULL) {
        DWORD n;

        /* Reset _WDIR structure */
        dirp->handle = INVALID_HANDLE_VALUE;
        dirp->patt = NULL;
        dirp->cached = 0;

        /* Compute the length of full path plus zero terminator */
        n = GetFullPathNameW (dirname, 0, NULL, NULL);

        /* Allocate room for absolute directory name and search pattern */
        dirp->patt = (wchar_t*) malloc (sizeof (wchar_t) * n + 16);
        if (dirp->patt) {

            /*
             * Convert relative directory name to an absolute one.  This
             * allows rewinddir() to function correctly even when current
             * working directory is changed between opendir() and rewinddir().
             */
            n = GetFullPathNameW (dirname, n, dirp->patt, NULL);
            if (n > 0) {
                wchar_t *p;

                /* Append search pattern \* to the directory name */
                p = dirp->patt + n;
                if (dirp->patt < p) {
                    switch (p[-1]) {
                    case '\\':
                    case '/':
                    case ':':
                        /* Directory ends in path separator, e.g. c:\temp\ */
                        /*NOP*/;
                        break;

                    default:
                        /* Directory name doesn't end in path separator */
                        *p++ = '\\';
                    }
                }
                *p++ = '*';
                *p = '\0';

                /* Open directory stream and retrieve the first entry */
                if (dirent_first (dirp)) {
                    /* Directory stream opened successfully */
                    error = 0;
                } else {
                    /* Cannot retrieve first entry */
                    error = 1;
                    dirent_set_errno (ENOENT);
                }

            } else {
                /* Cannot retrieve full path name */
                dirent_set_errno (ENOENT);
                error = 1;
            }

        } else {
            /* Cannot allocate memory for search pattern */
            error = 1;
        }

    } else {
        /* Cannot allocate _WDIR structure */
        error = 1;
    }

    /* Clean up in case of error */
    if (error  &&  dirp) {
        _wclosedir (dirp);
        dirp = NULL;
    }

    return dirp;
}

/*
 * Read next directory entry.  The directory entry is returned in dirent
 * structure in the d_name field.  Individual directory entries returned by
 * this function include regular files, sub-directories, pseudo-directories
 * "." and ".." as well as volume labels, hidden files and system files.
 */
static struct _wdirent*
_wreaddir(
    _WDIR *dirp)
{
    WIN32_FIND_DATAW *datap;
    struct _wdirent *entp;

    /* Read next directory entry */
    datap = dirent_next (dirp);
    if (datap) {
        size_t n;
        DWORD attr;
        
        /* Pointer to directory entry to return */
        entp = &dirp->ent;

        /* 
         * Copy file name as wide-character string.  If the file name is too
         * long to fit in to the destination buffer, then truncate file name
         * to PATH_MAX characters and zero-terminate the buffer.
         */
        n = 0;
        while (n + 1 < PATH_MAX  &&  datap->cFileName[n] != 0) {
            entp->d_name[n] = datap->cFileName[n];
            n++;
        }
        dirp->ent.d_name[n] = 0;

        /* Length of file name excluding zero terminator */
        entp->d_namlen = n;

        /* File type */
        attr = datap->dwFileAttributes;
        if ((attr & FILE_ATTRIBUTE_DEVICE) != 0) {
            entp->d_type = DT_CHR;
        } else if ((attr & FILE_ATTRIBUTE_DIRECTORY) != 0) {
            entp->d_type = DT_DIR;
        } else {
            entp->d_type = DT_REG;
        }

        /* Reset dummy fields */
        entp->d_ino = 0;
        entp->d_reclen = sizeof (struct _wdirent);

    } else {

        /* Last directory entry read */
        entp = NULL;

    }

    return entp;
}

/*
 * Close directory stream opened by opendir() function.  This invalidates the
 * DIR structure as well as any directory entry read previously by
 * _wreaddir().
 */
static int
_wclosedir(
    _WDIR *dirp)
{
    int ok;
    if (dirp) {

        /* Release search handle */
        if (dirp->handle != INVALID_HANDLE_VALUE) {
            FindClose (dirp->handle);
            dirp->handle = INVALID_HANDLE_VALUE;
        }

        /* Release search pattern */
        if (dirp->patt) {
            free (dirp->patt);
            dirp->patt = NULL;
        }

        /* Release directory structure */
        free (dirp);
        ok = /*success*/0;

    } else {
        /* Invalid directory stream */
        dirent_set_errno (EBADF);
        ok = /*failure*/-1;
    }
    return ok;
}

/*
 * Rewind directory stream such that _wreaddir() returns the very first
 * file name again.
 */
static void
_wrewinddir(
    _WDIR* dirp)
{
    if (dirp) {
        /* Release existing search handle */
        if (dirp->handle != INVALID_HANDLE_VALUE) {
            FindClose (dirp->handle);
        }

        /* Open new search handle */
        dirent_first (dirp);
    }
}

/* Get first directory entry (internal) */
static WIN32_FIND_DATAW*
dirent_first(
    _WDIR *dirp)
{
    WIN32_FIND_DATAW *datap;

    /* Open directory and retrieve the first entry */
    dirp->handle = FindFirstFileW (dirp->patt, &dirp->data);
    if (dirp->handle != INVALID_HANDLE_VALUE) {

        /* a directory entry is now waiting in memory */
        datap = &dirp->data;
        dirp->cached = 1;

    } else {

        /* Failed to re-open directory: no directory entry in memory */
        dirp->cached = 0;
        datap = NULL;

    }
    return datap;
}

/* Get next directory entry (internal) */
static WIN32_FIND_DATAW*
dirent_next(
    _WDIR *dirp)
{
    WIN32_FIND_DATAW *p;

    /* Get next directory entry */
    if (dirp->cached != 0) {

        /* A valid directory entry already in memory */
        p = &dirp->data;
        dirp->cached = 0;

    } else if (dirp->handle != INVALID_HANDLE_VALUE) {

        /* Get the next directory entry from stream */
        if (FindNextFileW (dirp->handle, &dirp->data) != FALSE) {
            /* Got a file */
            p = &dirp->data;
        } else {
            /* The very last entry has been processed or an error occured */
            FindClose (dirp->handle);
            dirp->handle = INVALID_HANDLE_VALUE;
            p = NULL;
        }

    } else {

        /* End of directory stream reached */
        p = NULL;

    }

    return p;
}

/* 
 * Open directory stream using plain old C-string.
 */
static DIR*
opendir(
    const char *dirname) 
{
    struct DIR *dirp;
    int error;

    /* Must have directory name */
    if (dirname == NULL  ||  dirname[0] == '\0') {
        dirent_set_errno (ENOENT);
        return NULL;
    }

    /* Allocate memory for DIR structure */
    dirp = (DIR*) malloc (sizeof (struct DIR));
    if (dirp) {
        wchar_t wname[PATH_MAX];
        size_t n;

        /* Convert directory name to wide-character string */
        error = dirent_mbstowcs_s (&n, wname, PATH_MAX, dirname, PATH_MAX);
        if (!error) {

            /* Open directory stream using wide-character name */
            dirp->wdirp = _wopendir (wname);
            if (dirp->wdirp) {
                /* Directory stream opened */
                error = 0;
            } else {
                /* Failed to open directory stream */
                error = 1;
            }

        } else {
            /* 
             * Cannot convert file name to wide-character string.  This
             * occurs if the string contains invalid multi-byte sequences or
             * the output buffer is too small to contain the resulting
             * string.
             */
            error = 1;
        }

    } else {
        /* Cannot allocate DIR structure */
        error = 1;
    }

    /* Clean up in case of error */
    if (error  &&  dirp) {
        free (dirp);
        dirp = NULL;
    }

    return dirp;
}

/*
 * Read next directory entry.
 *
 * When working with text consoles, please note that file names returned by
 * readdir() are represented in the default ANSI code page while any output to
 * console is typically formatted on another code page.  Thus, non-ASCII
 * characters in file names will not usually display correctly on console.  The
 * problem can be fixed in two ways: (1) change the character set of console
 * to 1252 using chcp utility and use Lucida Console font, or (2) use
 * _cprintf function when writing to console.  The _cprinf() will re-encode
 * ANSI strings to the console code page so many non-ASCII characters will
 * display correcly.
 */
static struct dirent*
readdir(
    DIR *dirp) 
{
    WIN32_FIND_DATAW *datap;
    struct dirent *entp;

    /* Read next directory entry */
    datap = dirent_next (dirp->wdirp);
    if (datap) {
        size_t n;
        int error;

        /* Attempt to convert file name to multi-byte string */
        error = dirent_wcstombs_s(
            &n, dirp->ent.d_name, PATH_MAX, datap->cFileName, PATH_MAX);

        /* 
         * If the file name cannot be represented by a multi-byte string,
         * then attempt to use old 8+3 file name.  This allows traditional
         * Unix-code to access some file names despite of unicode
         * characters, although file names may seem unfamiliar to the user.
         *
         * Be ware that the code below cannot come up with a short file
         * name unless the file system provides one.  At least
         * VirtualBox shared folders fail to do this.
         */
        if (error  &&  datap->cAlternateFileName[0] != '\0') {
            error = dirent_wcstombs_s(
                &n, dirp->ent.d_name, PATH_MAX, 
                datap->cAlternateFileName, PATH_MAX);
        }

        if (!error) {
            DWORD attr;

            /* Initialize directory entry for return */
            entp = &dirp->ent;

            /* Length of file name excluding zero terminator */
            entp->d_namlen = n - 1;

            /* File attributes */
            attr = datap->dwFileAttributes;
            if ((attr & FILE_ATTRIBUTE_DEVICE) != 0) {
                entp->d_type = DT_CHR;
            } else if ((attr & FILE_ATTRIBUTE_DIRECTORY) != 0) {
                entp->d_type = DT_DIR;
            } else {
                entp->d_type = DT_REG;
            }

            /* Reset dummy fields */
            entp->d_ino = 0;
            entp->d_reclen = sizeof (struct dirent);

        } else {
            /* 
             * Cannot convert file name to multi-byte string so construct
             * an errornous directory entry and return that.  Note that
             * we cannot return NULL as that would stop the processing
             * of directory entries completely.
             */
            entp = &dirp->ent;
            entp->d_name[0] = '?';
            entp->d_name[1] = '\0';
            entp->d_namlen = 1;
            entp->d_type = DT_UNKNOWN;
            entp->d_ino = 0;
            entp->d_reclen = 0;
        }

    } else {
        /* No more directory entries */
        entp = NULL;
    }

    return entp;
}

/*
 * Close directory stream.
 */
static int
closedir(
    DIR *dirp) 
{
    int ok;
    if (dirp) {

        /* Close wide-character directory stream */
        ok = _wclosedir (dirp->wdirp);
        dirp->wdirp = NULL;

        /* Release multi-byte character version */
        free (dirp);

    } else {

        /* Invalid directory stream */
        dirent_set_errno (EBADF);
        ok = /*failure*/-1;

    }
    return ok;
}

/*
 * Rewind directory stream to beginning.
 */
static void
rewinddir(
    DIR* dirp) 
{
    /* Rewind wide-character string directory stream */
    _wrewinddir (dirp->wdirp);
}

/* Convert multi-byte string to wide character string */
static int
dirent_mbstowcs_s(
    size_t *pReturnValue,
    wchar_t *wcstr,
    size_t sizeInWords,
    const char *mbstr,
    size_t count)
{
    int error;

#if defined(_MSC_VER)  &&  _MSC_VER >= 1400

    /* Microsoft Visual Studio 2005 or later */
    error = mbstowcs_s (pReturnValue, wcstr, sizeInWords, mbstr, count);

#else

    /* Older Visual Studio or non-Microsoft compiler */
    size_t n;

    /* Convert to wide-character string (or count characters) */
    n = mbstowcs (wcstr, mbstr, sizeInWords);
    if (!wcstr  ||  n < count) {

        /* Zero-terminate output buffer */
        if (wcstr  &&  sizeInWords) {
            if (n >= sizeInWords) {
                n = sizeInWords - 1;
            }
            wcstr[n] = 0;
        }

        /* Length of resuting multi-byte string WITH zero terminator */
        if (pReturnValue) {
            *pReturnValue = n + 1;
        }

        /* Success */
        error = 0;

    } else {

        /* Could not convert string */
        error = 1;

    }

#endif

    return error;
}

/* Convert wide-character string to multi-byte string */
static int
dirent_wcstombs_s(
    size_t *pReturnValue,
    char *mbstr,
    size_t sizeInBytes, /* max size of mbstr */
    const wchar_t *wcstr,
    size_t count)
{
    int error;

#if defined(_MSC_VER)  &&  _MSC_VER >= 1400

    /* Microsoft Visual Studio 2005 or later */
    error = wcstombs_s (pReturnValue, mbstr, sizeInBytes, wcstr, count);

#else

    /* Older Visual Studio or non-Microsoft compiler */
    size_t n;

    /* Convert to multi-byte string (or count the number of bytes needed) */
    n = wcstombs (mbstr, wcstr, sizeInBytes);
    if (!mbstr  ||  n < count) {

        /* Zero-terminate output buffer */
        if (mbstr  &&  sizeInBytes) {
            if (n >= sizeInBytes) {
                n = sizeInBytes - 1;
            }
            mbstr[n] = '\0';
        }

        /* Lenght of resulting multi-bytes string WITH zero-terminator */
        if (pReturnValue) {
            *pReturnValue = n + 1;
        }

        /* Success */
        error = 0;

    } else {

        /* Cannot convert string */
        error = 1;

    }

#endif

    return error;
}

/* Set errno variable */
static void
dirent_set_errno(
    int error)
{
#if defined(_MSC_VER)  &&  _MSC_VER >= 1400

    /* Microsoft Visual Studio 2005 and later */
    _set_errno (error);

#else

    /* Non-Microsoft compiler or older Microsoft compiler */
    errno = error;

#endif
}


#ifdef __cplusplus
}
#endif
#endif /*DIRENT_H*/



#endif

#if !defined(GATEWARE_ENABLE_SYSTEM) || defined(GATEWARE_DISABLE_GFILE) || \
    (defined(GATEWARE_ENABLE_SYSTEM) && !defined(GATEWARE_DISABLE_GFILE) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	namespace GW
{
	namespace I
	{
		class GFileImplementation : public GFileInterface
		{
		public:
			GReturn Create() {
				return GReturn::INTERFACE_UNSUPPORTED;
			}

			GReturn OpenBinaryRead(const char* const _file) override {
				return GReturn::FAILURE;
			}

			GReturn OpenBinaryWrite(const char* const _file) override {
				return GReturn::FAILURE;
			}

			GReturn AppendBinaryWrite(const char* const _file) override {
				return GReturn::FAILURE;
			}

			GReturn OpenTextRead(const char* const _file) override {
				return GReturn::FAILURE;
			}

			GReturn OpenTextWrite(const char* const _file) override {
				return GReturn::FAILURE;
			}

			GReturn AppendTextWrite(const char* const _file) override {
				return GReturn::FAILURE;
			}

			GReturn Write(const char* const _inData, unsigned int _numBytes) override {
				return GReturn::FAILURE;
			}

			GReturn Read(char* _outData, unsigned int _numBytes) override {
				return GReturn::FAILURE;
			}

			GReturn WriteLine(const char* const _inData) override {
				return GReturn::FAILURE;
			}

			GReturn ReadLine(char* _outData, unsigned int _outDataSize, char _delimiter) override {
				return GReturn::FAILURE;
			}

			GReturn CloseFile() override {
				return GReturn::FAILURE;
			}

			GReturn FlushFile() override {
				return GReturn::FAILURE;
			}

			GReturn SetCurrentWorkingDirectory(const char* const _dir) override {
				return GReturn::FAILURE;
			}

			GReturn GetCurrentWorkingDirectory(char* _outDir, unsigned int _dirSize) override {
				return GReturn::FAILURE;
			}

			GReturn GetDirectorySize(unsigned int& _outSize) override {
				return GReturn::FAILURE;
			}

			GReturn GetSubDirectorySize(unsigned int& _outSize) override {
				return GReturn::FAILURE;
			}

			GReturn GetFilesFromDirectory(	char* _outFiles[], unsigned int _numFiles, 
											unsigned int _fileNameSize) override {
				return GReturn::FAILURE;
			}

			GReturn GetFoldersFromDirectory(unsigned int _numsubDir, unsigned int _subDirNameSize,
											char* _outsubDir[]) override {
				return GReturn::FAILURE;
			}

			GReturn GetFileSize(const char* const _file, unsigned int& _outSize) override {
				return GReturn::FAILURE;
			}

			GReturn Seek(unsigned int _seekFrom, int _amount, unsigned int& _outCurrPos) override {
				return GReturn::FAILURE;
			}
		};
	}
}

#elif defined(__APPLE__)
	#include <fstream>  //file streams
#include <string>  //strings
#include <atomic>  //atomic variables
#include <mutex>  //mutex locks
  //Internal utility functions
#include <stdio.h>

//dirent.h is not native to Windows and is added to the project
//The " " are used for include so the compiler knows to look in the
//project folder first.
//dirent.h is native in Linux and Mac so the < > are used to include.
#if defined(__APPLE__) || defined(__linux__)

//Apple and Linux includes.
  //Directory handling.
 //thread safety.
#include <sys/stat.h>  //File stats.
#include <string.h>
#include <cstring>

#define DIR_SEPERATOR '/'

#else

#error Gateware libraries are not currently supported for your platform

#endif

//The using statements for specifically what we are using.
using std::string;
using std::fstream;
using std::ios;
using std::atomic;
using std::mutex;
using std::getline;

namespace GW
{
    namespace I
    {
        class GFileImplementation : public virtual GW::I::GFileInterface, protected GThreadSharedImplementation
    
        {
            DIR* currDirStream;  //Maintains the current directory.
            fstream file;  //Maintains the current file (if one is open).
            FILE* binaryFile = NULL; //for binary read and write
            string currDir;  //A cached directory path for faster fetching.
            char initialDir[250];
            atomic<unsigned int> mode; //Used to track what open mode the file is in
            mutex lock; //Read/Write lock.
            unsigned int fileSize = 0;

        public:
            GFileImplementation()
            {
                currDirStream = nullptr;
            };
            
            virtual ~GFileImplementation()
            {
                SetCurrentWorkingDirectory(initialDir);
                //Close the current directory.
                closedir(currDirStream);

                //Close the file stream.
                CloseFile();
            };

            GReturn OpenBinaryRead(const char* const _file) override
            {
                //Check for invalid arguments.
                if (_file == nullptr)
                    return GW::GReturn::INVALID_ARGUMENT;

                //Ensure a file is not already open.
                if (file.is_open())
                    return GW::GReturn::FAILURE;

                //Open the new file in the currentWorkingDirectory.
                file.open(currDir + G_TO_UTF16(_file), ios::in | ios::binary);

                //If the file failed to open the function fails.
                if (!file.is_open())
                    return GW::GReturn::FILE_NOT_FOUND;

                //Set mode to read
                mode = ios::in;
                
                // get the file size
                GetFileSize(_file, fileSize);
                
                return GW::GReturn::SUCCESS;
            };

            GReturn OpenBinaryWrite(const char* const _file) override
            {

                //Check for invalid arguments.
                if (_file == nullptr)
                    return GW::GReturn::INVALID_ARGUMENT;

                //Check for invalid arguments.
                if (_file == nullptr)
                    return GW::GReturn::INVALID_ARGUMENT;

                //If the file is currently open we fail.
                if (file.is_open())
                    return GW::GReturn::FAILURE;

                //Open the new file.
                file.open(currDir + G_TO_UTF16(_file), ios::out | ios::binary);

                //If file failed to open we fail.
                if (!file.is_open())
                    return GW::GReturn::FILE_NOT_FOUND;

                //Set mode to write
                mode = ios::out;
                
                // get the file size
                GetFileSize(_file, fileSize);

                return GW::GReturn::SUCCESS;
            };

            GReturn AppendBinaryWrite(const char* const _file) override
            {
                //Check for invalid arguments.
                if (_file == nullptr)
                    return GW::GReturn::INVALID_ARGUMENT;

                //Close the current file if there is one.
                if (file.is_open())
                    return GW::GReturn::FAILURE;

                //Open the new file.
                file.open(currDir + G_TO_UTF16(_file), ios::out | ios::binary | ios::app | ios::ate);

                //If file failed to open we fail.
                if (!file.is_open())
                    return GW::GReturn::FILE_NOT_FOUND;

                //Set mode to write
                mode = ios::out;
                
                // get the file size
                GetFileSize(_file, fileSize);

                return GW::GReturn::SUCCESS;
            };

            GReturn OpenTextRead(const char* const _file) override
            {
                //Check for invalid arguments.
                if (_file == nullptr)
                    return GW::GReturn::INVALID_ARGUMENT;

                //Close the current file if there is one.
                if (file.is_open())
                    return GW::GReturn::FAILURE;

                //Open the new file.
                file.open(currDir + G_TO_UTF16(_file), ios::in);

                if (!file.is_open())
                    return GW::GReturn::FILE_NOT_FOUND;

                //Set mode to read
                mode = ios::in;
                
                // get the file size
                GetFileSize(_file, fileSize);

                return GW::GReturn::SUCCESS;
            };

            GReturn OpenTextWrite(const char* const _file) override
            {
                //Check for invalid arguments.
                if (_file == nullptr)
                    return GW::GReturn::INVALID_ARGUMENT;

                //Close the current file if there is one.
                if (file.is_open())
                    return GW::GReturn::FAILURE;

                //Open the new file.
                file.open(currDir + G_TO_UTF16(_file), ios::out);

                if (!file.is_open())
                    return GW::GReturn::FILE_NOT_FOUND;

                //Set mode to write
                mode = ios::out;
                
                // get the file size
                GetFileSize(_file, fileSize);

                return GW::GReturn::SUCCESS;
            };

            GReturn AppendTextWrite(const char* const _file) override
            {
                //Check for invalid arguments.
                if (_file == nullptr)
                    return GW::GReturn::INVALID_ARGUMENT;

                //Close the current file if there is one.
                if (file.is_open())
                    return GW::GReturn::FAILURE;

                //Open the new file.
                file.open(currDir + G_TO_UTF16(_file), ios::out | ios::app | ios::ate);

                if (!file.is_open())
                    return GW::GReturn::FILE_NOT_FOUND;

                //Set mode to write
                mode = ios::out;
                
                // get the file size
                GetFileSize(_file, fileSize);

                return GW::GReturn::SUCCESS;
            };

            GReturn Write(const char* const _inData, unsigned int _numBytes) override
            {
                //Check for invalid arguments.
                if (_inData == nullptr || _numBytes == 0)
                    return GW::GReturn::INVALID_ARGUMENT;

                //Ensure a file is open.
                if (!file.is_open() && binaryFile == NULL)
                    return GW::GReturn::FAILURE;

                //Make sure the file is opened for writing
                if (mode != ios::out)
                    return GW::GReturn::FAILURE;

                //Lock the write operations.
                lock.lock();

                file.write(_inData, _numBytes);
                
                // update the file size
                fileSize += _numBytes;

                lock.unlock();

                return GW::GReturn::SUCCESS;
            };

            GReturn Read(char* _outData, unsigned int _numBytes) override
            {
                if (_numBytes == 0)
                    return GW::GReturn::INVALID_ARGUMENT;

                //Ensure a file is open.
                if (!file.is_open() && binaryFile == NULL)
                {
                    _outData = nullptr;
                    return GW::GReturn::FAILURE;
                }

                //Make sure the file is opened for reading
                if (mode != ios::in)
                    return GW::GReturn::FAILURE;

                //Lock the read operations.
                lock.lock();

                file.read(_outData, _numBytes);

                lock.unlock();

                return GW::GReturn::SUCCESS;
            };

            GReturn WriteLine(const char* const _inData) override
            {
                //Check for invalid arguments.
                if (_inData == nullptr)
                    return GW::GReturn::INVALID_ARGUMENT;

                //Ensure a file is open.
                if (!file.is_open())
                    return GW::GReturn::FAILURE;

                //Make sure the file is opened for writing
                if (mode != ios::out)
                    return GW::GReturn::FAILURE;

                //Transfer the data to a string. #defines make it so the
                //string is what we need it to be on any system we support.
                string writeOutString = G_TO_UTF16(_inData);

                //Lock the write operations.
                lock.lock();

                //Write out the string.
                file << writeOutString;
                
                // update the file size
                fileSize += static_cast<unsigned int>(writeOutString.length());

                lock.unlock();

                return GW::GReturn::SUCCESS;
            };

            GReturn ReadLine(char* _outData, unsigned int _outDataSize, char _delimiter) override
            {
                if (_outData == nullptr || _outDataSize == 0)
                    return GW::GReturn::INVALID_ARGUMENT;

                //Ensure file is open.
                if (!file.is_open())
                    return GW::GReturn::FAILURE;

                //Make sure the file is opened for reading
                if (mode != ios::in)
                    return GW::GReturn::FAILURE;

                //The string to be read into.
                string outString;

                //Lock the read operations.
                lock.lock();

                //Just read in data normally.
                getline(file, outString, _delimiter);

            #if defined(TARGET_OS_IOS) || defined(TARGET_OS_SIMULATOR)
                INTERNAL::strlcpy(_outData, _outDataSize, G_TO_UTF8(outString).c_str());
            #else

                //Copy the data over to the out parameter.
                INTERNAL::strcpy_s(_outData, _outDataSize, G_TO_UTF8(outString).c_str());

            #endif

                lock.unlock();

                return GW::GReturn::SUCCESS;
            };

            GReturn CloseFile() override
            {
                //If a file is not open, we can not close it.
                if (!file.is_open() && binaryFile == NULL)
                    return GW::GReturn::FAILURE;

                if (binaryFile != NULL)
                {
                    fflush(binaryFile);
                    fclose(binaryFile);
                    binaryFile = nullptr;
                }
                else
                {
                    //Flush the file.
                    file.flush();
                    //Close the file.
                    file.close();
                }
                return GW::GReturn::SUCCESS;
            };

            GReturn FlushFile() override
            {
                //If a file is not open we can not flush it.
                if (!file.is_open() && binaryFile == NULL)
                    return GW::GReturn::FAILURE;

                if (binaryFile != NULL)
                    fflush(binaryFile);
                else
                {
                    //flush the file.
                    file.flush();
                }
                return GW::GReturn::SUCCESS;
            };

            GReturn SetCurrentWorkingDirectory(const char* const _dir) override
            {
                //Check for valid arguments.
                if (_dir == nullptr)
                    return GW::GReturn::INVALID_ARGUMENT;

                //Get the absolute path.
                char buffer[PATH_MAX];
                if (realpath(_dir, buffer) == nullptr)
                    return GW::GReturn::FAILURE;

                //Ensure the directory exists.
                struct stat s;
                if (stat(buffer, &s) != 0)
                    return GW::GReturn::FILE_NOT_FOUND;

                //Assign the passed in directory to our internal directory storage.
                currDir = buffer;
                currDir += DIR_SEPERATOR;

                //If there is an open directory, close it.
                if (currDirStream != nullptr)
                    closedir(currDirStream);

                //Open new directory.
                currDirStream = opendir(currDir.c_str());

                //Check to ensure directory is open.
                if (currDirStream == nullptr)
                    return GW::GReturn::FAILURE;

                return GW::GReturn::SUCCESS;
            };

            GReturn GetCurrentWorkingDirectory(char* _dir, unsigned int _dirSize) override
            {
                //Check for valid arguments.
                if (_dir == nullptr || _dirSize == 0)
                    return GW::GReturn::INVALID_ARGUMENT;

                //Check that a directory is open.
                if (currDirStream == nullptr)
                    return GW::GReturn::FAILURE;

            #if defined(TARGET_OS_IOS) || defined(TARGET_OS_SIMULATOR)
                INTERNAL::strlcpy(_dir, _dirSize, G_TO_UTF8(currDir).c_str());
            #else
                //Copy the current directory to the out parameter.
                INTERNAL::strcpy_s(_dir, _dirSize, G_TO_UTF8(currDir).c_str());
            #endif

                return GW::GReturn::SUCCESS;
            };

            GReturn GetDirectorySize(unsigned int& _outSize) override
            {
                //Check that there is a current working directory.
                if (currDirStream == nullptr)
                    return GW::GReturn::FAILURE;

                struct dirent* file;
                //Set the directory iterator back to the beginning.
                rewinddir(currDirStream);

                //Reset the dir size.
                _outSize = 0;

                //Get the number of files in directory.
                while ((file = readdir(currDirStream)))
                {
                    if (file->d_type == DT_REG)
                        ++_outSize;
                }

                //Set the directory iterator back to the beginning.
                rewinddir(currDirStream);

                return GW::GReturn::SUCCESS;
            };

            GReturn GetSubDirectorySize(unsigned int& _outSize) override
            {
                //Check that there is a current working directory.
                if (currDirStream == nullptr)
                    return GW::GReturn::FAILURE;

                struct dirent* subDir;
                //Set the directory iterator back to the beginning.
                rewinddir(currDirStream);

                //Reset the sub-dir size.
                _outSize = 0;

                while ((subDir = readdir(currDirStream)))
                {
                    if (strcmp(subDir->d_name, ".\0") == 0 ||
                        strcmp(subDir->d_name, "..\0") == 0)
                        continue;

                    if (subDir->d_type == DT_DIR)
                        ++_outSize;
                }

                //Set the directory iterator back to the beginning.
                rewinddir(currDirStream);

                return GW::GReturn::SUCCESS;
            };

            GReturn GetFilesFromDirectory(char* _outFiles[], unsigned int _numFiles, unsigned int _fileNameSize) override
            {
                //Check that there is a current working directory.
                if (currDirStream == nullptr)
                    return GW::GReturn::FAILURE;

                //Set the directory iterator back to the beginning.
                rewinddir(currDirStream);

                struct dirent* file;
                unsigned int fileIndex = 0;

                while ((file = readdir(currDirStream)) && fileIndex < _numFiles)
                {
                    if (file->d_type == DT_REG)
                    {
                        string fileName(file->d_name);

            #if defined(TARGET_OS_IOS) || defined(TARGET_OS_SIMULATOR)
                        INTERNAL::strlcpy(_outFiles[fileIndex], _fileNameSize, G_TO_UTF8(fileName).c_str());
            #else
                        INTERNAL::strcpy_s(_outFiles[fileIndex], _fileNameSize, G_TO_UTF8(fileName).c_str());
            #endif

                        ++fileIndex;
                    }
                    else
                        continue;
                }

                //Set the directory iterator back to the beginning.
                rewinddir(currDirStream);

                return GW::GReturn::SUCCESS;
            };

            GReturn GetFoldersFromDirectory(unsigned int _numsubDir, unsigned int _subDirNameSize, char* _outsubDir[]) override
            {
                //Check that there is a current working directory.
                if (currDirStream == nullptr)
                    return GW::GReturn::FAILURE;

                //Set the directory iterator back to the beginning.
                rewinddir(currDirStream);

                struct dirent* subDir;
                unsigned int subDirIndex = 0;

                while ((subDir = readdir(currDirStream)) && subDirIndex < _numsubDir)
                {

                    if (strcmp(subDir->d_name, ".\0") == 0 ||
                        strcmp(subDir->d_name, "..\0") == 0)
                        continue;

                    if (subDir->d_type == DT_DIR)
                    {
                        string subDirName(subDir->d_name);

            #if defined(TARGET_OS_IOS) || defined(TARGET_OS_SIMULATOR)
                        INTERNAL::strlcpy(_outsubDir[subDirIndex], _subDirNameSize, G_TO_UTF8(subDirName).c_str());
            #else
                        INTERNAL::strcpy_s(_outsubDir[subDirIndex], _subDirNameSize, G_TO_UTF8(subDirName).c_str());
            #endif

                        ++subDirIndex;
                    }
                    else
                        continue;
                }

                //Set the directory iterator back to the beginning.
                rewinddir(currDirStream);

                return GW::GReturn::SUCCESS;
            };

            GReturn GetFileSize(const char* const _file, unsigned int& _outSize) override
            {
                //Make a full path to the file.
                string filePath = currDir;
                filePath += G_TO_UTF16(_file);

                struct stat s;
                if (stat(filePath.c_str(), &s) != 0)
                    return GW::GReturn::FILE_NOT_FOUND;

                //Copy the file size to the out parameter.
                _outSize = (unsigned int)s.st_size;

                return GW::GReturn::SUCCESS;
            };

            GReturn Seek(unsigned int _seekFrom, int _amount, unsigned int& _outCurrPos) override {
                // if text file
                if (file.is_open()) {
                    // if not seeking from the current position
                    if (_seekFrom != -1) {
                        // check for invalid arguments
                        // lock
                        lock.lock();
                        if (0 <= _seekFrom + _amount && _seekFrom + _amount < fileSize) {
                            // seek to the new position relative to _seekFrom
                            std::streamoff offset = static_cast<unsigned long long>(_seekFrom) + static_cast<long long>(_amount);
                            file.seekg(offset, std::ios_base::beg);
                            
                            // set the output to the new current position
                            _outCurrPos = static_cast<unsigned int>(file.tellg());

                            // unlock
                            lock.unlock();

                            return GReturn::SUCCESS;
                        }
                        else {
                            // unlock
                            lock.unlock();
                            return GReturn::INVALID_ARGUMENT;
                        }
                    }
                    else { // seeking from the current position
                        // check for invalid arguments
                        // lock
                        lock.lock();

                        unsigned int pos = static_cast<unsigned int>(file.tellg());
                        if (0 <= pos + _amount && pos + _amount < fileSize) {
                            // seek to the new position relative to the current position
                            file.seekg(_amount, std::ios_base::cur);

                            // set the output to the new current position
                            _outCurrPos = static_cast<unsigned int>(file.tellg());

                            // unlock
                            lock.unlock();

                            return GReturn::SUCCESS;
                        }
                        else {
                            // unlock
                            lock.unlock();
                            return GReturn::INVALID_ARGUMENT;
                        }
                    }
                    
                }
                // if binary file
                else if (binaryFile != NULL) {
                    // check where we seek from
                    if (_seekFrom != -1) {
                        // check for invalid arguments.
                        // lock
                        lock.lock();
                        if (0 <= _seekFrom + _amount && _seekFrom + _amount < fileSize) {
                            // seek to the new position relative to _seekFrom
                            fseek(binaryFile, static_cast<unsigned long>(_seekFrom) + static_cast<long>(_amount), SEEK_SET);

                            // set the output to the new current position
                            fpos_t pos;
                            fgetpos(binaryFile, &pos);
                            _outCurrPos = static_cast<unsigned int>(pos);

                            // unlock
                            lock.unlock();

                            return GReturn::SUCCESS;
                        }
                        else {
                            // unlock
                            lock.unlock();
                            return GReturn::INVALID_ARGUMENT;
                        }
                    }
                    else { // seek from the current position
                        // check for invalid arguments
                        // lock
                        lock.lock();
                        fpos_t pos;
                        fgetpos(binaryFile, &pos);
                        if (0 <= static_cast<unsigned int>(pos) + _amount && static_cast<unsigned int>(pos) + _amount < fileSize) {
                            // seek to the new position relative to the current position
                            fseek(binaryFile, _amount, SEEK_CUR);

                            // set the output to the new current position
                            fgetpos(binaryFile, &pos);
                            _outCurrPos = static_cast<unsigned int>(pos);

                            // unlock
                            lock.unlock();

                            return GReturn::SUCCESS;
                        }
                        else {
                            // unlock
                            lock.unlock();
                            return GReturn::INVALID_ARGUMENT;
                        }
                    }
                }
                else return GReturn::FILE_NOT_FOUND;
            };

            GReturn Init()  //The init function for this class in order to initialize variables.
            {
                //Set the current working directory to the directory the program was ran from.
            #if TARGET_OS_IOS || TARGET_OS_SIMULATOR
                string tempDir = getenv("HOME");
                tempDir += "/Library";
                GW::GReturn rv = SetCurrentWorkingDirectory(tempDir.c_str());
                if (G_FAIL(rv))
                    return rv;
            #else
                GW::GReturn rv = SetCurrentWorkingDirectory("./");
                if (G_FAIL(rv))
                    return rv;
            #endif

                return GW::GReturn::SUCCESS;
            };
            
            GReturn Create()
            {
                if (G_FAIL(this->Init()))
                {
                    return GW::GReturn::FAILURE;
                }
                GetCurrentWorkingDirectory(initialDir, 250);
                return GW::GReturn::SUCCESS;
            };
        };
    }//end namespace I
}//end namespace GW

#undef DIR_SEPERATOR


#elif defined(__linux__)
	#include <fstream>  //file streams
#include <string>  //strings
#include <atomic>  //atomic variables
#include <mutex>  //mutex locks
#include <stdio.h>


#include <sys/stat.h>  //File stats.
#include <string.h>
#include <cstring>

#ifndef DIR_SEPERATOR
#define DIR_SEPERATOR '/'
#endif




namespace GW
{
	namespace I
	{
		class GFileImplementation : public virtual GW::I::GFileInterface,
			protected GThreadSharedImplementation
		{
		private:
			DIR* currDirStream;  //Maintains the current directory.
			std::fstream file;  //Maintains the current file (if one is open).
			FILE* binaryFile = NULL; //for binary read and write
			std::string currDir;  //A cached directory path for faster fetching.
            char initialDir[250];
			std::atomic<unsigned int> mode; //Used to track what open mode the file is in
			std::mutex lock; //Read/Write lock.
			unsigned int fileSize = 0;

		public:
			GFileImplementation()
			{
				currDirStream = nullptr;
			}
			
			~GFileImplementation()
			{
				SetCurrentWorkingDirectory(initialDir);
				//Close the current directory.
				closedir(currDirStream);
				//Close the file stream.
				CloseFile();
			}
			
			GReturn Create()
			{
				//Set the current working directory to the directory the program was ran from.
		#if TARGET_OS_IOS || TARGET_OS_SIMULATOR
			std::string tempDir = getenv("HOME");
			tempDir += "/Library";
			GReturn rv = SetCurrentWorkingDirectory(tempDir.c_str());
			if (G_FAIL(rv))
				return rv;
		#else
			GReturn rv = SetCurrentWorkingDirectory("./");
			if (G_FAIL(rv))
				return rv;
		#endif
			
			GetCurrentWorkingDirectory(initialDir, 250);
			return GReturn::SUCCESS;
			}

			GReturn OpenBinaryRead(const char* const _file) override
			{
				//Check for invalid arguments.
				if (_file == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//Ensure a file is not already open.
				if (file.is_open())
					return GReturn::FAILURE;

				//Open the new file in the currentWorkingDirectory.
				file.open(currDir + G_TO_UTF16(_file), std::ios::in | std::ios::binary);
				
				//If the file failed to open the function fails.
				if (!file.is_open())
					return GReturn::FILE_NOT_FOUND;

				//Set mode to read
				mode = std::ios::in;
				
				// get the file size
				GetFileSize(_file, fileSize);
				
				return GReturn::SUCCESS;
			}

			GReturn OpenBinaryWrite(const char* const _file) override
			{
				//Check for invalid arguments.
				if (_file == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//If the file is currently open we fail.
				if (file.is_open())
					return GReturn::FAILURE;

				//Open the new file.
				file.open(currDir + G_TO_UTF16(_file), std::ios::out | std::ios::binary);
				
				//If file failed to open we fail.
				if (!file.is_open())
					return GReturn::FILE_NOT_FOUND;

				//Set mode to write
				mode = std::ios::out;
				
				// get the file size
				GetFileSize(_file, fileSize);
				
				return GReturn::SUCCESS;
			}

			GReturn AppendBinaryWrite(const char* const _file) override
			{
				//Check for invalid arguments.
				if (_file == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//Close the current file if there is one.
				if (file.is_open())
					return GReturn::FAILURE;

				//Open the new file.
				file.open(currDir + G_TO_UTF16(_file), std::ios::out | std::ios::binary | std::ios::app | std::ios::ate);
				
				//If file failed to open we fail.
				if (!file.is_open())
					return GReturn::FILE_NOT_FOUND;

				//Set mode to write
				mode = std::ios::out;
				
				// get the file size
				GetFileSize(_file, fileSize);
				
				return GReturn::SUCCESS;
			}

			GReturn OpenTextRead(const char* const _file) override
			{
				//Check for invalid arguments.
				if (_file == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//Close the current file if there is one.
				if (file.is_open())
					return GReturn::FAILURE;

				//Open the new file.
				file.open(currDir + G_TO_UTF16(_file), std::ios::in);
				
				if (!file.is_open())
					return GReturn::FILE_NOT_FOUND;

				//Set mode to read
				mode = std::ios::in;
				
				// get the file size
				GetFileSize(_file, fileSize);
				
				return GReturn::SUCCESS;
			}

			GReturn OpenTextWrite(const char* const _file) override
			{
				//Check for invalid arguments.
				if (_file == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//Close the current file if there is one.
				if (file.is_open())
					return GReturn::FAILURE;

				//Open the new file.
				file.open(currDir + G_TO_UTF16(_file), std::ios::out);
				
				if (!file.is_open())
					return GReturn::FILE_NOT_FOUND;

				//Set mode to write
				mode = std::ios::out;
				
				// get the file size
				GetFileSize(_file, fileSize);
				
				return GReturn::SUCCESS;
			}

			GReturn AppendTextWrite(const char* const _file) override
			{
				//Check for invalid arguments.
				if (_file == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//Close the current file if there is one.
				if (file.is_open())
					return GReturn::FAILURE;

				//Open the new file.
				file.open(currDir + G_TO_UTF16(_file), std::ios::out | std::ios::app | std::ios::ate);
				
				if (!file.is_open())
					return GReturn::FILE_NOT_FOUND;

				//Set mode to write
				mode = std::ios::out;
				
				// get the file size
				GetFileSize(_file, fileSize);
				
				return GReturn::SUCCESS;
			}

			GReturn Write(const char* const _inData, unsigned int _numBytes) override
			{
				//Check for invalid arguments.
				if (_inData == nullptr || _numBytes == 0)
					return GReturn::INVALID_ARGUMENT;

				//Ensure a file is open.
				if (!file.is_open() && binaryFile == NULL)
					return GReturn::FAILURE;

				//Make sure the file is opened for writing
				if (mode != std::ios::out)
					return GReturn::FAILURE;

				//Lock the write operations.
				lock.lock();
				
				file.write(_inData, _numBytes);
				
				// update the file size
				fileSize += _numBytes;
				
				lock.unlock();
				return GReturn::SUCCESS;
			}

			GReturn Read(char* _outData, unsigned int _numBytes) override
			{
				if (_numBytes == 0)
					return GReturn::INVALID_ARGUMENT;

				//Ensure a file is open.
				if (!file.is_open() && binaryFile == NULL)
				{
					_outData = nullptr;
					return GReturn::FAILURE;
				}

				//Make sure the file is opened for reading
				if (mode != std::ios::in)
					return GReturn::FAILURE;

				//Lock the read operations.
				lock.lock();
				file.read(_outData, _numBytes);
				lock.unlock();
				return GReturn::SUCCESS;
			}

			GReturn WriteLine(const char* const _inData) override
			{
				//Check for invalid arguments.
				if (_inData == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//Ensure a file is open.
				if (!file.is_open())
					return GReturn::FAILURE;

				//Make sure the file is opened for writing
				if (mode != std::ios::out)
					return GReturn::FAILURE;

				//Transfer the data to a string. #defines make it so the
				//string is what we need it to be on any system we support.
				std::string writeOutString = G_TO_UTF16(_inData);

				//Lock the write operations.
				lock.lock();
				
				file << writeOutString;
				
				// update the file size
				fileSize += static_cast<unsigned int>(writeOutString.length());
				
				lock.unlock();
				return GReturn::SUCCESS;
			}

			GReturn ReadLine(char* _outData, unsigned int _outDataSize, char _delimiter) override
			{
				if (_outData == nullptr || _outDataSize == 0)
					return GReturn::INVALID_ARGUMENT;

				//Ensure file is open.
				if (!file.is_open())
					return GReturn::FAILURE;

				//Make sure the file is opened for reading
				if (mode != std::ios::in)
					return GReturn::FAILURE;

				//The string to be read into.
				std::string outString;

				//Lock the read operations.
				lock.lock();
				
				//Just read in data normally.
				std::getline(file, outString, _delimiter);
				
				//Copy the data over to the out parameter.
				INTERNAL::strcpy_s(_outData, _outDataSize, G_TO_UTF8(outString).c_str());
				
				lock.unlock();
				
				return GReturn::SUCCESS;
			}

			GReturn CloseFile() override
			{
				//If a file is not open, we can not close it.
				if (!file.is_open() && binaryFile == NULL)
					return GReturn::FAILURE;

				if (binaryFile != NULL)
				{
					fflush(binaryFile);
					fclose(binaryFile);
					binaryFile = nullptr;
				}
				else
				{
					//Flush the file.
					file.flush();
					//Close the file.
					file.close();
				}
				
				// update the file size
				fileSize = 0;
				
				return GReturn::SUCCESS;
			}

			GReturn FlushFile() override
			{
				//If a file is not open we can not flush it.
				if (!file.is_open() && binaryFile == NULL)
					return GReturn::FAILURE;

				if (binaryFile != NULL)
				{
					fflush(binaryFile);
				}
				else
				{
					//flush the file.
					file.flush();
				}
				return GReturn::SUCCESS;
			}

			GReturn SetCurrentWorkingDirectory(const char* const _dir) override
			{
				//Check for valid arguments.
				if (_dir == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//Get the absolute path.
				char buffer[PATH_MAX];
				if (realpath(_dir, buffer) == nullptr)
					return GReturn::FAILURE;

				//Ensure the directory exists.
				struct stat s;
				if (stat(buffer, &s) != 0)
					return GReturn::FILE_NOT_FOUND;

				//Assign the passed in directory to our internal directory storage.
				currDir = buffer;
				currDir += DIR_SEPERATOR;

				//If there is an open directory, close it.
				if (currDirStream != nullptr)
					closedir(currDirStream);

				//Open new directory.
				currDirStream = opendir(currDir.c_str());

				//Check to ensure directory is open.
				if (currDirStream == nullptr)
					return GReturn::FAILURE;

				return GReturn::SUCCESS;
			}

			GReturn GetCurrentWorkingDirectory(char* _dir, unsigned int _dirSize) override
			{
				//Check for valid arguments.
				if (_dir == nullptr || _dirSize == 0)
					return GReturn::INVALID_ARGUMENT;

				//Check that a directory is open.
				if (currDirStream == nullptr)
					return GReturn::FAILURE;

				INTERNAL::strcpy_s(_dir, _dirSize, G_TO_UTF8(currDir).c_str());
				return GReturn::SUCCESS;
			}

			GReturn GetDirectorySize(unsigned int& _outSize) override
			{
				//Check that there is a current working directory.
				if (currDirStream == nullptr)
					return GReturn::FAILURE;

				struct dirent* file;
				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);

				//Reset the dir size.
				_outSize = 0;

				//Get the number of files in directory.
				while ((file = readdir(currDirStream)))
				{
					if (file->d_type == DT_REG)
						++_outSize;
				}

				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);
				
				return GReturn::SUCCESS;
			}

			GReturn GetSubDirectorySize(unsigned int& _outSize) override
			{
				//Check that there is a current working directory.
				if (currDirStream == nullptr)
					return GReturn::FAILURE;

				struct dirent* subDir;
				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);

				//Reset the sub-dir size.
				_outSize = 0;

				while ((subDir = readdir(currDirStream)))
				{
					if (strcmp(subDir->d_name, ".\0") == 0 ||
						strcmp(subDir->d_name, "..\0") == 0)
						continue;

					if (subDir->d_type == DT_DIR)
						++_outSize;
				}

				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);
				return GReturn::SUCCESS;
			}

			GReturn GetFilesFromDirectory(char* _outFiles[], unsigned int _numFiles, unsigned int _fileNameSize) override
			{
				//Check that there is a current working directory.
				if (currDirStream == nullptr)
					return GW::GReturn::FAILURE;
				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);

				struct dirent* file;
				unsigned int fileIndex = 0;
				while ((file = readdir(currDirStream)) && fileIndex < _numFiles)
				{
					if (file->d_type == DT_REG)
					{
						std::string fileName(file->d_name);
						INTERNAL::strcpy_s(_outFiles[fileIndex], _fileNameSize, G_TO_UTF8(fileName).c_str());
						++fileIndex;
					}
					else
						continue;
				}

				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);
				return GReturn::SUCCESS;
			}

			GReturn GetFoldersFromDirectory(unsigned int _numsubDir, unsigned int _subDirNameSize, char* _outsubDir[]) override
			{
				//Check that there is a current working directory.
				if (currDirStream == nullptr)
					return GReturn::FAILURE;
					
				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);

				struct dirent* subDir;
				unsigned int subDirIndex = 0;
				
				while ((subDir = readdir(currDirStream)) && subDirIndex < _numsubDir)
				{

					if (strcmp(subDir->d_name, ".\0") == 0 ||
						strcmp(subDir->d_name, "..\0") == 0)
						continue;

					if (subDir->d_type == DT_DIR)
					{
						std::string subDirName(subDir->d_name);
						INTERNAL::strcpy_s(_outsubDir[subDirIndex], _subDirNameSize, G_TO_UTF8(subDirName).c_str());
						++subDirIndex;
					}
					else
						continue;
				}

				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);
				return GReturn::SUCCESS;
			}

			GReturn GetFileSize(const char* const _file, unsigned int& _outSize) override
			{
				//Make a full path to the file.
				std::string filePath = currDir;
				filePath += G_TO_UTF16(_file);

				struct stat s;
				if (stat(filePath.c_str(), &s) != 0)
					return GReturn::FILE_NOT_FOUND;

				//Copy the file size to the out parameter.
				_outSize = (unsigned int)s.st_size;

				return GReturn::SUCCESS;
			}

			GReturn Seek(unsigned int _seekFrom, int _amount, unsigned int& _outCurrPos) override {
				// if text file
				if (file.is_open()) {
					// if not seeking from the current position
					if (_seekFrom != -1) {
						// check for invalid arguments
						// lock
						lock.lock();
						if (0 <= _seekFrom + _amount && _seekFrom + _amount < fileSize) {
							// seek to the new position relative to _seekFrom
							std::streamoff offset = static_cast<unsigned long long>(_seekFrom) + static_cast<long long>(_amount);
							file.seekg(offset, std::ios_base::beg);
							
							// set the output to the new current position
							_outCurrPos = static_cast<unsigned int>(file.tellg());

							// unlock
							lock.unlock();

							return GReturn::SUCCESS;
						} 
						else {
							// unlock
							lock.unlock();
							return GReturn::INVALID_ARGUMENT;
						}
					}
					else { // seeking from the current position
						// check for invalid arguments
						// lock
						lock.lock();

						unsigned int pos = static_cast<unsigned int>(file.tellg());
						if (0 <= pos + _amount && pos + _amount < fileSize) {
							// seek to the new position relative to the current position
							file.seekg(_amount, std::ios_base::cur);

							// set the output to the new current position
							_outCurrPos = static_cast<unsigned int>(file.tellg());

							// unlock
							lock.unlock();

							return GReturn::SUCCESS;
						} 
						else {
							// unlock
							lock.unlock();
							return GReturn::INVALID_ARGUMENT;
						}
					}
					
				} 
				// if binary file
				else if (binaryFile != NULL) {
					// check where we seek from
					if (_seekFrom != -1) {
						// check for invalid arguments
						// lock
						lock.lock();
						if (0 <= _seekFrom + _amount && _seekFrom + _amount < fileSize) {
							// seek to the new position relative to _seekFrom
							fseek(binaryFile, static_cast<unsigned long>(_seekFrom) + static_cast<long>(_amount), SEEK_SET);

							// set the output to the new current position
							fpos_t pos;
							fgetpos(binaryFile, &pos);
							_outCurrPos = static_cast<unsigned int>(pos.__pos);

							// unlock
							lock.unlock();

							return GReturn::SUCCESS;
						} 
						else {
							// unlock
							lock.unlock();
							return GReturn::INVALID_ARGUMENT;
						}
					} 
					else { // seek from the current position
						// check for invalid arguments
						// lock
						lock.lock();
						fpos_t pos;
						fgetpos(binaryFile, &pos);
						if (0 <= static_cast<unsigned int>(pos.__pos) + _amount && static_cast<unsigned int>(pos.__pos) + _amount < fileSize) {
							// seek to the new position relative to the current position
							fseek(binaryFile, _amount, SEEK_CUR);

							// set the output to the new current position
							fgetpos(binaryFile, &pos);
							_outCurrPos = static_cast<unsigned int>(pos.__pos);

							// unlock
							lock.unlock();

							return GReturn::SUCCESS;
						} 
						else {
							// unlock
							lock.unlock();
							return GReturn::INVALID_ARGUMENT;
						}
					}
				} 
				else return GReturn::FILE_NOT_FOUND;
			}
		};
	}//end namespace I
}//end namespace GW

#undef DIR_SEPERATOR


#elif defined(_WIN32)
	#include <fstream>  //file streams
#include <string>  //strings
#include <atomic>  //atomic variables
#include <mutex>  //mutex locks
#include <stdio.h>

#include <io.h>  //Included for mode change.
#include <fcntl.h>  //Included for mode change.



#ifndef DIR
#define DIR _WDIR
#endif
#ifndef dirent
#define dirent _wdirent
#endif
#ifndef fstream
#define fstream wfstream
#endif
#ifndef string
#define string wstring
#endif

#ifndef opendir
#define opendir _wopendir
#endif
#ifndef readdir
#define readdir _wreaddir
#endif
#ifndef closedir
#define closedir _wclosedir
#endif
#ifndef rewinddir
#define rewinddir _wrewinddir
#endif

#ifndef DIR_SEPERATOR
#define DIR_SEPERATOR L'\\'
#endif

namespace GW
{
	namespace I
	{
		class GFileImplementation : public virtual GW::I::GFileInterface,
			protected GThreadSharedImplementation
		{
		private:
			DIR* currDirStream;  //Maintains the current directory.
			std::fstream file;  //Maintains the current file (if one is open).
			FILE* binaryFile = NULL; //for binary read and write
			char initialDir[250] = "";
			errno_t err;// for checking file opened in secure way

			unsigned int fileSize = 0;

			std::string currDir;  //A cached directory path for faster fetching.

			std::atomic<unsigned int> mode; //Used to track what open mode the file is in
			std::mutex lock; //Read/Write lock.
		public:
			GFileImplementation()
			{
				err = 0;
				currDirStream = nullptr;
			}
			~GFileImplementation()
			{
				SetCurrentWorkingDirectory(initialDir);
				//Close the current directory.
				closedir(currDirStream);
				//Close the file stream.
				CloseFile();
			}

			GReturn Create()
			{
				//Set the current working directory to the directory the program was ran from.
				GReturn rv = SetCurrentWorkingDirectory("./");
				if (G_FAIL(rv))
					return rv;

				GetCurrentWorkingDirectory(initialDir, 250);

				//Create a UTF8 Locale to imbue the fstream with.
				std::locale utf8Locale(std::locale(), new std::codecvt_utf8<wchar_t>);

				//Imbue the fstream.
				utf8Locale = file.imbue(utf8Locale);

				return GReturn::SUCCESS;
			}

			GReturn OpenBinaryRead(const char* const _file) override
			{
				//Check for invalid arguments.
				if (_file == nullptr)
					return GReturn::INVALID_ARGUMENT;

				char tempDir[260];
				strcpy_s(tempDir, INTERNAL::G_TO_UTF8(currDir).c_str());
				strcat_s(tempDir, _file);

				//using fopen_s to securely open the file in binary reading mode
				if ((err = fopen_s(&binaryFile, tempDir, "rb")) != 0)
				{
					if (err == 2)
						return GReturn::FILE_NOT_FOUND;
					else
						return GReturn::FAILURE;
				}

				//Set mode to read
				mode = std::ios::in;

				// get the file size
				GetFileSize(_file, fileSize);

				return GReturn::SUCCESS;
			}

			GReturn OpenBinaryWrite(const char* const _file) override
			{
				//Check for invalid arguments.
				if (_file == nullptr)
					return GReturn::INVALID_ARGUMENT;

				char tempDir[260];
				strcpy_s(tempDir, INTERNAL::G_TO_UTF8(currDir).c_str());
				strcat_s(tempDir, _file);

				//using fopen_s to securely open the file in binary writing mode
				if ((err = fopen_s(&binaryFile, tempDir, "wb")) != 0)
				{
					if (err == 2)
						return GReturn::FILE_NOT_FOUND;
					else
						return GReturn::FAILURE;
				}

				//Set mode to write
				mode = std::ios::out;

				// get the file size
				GetFileSize(_file, fileSize);

				return GReturn::SUCCESS;
			}

			GReturn AppendBinaryWrite(const char* const _file) override
			{
				//Check for invalid arguments.
				if (_file == nullptr)
					return GReturn::INVALID_ARGUMENT;

				char tempDir[260];
				strcpy_s(tempDir, INTERNAL::G_TO_UTF8(currDir).c_str());
				strcat_s(tempDir, _file);

				//using fopen_s to securely open the file in binary appending mode
				if ((err = fopen_s(&binaryFile, tempDir, "ab")) != 0)
				{
					if (err == 2)
						return GReturn::FILE_NOT_FOUND;
					else
						return GReturn::FAILURE;
				}

				//Set mode to write
				mode = std::ios::out;

				// get the file size
				GetFileSize(_file, fileSize);

				return GReturn::SUCCESS;
			}

			GReturn OpenTextRead(const char* const _file) override
			{
				//Check for invalid arguments.
				if (_file == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//Close the current file if there is one.
				if (file.is_open())
					return GReturn::FAILURE;

				//Open the new file.
				file.open(currDir + INTERNAL::G_TO_UTF16(_file), std::ios::in);

				if (!file.is_open())
					return GReturn::FILE_NOT_FOUND;

				//Set mode to read
				mode = std::ios::in;

				// get the file size
				GetFileSize(_file, fileSize);

				return GReturn::SUCCESS;
			}

			GReturn OpenTextWrite(const char* const _file) override
			{
				//Check for invalid arguments.
				if (_file == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//Close the current file if there is one.
				if (file.is_open())
					return GReturn::FAILURE;

				//Open the new file.
				file.open(currDir + INTERNAL::G_TO_UTF16(_file), std::ios::out);

				if (!file.is_open())
					return GReturn::FILE_NOT_FOUND;

				//Set mode to write
				mode = std::ios::out;

				// get the file size
				GetFileSize(_file, fileSize);

				return GReturn::SUCCESS;
			}

			GReturn AppendTextWrite(const char* const _file) override
			{
				//Check for invalid arguments.
				if (_file == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//Close the current file if there is one.
				if (file.is_open())
					return GReturn::FAILURE;

				//Open the new file.
				file.open(currDir + INTERNAL::G_TO_UTF16(_file), std::ios::out | std::ios::app | std::ios::ate);

				if (!file.is_open())
					return GReturn::FILE_NOT_FOUND;

				//Set mode to write
				mode = std::ios::out;

				// get the file size
				GetFileSize(_file, fileSize);

				return GReturn::SUCCESS;
			}

			GReturn Write(const char* const _inData, unsigned int _numBytes) override
			{
				//Check for invalid arguments.
				if (_inData == nullptr || _numBytes == 0)
					return GReturn::INVALID_ARGUMENT;

				//Ensure a file is open.
				if (!file.is_open() && binaryFile == NULL)
					return GReturn::FAILURE;

				//Make sure the file is opened for writing
				if (mode != std::ios::out)
					return GReturn::FAILURE;

				//Lock the write operations.
				lock.lock();

				//On windows we need to cast the char* to a wchar_t*.
				if (binaryFile)
				{
					fwrite((void*)_inData, sizeof(char), _numBytes, binaryFile);
				}
				else
					file.write((wchar_t*)_inData, _numBytes);

				// update the file size
				fileSize += _numBytes;

				lock.unlock();

				return GReturn::SUCCESS;
			}

			GReturn Read(char* _outData, unsigned int _numBytes) override
			{
				if (_numBytes == 0)
					return GReturn::INVALID_ARGUMENT;

				//Ensure a file is open.
				if (!file.is_open() && binaryFile == NULL)
				{
					_outData = nullptr;
					return GReturn::FAILURE;
				}

				//Make sure the file is opened for reading
				if (mode != std::ios::in)
					return GReturn::FAILURE;

				//Lock the read operations.
				lock.lock();

				if (binaryFile)
				{
					//setting the buffer size(2nd parameter) be as big as reading data size(_numBytes)
					fread_s(_outData, _numBytes, sizeof(char), _numBytes, binaryFile);
				}
				else
				{
					// this is only a problem on win32
					if ((_numBytes % 2) == 1) { // check for odd number of bytes to read because utf-16
						char tmp[2];
						//On Windows we need to cast the _outData char* to a wchar_t*.
						file.read((wchar_t*)_outData, _numBytes - 1); // read 1 less bytes into the buffer directly
						file.read((wchar_t*)tmp, 1); // read the last byte into the tmp
						_outData[_numBytes - 1] = tmp[0]; // assign the last byte
					} else {
						file.read((wchar_t*)_outData, _numBytes);
					}
				}

				lock.unlock();

				return GReturn::SUCCESS;
			}

			GReturn WriteLine(const char* const _inData) override
			{
				//Check for invalid arguments.
				if (_inData == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//Ensure a file is open.
				if (!file.is_open())
					return GReturn::FAILURE;

				//Make sure the file is opened for writing
				if (mode != std::ios::out)
					return GReturn::FAILURE;

				//Transfer the data to a string. #defines make it so the
				//string is what we need it to be on any system we support.
				std::string writeOutString = INTERNAL::G_TO_UTF16(_inData);

				//Lock the write operations.
				lock.lock();

				//Write out the string.
				file << writeOutString;

				// update the file size
				fileSize += static_cast<unsigned int>(writeOutString.length());

				lock.unlock();
				
				return GReturn::SUCCESS;
			}

			GReturn ReadLine(char* _outData, unsigned int _outDataSize, char _delimiter) override
			{
				if (_outData == nullptr || _outDataSize == 0)
					return GReturn::INVALID_ARGUMENT;

				//Ensure file is open.
				if (!file.is_open())
					return GReturn::FAILURE;

				//Make sure the file is opened for reading
				if (mode != std::ios::in)
					return GReturn::FAILURE;

				//The string to be read into.
				std::string outString;

				//Lock the read operations.
				lock.lock();

				//Convert the UTF8 delimeter to UTF16.
				const wchar_t delimiter = *INTERNAL::G_TO_UTF16(_delimiter).c_str();

				//Read the information.
				std::getline(file, outString, delimiter);

				//Copy the data over to the out parameter.
				strncpy_s(_outData, _outDataSize, INTERNAL::G_TO_UTF8(outString).c_str(), _TRUNCATE);

				//Copy the data over to the out parameter.
				strcpy_s(_outData, _outDataSize, INTERNAL::G_TO_UTF8(outString).c_str());

				lock.unlock();

				return GReturn::SUCCESS;
			}

			GReturn CloseFile() override
			{
				//If a file is not open, we can not close it.
				if (!file.is_open() && binaryFile == NULL)
					return GReturn::FAILURE;

				if (binaryFile != NULL)
				{
					fflush(binaryFile);
					fclose(binaryFile);
					binaryFile = nullptr;
				}
				else
				{
					//Flush the file.
					file.flush();
					//Close the file.
					file.close();
				}

				// update the file size
				fileSize = 0;

				return GReturn::SUCCESS;
			}

			GReturn FlushFile() override
			{
				//If a file is not open we can not flush it.
				if (!file.is_open() && binaryFile == NULL)
					return GReturn::FAILURE;

				if (binaryFile != NULL)
					fflush(binaryFile);
				else
				{
					//flush the file.
					file.flush();
				}

				return GReturn::SUCCESS;
			}

			GReturn SetCurrentWorkingDirectory(const char* const _dir) override
			{
				//Check for valid arguments.
				if (_dir == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//Get the absolute path.
				wchar_t buffer[MAX_PATH];
				if (_wfullpath(buffer, INTERNAL::G_TO_UTF16(_dir).c_str(), MAX_PATH) == nullptr)
					return GReturn::FAILURE;

				//Check to make sure the directory exists.
				struct _stat s;
				if (_wstat(buffer, &s) != 0)
					return GReturn::FILE_NOT_FOUND;

				//Assign the passed in directory to our internal directory storage.
				currDir = buffer;
				currDir += DIR_SEPERATOR;

				//If there is an open directory, close it.
				if (currDirStream != nullptr)
					closedir(currDirStream);

				//Open new directory.
				currDirStream = opendir(currDir.c_str());

				//Check to ensure directory is open.
				if (currDirStream == nullptr)
					return GReturn::FAILURE;

				return GReturn::SUCCESS;
			}

			GReturn GetCurrentWorkingDirectory(char* _dir, unsigned int _dirSize) override
			{
				//Check for valid arguments.
				if (_dir == nullptr || _dirSize == 0)
					return GReturn::INVALID_ARGUMENT;

				//Check that a directory is open.
				if (currDirStream == nullptr)
					return GReturn::FAILURE;

				//Copy the current directory to the out parameter.
				strcpy_s(_dir, _dirSize, INTERNAL::G_TO_UTF8(currDir).c_str());
				return GReturn::SUCCESS;
			}

			GReturn GetDirectorySize(unsigned int& _outSize) override
			{
				//Check that there is a current working directory.
				if (currDirStream == nullptr)
					return GReturn::FAILURE;

				struct dirent* currFile;
				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);

				//Reset the dir size.
				_outSize = 0;

				// In Windows platform when rewinddir is called, the first 2 dir will be . and ..
				// We can simply skip them
				currFile = readdir(currDirStream);
				if (currFile == nullptr)
					return GReturn::FAILURE;
				currFile = readdir(currDirStream);
				if (currFile == nullptr)
					return GReturn::FAILURE;

				//Get the number of files in directory.
				while ((currFile = readdir(currDirStream)))
				{
					if (currFile->d_type == DT_REG)
						++_outSize;
				}

				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);

				return GReturn::SUCCESS;
			}

			GReturn GetSubDirectorySize(unsigned int& _outSize) override
			{
				//Check that there is a current working directory.
				if (currDirStream == nullptr)
					return GReturn::FAILURE;

				struct dirent* subDir;
				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);

				//Reset the sub-dir size.
				_outSize = 0;

				// In Windows platform when rewinddir is called, the first 2 dir will be . and ..
				// We can simply skip them
				subDir = readdir(currDirStream);
				if (subDir == nullptr)
					return GReturn::FAILURE;
				subDir = readdir(currDirStream);
				if (subDir == nullptr)
					return GReturn::FAILURE;

				while ((subDir = readdir(currDirStream)))
				{
					if (subDir->d_type == DT_DIR)
						++_outSize;
				}

				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);

				return GReturn::SUCCESS;
			}

			GReturn GetFilesFromDirectory(char* _outFiles[], unsigned int _numFiles, unsigned int _fileNameSize) override
			{
				//Check that there is a current working directory.
				if (currDirStream == nullptr)
					return GReturn::FAILURE;

				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);

				struct dirent* currFile;
				unsigned int fileIndex = 0;

				// In Windows platform when rewinddir is called, the first 2 dir will be . and ..
				// We can simply skip them
				currFile = readdir(currDirStream);
				if (currFile == nullptr)
					return GReturn::FAILURE;
				currFile = readdir(currDirStream);
				if (currFile == nullptr)
					return GReturn::FAILURE;

				while ((currFile = readdir(currDirStream)) && fileIndex < _numFiles)
				{
					if (currFile->d_type == DT_REG)
					{
						std::string fileName(currFile->d_name);
						strcpy_s(_outFiles[fileIndex], _fileNameSize, INTERNAL::G_TO_UTF8(fileName).c_str());
						++fileIndex;
					}
					else
						continue;
				}

				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);

				return GReturn::SUCCESS;
			}

			GReturn GetFoldersFromDirectory(unsigned int _numsubDir, unsigned int _subDirNameSize, char* _outsubDir[])
			{
				//Check that there is a current working directory.
				if (currDirStream == nullptr)
					return GReturn::FAILURE;

				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);

				struct dirent* subDir;
				unsigned int subDirIndex = 0;

				// In Windows platform when rewinddir is called, the first 2 dir will be . and ..
				// We can simply skip them
				subDir = readdir(currDirStream);
				if (subDir == nullptr)
					return GReturn::FAILURE;
				subDir = readdir(currDirStream);
				if (subDir == nullptr)
					return GReturn::FAILURE;

				while ((subDir = readdir(currDirStream)) && subDirIndex < _numsubDir)
				{
					if (subDir->d_type == DT_DIR)
					{
						std::string subDirName(subDir->d_name);
						strcpy_s(_outsubDir[subDirIndex], _subDirNameSize, INTERNAL::G_TO_UTF8(subDirName).c_str());
						++subDirIndex;
					}
					else
						continue;
				}

				//Set the directory iterator back to the beginning.
				rewinddir(currDirStream);
				return GReturn::SUCCESS;
			}

			GReturn GetFileSize(const char* const _file, unsigned int& _outSize) override
			{
				//Make a full path to the file.
				std::string filePath = currDir;
				filePath += INTERNAL::G_TO_UTF16(_file);

				//Other than the UTF8 to UTF16 conversion for the windows calls,
				//this is handled the same for each platform.
				//We call stat() and it fills in the passed in function
				//with the stats of the passed in path.
				struct _stat s;
				if (_wstat(filePath.c_str(), &s) != 0)
					return GReturn::FILE_NOT_FOUND;

				//Copy the file size to the out parameter.
				_outSize = s.st_size;

				return GReturn::SUCCESS;
			}

			GReturn Seek(unsigned int _seekFrom, int _amount, unsigned int& _outCurrPos) override
			{
				// if text file
				if (file.is_open()) {
					// if not seeking from the current position
					if (_seekFrom != -1) {
						// check for invalid arguments
						// lock
						lock.lock();
						if (0 <= _seekFrom + _amount && _seekFrom + _amount < fileSize) {
							// seek to the new position relative to _seekFrom
							std::streamoff offset = static_cast<unsigned long long>(_seekFrom) + static_cast<long long>(_amount);
							file.seekg(offset, std::ios_base::beg);
							
							// set the output to the new current position
							_outCurrPos = static_cast<unsigned int>(file.tellg());

							// unlock
							lock.unlock();

							return GReturn::SUCCESS;
						} 
						else {
							// unlock
							lock.unlock();
							return GReturn::INVALID_ARGUMENT;
						}
					}
					else { // seeking from the current position
						// check for invalid arguments
						// lock
						lock.lock();
						unsigned int pos = static_cast<unsigned int>(file.tellg());
						if (0 <= pos + _amount && pos + _amount < fileSize) {
							// seek to the new position relative to the current position
							file.seekg(_amount, std::ios_base::cur);

							// set the output to the new current position
							_outCurrPos = static_cast<unsigned int>(file.tellg());

							// unlock
							lock.unlock();

							return GReturn::SUCCESS;
						} 
						else {
							// unlock
							lock.unlock();
							return GReturn::INVALID_ARGUMENT;
						}
					}
					
				} 
				// if binary file
				else if (binaryFile != NULL) {
					// check where we seek from
					if (_seekFrom != -1) {
						// check for invalid arguments
						// lock
						lock.lock();
						if (0 <= _seekFrom + _amount && _seekFrom + _amount < fileSize) {
							// seek to the new position relative to _seekFrom
							fseek(binaryFile, static_cast<unsigned long>(_seekFrom) + static_cast<long>(_amount), SEEK_SET);

							// set the output to the new current position
							fpos_t pos;
							fgetpos(binaryFile, &pos);
							_outCurrPos = static_cast<int>(pos);

							// unlock
							lock.unlock();

							return GReturn::SUCCESS;
						} 
						else {
							// unlock
							lock.unlock();
							return GReturn::INVALID_ARGUMENT;
						}
					} 
					else { // seek from the current position
						// check for invalid arguments
						// lock
						lock.lock();

						fpos_t pos;
						fgetpos(binaryFile, &pos);
						if (0 <= static_cast<unsigned int>(pos) + _amount && static_cast<unsigned int>(pos) + _amount < fileSize) {
							// seek to the new position relative to the current position
							fseek(binaryFile, _amount, SEEK_CUR);

							// set the output to the new current position
							fgetpos(binaryFile, &pos);
							_outCurrPos = static_cast<unsigned int>(pos);

							// unlock
							lock.unlock();

							return GReturn::SUCCESS;
						} 
						else {
							// unlock
							lock.unlock();
							return GReturn::INVALID_ARGUMENT;
						}
					}
				} 
				else return GReturn::FILE_NOT_FOUND;
			}

			GReturn LockAsyncRead() const override
			{
				return GThreadSharedImplementation::LockAsyncRead();
			}

			GReturn UnlockAsyncRead() const override
			{
				return GThreadSharedImplementation::UnlockAsyncRead();
			}

			GReturn LockSyncWrite() override
			{
				return GThreadSharedImplementation::LockSyncWrite();
			}

			GReturn UnlockSyncWrite() override
			{
				return GThreadSharedImplementation::UnlockSyncWrite();
			}
		};
	} // end namespace I
} // end namespace GW

#undef DIR_SEPERATOR
#undef DIR
#undef dirent
#undef fstream
#undef string

#undef opendir
#undef readdir
#undef closedir
#undef rewinddir

#endif


namespace GW
{
	namespace SYSTEM
	{
		class GFile final 
			: public I::GProxy<I::GFileInterface, I::GFileImplementation>
		{
			// All Gateware API interfaces contain no variables & are pure virtual.
		public:
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GFile)
			GATEWARE_FUNCTION(OpenBinaryRead)
			GATEWARE_FUNCTION(OpenBinaryWrite)
			GATEWARE_FUNCTION(AppendBinaryWrite)
			GATEWARE_FUNCTION(OpenTextRead)
			GATEWARE_FUNCTION(OpenTextWrite)
			GATEWARE_FUNCTION(AppendTextWrite)
			GATEWARE_FUNCTION(Write)
			GATEWARE_FUNCTION(Read)
			GATEWARE_FUNCTION(WriteLine)
			GATEWARE_FUNCTION(ReadLine)
			GATEWARE_FUNCTION(CloseFile)
			GATEWARE_FUNCTION(FlushFile)
			GATEWARE_FUNCTION(SetCurrentWorkingDirectory)
			GATEWARE_FUNCTION(GetCurrentWorkingDirectory)
			GATEWARE_FUNCTION(GetDirectorySize)
			GATEWARE_FUNCTION(GetSubDirectorySize)
			GATEWARE_FUNCTION(GetFilesFromDirectory)
			GATEWARE_FUNCTION(GetFoldersFromDirectory)
			GATEWARE_FUNCTION(GetFileSize)
			GATEWARE_FUNCTION(Seek)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GFILE_H

/*---------------------------------
|	End of GFile.h
----------------------------------*/


/*---------------------------------
|	Begin of GDaemon.h
----------------------------------*/
#ifndef GDAEMON_H
#define GDAEMON_H




namespace GW
{
	namespace I
	{
		class GDaemonInterface : public virtual GEventGeneratorInterface
		{
		public:
			enum class Events
			{
				OPERATION_COMPLETED,
				OPERATIONS_PAUSED,
				OPERATIONS_RESUMING
			};

			struct EVENT_DATA
			{
				unsigned long long operationCount;
			};

			virtual GReturn Pause(bool _wait, unsigned int _spinUntil) = 0;
			virtual GReturn Resume() = 0;
			virtual GReturn Counter(unsigned long long& _outCounter) const = 0;
		};
	}
};

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GDaemon.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_SYSTEM) || defined(GATEWARE_DISABLE_GDAEMON) || \
    (defined(GATEWARE_ENABLE_SYSTEM) && !defined(GATEWARE_DISABLE_GDAEMON) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	// dummy implementation of GDaemon
namespace GW {
	namespace I {
		class GDaemonImplementation :	public virtual GDaemonInterface,
										public GEventGeneratorImplementation
		{
		public:
			GReturn Create(unsigned int _targetInterval, std::function<void()> _daemonOperation) {
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			GReturn Create(unsigned int _targetInterval, 
				std::function<void()> _daemonOperation, unsigned int _delayOrPause) {
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			GReturn Create(CORE::GLogic _daemonLogic, 
				unsigned int _targetInterval, unsigned int _delayOrPause) {
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			GReturn Pause(bool _wait, unsigned int _spinUntil) override {
				return GReturn::FAILURE;
			}
			GReturn Resume() override {
				return GReturn::FAILURE;
			}
			GReturn Counter(unsigned long long& _outCounter) const override {
				return GReturn::FAILURE;
			}
		};
	} // end CORE
} // end GW

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
	// Link to our internal thread pool
#ifndef GW_INTERNAL_THREADPOOL
#define GW_INTERNAL_THREADPOOL

 // current implementation used for threadpools


// where Gateware keeps it's "invisible" global variables, do not modify outside of Gateware implementations
namespace internal_gw // DEVS: Only allowed on approval, favor static class members if a global is required.
{
	// for variables to be truly global across translation units they must be static WITHIN a function or class.
	// This allows us to avoid using extern and requiring definition in a user translation unit.
	static nbsdx::concurrent::ThreadPool<G_MAX_THREAD_POOL_SIZE>& GatewareThreadPool() // avoids a name colission in other units
	{
		// internally this ThreadPool has been adapted to use std::thread::hardware_concurrency() threads 
		static nbsdx::concurrent::ThreadPool<G_MAX_THREAD_POOL_SIZE> gatewareThreadPool;
		return gatewareThreadPool; // the only one we have, static inside the function ensure it is the same
	}
}
#endif 




#include <vector>
#include <chrono>

// Make the implentation belong to the proper gateware namespace
// We cannot use "using" here as this is an HPP and supports header only deployments
namespace GW {
	namespace I { // Going to switch to using containment for GEventGenerator (safer)
		class GDaemonImplementation : public virtual GDaemonInterface
		{
            // GDaemonImplementation HAS A GEventGenerator.
            // This will be safer than private Inheritance when we need to pass the generator around.
            CORE::GEventGenerator generator;
            // defines what a daemon actually is
			typedef std::tuple<std::chrono::time_point<std::chrono::steady_clock>,
				unsigned long long, CORE::GEventReceiver> Daemon;
			// Global daemon managment variables, intialized below the class
			// responsible for creating and joining/stopping the daemon visitor
			class GDaemonManager {
			public:
				// Used to control access to the internal global daemon resources, must also be global
				CORE::GThreadShared g_daemonAccess;
				// Allows external insertion into the daemon list (prevents blocking)
				std::vector<Daemon> g_insertionStack; // order not critical so we favor cache perf
				// This just exists to allow GEventReceivers to exist
				CORE::GEventGenerator g_daemonNotifier;
				// Used to enable more advanced and careful sleeping in the manager thread
				std::condition_variable g_managerNotifier;
				// launches daemon thread
				GDaemonManager() {
					g_daemonAccess.Create();
					g_daemonNotifier.Create();
					g_daemonVisitor = std::thread(&GDaemonManager::processWaitingDaemons, this);
				}
				// frees daemon thread
				~GDaemonManager() {
					// were done now, this will signal thread to exit
					g_daemonNotifier = nullptr;
					if (g_daemonVisitor.joinable())
					{
						// its time to go... WAKE UP!!!
						g_managerNotifier.notify_one();
						g_daemonVisitor.join();
					}
					g_daemonAccess = nullptr;
				}
			private:
				// Global list of all daemons, traversed by worker thread adding them to the thread pool as needed. 
				std::vector<Daemon> g_daemons; // stores all daemons
				// Global worker thread not part of the main thread pool but responsible for adding to it.
				// Having g_daemonVisitor and GDaemonManager allows for safe termination of the Daemons with the
				// added benefit of being able to debug the end of the system. Without this, daemons would
				// have to be detached and There wouldn't be a guaranteed way to allow the thread to exit 
				// normally at the end of main.
				std::thread g_daemonVisitor;
				// routine that manages the daemon set until the last has finshed (defined below)
				void processWaitingDaemons()
				{
					std::mutex sleeper; // used only for more controlled naps with std::condition_variable 
					// local function to update thread sleep time as needed
					auto updateNextWake = [](const std::chrono::time_point<std::chrono::steady_clock> upnext,
						std::chrono::time_point<std::chrono::steady_clock>& nextwake, bool& allow)
					{
						if (allow) // can only be updated once by the youngest
						{
							// we shorten the sleep time by potential spin time to better ensure launch
							nextwake = upnext - std::chrono::microseconds(G_DAEMON_LAUNCH_THRESHOLD);
							allow = false; // no more changes allowed, stay young
						}
					};
					do // loop until the program ends
					{
						bool allow_adj = true; // has the wake time been adjusted yet? (only allow once per loop)
						// grab the original time at loop start
						std::chrono::time_point<std::chrono::steady_clock> origin = std::chrono::steady_clock::now();
						// by default the next cycle is at "G_THREAD_DEFAULT_SLEEP" from now.
						// however if there are unlaunched items in the list below we sleep till right before the next up. 
						// Var used to record the youngest item that is not going to be launched this cycle.
						std::chrono::time_point<std::chrono::steady_clock> nextwake =
							origin + std::chrono::microseconds(G_THREAD_DEFAULT_SLEEP);
						// lock the daemon array, sort it, traverse it, unlock it.
						if (+g_daemonAccess.LockSyncWrite())
						{
							// transfer any waiting Daemons into the main list. (staging)
							while (g_insertionStack.empty() == false)
							{
								g_daemons.push_back(g_insertionStack.back());
								g_insertionStack.pop_back();
							}
							// once we have inserted any waiting Daemons into the list we unlock to not cause stalls 
							g_daemonAccess.UnlockSyncWrite();

							//num_daemons = g_daemons.size(); // how many do we have now?
							std::sort(g_daemons.begin(), g_daemons.end(), sortWaitingDaemons);
							for (auto i = g_daemons.begin(); i != g_daemons.end(); ) // iteration is contolled inside
							{
								// grab the exact time at loop start
								std::chrono::time_point<std::chrono::steady_clock> exact = std::chrono::steady_clock::now();
								// if the GEventGenerator(GDaemon) is dead remove it from the list. 
								if (std::get<2>(*i) == nullptr)
								{
									i = g_daemons.erase(i); // get rid of this one and move to the next
								}
								// launch any valid daemons who are past time.
								else if (std::get<0>(*i) <= exact)
								{
									// deltaLag describes how far behind the daemon is.
									// numPeriods is how many periods have been missed in that time(deltaLag).
									// So, if this daemon is in the past after 1 period increase, 
									// set it's timer for the period it 'should' be at.
									// (currentTime += numOfMissedPeriods * periodLength)
									// This method is to prevent a "rubber-banding" sort of behavior.
									unsigned long long deltaLag = 
										std::chrono::duration_cast<std::chrono::milliseconds>(exact - std::get<0>(*i)).count();
									unsigned long long numPeriods = deltaLag / std::get<1>(*i);
									if ((std::get<0>(*i) + std::chrono::milliseconds(std::get<1>(*i))) < exact)
										std::get<0>(*i) += std::chrono::milliseconds(numPeriods * std::get<1>(*i));
									// before we launch we set the time to the next time step. (add time)
									std::get<0>(*i) += std::chrono::milliseconds(std::get<1>(*i));
									// update the wake cycle as needed
									updateNextWake(std::get<0>(*i), nextwake, allow_adj);
									// weak handle to GEventReceiver which we will invoke
									auto caller = std::get<2>(*i);
									// add to threadpool, invoke Daemon routine
									internal_gw::GatewareThreadPool().AddJob([caller]() {
										// should be safe and not cause oddness
										caller.Invoke();
									});
									// move to the next item and continue traversal
									++i; // see if anyone else needs to be launched
								}
								else // if we get here we know the current Daemon is in the future
								{
									// how much time till this must launch?
									unsigned long long microleft =
										std::chrono::duration_cast<std::chrono::microseconds>(exact - std::get<0>(*i)).count();
									// if a daemon is less than G_DAEMON_LAUNCH_THRESHOLD microseconds from starting we spinlock.
									if (microleft <= G_DAEMON_LAUNCH_THRESHOLD)
									{
										while (std::chrono::steady_clock::now() < std::get<0>(*i))
											std::this_thread::yield(); // spin lock and restart loop to launch
									}
									else // not time for this one yet, we move on
									{
										// update the wake cycle as needed
										updateNextWake(std::get<0>(*i), nextwake, allow_adj);
										++i;
									}
								}
							}
						}
						// once we exit the loop we have this thread take a short nap.
						// we wait for the default thread sleep time: G_THREAD_DEFAULT_SLEEP (typically 16ms)
						// reduce by the launch threshold so we have a better possibility of launching on time
						// if possible we wait for the next launching time span.
						// If a new daemon is added or a destructor is invoked we will be notified while sleeping.
						// The suprious wakeup will wake the thread no matter what since it is always safe to do so.
						{
							std::unique_lock<std::mutex> locker(sleeper);
							g_managerNotifier.wait_until(locker, nextwake, [&]() { return true; });
							///std::this_thread::sleep_until(nextwake); // how we used to do it
						}
					// The loop ends when g_daemonNotifier is destructed	
					} while (g_daemonNotifier);
				}
			};
			//static GDaemonManager g_daemonManager;
			static GDaemonManager& GetDaemonManager()
			{
				static GDaemonManager g_daemonManager;
				return g_daemonManager;
			}
			static bool sortWaitingDaemons(const GDaemonImplementation::Daemon& _a,
				const GDaemonImplementation::Daemon& _b)
			{
				return std::get<0>(_a) < std::get<0>(_b); // compare time points
			}
			// daemons are sorted by when they must next run in accending order (oldest first)
			
			// * End Globals, start local variables *

			// used to pause execution of this daemon (disabled during Initialization)
			std::atomic_bool paused = { true };
			// flag that controls pauseing and resuming of a daemon
			std::atomic_flag running = ATOMIC_FLAG_INIT;
			// keeps track of the current thread running our daemon to avoid possible deadlock
			std::atomic<std::thread::id> runner; // deafault constructor is a non-thread
			// the amount of time (milliseconds) between execution events
			unsigned int period = 0;
			// tracks the number of complete executions of the daemon
			std::atomic_uint64_t count;
			// caches a copy of the routine to be applied at the interval
			CORE::GEventReceiver daemon;
		public:
			// required for HAS-A relationship
			GReturn Register(CORE::GEventCache _observer) override {
				return generator.Register(_observer);
			}
			GReturn Register(CORE::GEventResponder _observer) override {
				return generator.Register(_observer);
			}
			GReturn Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) override {
				return generator.Register(_observer, _callback);
			}
			GReturn Deregister(CORE::GInterface _observer) override {
				return generator.Deregister(_observer);
			}
			GReturn Observers(unsigned int& _outCount) const override {
				return generator.Observers(_outCount);
			}
			GReturn Push(const GEvent& _newEvent) override {
				return generator.Push(_newEvent);
			}
			// actual implementation functions here
			// alternative create, allows user to start the daemon paused
			GReturn Create(unsigned int _targetInterval, std::function<void()> _daemonOperation, unsigned int _delay)
			{
				if (_targetInterval == 0) // daemons can't run faster than 1000hz
					return GReturn::INVALID_ARGUMENT;
				// If a _delay was supplied we need to unpause this daemon immediately (otherwise start paused)
				if (_delay > 0)
					paused = false; // intialized to true by default (for simplified init reasons)
                // make an internal event generator to implement that functionality
                // this may not be as efficient as private inheritance but allows for
                // safe message sending if the _daemonOperation is used to delete/replace this proxy
                generator.Create();
				period = _targetInterval; // fixed time step between daemon invocations
				count = 0; // nothing has been excecuted yet
				// create daemon here
				daemon.Create(GetDaemonManager().g_daemonNotifier, [&, _daemonOperation]() {
					// This is called wether we are ready or not.
					// Only run code if we are not already running
					if (std::atomic_flag_test_and_set_explicit(&running, std::memory_order_acquire) == false)
					{
						if (paused == false) // only execute when not paused
						{
							GEvent send; // event package
							runner = std::this_thread::get_id(); // avoid deadlocks
                            // this operation could technically erase this class so save a safe handle
                            CORE::GEventGenerator safe = generator;
                            if (_daemonOperation) // these are optional so we need to check
								_daemonOperation(); // we assume this MAY delete "this"
							// increase count, notify listeners and unlock spin if still possible
							CORE::GEventGenerator::burst_w alive = *safe;
							if (alive)
							{	// notify anyone listening we have completed
								unsigned long long c = ++count; // increase & copy count to POD
								send.Write(Events::OPERATION_COMPLETED, c); // send current count
								alive->Push(send); // a daemon run is not done till eveyone has received it
								std::atomic_flag_clear_explicit(&running, std::memory_order_release);
							}
						}
						else // allow execution again
							std::atomic_flag_clear_explicit(&running, std::memory_order_release);
					}
					// done
				});
				// add ourselves to the vector
				// insert our daemon into the global list for processing
				GetDaemonManager().g_daemonAccess.LockSyncWrite();
				// insert relevant data to begin processing
				GetDaemonManager().g_insertionStack.push_back(
					{	std::chrono::steady_clock::now() + std::chrono::milliseconds(_delay),
						static_cast<unsigned long long>(period), daemon });
				GetDaemonManager().g_daemonAccess.UnlockSyncWrite();
				// wakeup the manager thread if it is snoozing
				GetDaemonManager().g_managerNotifier.notify_one();
				// were done here, the daemon processor will takeover.
				return GReturn::SUCCESS;
			}
			// main create, starts the daemon immediately unpaused
			GReturn Create(unsigned int _targetInterval, std::function<void()> _daemonOperation)
			{
				paused = false; // start running right away! (true by default)
				return Create(_targetInterval, _daemonOperation, 0);
			}
			// alternate create, provide swappable logic
			GReturn Create(CORE::GLogic _daemonLogic, unsigned int _targetInterval, unsigned int _delayOrPause)
			{
				if (_daemonLogic == nullptr) return GReturn::INVALID_ARGUMENT;
				return Create(_targetInterval, [_daemonLogic]() { _daemonLogic.Invoke(); }, _delayOrPause);
			}
			GReturn Pause(bool _wait, unsigned int _spinUntil) override
			{
				if (paused == true) // no need to do this twice
					return GReturn::REDUNDANT;
				// inform the external threads to no longer execute our daemon
				paused = true;
				// if _wait == true we use the spin lock technique from GConcurrent
				if (_wait)
				{
					// are we inside the daemon thread?
					if (runner == std::this_thread::get_id())
					{
						paused = false; // didn't work so don't change the behavior
						return GReturn::DEADLOCK; // This would cause a deadlock!
					}
					// waits until "working" is false, sleeping the thread for 1ms each time _spinUntil is reached.
					auto last = std::chrono::steady_clock::now();
					// This operation is lock free, so very optimized for short wait times
					while (std::atomic_flag_test_and_set_explicit(&running, std::memory_order_acquire))
					{	// measures how much time this thread is spin locked
						if (std::chrono::duration_cast<std::chrono::nanoseconds>(
							std::chrono::steady_clock::now() - last).count() >= _spinUntil)
						{
							// if things take longer than our maximum lock time we free the thread and try again later
							std::this_thread::sleep_for(std::chrono::microseconds(G_THREAD_DEFAULT_SLEEP));
							last = std::chrono::steady_clock::now();
						}
					}
					// Once we have converged we release our lock so we can lock again later.
					std::atomic_flag_clear_explicit(&running, std::memory_order_release);
				}
				// notify anyone listening a pause has been requested.
				GEvent send;
				unsigned long long c = count;
				send.Write(Events::OPERATIONS_PAUSED, c);
				Push(send); // let everyone know who cares
				// so far so good
				return GReturn::SUCCESS;
			}
			GReturn Resume() override
			{
				if (paused == false) // no need to do this twice
					return GReturn::REDUNDANT;
				// since we don't wait in this function, checking for deadlocks is not required
				paused = false;
				// notify anyone listening a resume has been requested.
				GEvent send;
				unsigned long long c = count;
				send.Write(Events::OPERATIONS_RESUMING, c);
				Push(send); // let everyone know who cares
				return GReturn::SUCCESS;
			}
			GReturn Counter(unsigned long long& _outCounter) const override
			{
				_outCounter = count; // this can't really fail
				return GReturn::SUCCESS;
			}
			// destructor ensures no waiting jobs exist
			~GDaemonImplementation()
			{
				// wakeup the manager thread if it is snoozing
				GetDaemonManager().g_managerNotifier.notify_one();
				// ensure we do not run any more daemon code
				Pause(true, 0);
			}
		};
	} // end CORE
} // end GW


#endif



namespace GW
{
	namespace SYSTEM
	{
		class GDaemon final
			: public I::GProxy<I::GDaemonInterface, I::GDaemonImplementation, unsigned int, std::function<void()>>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GDaemon)
			GATEWARE_TYPEDEF(Events)
			GATEWARE_TYPEDEF(EVENT_DATA)
			GATEWARE_FUNCTION(Pause)
			GATEWARE_FUNCTION(Resume)
			GATEWARE_CONST_FUNCTION(Counter)
				
			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GDAEMON_H

/*---------------------------------
|	End of GDaemon.h
----------------------------------*/


/*---------------------------------
|	Begin of GConcurrent.h
----------------------------------*/
#ifndef GCONCURRENT_H
#define GCONCURRENT_H




namespace GW
{
	namespace I
	{
		class GConcurrentInterface : public virtual GEventGeneratorInterface
		{
		public:
			enum class Events
			{
				SINGULAR_TASK_COMPLETE,
				PARALLEL_TASK_COMPLETE,
				PARALLEL_SECTION_COMPLETE
			};

			struct EVENT_DATA
			{
				unsigned long long taskSubmissionIndex;
				unsigned long long microsecondsElapsed;
				unsigned int completionRange[2];
			};

			virtual GReturn BranchSingular(std::function<void()> _singleTask) = 0;
			virtual GReturn BranchDynamic(CORE::GLogic _dynamicTask) = 0;
			template<typename Data>
			GReturn BranchParallel(	void(*_parallelTask)(Data&), unsigned int _arraySize, Data* _outDataArray);
			template<typename Input, typename Output>
			GReturn BranchParallel(	void(*_parallelTask)(const Input*,Output*,unsigned int,const void*), unsigned int _maxSection, unsigned int _arraySize, const void* _userData, int _inStride, const Input* _inputArray, int _outStride, Output* _outputArray);
			virtual GReturn Converge(unsigned int _spinUntil) = 0;
		};
	}
};

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GConcurrent.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_SYSTEM) || defined(GATEWARE_DISABLE_GCONCURRENT) || \
    (defined(GATEWARE_ENABLE_SYSTEM) && !defined(GATEWARE_DISABLE_GCONCURRENT) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	// dummy implementation of GConcurrent
namespace GW {
	namespace I {
		class GConcurrentImplementation :	public virtual GConcurrentInterface,
											public GEventGeneratorImplementation
		{
		public:
			// actual dummies for this class
			GReturn Create(bool _nope) { 
				return GReturn::INTERFACE_UNSUPPORTED; 
			}
			GReturn BranchSingular(std::function<void()> _singleTask) override	{ 
				return GReturn::FAILURE;
			}
			GReturn BranchDynamic(CORE::GLogic _dynamicTask) override {
				return GReturn::FAILURE;
			}
			template<typename Data>
			GReturn BranchParallel(void(*_parallelTask)(Data&),
				unsigned int _arraySize, Data* _outDataArray) {
				return GReturn::FAILURE;
			}
			template<typename Input, typename Output>
			GReturn BranchParallel(void(*_parallelTask)(const Input*, Output*, unsigned int, const void*),
				unsigned int _maxSection, unsigned int _arraySize, const void* _userData,
				int _inStride, const Input* _inputArray,
				int _outStride, Output* _outputArray) {
				return GReturn::FAILURE;
			}
			GReturn Converge(unsigned int _spinUntil) override {
				return GReturn::FAILURE;
			}
		};
	} // end CORE
} // end GW

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
	// Link to our internal thread pool
#ifndef GW_INTERNAL_THREADPOOL
#define GW_INTERNAL_THREADPOOL

 // current implementation used for threadpools


// where Gateware keeps it's "invisible" global variables, do not modify outside of Gateware implementations
namespace internal_gw // DEVS: Only allowed on approval, favor static class members if a global is required.
{
	// for variables to be truly global across translation units they must be static WITHIN a function or class.
	// This allows us to avoid using extern and requiring definition in a user translation unit.
	static nbsdx::concurrent::ThreadPool<G_MAX_THREAD_POOL_SIZE>& GatewareThreadPool() // avoids a name colission in other units
	{
		// internally this ThreadPool has been adapted to use std::thread::hardware_concurrency() threads 
		static nbsdx::concurrent::ThreadPool<G_MAX_THREAD_POOL_SIZE> gatewareThreadPool;
		return gatewareThreadPool; // the only one we have, static inside the function ensure it is the same
	}
}
#endif 



// Make the implentation belong to the proper gateware namespace
// We cannot use "using" here as this is an HPP and supports header only deployments
namespace GW {
	namespace I {
		// Just like GEventReceiver except it can store multiple events in a queue so you can delay processing
		class GConcurrentImplementation : public virtual GConcurrentInterface
		{
			bool supressEvents = false;
			std::atomic_uint tasksProcessing;  
			std::atomic_uint64_t taskSubmissionIndex;
			// This is flag is only false when tasksProcessing == 0
			// It is used to efficiently spin-lock during a Converge operation
			std::atomic_flag working = ATOMIC_FLAG_INIT;
			// HAS A relationship allows for safe lifetime access in external threads
			CORE::GEventGenerator generator;
			// this class creates a message when it falls out of scope (uses shared_ptr)
			// solves the issue on how to notify when all parallel threads complete
			struct ScopedEvent {
				EVENT_DATA info = { 0, 0, { 0,1 } };
				CORE::GEventGenerator me; // safe even if proxied object is destructed
				std::chrono::time_point<std::chrono::steady_clock> start;
				~ScopedEvent() {
					GEvent send; // what people are listening for
					auto end = std::chrono::steady_clock::now();
					info.microsecondsElapsed = 
						std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
					if (+send.Write(Events::PARALLEL_TASK_COMPLETE, info))
						me.Push(send); // Notify anyone who is listening the Parrallel Task has completed
				}
			};
			
		public:
			// required for HAS-A relationship
			GReturn Register(CORE::GEventCache _observer) override {
				return generator.Register(_observer);
			}
			GReturn Register(CORE::GEventResponder _observer) override {
				return generator.Register(_observer);
			}
			GReturn Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) override {
				return generator.Register(_observer, _callback);
			}
			GReturn Deregister(CORE::GInterface _observer) override {
				return generator.Deregister(_observer);
			}
			GReturn Observers(unsigned int& _outCount) const override {
				return generator.Observers(_outCount);
			}
			GReturn Push(const GEvent& _newEvent) override {
				return generator.Push(_newEvent);
			}
			// actual implementation starts here
			GReturn Create(bool _supressEvents)
			{
				supressEvents = _supressEvents;
				tasksProcessing = 0;
				taskSubmissionIndex = 0;
				return generator.Create();
			}
			GReturn BranchSingular(std::function<void()> _singleTask) override
			{
				if (_singleTask == nullptr)
					return GReturn::INVALID_ARGUMENT;
				EVENT_DATA einfo = { 0, 0, { 0,1 } };
				std::chrono::time_point<std::chrono::steady_clock> start;
				++tasksProcessing; // as soon as a task is submitted it is considered to be processing
				if (tasksProcessing == 1) // aquire "working" lock until no tasks are processing anymore
					std::atomic_flag_test_and_set_explicit(&working, std::memory_order_acquire);
				// send events to end users?
				if (supressEvents == false)
				{
					start = std::chrono::steady_clock::now();
					einfo.taskSubmissionIndex = ++taskSubmissionIndex;
				}
				// Safe transfer of event supression state.
				bool supress = supressEvents;
				// because "singleTask" below could theoretically invalidate "this" we use a safe handle 
				CORE::GEventGenerator safe = generator;
				// We identify each job from this GConcurrent with our memory address.
				// this helps us avoid deadlock scenarios when using the "Converge" routine.
				unsigned long long jobID = reinterpret_cast<unsigned long long>(this);
				// we need to send by reference due to "tasksProcessing" being a class member.
				// The task itself & a few other items must be copied as they will fall out of scope.
				internal_gw::GatewareThreadPool().AddJob([&, _singleTask, supress, safe,
															einfo, start]() mutable {
					_singleTask(); // execute job while within the thread pool
					// send any event that still must be sent
					if (supress == false)
					{
						GEvent send; // what people are listening for
						auto end = std::chrono::steady_clock::now();
						einfo.microsecondsElapsed =
							std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
						// Notify anyone who is listening
						send.Write(Events::SINGULAR_TASK_COMPLETE, einfo);
						safe.Push(send);
					}
					// increase count, notify listeners and unlock spin if still possible
					CORE::GEventGenerator::burst_w alive = *safe;
					if (alive)
					{
						--tasksProcessing; // tasks are also considered processing until all event responders have completed
						if (tasksProcessing == 0) // disable spinlock
							std::atomic_flag_clear_explicit(&working, std::memory_order_release);
					}
				}, jobID); // so we know who owns this job
				return GReturn::SUCCESS;
			}
			// Due to std::function's argressive constructor we had to give this function a unique name
			GReturn BranchDynamic(CORE::GLogic _dynamicTask) override 
			{
				if (_dynamicTask == nullptr) return GReturn::INVALID_ARGUMENT;
				return BranchSingular([_dynamicTask]() { _dynamicTask.Invoke(); });
			}
			template<typename Input, typename Output>
			GReturn BranchParallel(	void(*_parallelTask)(const Input*, Output*,unsigned int,const void*), 
									unsigned int _maxSection, unsigned int _arraySize, const void* _userData,
									int _inStride, const Input* _inputArray, int _outStride, Output* _outputArray)
			{
				// error check what is possible
				if (_parallelTask == nullptr) return GReturn::INVALID_ARGUMENT;
				if (_maxSection == 0) return GReturn::INVALID_ARGUMENT;
				if (_arraySize == 0) return GReturn::INVALID_ARGUMENT;
				// Input & Output may not be the same array. (if you need this just use Output alone!)
				if ((_inputArray || _outputArray) && 
					reinterpret_cast<std::uintptr_t>(_inputArray) == 
					reinterpret_cast<std::uintptr_t>(_outputArray))
					return GReturn::INVALID_ARGUMENT;
				// set input and output stride if not provided
				if (_inStride == 0) _inStride = sizeof(Input);
				if (_outStride == 0) _outStride = sizeof(Output);
				// check for overlapped memory if it could exist
				if (_inputArray != nullptr && _outputArray != nullptr)
				{
					std::uintptr_t input_start = reinterpret_cast<std::uintptr_t>(_inputArray);
					std::uintptr_t output_start = reinterpret_cast<std::uintptr_t>(_outputArray);
					std::uintptr_t input_end = input_start + static_cast<std::uintptr_t>(_arraySize) * _inStride;
					std::uintptr_t output_end = output_start + static_cast<std::uintptr_t>(_arraySize) * _outStride;
					if (input_start < output_start && input_end > output_start)
						return GReturn::MEMORY_CORRUPTION;
					if (output_start < input_start && output_end > input_start)
						return GReturn::MEMORY_CORRUPTION;
				}
				// Safe transfer of event supression state.
				bool supress = supressEvents;
				// When the shared object falls completely out of scope we know all threads have completed.
				std::shared_ptr<ScopedEvent> waitForDeath;
				// because "parallelTask" below could theoretically invalidate "this" we use a safe handle 
				CORE::GEventGenerator safe = generator;
				// error checks done we compute required jobs and submitt to thread pool.
				EVENT_DATA einfo = { 0, 0, { 0,_arraySize } };
				if (supressEvents == false)
				{
					einfo.taskSubmissionIndex = ++taskSubmissionIndex;
					// allocate a ScopedEvent to handle the last message
					waitForDeath = std::make_shared<ScopedEvent>();
					waitForDeath->info = einfo;
					waitForDeath->start = std::chrono::steady_clock::now();
					waitForDeath->me = generator; // safe even if proxied object is destructed
				}
				// determine total amount of jobs to be sent
				int jobCount = ((_arraySize / _maxSection) + ((_arraySize % _maxSection) ? 1 : 0));
				// loop sending a job for each parallel task
				for (int i = 0; i < jobCount; ++i)
				{
					// as soon as a task is submitted it is considered to be processing
					++tasksProcessing;
					if (tasksProcessing == 1) // aquire "working" lock until no tasks are processing anymore
						std::atomic_flag_test_and_set_explicit(&working, std::memory_order_acquire);
					// include completion event info (fixed for C++11 syntax)
                    einfo.completionRange[0] = i * _maxSection;
                    einfo.completionRange[1] = (i+1) * _maxSection - 1;
					if (einfo.completionRange[1] >= _arraySize)
						einfo.completionRange[1] = _arraySize - 1u;
					// We identify each job from this GConcurrent with our memory address.
					// this helps us avoid deadlock scenarios when using the "Converge" routine.
					unsigned long long jobID = reinterpret_cast<unsigned long long>(this);
					// launch job, copy ScopedEvent so it does not fall out of scope until we are done.
					// The task itself & a few other items must be copied as they will fall out of scope.
					internal_gw::GatewareThreadPool().AddJob([&, _parallelTask, _inStride, _inputArray, 
																_outStride, _outputArray, _userData, 
																einfo, supress, waitForDeath, safe]() mutable {
						// used for timing individual sections to help find performance bottlenecks.
						std::chrono::time_point<std::chrono::steady_clock> start;
						if (supress == false)
							start = std::chrono::steady_clock::now();
						// traverse using byte pointers to account for unique data strides
						const unsigned char* in = reinterpret_cast<const unsigned char*>(_inputArray) + static_cast<uint64_t>(einfo.completionRange[0]) * _inStride;
						unsigned char* out = reinterpret_cast<unsigned char*>(_outputArray) + static_cast<uint64_t>(einfo.completionRange[0]) * _outStride;
						// do the actual work requested
						for (unsigned int j = einfo.completionRange[0]; j <= einfo.completionRange[1]; ++j, in += _inStride, out += _outStride)
						{
							_parallelTask(reinterpret_cast<const Input*>(in),
								reinterpret_cast<Output*>(out), j, _userData);
						}
						// if the user wants to be informed we inform them
						if (supress == false)
						{
							GEvent send; // what people are listening for
							auto end = std::chrono::steady_clock::now();
							einfo.microsecondsElapsed = // *NEW* Include timing data always
								std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
							send.Write(Events::PARALLEL_SECTION_COMPLETE, einfo);
							safe.Push(send); // Notify anyone who is listening
						}
						// manually free "waitForDeath" here so like "BranchSingular" tasksprocessing is inclusive
						// to any event responders who may be reacting to completed events.
						waitForDeath.reset(); // drop this copy (will invoke destructor if this is the last one)
						// increase count, notify listeners and unlock spin if still possible
						CORE::GEventGenerator::burst_w alive = *safe;
						if (alive)
						{
							--tasksProcessing; // tasks are considered processing until all responders have reacted
							if (tasksProcessing == 0) // disable spinlock
								std::atomic_flag_clear_explicit(&working, std::memory_order_release);
						}
					}, jobID); // so we know who owns this job
				}
				return GReturn::SUCCESS;
			}
			// specialization of void input type
			template<typename Output>
			GReturn BranchParallel(void(*_parallelTask)(const void*, Output*, unsigned int, const void*),
				unsigned int _maxSection, unsigned int _arraySize, const void* _userData,
				int _inStride, const void* _inputArray, int _outStride, Output* _outputArray)
			{
				void(*_job)(const size_t*, Output*, unsigned int, const void*) =
					reinterpret_cast<void(*)(const size_t*, Output*, unsigned int, const void*)>(_parallelTask);
				return BranchParallel<size_t, Output>(_job, _maxSection, _arraySize, _userData, _inStride,
					static_cast<const size_t*>(_inputArray), _outStride, _outputArray);
			}
			// specialization of void output type
			template<typename Input>
			GReturn BranchParallel(void(*_parallelTask)(const Input*, void*, unsigned int, const void*),
				unsigned int _maxSection, unsigned int _arraySize, const void* _userData,
				int _inStride, const Input* _inputArray, int _outStride, void* _outputArray)
			{
				void(*_job)(const Input*, size_t*, unsigned int, const void*) =
					reinterpret_cast<void(*)(const Input*, size_t*, unsigned int, const void*)>(_parallelTask);
				return BranchParallel<Input, size_t>(_parallelTask, _maxSection, _arraySize, _userData, _inStride,
					_inputArray, _outStride, static_cast<size_t*>(_outputArray));
			}
			// simplified version
			template<typename Data>
			GReturn BranchParallel(void(*_parallelTask)(Data&), unsigned int _arraySize, Data* _outDataArray) 
			{
				// error check what is possible
				if (_parallelTask == nullptr) return GReturn::INVALID_ARGUMENT;
				if (_arraySize == 0) return GReturn::INVALID_ARGUMENT;
				if (_outDataArray == nullptr) return GReturn::INVALID_ARGUMENT;
				// Safe transfer of event supression state.
				bool supress = supressEvents;
				// When the shared object falls completely out of scope we know all threads have completed.
				std::shared_ptr<ScopedEvent> waitForDeath;
				// because "parallelTask" below could theoretically invalidate "this" we use a safe handle 
				CORE::GEventGenerator safe = generator;
				// error checks done we compute required jobs and submitt to thread pool.
				EVENT_DATA einfo = { 0, 0, { 0,_arraySize } };
				if (supressEvents == false)
				{
					einfo.taskSubmissionIndex = ++taskSubmissionIndex;
					// allocate a ScopedEvent to handle the last message
					waitForDeath = std::make_shared<ScopedEvent>();
					waitForDeath->info = einfo;
					waitForDeath->start = std::chrono::steady_clock::now();
					waitForDeath->me = generator; // safe even if proxied object is destructed
				}
				// determine total amount of jobs to be sent
				int autoSection = (sizeof(Data) * _arraySize) / G_CONCURRENT_AUTO_SECTION;// one thread per Nkb items 
				int jobCount = ((_arraySize / autoSection) + ((_arraySize % autoSection) ? 1 : 0));
				// loop sending a job for each parallel task
				for (int i = 0; i < jobCount; ++i)
				{
					// as soon as a task is submitted it is considered to be processing
					++tasksProcessing;
					if (tasksProcessing == 1) // aquire "working" lock until no tasks are processing anymore
						std::atomic_flag_test_and_set_explicit(&working, std::memory_order_acquire);
					// include completion event info (fixed for C++11 syntax)
					einfo.completionRange[0] = i * autoSection;
					einfo.completionRange[1] = (i + 1) * autoSection - 1;
					if (einfo.completionRange[1] >= _arraySize)
						einfo.completionRange[1] = _arraySize - 1u;
					// We identify each job from this GConcurrent with our memory address.
					// this helps us avoid deadlock scenarios when using the "Converge" routine.
					unsigned long long jobID = reinterpret_cast<unsigned long long>(this);
					// launch job, copy ScopedEvent so it does not fall out of scope until we are done.
					// The task itself & a few other items must be copied as they will fall out of scope.
					internal_gw::GatewareThreadPool().AddJob([&, _parallelTask, _outDataArray,
						einfo, supress, waitForDeath, safe]() mutable {
							// used for timing individual sections to help find performance bottlenecks.
							std::chrono::time_point<std::chrono::steady_clock> start;
							if (supress == false)
								start = std::chrono::steady_clock::now();
							// do the actual work requested
							for (unsigned int j = einfo.completionRange[0]; 
								j <= einfo.completionRange[1]; ++j)
							{
								_parallelTask(_outDataArray[j]);
							}
							// if the user wants to be informed we inform them
							if (supress == false)
							{
								GEvent send; // what people are listening for
								auto end = std::chrono::steady_clock::now();
								einfo.microsecondsElapsed = // *NEW* Include timing data always
									std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
								send.Write(Events::PARALLEL_SECTION_COMPLETE, einfo);
								safe.Push(send); // Notify anyone who is listening
							}
							// manually free "waitForDeath" here so like "BranchSingular" tasksprocessing is inclusive
							// to any event responders who may be reacting to completed events.
							waitForDeath.reset(); // drop this copy (will invoke destructor if this is the last one)
							// increase count, notify listeners and unlock spin if still possible
							CORE::GEventGenerator::burst_w alive = *safe;
							if (alive)
							{
								--tasksProcessing; // tasks are considered processing until all responders have reacted
								if (tasksProcessing == 0) // disable spinlock
									std::atomic_flag_clear_explicit(&working, std::memory_order_release);
							}
						}, jobID); // so we know who owns this job
				}
				return GReturn::SUCCESS;
			}
			GReturn Converge(unsigned int _spinUntil) override
			{
				// don't converge inside yourself, that bad m'kay?
				if (internal_gw::GatewareThreadPool().InsideJob(reinterpret_cast<unsigned long long>(this)))
					return GReturn::DEADLOCK;
				// waits until "working" is false, sleeping the thread for 1ms each time _spinUntil is reached.
				auto last = std::chrono::steady_clock::now();
				// This operation is lock free, so very optimized for short wait times
				while (std::atomic_flag_test_and_set_explicit(&working, std::memory_order_acquire))
				{	// measures how much time this thread is spin locked
					if (std::chrono::duration_cast<std::chrono::nanoseconds>(
						std::chrono::steady_clock::now() - last).count() >= _spinUntil)
					{
						// if things take longer than our maximum lock time we free the thread and try again later
						last = std::chrono::steady_clock::now();
					}
				}
				// Once we have converged we release our lock so we can lock again later.
				std::atomic_flag_clear_explicit(&working, std::memory_order_release);
				return GReturn::SUCCESS;
			}
			// Ensures "ScopedEvent" stays valid until all tasks complete
			~GConcurrentImplementation()
			{
				Converge(0);
			}
		};
	} // end CORE
} // end GW


#endif



namespace GW
{
	namespace SYSTEM
	{
		class GConcurrent final
			: public I::GProxy<I::GConcurrentInterface, I::GConcurrentImplementation, bool>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GConcurrent)
			GATEWARE_TYPEDEF(Events)
			GATEWARE_TYPEDEF(EVENT_DATA)
			GATEWARE_FUNCTION(BranchSingular)
			GATEWARE_FUNCTION(BranchDynamic)
			GATEWARE_TEMPLATE_FUNCTION(BranchParallel)
			GATEWARE_FUNCTION(Converge)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GCONCURRENT_H

/*---------------------------------
|	End of GConcurrent.h
----------------------------------*/


/*---------------------------------
|	Begin of GLog.h
----------------------------------*/
#ifndef GLOG_H
#define GLOG_H




namespace GW
{
	namespace I
	{
		class GLogInterface : public virtual GInterfaceInterface
		{
		public:
			virtual GReturn Log(const char* const _log) = 0;
			virtual GReturn LogCategorized(const char* const _category, const char* const _log) = 0;
			virtual GReturn EnableVerboseLogging(bool _value) = 0;
			virtual GReturn EnableConsoleLogging(bool _value) = 0;
			virtual GReturn Flush() = 0;
		};
	}
}

// Implementaion for GLog.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_SYSTEM) || defined(GATEWARE_DISABLE_GLOG) || \
    (defined(GATEWARE_ENABLE_SYSTEM) && !defined(GATEWARE_DISABLE_GLOG) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	namespace GW
{
	namespace I
	{
		class GLogImplementation : public virtual GLogInterface
		{
		public:
			GW::GReturn Init(const char* const _fileName)
			{
				return GReturn::FAILURE;
			};

			GW::GReturn Init(GW::SYSTEM::GFile _file)
			{
				return GReturn::FAILURE;
			};

			GW::GReturn Log(const char* const _log) override
			{
				return GReturn::FAILURE;
			};

			GW::GReturn LogCategorized(const char* const _category, const char* const _log) override
			{
				return GReturn::FAILURE;
			};

			GW::GReturn EnableVerboseLogging(bool _value) override
			{
				return GReturn::FAILURE;
			};

			GW::GReturn EnableConsoleLogging(bool _value) override
			{
				return GReturn::FAILURE;
			};

			GW::GReturn Flush() override
			{
				return GReturn::FAILURE;
			};

			GW::GReturn Create(const char* const _fileName)
			{
				return GReturn::FEATURE_UNSUPPORTED;
			};

			GW::GReturn Create(GW::SYSTEM::GFile _file)
			{
				return GReturn::FEATURE_UNSUPPORTED;
			};
		};
	} //end namespace I
} // end namespace GW

#elif defined(__APPLE__) || defined(__linux__)
	



#include <queue>
#include <mutex>
#include <sstream>
#include <iostream>
#include <condition_variable>

#define MAX_QUEUE_SIZE 20
#define THREAD_SLEEP_TIME 1
#define TIME_BUFFER 40

namespace GW
{
	namespace I
	{
		class GLogImplementation : public virtual GLogInterface,
			protected GThreadSharedImplementation
		{
		private:
			GW::SYSTEM::GFile logFile;
			GW::SYSTEM::GConcurrent thread;
			std::atomic<bool> threadRunning;

			std::condition_variable conditional;
			std::mutex queueLock;
			std::queue<std::string> logQueue;

			bool isVerbose = true;
			bool isConsoleLogged = false;

			unsigned long long GetThreadID()
			{
				std::stringstream ss;
				ss << std::this_thread::get_id();
				return std::stoull(ss.str());
			};

			GReturn LauchThread()
			{
				isVerbose = true;
				isConsoleLogged = false;
				threadRunning = true;
				thread.Create(false);
				return thread.BranchSingular([&]() {
					std::unique_lock<std::mutex> localQueueLock(queueLock);
					while (threadRunning || logQueue.size() != 0)
					{
						//Will lock the mutex when awaken and unlock it when put back to sleep.
						conditional.wait_for(localQueueLock, std::chrono::seconds(THREAD_SLEEP_TIME));
						//If there is anything to write.
						if (logQueue.size() != 0)
						{
							while (logQueue.size() != 0)
							{
								logFile.WriteLine(logQueue.front().c_str());
								logQueue.pop();

								logFile.FlushFile();
							}
						}
					}
				});
			}
		public:
			~GLogImplementation()
			{
				threadRunning = false;
				thread.Converge(0);
			}

			GReturn Create(const char* const _fileName)
			{
				GReturn rv = logFile.Create();
				if (G_FAIL(rv))
					return rv;

				rv = logFile.AppendTextWrite(_fileName);
				if (G_FAIL(rv))
					return rv;

				return LauchThread();
			}

			GReturn Create(SYSTEM::GFile _file)
			{
				if (!_file)
					return GReturn::INVALID_ARGUMENT;
				logFile = _file;

				return LauchThread();
			}

			GReturn Log(const char* const _log) override
			{
				if (_log == nullptr)
					return GReturn::INVALID_ARGUMENT;

				std::stringstream logStream;

				//Check verbose logging and add the verbose info if on.
				if (isVerbose)
				{
					time_t t = time(0);   //Get time now.
					char timeBuffer[TIME_BUFFER];

					//Parse the time out to readable time.
					std::string buffer(asctime(localtime(&t)));
					INTERNAL::strcpy_s(timeBuffer, TIME_BUFFER, buffer.c_str());

					//Get rid of new line added by asctime.
					timeBuffer[strlen(timeBuffer) - 1] = '\0';

					//Create our log string.
					logStream << "[" << timeBuffer << "] ThreadID[";
					logStream << GetThreadID() << "]\t";
				}

				//Add the log and a newline.
				logStream << _log << "\r\n";

				//Lock the mutex to push the new message.
				queueLock.lock();

				//Check to see if we are at our max messages.
				if (logQueue.size() >= MAX_QUEUE_SIZE)
				{
					queueLock.unlock();
					return GW::GReturn::FAILURE;
				}

				//Push the message to the queue.
				logQueue.push(logStream.str());

				if (isConsoleLogged)
					std::cout << logStream.str();
				queueLock.unlock();
				return GReturn::SUCCESS;
			}

			GReturn LogCategorized(const char* const _category, const char* const _log) override
			{
				if (_category == nullptr || _log == nullptr)
					return GW::GReturn::INVALID_ARGUMENT;

				//The stream that will contain the full message.
				std::stringstream logStream;

				//Check verbose logging and add the verbose info if on.
				if (isVerbose)
				{
					time_t t = time(0);   //Get time now.
					char timeBuffer[TIME_BUFFER];

					//Parse time to readable time.
					std::string buffer(asctime(localtime(&t)));
					INTERNAL::strcpy_s(timeBuffer, TIME_BUFFER, buffer.c_str());

					//Get rid of new line added by asctime.
					timeBuffer[strlen(timeBuffer) - 1] = '\0';

					//Build the string.
					logStream << "[" << timeBuffer << "] ThreadID[";
					logStream << GetThreadID() << "]\t";
				}

				//Add the category and message.
				logStream << "[" << _category << "]\t" << _log << "\r\n";

				//Lock the mutex to push the new msg.
				queueLock.lock();

				//Check to see if we are at our max messages.
				if (logQueue.size() >= MAX_QUEUE_SIZE)
				{
					queueLock.unlock();
					return GW::GReturn::FAILURE;
				}

				//Push the message to the queue.
				logQueue.push(logStream.str());

				if (isConsoleLogged)
					std::cout << logStream.str();
				queueLock.unlock();
				return GReturn::SUCCESS;
			}

			GReturn EnableVerboseLogging(bool _value) override
			{
				isVerbose = _value;
				return GReturn::SUCCESS;
			};

			GReturn EnableConsoleLogging(bool _value) override
			{
				isConsoleLogged = _value;
				return GReturn::SUCCESS;
			};

			GReturn Flush() override
			{
				conditional.notify_all();
				return GReturn::SUCCESS;
			};

			GReturn LockAsyncRead() const override { return GThreadSharedImplementation::LockAsyncRead(); }
			GReturn UnlockAsyncRead() const override { return GThreadSharedImplementation::UnlockAsyncRead(); }
			GReturn LockSyncWrite() override { return GThreadSharedImplementation::LockSyncWrite(); }
			GReturn UnlockSyncWrite() override { return GThreadSharedImplementation::UnlockSyncWrite(); }
		};
	} //end namespace I
} // end namespace GW

#undef MAX_QUEUE_SIZE
#undef THREAD_SLEEP_TIME
#undef TIME_BUFFER

#elif defined(_WIN32)
	



#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <queue>
#include <atomic>
#include <mutex>
#include <sstream>
#include <iostream>
#include <condition_variable>

#define MAX_QUEUE_SIZE 20
#define THREAD_SLEEP_TIME 1
#define TIME_BUFFER 40

namespace GW
{
	namespace I
	{
		class GLogImplementation : public virtual GLogInterface,
			protected GThreadSharedImplementation
		{
		private:
			GW::SYSTEM::GFile logFile;
			GW::SYSTEM::GConcurrent thread;
			std::atomic<bool> threadRunning;

			std::condition_variable conditional;
			std::mutex queueLock;
			std::queue<std::string> logQueue;

			bool isVerbose = true;
			bool isConsoleLogged = false;

			unsigned long long GetThreadID()
			{
				std::stringstream ss;
				ss << std::this_thread::get_id();
				return std::stoull(ss.str());
			};

			GReturn LauchThread()
			{
				isVerbose = true;
				isConsoleLogged = false;
				threadRunning = true;
				thread.Create(false);
				return thread.BranchSingular([&]() {
					std::unique_lock<std::mutex> localQueueLock(queueLock);
					while (threadRunning || logQueue.size() != 0)
					{
						//Will lock the mutex when awaken and unlock it when put back to sleep.
						conditional.wait_for(localQueueLock, std::chrono::seconds(THREAD_SLEEP_TIME));
						//If there is anything to write.
						if (logQueue.size() != 0)
						{
							while (logQueue.size() != 0)
							{
								logFile.WriteLine(logQueue.front().c_str());
								logQueue.pop();

								logFile.FlushFile();
							}
						}
					}
				});
			}
		public:
			~GLogImplementation()
			{
				threadRunning = false;
				thread.Converge(0);
			}

			GReturn Create(const char* const _fileName)
			{
				GReturn rv = logFile.Create();
				if (G_FAIL(rv))
					return rv;

				rv = logFile.AppendTextWrite(_fileName);
				if (G_FAIL(rv))
					return rv;

				return LauchThread();
			}

			GReturn Create(SYSTEM::GFile _file)
			{
				if (!_file)
					return GReturn::INVALID_ARGUMENT;
				logFile = _file;

				return LauchThread();
			}

			GReturn Log(const char* const _log) override
			{
				if (_log == nullptr)
					return GReturn::INVALID_ARGUMENT;

				std::stringstream logStream;

				//Check verbose logging and add the verbose info if on.
				if (isVerbose)
				{
					time_t t = time(0);   //Get time now.
					char timeBuffer[TIME_BUFFER];

					//Parse the time out to readable time.
					struct tm buf;
					localtime_s(&buf, &t);
					asctime_s(timeBuffer, TIME_BUFFER, &buf);

					//Get rid of new line added by asctime.
					timeBuffer[strlen(timeBuffer) - 1] = '\0';

					//Create our log string.
					logStream << "[" << timeBuffer << "] ThreadID[";
					logStream << GetThreadID() << "]\t";
				}

				//Add the log and a newline.
				logStream << _log << "\r\n";

				//Lock the mutex to push the new message.
				queueLock.lock();

				//Check to see if we are at our max messages.
				if (logQueue.size() >= MAX_QUEUE_SIZE)
				{
					queueLock.unlock();
					return GW::GReturn::FAILURE;
				}

				//Push the message to the queue.
				logQueue.push(logStream.str());

				if (isConsoleLogged)
					std::cout << logStream.str();
				OutputDebugStringW(INTERNAL::G_TO_UTF16(logStream.str()).c_str());
				queueLock.unlock();
				return GReturn::SUCCESS;
			}

			GReturn LogCategorized(const char* const _category, const char* const _log) override
			{
				if (_category == nullptr || _log == nullptr)
					return GW::GReturn::INVALID_ARGUMENT;

				//The stream that will contain the full message.
				std::stringstream logStream;

				//Check verbose logging and add the verbose info if on.
				if (isVerbose)
				{
					time_t t = time(0);   //Get time now.
					char timeBuffer[TIME_BUFFER];

					//Parse time to readable time.
					struct tm buf;
					localtime_s(&buf, &t);
					asctime_s(timeBuffer, TIME_BUFFER, &buf);

					//Get rid of new line added by asctime.
					timeBuffer[strlen(timeBuffer) - 1] = '\0';

					//Build the string.
					logStream << "[" << timeBuffer << "] ThreadID[";
					logStream << GetThreadID() << "]\t";
				}

				//Add the category and message.
				logStream << "[" << _category << "]\t" << _log << "\r\n";

				//Lock the mutex to push the new msg.
				queueLock.lock();

				//Check to see if we are at our max messages.
				if (logQueue.size() >= MAX_QUEUE_SIZE)
				{
					queueLock.unlock();
					return GW::GReturn::FAILURE;
				}

				//Push the message to the queue.
				logQueue.push(logStream.str());

				if (isConsoleLogged)
					std::cout << logStream.str();
				OutputDebugStringW(INTERNAL::G_TO_UTF16(logStream.str()).c_str());
				queueLock.unlock();
				return GReturn::SUCCESS;
			}

			GReturn EnableVerboseLogging(bool _value) override
			{
				isVerbose = _value;
				return GReturn::SUCCESS;
			};

			GReturn EnableConsoleLogging(bool _value) override
			{
				isConsoleLogged = _value;
				return GReturn::SUCCESS;
			};

			GReturn Flush() override
			{
				conditional.notify_all();
				return GReturn::SUCCESS;
			};

			GReturn LockAsyncRead() const override { return GThreadSharedImplementation::LockAsyncRead(); }
			GReturn UnlockAsyncRead() const override { return GThreadSharedImplementation::UnlockAsyncRead(); }
			GReturn LockSyncWrite() override { return GThreadSharedImplementation::LockSyncWrite(); }
			GReturn UnlockSyncWrite() override { return GThreadSharedImplementation::UnlockSyncWrite(); }
		};
	} //end namespace I
} // end namespace GW

#undef MAX_QUEUE_SIZE
#undef THREAD_SLEEP_TIME
#undef TIME_BUFFER

#endif


namespace GW
{
	namespace SYSTEM
	{
		class GLog final 
			: public I::GProxy<I::GLogInterface, I::GLogImplementation, const char * const>
		{
			// All Gateware API interfaces contain no variables & are pure virtual.
		public:
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GLog)
			GATEWARE_FUNCTION(Log)
			GATEWARE_FUNCTION(LogCategorized)
			GATEWARE_FUNCTION(EnableVerboseLogging)
			GATEWARE_FUNCTION(EnableConsoleLogging)
			GATEWARE_FUNCTION(Flush)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GLOG_H

/*---------------------------------
|	End of GLog.h
----------------------------------*/


/*---------------------------------
|	Begin of GWindow.h
----------------------------------*/
#ifndef GWINDOW_H
#define GWINDOW_H





namespace GW
{
	namespace I
	{
		class GWindowInterface : public virtual GEventGeneratorInterface
		{
		public:
			enum class Events
			{
				MINIMIZE,
				MAXIMIZE,
				RESIZE,
				MOVE,
				DISPLAY_CLOSED,
				EVENTS_PROCESSED,
				DESTROY,
			};

			struct EVENT_DATA
			{
				Events eventFlags;
				unsigned int height;
				unsigned int width;
				unsigned int clientHeight;
				unsigned int clientWidth;
				int windowX;
				int windowY;
				void* windowHandle;
			};

			virtual GReturn ProcessWindowEvents() = 0;
			virtual GReturn ReconfigureWindow(int _x, int _y, int _width, int _height, GW::SYSTEM::GWindowStyle _style) = 0;
			virtual GReturn SetWindowName(const char* _newName) = 0;
			virtual GReturn SetIcon(int _width, int _height, const unsigned int* _argbPixels) = 0;
			virtual GReturn MoveWindow(int _x, int _y) = 0;
			virtual GReturn ResizeWindow(int _width, int _height) = 0;
			virtual GReturn Maximize() = 0;
			virtual GReturn Minimize() = 0;
			virtual GReturn ChangeWindowStyle(GW::SYSTEM::GWindowStyle _style) = 0;
			virtual GReturn	GetWidth(unsigned int& _outWidth) const = 0;
			virtual GReturn	GetHeight(unsigned int& _outHeight) const = 0;
			virtual GReturn	GetClientWidth(unsigned int& _outClientWidth) const = 0;
			virtual GReturn	GetClientHeight(unsigned int& _outClientHeight) const = 0;
			virtual GReturn	GetX(unsigned int& _outX) const = 0;
			virtual GReturn	GetY(unsigned int& _outY) const = 0;
			virtual GReturn GetClientTopLeft(unsigned int& _outX, unsigned int& _outY) const = 0;
			virtual GReturn GetWindowHandle(GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE& _outUniversalWindowHandle) const = 0;
			virtual GReturn IsFullscreen(bool& _outIsFullscreen) const = 0;
			virtual GReturn IsFocus(bool& _outIsFocus) const = 0;
		};
	}
}

// Implementaion for GWindow.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_SYSTEM) || defined(GATEWARE_DISABLE_GWINDOW) || \
    (defined(GATEWARE_ENABLE_SYSTEM) && !defined(GATEWARE_DISABLE_GWINDOW) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
	namespace I
	{
		class GWindowImplementation :	public virtual GWindowInterface,
										public GEventGeneratorImplementation
		{
		public:
			GReturn Create(int _x, int _y, int _width, int _height, SYSTEM::GWindowStyle _style)
			{
				return GReturn::FAILURE;
			}

			GReturn ProcessWindowEvents() override
			{
				return GReturn::FAILURE;
			}

			GReturn ReconfigureWindow(int _x, int _y, int _width, int _height, SYSTEM::GWindowStyle _style) override
			{
				return GReturn::FAILURE;
			}

			GReturn SetWindowName(const char* _newName) override
			{
				return GReturn::FAILURE;
			}

			GReturn SetIcon(int _width, int _height, const unsigned int* _argbPixels) override
			{
				return GReturn::FAILURE;
			}

			GReturn MoveWindow(int _x, int _y) override
			{
				return GReturn::FAILURE;
			}

			GReturn ResizeWindow(int _width, int _height) override
			{
				return GReturn::FAILURE;
			}

			GReturn Maximize() override
			{
				return GReturn::FAILURE;
			}

			GReturn Minimize() override
			{
				return GReturn::FAILURE;
			}

			GReturn ChangeWindowStyle(SYSTEM::GWindowStyle _style) override
			{
				return GReturn::FAILURE;
			}

			GReturn GetWidth(unsigned int& _outWidth) const override
			{
				return GReturn::FAILURE;
			}

			GReturn GetHeight(unsigned int& _outHeight) const override
			{
				return GReturn::FAILURE;
			}

			GReturn GetClientWidth(unsigned int& _outClientWidth) const override
			{
				return GReturn::FAILURE;
			}

			GReturn GetClientHeight(unsigned int& _outClientHeight) const override
			{
				return GReturn::FAILURE;
			}

			GReturn GetX(unsigned int& _outX) const override
			{
				return GReturn::FAILURE;
			}

			GReturn GetY(unsigned int& _outY) const override
			{
				return GReturn::FAILURE;
			}

			GReturn GetClientTopLeft(unsigned int& _outX, unsigned int& _outY) const override
			{
				return GReturn::FAILURE;
			}

			GReturn GetWindowHandle(SYSTEM::UNIVERSAL_WINDOW_HANDLE & _outUniversalWindowHandle) const override
			{
				return GReturn::FAILURE;
			}

			GReturn IsFullscreen(bool& _outIsFullscreen) const override
			{
				return GReturn::FAILURE;
			}
			
			GReturn IsFocus(bool& _outIsFocus) const override
			{
				return GReturn::FAILURE;
			}
			
			/*GReturn Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) override
			{
				return GReturn::FAILURE;
			}

			GReturn Observers(unsigned int& _outCount) const override
			{
				return GReturn::FAILURE;
			}

			GReturn Push(const GEvent & _newEvent) override
			{
				return GReturn::FAILURE;
			}*/
		};
	}
}


#elif defined(__APPLE__)
    #ifdef __OBJC__
@import Foundation;
@import Cocoa;
@import AppKit;
#endif

#include <thread>

#include <iostream>

#define GWINDOW_EVENT_FLUSHES 10
#define GWINDOW_SLEEP_TIME_BETWEEN_FLUSHES std::chrono::milliseconds(100)
// Flushes events several times. Used during certain style reconfigurations to ensure windows
// complete their transition fully. Otherwise, windows may remain partly visible when deallocated
// before the transition is complete.
#define GWINDOW_FLUSH_MAC_EVENTS_SEVERAL_TIMES()\
int gwinEventFlushs = 0;\
if (GWINDOW_EVENT_FLUSHES > 0)\
    do\
    {\
        std::this_thread::sleep_for(GWINDOW_SLEEP_TIME_BETWEEN_FLUSHES);\
        FlushMacEventLoop();\
    }\
    while (++gwinEventFlushs <= GWINDOW_EVENT_FLUSHES)

namespace GW
{
    namespace I
    {
        class GWindowImplementation;
    }
}

namespace internal_gw
{
    // GWAppDelegate Interface
    
    // Forward declarations of GWAppDelegate methods
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWAppDelegate, void, applicationDidFinishLaunching, NSNotification* notification);

    // Creates the GWAppDelegate class at runtime when G_OBJC_GET_CLASS(GWAppDelegate) is called.
    G_OBJC_CLASS_BEGIN(GWAppDelegate, NSObject<NSApplicationDelegate>)
    {
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GWAppDelegate, applicationDidFinishLaunching, "v@:@", :);
    }
    G_OBJC_CLASS_END(GWAppDelegate)

    // GWAppDelegate Interface End



    // GWResponder Interface
    // The GWResponder is our interpretation of the NSResponder that will propagate window messages to other responders

    // Forward declarations of GWResponder methods
    G_OBJC_HEADER_INSTANCE_METHOD(GWResponder, bool, acceptFirstResponder);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWResponder, bool, acceptsFirstMouse, NSEvent* event);
    
    // Creates the GWResponder class at runtime when G_OBJC_GET_CLASS(GWResponder) is called.
    G_OBJC_CLASS_BEGIN(GWResponder, NSResponder)
    {
        G_OBJC_CLASS_METHOD(GWResponder, acceptFirstResponder, "B@:");
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GWResponder, acceptsFirstMouse, "B@:@", :);
    }
    G_OBJC_CLASS_END(GWResponder)

    // GWResponder Interface End



    // GWDelegate Interface
    // The GWDelegate will be the delegate of the main window which will receive window events

    // Data members of GWDelegate
    G_OBJC_DATA_MEMBERS_STRUCT(GWDelegate)
    {
        GW::I::GWindowImplementation* pWindow;
        GW::I::GWindowInterface::EVENT_DATA eventData;
        GW::GEvent gevent;
        GW::SYSTEM::GWindowStyle* gWindowStyle;
        bool* windowWasDestroyed;
        bool* windowNeedsRedirecting;
        bool* windowStyleNeedsUpdating;
    };

    // Forward declarations of GWDelegate methods
    G_OBJC_HEADER_DATA_MEMBERS_PROPERTY_METHOD(GWDelegate);

    G_OBJC_HEADER_STATIC_METHOD_WITH_ARGUMENTS(GWDelegate, void, doNothing, id threadID);

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, NSSize, windowWillResize, NSWindow* sender, NSSize frameSize);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowDidResize, NSNotification* notification);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowDidMove, NSNotification* notification);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowDidMiniaturize, NSNotification* notification);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowDidDeminiaturize, NSNotification* notification);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowDidEnterFullScreen, NSNotification* notification);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowDidExitFullScreen, NSNotification* notification);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowWillClose, NSNotification* notification);

    // Creates the GWDelegate class at runtime when G_OBJC_GET_CLASS(GWDelegate) is called
    G_OBJC_CLASS_BEGIN(GWDelegate, NSObject<NSWindowDelegate>)
    {
        G_OBJC_CLASS_DATA_MEMBERS_PROPERTY(GWDelegate);

        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GWDelegate, doNothing, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GWDelegate, windowWillResize, "@@:@@", ::);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GWDelegate, windowDidResize, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GWDelegate, windowDidMove, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GWDelegate, windowDidMiniaturize, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GWDelegate, windowDidDeminiaturize, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GWDelegate, windowDidEnterFullScreen, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GWDelegate, windowDidExitFullScreen, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GWDelegate, windowWillClose, "v@:@", :);
    }
    G_OBJC_CLASS_END(GWDelegate)

    // GWDelegate Interface End
}

#include <atomic>
#include <mutex>
#include <string.h>

// This file is automatically generated by our CMake build scripts.
// Authors: Gerard Vega (original CMake build system) & Yangjie Yao(Wolfram auto-versioning)

#ifndef GVERSION_HPP
#define GVERSION_HPP

// Ensure developers are only building Gateware on x64 platforms.
static_assert(sizeof(void*) == 8, "Gateware supports x64 platforms only.");

// The Major version is increased when a new library is added.(minor & patch are reset)
#define GATEWARE_MAJOR 2
// The Minor version is increased whenever an interface is altered.(patch is reset)
#define GATEWARE_MINOR 0
// The Patch version is increased whenever a bug or leak is fixed.(nothing is reset)
#define GATEWARE_PATCH 'b'
// Pulled directly from GIT  
#define GATEWARE_BRANCH "master"
// Pulled directly from GIT
#define GATEWARE_COMMIT_HASH 0x96078a9
// Standard Window Title Bar
#define GATEWARE_VERSION_STRING "Gateware v2.0b"
// Window Title Bar displayed in DEBUG builds
#define GATEWARE_VERSION_STRING_LONG "Gateware v2.0b (master) [96078a9]"

#endif



namespace GW
{
    namespace I
    {
        class GWindowImplementation :   public virtual GWindowInterface,
                                        public GEventGeneratorImplementation
        {
        private:
            NSWindow* window;
            NSAutoreleasePool* pool;

            std::atomic<int> xPos;
            std::atomic<int> yPos;
            std::atomic<int> width;
            std::atomic<int> height;

            SYSTEM::GWindowStyle gWindowStyle;
            GEvent gEvent;
            GW::I::GWindowInterface::EVENT_DATA* eventData;
            __block bool windowWasDestroyed;
            __block bool windowNeedsRedirecting;
            __block bool windowStyleNeedsUpdating;
            __block bool reconfigRequiresExtraStep;

            void SetInteralData(int _x, int _y, int _width, int _height, SYSTEM::GWindowStyle _style)
            {
                width = _width;
                height = _height;
                xPos = _x;
                yPos = _y;
                gWindowStyle = _style;
            }

            id responder;
            id delegate;
            id appDel;

            GReturn OpenWindow()
            {
                if (window)
                    return GReturn::REDUNDANT;

                responder = [internal_gw::G_OBJC_GET_CLASS(GWResponder) alloc];
                delegate = [internal_gw::G_OBJC_GET_CLASS(GWDelegate) alloc];
                appDel = [internal_gw::G_OBJC_GET_CLASS(GWAppDelegate) alloc];

                internal_gw::G_OBJC_DATA_MEMBERS_TYPE(GWDelegate)& delegateDataMembers = internal_gw::G_OBJC_GET_DATA_MEMBERS(GWDelegate, delegate);
                delegateDataMembers.pWindow = this;
                delegateDataMembers.gWindowStyle = &gWindowStyle;
                delegateDataMembers.windowWasDestroyed = &windowWasDestroyed;
                delegateDataMembers.windowNeedsRedirecting = &windowNeedsRedirecting;
                delegateDataMembers.windowStyleNeedsUpdating = &windowStyleNeedsUpdating;
                
                windowWasDestroyed = false;
                windowNeedsRedirecting = false;
                windowStyleNeedsUpdating = false;
                reconfigRequiresExtraStep = false;
                
                eventData = &delegateDataMembers.eventData;

                pool = [[NSAutoreleasePool alloc]init];

                [NSApplication sharedApplication] ;

                [NSThread detachNewThreadSelector : @selector(doNothing : ) toTarget: delegate withObject : nil] ;

                [NSApp setActivationPolicy : NSApplicationActivationPolicyRegular] ;
                [NSApp setDelegate : appDel] ;
                
                NSUInteger windowStyleMask = ConvertWindowsStyle(gWindowStyle);

                CGSize screenSize = [[NSScreen mainScreen] frame].size;
                
                NSRect windowRect;
                if (gWindowStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERLESS)
                {
                    windowRect = NSMakeRect(xPos, screenSize.height - yPos - height, screenSize.width, screenSize.height);
                    
                    [NSMenu setMenuBarVisible:NO];
                }
                else
                {
                    windowRect = NSMakeRect(xPos, screenSize.height - yPos - height, width, height);
                    
                    // Adjust the window rect so the content area is the desired width and height.
                    ConvertContentRectToFrameRect(windowRect, windowStyleMask);
                    
                    [NSMenu setMenuBarVisible:YES];
                }

                window = [[NSWindow alloc]initWithContentRect:windowRect
                    styleMask : windowStyleMask
                    backing : NSBackingStoreBuffered
                    defer : NO];
                
                if (window == nil)
                    return GReturn::FAILURE;
#ifdef _DEBUG
#define GATEWARE_WINDOW_NAME GATEWARE_VERSION_STRING_LONG
#else
#define GATEWARE_WINDOW_NAME GATEWARE_VERSION_STRING
#endif
                [window setTitle : @GATEWARE_WINDOW_NAME];
#undef GATEWARE_WINDOW_NAME
                
                [window setFrame : windowRect display : YES] ;

                if (gWindowStyle == SYSTEM::GWindowStyle::WINDOWEDLOCKED)
                    [window setCollectionBehavior : NSWindowCollectionBehaviorFullScreenNone];
                else
                    [window setCollectionBehavior : NSWindowCollectionBehaviorFullScreenPrimary];
                
                [responder setNextResponder : window.nextResponder] ;
                [window setNextResponder : responder] ;
                [window makeFirstResponder : window.contentView] ;
                [window.contentView setNextResponder : responder] ;

                [window setDelegate : delegate] ;
                [window makeKeyAndOrderFront : nil] ;

                if (gWindowStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERED || gWindowStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERLESS)
                {
                    [window toggleFullScreen : nil] ;
                    FlushMacEventLoop();
                }
                else if (gWindowStyle == SYSTEM::GWindowStyle::MINIMIZED)
                {
                    [window miniaturize : nil] ;
                    FlushMacEventLoop();
                    
                    [pool drain] ;
                    
                    if ([window isMiniaturized])
                        return GReturn::SUCCESS;
                    
                    return GReturn::FAILURE;
                }
                
                [pool drain] ;
                
                if ([window isVisible])
                    return GReturn::SUCCESS;
                else
                    return GReturn::FAILURE;
            }
            
            /*
                Converts a content area (aka client area) rectangle to a window frame rectangle, while taking into account
                the style mask of the window. The resultant rectangle is large enough to size a window so that contains the
                full size of the original rectangle passed to the function.
             */
            void ConvertContentRectToFrameRect(NSRect& _rect, const NSUInteger _mask) const
            {
                // Get the content area (client area) after creating a window frame with _rect.
                NSRect contentRect = [NSWindow contentRectForFrameRect:_rect styleMask:_mask];
                
                // Calculate the border size
                CGSize borderSize = NSMakeSize(
                       _rect.size.width - contentRect.size.width,
                       _rect.size.height - contentRect.size.height
                );
                
                _rect.origin.y -= borderSize.height; // Adjust the y position to account for the titlebar.
                // Add the border size to _rect to create a frame area that preserves the desired content area dimensions.
                _rect.size = NSMakeSize(
                       _rect.size.width + borderSize.width,
                       _rect.size.height + borderSize.height
                );
            }
            
            /*
                Takes a GWindowStyle and returns the corresponding NSWindowStyleMask.
             */
            NSUInteger ConvertWindowsStyle(SYSTEM::GWindowStyle _style) const
            {
                switch (_style)
                {
                    case SYSTEM::GWindowStyle::FULLSCREENBORDERED:
                    case SYSTEM::GWindowStyle::WINDOWEDBORDERED:
                    case SYSTEM::GWindowStyle::MINIMIZED:
                        return NSWindowStyleMaskTitled | NSWindowStyleMaskClosable | NSWindowStyleMaskResizable | NSWindowStyleMaskMiniaturizable;
                        
                    case SYSTEM::GWindowStyle::WINDOWEDLOCKED:
                        return NSWindowStyleMaskTitled | NSWindowStyleMaskClosable | NSWindowStyleMaskMiniaturizable;
                        
                    case SYSTEM::GWindowStyle::FULLSCREENBORDERLESS:
                    case SYSTEM::GWindowStyle::WINDOWEDBORDERLESS:
                        return NSWindowStyleMaskMiniaturizable;
                }
                return 0;
            }
            
        public:
            ~GWindowImplementation()
            {
                RUN_ON_UI_THREAD(^ {
                    if (window && [window acceptsMouseMovedEvents])
                    {
                        [window setAcceptsMouseMovedEvents:NO];
                        FlushMacEventLoop();
                    }
                    
                    [NSMenu setMenuBarVisible:YES];
                    FlushMacEventLoop();
                    
                    if (window)
                    {
                        NSWindowStyleMask winStyle = [window styleMask];
                        if ((winStyle & NSWindowStyleMaskFullScreen) == NSWindowStyleMaskFullScreen)
                        {
                            [window toggleFullScreen : nil] ;
                            FlushMacEventLoop();
                        }
                        else if ([window isMiniaturized])
                        {
                            [window deminiaturize : nil];
                            FlushMacEventLoop();
                        }
                        
                        [window close];
                        FlushMacEventLoop();
                    }

                    // A paranoia check to make sure there are no remaining
                    // events that may trigger after the window is cleaned up.
                    for (int i = 0; i < 10; ++i)
                        FlushMacEventLoop();
                });
                
                if (window)
                {
                    // Remove subviews like the one added by GRasterSurface.
                    NSArray* subViewArray = [[window contentView] subviews];
                    for (id obj in subViewArray)
                        [obj removeFromSuperview];
                        
                    [window release] ;
                    window = nil;
                }
                
                if (responder)
                {
                    [responder release] ;
                    responder = nil;
                }
                
                if (delegate)
                {
                    [(delegate)release] ;
                    (delegate) = nil;
                }
                
                if (appDel)
                {
                    [appDel release] ;
                    appDel = nil;
                }
            }

            GReturn Create(int _x, int _y, int _width, int _height, SYSTEM::GWindowStyle _style)
            {
                this->SetInteralData(_x, _y, _width, _height, _style);
                return OpenWindow();
            }
               // TODO: make seperate var to kill the window
            GReturn ProcessWindowEvents() override
            {
                if (windowWasDestroyed)
                    return GReturn::FAILURE;
                
                RUN_ON_UI_THREAD(^ {
                    FlushMacEventLoop();
                    eventData->eventFlags = Events::EVENTS_PROCESSED;
                    gEvent.Write(Events::EVENTS_PROCESSED, *eventData);
                    Push(gEvent);
                });

                return GReturn::SUCCESS;
            }

            GReturn ReconfigureWindow(int _x, int _y, int _width, int _height, GW::SYSTEM::GWindowStyle _style) override
            {
                if (windowWasDestroyed)
                    return GReturn::FAILURE;
                
                GW::SYSTEM::GWindowStyle prevStyle = gWindowStyle;
                SetInteralData(_x, _y, _width, _height, _style);
                
                switch (gWindowStyle)
                {
                case SYSTEM::GWindowStyle::WINDOWEDBORDERED:
                {
                    bool fullscreen;
                    IsFullscreen(fullscreen);
                    
                    // If the window is minimized or fullscreen, it will need to be brought out of those states
                    // before modifying the window further.
                    if (fullscreen)
                    {
                        if (prevStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERED)
                        {
                            // Must use RUN_ON_UI_THREAD when changing the window's look.
                            RUN_ON_UI_THREAD(^ {
                                windowNeedsRedirecting = true; // Marks that exiting fullscreen doesn not complete the style change.
                                [window toggleFullScreen : nil];

                                // Flush the events so they propagate.
                                FlushMacEventLoop();
                            });

                            return GReturn::SUCCESS;
                        }
                        else if (prevStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERLESS)
                        {
                            RUN_ON_UI_THREAD(^ {
                                windowNeedsRedirecting = true;
                                reconfigRequiresExtraStep = true;
                                [window toggleFullScreen : nil];
                                
                                GWINDOW_FLUSH_MAC_EVENTS_SEVERAL_TIMES();
                            });

                            return GReturn::SUCCESS;
                        }
                    }
                    else if ([window isMiniaturized])
                    {
                        RUN_ON_UI_THREAD(^ {
                            windowNeedsRedirecting = true;
                            [window deminiaturize : nil];

                            FlushMacEventLoop();
                        });
                    }
                    else if (gWindowStyle == prevStyle && !reconfigRequiresExtraStep)
                    {
                        RUN_ON_UI_THREAD(^ {
                            NSUInteger mask = NSWindowStyleMaskTitled | NSWindowStyleMaskClosable | NSWindowStyleMaskResizable | NSWindowStyleMaskMiniaturizable;
                            CGSize screenSize = [[NSScreen mainScreen] frame].size;
                            NSRect rect = NSMakeRect(xPos, screenSize.height - yPos - height, width, height);
                            NSRect windowFrame = [window frame];
                            
                            ConvertContentRectToFrameRect(rect, mask);
                            
                            if ([window styleMask] != mask)
                                [window setStyleMask : mask] ;
                            else if (windowFrame.origin.x != rect.origin.x ||
                                windowFrame.origin.y != rect.origin.y ||
                                windowFrame.size.width != rect.size.width ||
                                windowFrame.size.height != rect.size.height)
                                [window setFrame : rect display : YES] ;
                            
                            [window setCollectionBehavior : NSWindowCollectionBehaviorFullScreenPrimary];

                            FlushMacEventLoop();
                        });
                    }
                    else
                    {
                        RUN_ON_UI_THREAD(^ {
                            NSUInteger mask = NSWindowStyleMaskTitled | NSWindowStyleMaskClosable | NSWindowStyleMaskResizable | NSWindowStyleMaskMiniaturizable;
                            CGSize screenSize = [[NSScreen mainScreen] frame].size;
                            NSRect rect = NSMakeRect(xPos, screenSize.height - yPos - height, width, height);

                            [NSMenu setMenuBarVisible : YES];
                            
                            reconfigRequiresExtraStep = false;
                            [window setHasShadow: YES];
                            if ([window styleMask] != mask)
                                windowStyleNeedsUpdating = true;
                            
                            ConvertContentRectToFrameRect(rect, mask);
                            
                            NSRect windowFrame = [window frame];
                            if (windowFrame.origin.x != rect.origin.x ||
                                windowFrame.origin.y != rect.origin.y ||
                                windowFrame.size.width != rect.size.width ||
                                windowFrame.size.height != rect.size.height)
                                [window setFrame : rect display : YES] ;
                            else
                            {
                                windowStyleNeedsUpdating = false;
                                if ([window styleMask] != mask)
                                    [window setStyleMask : mask] ;
                            }
                            
                            [window setCollectionBehavior : NSWindowCollectionBehaviorFullScreenPrimary];

                            FlushMacEventLoop();
                        });
                    }

                    if (window)
                        return GReturn::SUCCESS;

                    return GReturn::FAILURE;
                }
                break;

                case SYSTEM::GWindowStyle::WINDOWEDBORDERLESS:
                {
                    bool fullscreen;
                    IsFullscreen(fullscreen);
                    
                    if (fullscreen)
                    {
                        if (prevStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERED)
                        {
                            RUN_ON_UI_THREAD(^ {
                                windowNeedsRedirecting = true;
                                reconfigRequiresExtraStep = true;
                                [window toggleFullScreen : nil];
                                
                                FlushMacEventLoop();
                            });

                            return GReturn::SUCCESS;
                        }
                        else if (prevStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERLESS)
                        {
                            RUN_ON_UI_THREAD(^ {
                                windowNeedsRedirecting = true;
                                reconfigRequiresExtraStep = true;
                                [window toggleFullScreen : nil];
                                
                                FlushMacEventLoop();
                            });

                            return GReturn::SUCCESS;
                        }
                    }
                    else if ([window isMiniaturized])
                    {
                        RUN_ON_UI_THREAD(^ {
                            windowNeedsRedirecting = true;
                            [window deminiaturize : nil];

                            FlushMacEventLoop();
                        });
                    }
                    else if (gWindowStyle == prevStyle && !reconfigRequiresExtraStep)
                    {
                        RUN_ON_UI_THREAD(^ {
                            NSUInteger mask = NSWindowStyleMaskBorderless;
                            CGSize screenSize = [[NSScreen mainScreen] frame].size;
                            NSRect rect = NSMakeRect(xPos, screenSize.height - yPos - height, width, height);
                            NSRect windowFrame = [window frame];
                            
                            ConvertContentRectToFrameRect(rect, mask);
                            
                            if ([window styleMask] != mask)
                                [window setStyleMask : mask] ;
                            else if (windowFrame.origin.x != rect.origin.x ||
                                windowFrame.origin.y != rect.origin.y ||
                                windowFrame.size.width != rect.size.width ||
                                windowFrame.size.height != rect.size.height)
                                [window setFrame : rect display : YES] ;
                            
                            [window setCollectionBehavior : NSWindowCollectionBehaviorFullScreenPrimary];

                            FlushMacEventLoop();
                        });
                    }
                    else
                    {
                        RUN_ON_UI_THREAD(^ {
                            NSUInteger mask = NSWindowStyleMaskBorderless;
                            CGSize screenSize = [[NSScreen mainScreen] frame].size;
                            NSRect rect = NSMakeRect(xPos, screenSize.height - yPos - height, width, height);

                            [NSMenu setMenuBarVisible : YES];
                            
                            reconfigRequiresExtraStep = false;
                            [window setHasShadow: YES];
                            if ([window styleMask] != mask)
                                windowStyleNeedsUpdating = true;
                            
                            ConvertContentRectToFrameRect(rect, mask);
                            
                            NSRect windowFrame = [window frame];
                            if (windowFrame.origin.x != rect.origin.x ||
                                windowFrame.origin.y != rect.origin.y ||
                                windowFrame.size.width != rect.size.width ||
                                windowFrame.size.height != rect.size.height)
                                [window setFrame : rect display : YES] ;
                            else
                            {
                                windowStyleNeedsUpdating = false;
                                if ([window styleMask] != mask)
                                    [window setStyleMask : mask] ;
                            }
                            [window setCollectionBehavior : NSWindowCollectionBehaviorFullScreenPrimary];

                            FlushMacEventLoop();
                        });
                    }

                    if (window)
                        return GReturn::SUCCESS;

                    return GReturn::FAILURE;
                }
                break;
                        
                case SYSTEM::GWindowStyle::WINDOWEDLOCKED:
                {
                    bool fullscreen;
                    IsFullscreen(fullscreen);
                    
                    if (fullscreen)
                    {
                        if (prevStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERED)
                        {
                            RUN_ON_UI_THREAD(^ {
                                windowNeedsRedirecting = true;
                                [window toggleFullScreen : nil];
                                
                                FlushMacEventLoop();
                            });

                            return GReturn::SUCCESS;
                        }
                        else if (prevStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERLESS)
                        {
                            RUN_ON_UI_THREAD(^ {
                                windowNeedsRedirecting = true;
                                reconfigRequiresExtraStep = true;
                                [window toggleFullScreen : nil];
                                
                                GWINDOW_FLUSH_MAC_EVENTS_SEVERAL_TIMES();
                            });

                            return GReturn::SUCCESS;
                        }
                    }
                    else if ([window isMiniaturized])
                    {
                        RUN_ON_UI_THREAD(^ {
                            windowNeedsRedirecting = true;
                            [window deminiaturize : nil];

                            FlushMacEventLoop();
                        });
                    }
                    else if (gWindowStyle == prevStyle && !reconfigRequiresExtraStep)
                    {
                        RUN_ON_UI_THREAD(^ {
                            NSUInteger mask = NSWindowStyleMaskTitled | NSWindowStyleMaskClosable | NSWindowStyleMaskMiniaturizable;
                            CGSize screenSize = [[NSScreen mainScreen] frame].size;
                            NSRect rect = NSMakeRect(xPos, screenSize.height - yPos - height, width, height);
                            NSRect windowFrame = [window frame];
                            
                            ConvertContentRectToFrameRect(rect, mask);
                            
                            if ([window styleMask] != mask)
                                [window setStyleMask : mask] ;
                            else if (windowFrame.origin.x != rect.origin.x ||
                                windowFrame.origin.y != rect.origin.y ||
                                windowFrame.size.width != rect.size.width ||
                                windowFrame.size.height != rect.size.height)
                                [window setFrame : rect display : YES] ;
                            
                            [window setCollectionBehavior : NSWindowCollectionBehaviorFullScreenNone];

                            FlushMacEventLoop();
                        });
                    }
                    else
                    {
                        RUN_ON_UI_THREAD(^ {
                            NSUInteger mask = NSWindowStyleMaskTitled | NSWindowStyleMaskClosable | NSWindowStyleMaskMiniaturizable;
                            CGSize screenSize = [[NSScreen mainScreen] frame].size;
                            NSRect rect = NSMakeRect(xPos, screenSize.height - yPos - height, width, height);

                            [NSMenu setMenuBarVisible : YES];
                            
                            reconfigRequiresExtraStep = false;
                            [window setHasShadow: YES];
                            if ([window styleMask] != mask)
                                windowStyleNeedsUpdating = true;
                            
                            ConvertContentRectToFrameRect(rect, mask);
                            
                            NSRect windowFrame = [window frame];
                            if (windowFrame.origin.x != rect.origin.x ||
                                windowFrame.origin.y != rect.origin.y ||
                                windowFrame.size.width != rect.size.width ||
                                windowFrame.size.height != rect.size.height)
                                [window setFrame : rect display : YES] ;
                            else
                            {
                                windowStyleNeedsUpdating = false;
                                if ([window styleMask] != mask)
                                    [window setStyleMask : mask] ;
                            }
                            [window setCollectionBehavior : NSWindowCollectionBehaviorFullScreenNone];

                            FlushMacEventLoop();
                        });
                    }

                    if (window)
                        return GReturn::SUCCESS;

                    return GReturn::FAILURE;
                }
                break;

                case SYSTEM::GWindowStyle::FULLSCREENBORDERED:
                {
                    bool fullscreen;
                    IsFullscreen(fullscreen);

                    if (fullscreen)
                    {
                        if (gWindowStyle == prevStyle)
                            return GReturn::SUCCESS;
                        else if (prevStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERLESS)
                        {
                            RUN_ON_UI_THREAD(^ {
                                windowNeedsRedirecting = true;
                                reconfigRequiresExtraStep = true;
                                [window toggleFullScreen : nil];

                                GWINDOW_FLUSH_MAC_EVENTS_SEVERAL_TIMES();
                            });

                            if (window)
                                return GReturn::SUCCESS;

                            return GReturn::FAILURE;
                        }
                    }
                    else if ([window isMiniaturized])
                    {
                        RUN_ON_UI_THREAD(^ {
                            windowNeedsRedirecting = true;
                            [window deminiaturize : nil];

                            FlushMacEventLoop();
                        });
                    }
                    else
                    {
                        RUN_ON_UI_THREAD(^ {
                            NSUInteger styleMask = NSWindowStyleMaskTitled | NSWindowStyleMaskClosable | NSWindowStyleMaskResizable | NSWindowStyleMaskMiniaturizable;

                            [NSMenu setMenuBarVisible : YES];

                            [window setStyleMask : styleMask] ;
                            [window setCollectionBehavior : NSWindowCollectionBehaviorFullScreenPrimary];
                            [window toggleFullScreen : nil];

                            if (reconfigRequiresExtraStep)
                            {
                                reconfigRequiresExtraStep = false;
                                GWINDOW_FLUSH_MAC_EVENTS_SEVERAL_TIMES();
                            }
                            else
                                FlushMacEventLoop();
                        });

                        if (window)
                            return GReturn::SUCCESS;

                        return GReturn::FAILURE;
                    }
                }
                break;

                case SYSTEM::GWindowStyle::FULLSCREENBORDERLESS:
                {
                    bool fullscreen;
                    IsFullscreen(fullscreen);

                    if (fullscreen)
                    {
                        if (gWindowStyle == prevStyle)
                            return GReturn::SUCCESS;
                        else if (prevStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERED)
                        {
                            RUN_ON_UI_THREAD(^ {
                                windowNeedsRedirecting = true;
                                [window toggleFullScreen : nil];

                                FlushMacEventLoop();
                            });
                            
                            if (window)
                                return GReturn::SUCCESS;

                            return GReturn::FAILURE;
                        }
                    }
                    else if ([window isMiniaturized])
                    {
                        RUN_ON_UI_THREAD(^ {
                            windowNeedsRedirecting = true;
                            [window deminiaturize : nil];

                            FlushMacEventLoop();
                        });
                    }
                    else
                    {
                        RUN_ON_UI_THREAD(^ {
                            NSUInteger styleMask = NSWindowStyleMaskMiniaturizable;
                            CGSize screenSize = [[NSScreen mainScreen] frame].size;
                            NSRect rect = NSMakeRect(0, 0, screenSize.width, screenSize.height);

                            [NSMenu setMenuBarVisible : NO];

                            [window setStyleMask : styleMask] ;
                            [window setFrame : rect display : YES] ;
                            [window setCollectionBehavior : NSWindowCollectionBehaviorFullScreenPrimary];
                            [window toggleFullScreen : nil];

                            FlushMacEventLoop();
                        });
                    }
                    
                    if (window)
                        return GReturn::SUCCESS;

                    return GReturn::FAILURE;
                }
                break;

                case SYSTEM::GWindowStyle::MINIMIZED:
                {
                    bool fullscreen;
                    IsFullscreen(fullscreen);
                    
                    if (fullscreen)
                    {
                        if (prevStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERED)
                        {
                            RUN_ON_UI_THREAD(^ {
                                windowNeedsRedirecting = true;
                                [window toggleFullScreen : nil];
                                
                                FlushMacEventLoop();
                            });

                            return GReturn::SUCCESS;
                        }
                        else if (prevStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERLESS)
                        {
                            RUN_ON_UI_THREAD(^ {
                                [NSMenu setMenuBarVisible : YES];
                                
                                [window setHasShadow: YES];
                                
                                windowNeedsRedirecting = true;
                                [window toggleFullScreen : nil];
                                
                                FlushMacEventLoop();
                            });

                            return GReturn::SUCCESS;
                        }
                    }
                    else
                    {
                        RUN_ON_UI_THREAD(^ {
                            [NSMenu setMenuBarVisible : YES];
                            
                            [window miniaturize : nil] ;
                            
                            FlushMacEventLoop();
                        });
                    }

                    if ([window isMiniaturized])
                        return GReturn::SUCCESS;

                    return GReturn::FAILURE;
                }
                break;
                }
                
                return GReturn::SUCCESS;
            }

            GReturn SetWindowName(const char* _newName) override
            {
                __block bool operationResult = false;

                if (_newName == nil)
                    return GReturn::INVALID_ARGUMENT;

                if (windowWasDestroyed)
                    return GReturn::FAILURE;

                RUN_ON_UI_THREAD(^ {
                    NSString* macName = [NSString stringWithCString : _newName encoding : NSUTF8StringEncoding];
                    window.title = macName;

                    if (window.title == macName)
                        operationResult = true;
                });
                if (operationResult)
                    return GReturn::SUCCESS;

                return GReturn::FAILURE;
            }

			GReturn SetIcon(int _width, int _height, const unsigned int* _argbPixels) override
            {
                if (_argbPixels == nullptr)
                    return GReturn::INVALID_ARGUMENT;
                else if (_width <= 0 || _height <= 0)
                    return GReturn::INVALID_ARGUMENT;

                if (windowWasDestroyed)
                    return GReturn::FAILURE;

                NSBitmapImageRep* bitmap = [[NSBitmapImageRep alloc]
                    initWithBitmapDataPlanes:NULL
                    pixelsWide : _width
                    pixelsHigh : _height
                    bitsPerSample : 8
                    samplesPerPixel : 4
                    hasAlpha : YES
                    isPlanar : NO
                    colorSpaceName : NSDeviceRGBColorSpace
                    bitmapFormat : NSBitmapFormatAlphaFirst
                    bytesPerRow : 0
                    bitsPerPixel : 0
                ];
                unsigned int* imagePixels = (unsigned int*)[bitmap bitmapData];
                NSImage* image = [[NSImage alloc] init];
                [image addRepresentation : bitmap] ;

                // Convert the pixels from ARGB ro BGRA
                for (size_t i = 0; i < _width * _height; ++i)
                    imagePixels[i] = (_argbPixels[i] & 0xFF000000) >> 24
                                   | (_argbPixels[i] & 0x00FF0000) >> 8
                                   | (_argbPixels[i] & 0x0000FF00) << 8
                                   | (_argbPixels[i] & 0x000000FF) << 24;
                
                [NSApplication sharedApplication].applicationIconImage = image;
                
                [image release];
                image = nil;
                
                [bitmap release];
                bitmap = nil;

                return GReturn::SUCCESS;
            }

            GReturn MoveWindow(int _x, int _y) override
            {
                if (windowWasDestroyed)
                    return GReturn::FAILURE;

                SetInteralData(_x, _y, width, height, gWindowStyle);

                RUN_ON_UI_THREAD(^ {
                    CGSize screenSize = [[NSScreen mainScreen] frame].size;
                    
                    CGPoint newPos;
                    newPos.y = screenSize.height - yPos;
                    newPos.x = xPos;

                    NSPoint pointPos;
                    pointPos.y = newPos.y;
                    pointPos.x = newPos.x;

                    [window setFrameTopLeftPoint : pointPos] ;
                    FlushMacEventLoop();
                });

                return GReturn::SUCCESS;
            }

            GReturn ResizeWindow(int _width, int _height) override
            {
                if (windowWasDestroyed)
                    return GReturn::FAILURE;

                CGSize screenSize = [[NSScreen mainScreen] frame].size;
                SetInteralData(xPos, screenSize.height - yPos - _height, _width, _height, gWindowStyle);
                
                NSUInteger windowStyleMask = ConvertWindowsStyle(gWindowStyle);

                RUN_ON_UI_THREAD(^ {
                    NSRect rect = NSMakeRect(xPos, yPos, _width, _height);
                    
                    ConvertContentRectToFrameRect(rect, windowStyleMask);

                    [window setFrame : rect display : YES] ;
                    FlushMacEventLoop();
                });
                return GReturn::SUCCESS;
            }

            GReturn Maximize() override
            {
                if (windowWasDestroyed)
                    return GReturn::FAILURE;

                if (gWindowStyle == SYSTEM::GWindowStyle::WINDOWEDBORDERED || gWindowStyle == SYSTEM::GWindowStyle::MINIMIZED)
                {
                    return ChangeWindowStyle(SYSTEM::GWindowStyle::FULLSCREENBORDERED);
                }
                else if (gWindowStyle == SYSTEM::GWindowStyle::WINDOWEDBORDERLESS)
                {
                    return ChangeWindowStyle(SYSTEM::GWindowStyle::FULLSCREENBORDERLESS);
                }
                else
                {
                    bool fullscreen;
                    IsFullscreen(fullscreen);
                    
                    if (!fullscreen)
                    {
                        if (gWindowStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERED)
                        {
                            return ChangeWindowStyle(SYSTEM::GWindowStyle::FULLSCREENBORDERED);
                        }
                        else if (gWindowStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERLESS)
                        {
                            return ChangeWindowStyle(SYSTEM::GWindowStyle::FULLSCREENBORDERLESS);
                        }
                    }
                }

                return GReturn::REDUNDANT;
            }

            GReturn Minimize() override
            {
                return ChangeWindowStyle(SYSTEM::GWindowStyle::MINIMIZED);
            }

            GReturn ChangeWindowStyle(GW::SYSTEM::GWindowStyle _style) override
            {
                return ReconfigureWindow(xPos, yPos, width, height, _style);
            }

            GReturn GetWidth(unsigned int& _outWidth) const override
            {
                if (windowWasDestroyed)
                    return GReturn::FAILURE;
                NSRect rect = window.frame;
                _outWidth = rect.size.width;
                return GReturn::SUCCESS;
            }

            GReturn GetHeight(unsigned int& _outHeight) const override
            {
                if (windowWasDestroyed)
                    return GReturn::FAILURE;
                NSRect rect = window.frame;
                _outHeight = rect.size.height;
                return GReturn::SUCCESS;
            }

            GReturn GetClientWidth(unsigned int& _outClientWidth) const override
            {
                if (windowWasDestroyed)
                    return GReturn::FAILURE;
                NSRect rect = window.frame;
                NSRect contentRect = [window contentRectForFrameRect : rect];
                _outClientWidth = contentRect.size.width;
                return GReturn::SUCCESS;
            }

            GReturn GetClientHeight(unsigned int& _outClientHeight) const override
            {
                if (windowWasDestroyed)
                    return GReturn::FAILURE;
                NSRect rect = window.frame;
                NSRect contentRect = [window contentRectForFrameRect : rect];
                _outClientHeight = contentRect.size.height;
                return GReturn::SUCCESS;
            }

            GReturn GetX(unsigned int& _outX) const override
            {
                if (windowWasDestroyed)
                    return GReturn::FAILURE;
                NSRect rect = window.frame;
                _outX = rect.origin.x;
                return GReturn::SUCCESS;
            }

            GReturn GetY(unsigned int& _outY) const override
            {
                if (windowWasDestroyed)
                    return GReturn::FAILURE;
                NSRect rect = window.frame;
                CGSize screenSize = [[NSScreen mainScreen] frame].size;
                _outY = screenSize.height - rect.origin.y - rect.size.height;
                return GReturn::SUCCESS;
            }

            GReturn GetClientTopLeft(unsigned int& _outX, unsigned int& _outY) const override
            {
                if (windowWasDestroyed)
                    return GReturn::FAILURE;
                NSRect rect = window.frame;
                NSRect contentRect = [window contentRectForFrameRect : rect];
                NSRect screenSize = [[NSScreen mainScreen] frame];
                
                unsigned int x;
                unsigned int y;
                GetX(x);
                GetY(y);
                y = screenSize.size.height - y;
                
                _outX = x - contentRect.origin.x;
                _outY = y - (contentRect.origin.y + contentRect.size.height); // origin is expressed with +y axis going up
                return GReturn::SUCCESS;
            }

            GReturn GetWindowHandle(GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE& _outUniversalWindowHandle) const override
            {
                if (windowWasDestroyed)
                    return GReturn::FAILURE;

                if (!(__bridge void*)window)
                {
                    return GReturn::FAILURE;
                }
                _outUniversalWindowHandle.window = window;
                return GReturn::SUCCESS;
            }

            GReturn IsFullscreen(bool& _outIsFullscreen) const override
            {
                if (windowWasDestroyed)
                    return GReturn::FAILURE;

                __block NSWindowStyleMask winStyle;
                RUN_ON_UI_THREAD(^ { winStyle = [window styleMask]; });
                if ((winStyle & NSWindowStyleMaskFullScreen) == NSWindowStyleMaskFullScreen)
                    _outIsFullscreen = TRUE;
                else
                    _outIsFullscreen = FALSE;

                return GReturn::SUCCESS;
            }

            GReturn IsFocus(bool& _outIsFocus) const override
            {
                if (windowWasDestroyed)
                    return GReturn::FAILURE;
                // mac auto filters input events based on active window
                // for conformity we may need a way to get backgroud keys
                // then this function will be needed for filtering.
                _outIsFocus = true;
                return GReturn::SUCCESS;
            }
        };
    }
}

namespace internal_gw
{
    // GWAppDelegate Implementation

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWAppDelegate, void, applicationDidFinishLaunching, NSNotification* notification)
    {
        [NSApp stop : nil] ;

        NSPoint p;
        p.x = 0;
        p.y = 0;

        NSAutoreleasePool* pool = [[NSAutoreleasePool alloc]init];

        NSEvent* event = [NSEvent otherEventWithType : NSEventTypeApplicationDefined
            location : p
            modifierFlags : 0
            timestamp : 0
            windowNumber : 0
            context : nil
            subtype : 0
            data1 : 0
            data2 : 0];

        [NSApp postEvent : event atStart : YES] ;
        [pool drain] ;
    }

    // GWAppDelegate Implementation End



    // GWResponder Implementation

    G_OBJC_HEADER_INSTANCE_METHOD(GWResponder, bool, acceptFirstResponder)
    {
        return YES;
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWResponder, bool, acceptsFirstMouse, NSEvent* event)
    {
        return YES;
    }

    // GWResponder Implementation End



    // GWDelegate Implementation

    G_OBJC_IMPLEMENTATION_DATA_MEMBERS_PROPERTY_METHOD(GWDelegate);

    G_OBJC_HEADER_STATIC_METHOD_WITH_ARGUMENTS(GWDelegate, void, doNothing, id threadID) {}

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, NSSize, windowWillResize, NSWindow* sender, NSSize frameSize)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GWDelegate)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GWDelegate, self);
        
        //Tells the delegate that the window will be resized (whether by the user or through one of the setFrame...methods
        //other than setFrame:display)
        GW::I::GWindowInterface::EVENT_DATA& eventData = selfDataMembers.eventData;
        eventData.eventFlags = GW::I::GWindowInterface::Events::RESIZE;
        eventData.height = frameSize.height;
        eventData.width = frameSize.width;
		NSSize contentSize = [sender contentRectForFrameRect : sender.frame].size;
		eventData.clientHeight = contentSize.height;
		eventData.clientWidth = contentSize.width;
        CGSize screenSize = [[NSScreen mainScreen] frame].size;
        eventData.windowX = sender.frame.origin.x;
        eventData.windowY = screenSize.height - sender.frame.origin.y - sender.frame.size.height;
        eventData.windowHandle = (__bridge void*)sender;

        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(eventData.eventFlags, eventData);

        GW::I::GWindowImplementation* pWindow = selfDataMembers.pWindow;
        pWindow->Push(gevent);
        
        return frameSize;
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowDidResize, NSNotification* notification)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GWDelegate)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GWDelegate, self);
        
        //Tells the delegate that the window been resized
        NSWindow* window = notification.object;

        GW::I::GWindowInterface::EVENT_DATA& eventData = selfDataMembers.eventData;
        eventData.eventFlags = GW::I::GWindowInterface::Events::RESIZE;
        eventData.height = window.frame.size.height;
        eventData.width = window.frame.size.width;
		NSSize contentSize = [window contentRectForFrameRect : window.frame].size;
		eventData.clientHeight = contentSize.height;
		eventData.clientWidth = contentSize.width;
        CGSize screenSize = [[NSScreen mainScreen] frame].size;
        eventData.windowX = window.frame.origin.x;
        eventData.windowY = screenSize.height - window.frame.origin.y - window.frame.size.height;
        eventData.windowHandle = (__bridge void*)window;

        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(eventData.eventFlags, eventData);

        GW::I::GWindowImplementation* pWindow = selfDataMembers.pWindow;
        pWindow->Push(gevent);
        
        if (*selfDataMembers.windowStyleNeedsUpdating)
        {
            *selfDataMembers.windowStyleNeedsUpdating = false;
            selfDataMembers.pWindow->ChangeWindowStyle(*selfDataMembers.gWindowStyle);
        }
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowDidMove, NSNotification* notification)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GWDelegate)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GWDelegate, self);
        
        //Tells the delegate that the window has moved.
        NSWindow* window = notification.object;

        GW::I::GWindowInterface::EVENT_DATA& eventData = selfDataMembers.eventData;
        eventData.eventFlags = GW::I::GWindowInterface::Events::MOVE;
        eventData.height = window.frame.size.height;
        eventData.width = window.frame.size.width;
		NSSize contentSize = [window contentRectForFrameRect : window.frame].size;
		eventData.clientHeight = contentSize.height;
		eventData.clientWidth = contentSize.width;
        CGSize screenSize = [[NSScreen mainScreen] frame].size;
        eventData.windowX = window.frame.origin.x;
        eventData.windowY = screenSize.height - window.frame.origin.y - window.frame.size.height;
        eventData.windowHandle = (__bridge void*)window;

        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(eventData.eventFlags, eventData);

        GW::I::GWindowImplementation* pWindow = selfDataMembers.pWindow;
        pWindow->Push(gevent);
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowDidMiniaturize, NSNotification* notification)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GWDelegate)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GWDelegate, self);
        
        //Tells the delegate that the window has been minimized.
        NSWindow* window = notification.object;

        GW::I::GWindowInterface::EVENT_DATA& eventData = selfDataMembers.eventData;
        eventData.eventFlags = GW::I::GWindowInterface::Events::MINIMIZE;
        eventData.height = window.frame.size.height;
        eventData.width = window.frame.size.width;
		NSSize contentSize = [window contentRectForFrameRect : window.frame].size;
		eventData.clientHeight = contentSize.height;
		eventData.clientWidth = contentSize.width;
        CGSize screenSize = [[NSScreen mainScreen] frame].size;
        eventData.windowX = window.frame.origin.x;
        eventData.windowY = screenSize.height - window.frame.origin.y - window.frame.size.height;
        eventData.windowHandle = (__bridge void*)window;

        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(eventData.eventFlags, eventData);

        GW::I::GWindowImplementation* pWindow = selfDataMembers.pWindow;
        pWindow->Push(gevent);
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowDidDeminiaturize, NSNotification* notification)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GWDelegate)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GWDelegate, self);
        
        //Tells the delegate that the window has been deminimized.
        NSWindow* window = notification.object;

        GW::I::GWindowInterface::EVENT_DATA& eventData = selfDataMembers.eventData;
        eventData.eventFlags = GW::I::GWindowInterface::Events::RESIZE;
        eventData.height = window.frame.size.height;
        eventData.width = window.frame.size.width;
		NSSize contentSize = [window contentRectForFrameRect : window.frame].size;
		eventData.clientHeight = contentSize.height;
		eventData.clientWidth = contentSize.width;
        CGSize screenSize = [[NSScreen mainScreen] frame].size;
        eventData.windowX = window.frame.origin.x;
        eventData.windowY = screenSize.height - window.frame.origin.y - window.frame.size.height;
        eventData.windowHandle = (__bridge void*)window;

        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(eventData.eventFlags, eventData);

        GW::I::GWindowImplementation* pWindow = selfDataMembers.pWindow;
        pWindow->Push(gevent);
        
        //A window might need to be redirected to another state after becoming windowed for the following reasons:
        //    - macOS does not support minimizing directly from FullScreen.
        //    - Switching between FULLSCREENBORDERED and FULLSCREENBORDERLESS leads to empty screen spaces.
        //    - Resizing a window and exiting fullscreen causes EXC_BAD_ACCESS errors.
        if (*selfDataMembers.windowNeedsRedirecting)
        {
            *selfDataMembers.windowNeedsRedirecting = false;
            selfDataMembers.pWindow->ChangeWindowStyle(*selfDataMembers.gWindowStyle);
        }
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowDidEnterFullScreen, NSNotification* notification)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GWDelegate)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GWDelegate, self);

        //The window has entered full-screen mode.
        NSWindow* window = notification.object;

        GW::I::GWindowInterface::EVENT_DATA& eventData = selfDataMembers.eventData;
        eventData.eventFlags = GW::I::GWindowInterface::Events::MAXIMIZE;
        eventData.height = window.frame.size.height;
        eventData.width = window.frame.size.width;
		NSSize contentSize = [window contentRectForFrameRect : window.frame].size;
		eventData.clientHeight = contentSize.height;
		eventData.clientWidth = contentSize.width;
        CGSize screenSize = [[NSScreen mainScreen] frame].size;
        eventData.windowX = window.frame.origin.x;
        eventData.windowY = screenSize.height - window.frame.origin.y - window.frame.size.height;
        eventData.windowHandle = (__bridge void*)window;

        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(eventData.eventFlags, eventData);

        GW::I::GWindowImplementation* pWindow = selfDataMembers.pWindow;
        pWindow->Push(gevent);
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowDidExitFullScreen, NSNotification* notification)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GWDelegate)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GWDelegate, self);
        
        //The window has left full-screen mode.
        
        if (*selfDataMembers.windowNeedsRedirecting)
        {
            *selfDataMembers.windowNeedsRedirecting = false;
            selfDataMembers.pWindow->ChangeWindowStyle(*selfDataMembers.gWindowStyle);
        }
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GWDelegate, void, windowWillClose, NSNotification* notification)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GWDelegate)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GWDelegate, self);
        
        //Tells the delegate that the window is about to close.
        NSWindow* window = notification.object;

        GW::I::GWindowInterface::EVENT_DATA& eventData = selfDataMembers.eventData;
        eventData.eventFlags = GW::I::GWindowInterface::Events::DESTROY;
        eventData.height = window.frame.size.height;
        eventData.width = window.frame.size.width;
		NSSize contentSize = [window contentRectForFrameRect : window.frame].size;
		eventData.clientHeight = contentSize.height;
		eventData.clientWidth = contentSize.width;
        CGSize screenSize = [[NSScreen mainScreen] frame].size;
        eventData.windowX = window.frame.origin.x;
        eventData.windowY = screenSize.height - window.frame.origin.y - window.frame.size.height;
        eventData.windowHandle = (__bridge void*)window;

        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(eventData.eventFlags, eventData);

        *selfDataMembers.windowWasDestroyed = true;
        GW::I::GWindowImplementation* pWindow = selfDataMembers.pWindow;
        pWindow->Push(gevent);
    }

    // GWDelegate Implementation End
}

#undef GWINDOW_EVENT_FLUSHES
#undef GWINDOW_SLEEP_TIME_BETWEEN_FLUSHES
#undef GWINDOW_FLUSH_MAC_EVENTS_SEVERAL_TIMES


#elif defined(__linux__)
    #include <X11/Xlib.h>
#include <X11/Xatom.h>
#include <X11/Xutil.h>
#include <X11/Xresource.h>
#include <limits.h>
#include <unistd.h>
#include <string.h>
#include <thread>

// This file is automatically generated by our CMake build scripts.
// Authors: Gerard Vega (original CMake build system) & Yangjie Yao(Wolfram auto-versioning)

#ifndef GVERSION_HPP
#define GVERSION_HPP

// Ensure developers are only building Gateware on x64 platforms.
static_assert(sizeof(void*) == 8, "Gateware supports x64 platforms only.");

// The Major version is increased when a new library is added.(minor & patch are reset)
#define GATEWARE_MAJOR 2
// The Minor version is increased whenever an interface is altered.(patch is reset)
#define GATEWARE_MINOR 0
// The Patch version is increased whenever a bug or leak is fixed.(nothing is reset)
#define GATEWARE_PATCH 'b'
// Pulled directly from GIT  
#define GATEWARE_BRANCH "master"
// Pulled directly from GIT
#define GATEWARE_COMMIT_HASH 0x96078a9
// Standard Window Title Bar
#define GATEWARE_VERSION_STRING "Gateware v2.0b"
// Window Title Bar displayed in DEBUG builds
#define GATEWARE_VERSION_STRING_LONG "Gateware v2.0b (master) [96078a9]"

#endif



// Depending on the hardware, the default color buffer size isn't always 32-bit.
// GLX is needed to create a window for OpenGL with a 32-bit color buffer.
#if defined(GATEWARE_ENABLE_GRAPHICS) && !defined(GATEWARE_DISABLE_GOPENGLSURFACE)
#include <GL/glx.h>
#endif

//#define GWINDOW_DEBUG_LINUX_OUTPUT_EVENTS // Enables debug output of GWindow events.
//#define GWINDOW_DEBUG_LINUX_OUTPUT_EVENT_DATA // Enables debug output of GWindow event data.
//#define GWINDOW_DEBUG_LINUX_OUTPUT_EVENTS_EVENTS_PROCESSED // Enable output of events processed.
//#define GWINDOW_DEBUG_LINUX_OUTPUT_X11_EVENTS // Enables debug output of X11 events.
//#define GWINDOW_DEBUG_LINUX_OUTPUT_GETWINDOWPOSITIONANDSIZE // Enables debug output of calls to GetWindowPositionAndSize().
//#define GWINDOW_DEBUG_LINUX_OUTPUT_ISWINDOWDIFFERENT // Enables debug output of calls to IsWindowDifferent().
//#define GWINDOW_DEBUG_LINUX_OUTPUT_TRAVERSEWINDOWTREEFORRESERVEDSPACE // Enables debug output of calls to TraverseWindowTreeForReservedSpace().
//#define GWINDOW_DEBUG_LINUX_OUTPUT_GETUNRESERVEDSPACE // Enables debug output of calls to GetUnreservedSpace().
//#define GWINDOW_DEBUG_LINUX_OUTPUT_SETUPATOM // Enables debug output of calls to SetupAtom().
//#define GWINDOW_DEBUG_LINUX_OUTPUT_XERROREVENTS // Enables debug output of calls to HandleError().
//#define GWINDOW_DEBUG_LINUX_OUTPUT_GETWINDOWBORDERSIZES // Enables debug output of calls to GetWindowBorderSizes().
//#define GWINDOW_DEBUG_LINUX_OUTPUT_GETCLIENTTOPLEFT // Enables debug output of calls to GetClientTopLeft().
//#define GWINDOW_DEBUG_LINUX_OUTPUT_RETRIES // Enables debug output of retries made by G_RETRY_IF_FAILED().

// Retries a function that returns a bool if the return value is false. This macro was specifically
// made for calling X11 functions that may fail at first but then return success when called later.
// This is one of the many frustrations of working with X server. It forced me to do this. I don't
// like it. Please, find a better way.
#define G_RETRY_IF_FAILED(function_call)\
	constexpr unsigned int SLEEP_TIME = 100;\
	constexpr unsigned int MAX_RETRIES = 5;\
	unsigned int g_retries = 0;\
	bool g_success = false;\
	do\
	{\
		g_success = function_call;\
		if (!g_success)\
		{\
			std::this_thread::sleep_for(std::chrono::milliseconds(SLEEP_TIME));\
			++g_retries;\
		}\
	}\
	while (!g_success && g_retries <= MAX_RETRIES)

namespace GW
{
	namespace I
	{
		class GWindowImplementation :	public virtual GWindowInterface,
										public GEventGeneratorImplementation
		{
		private:
			Display* display;
			Window window;

			bool destroyEventIsSentByXButton;
			bool windowIsRunning;
			Atom prop_type;
			Atom prop_full;
			Atom prop_hMax;
			Atom prop_vMax;
			Atom prop_strut;
			//Atom prop_strutPartial; // Similar to prop_strut.
			//Atom prop_workArea; // Use to get dimensions across multiple screens.
			Atom prop_client;
			Atom prop_hints;
			Atom prop_hidden;
			Atom prop_active;
			Atom prop_extents;
			Atom prop_close;
			Atom wmDeleteMessage;

			struct Hint
			{
				unsigned long flags;
				unsigned long functions;
				unsigned long decorations;
				long inputMode;
				unsigned long status;

			} hint;

			int m_WindowX;
			int m_WindowY;
			int m_WindowWidth;
			int m_WindowHeight;
			SYSTEM::GWindowStyle m_WindowStyle;
			
			int prevX; int prevY;
			unsigned int prevWidth; unsigned int prevHeight;
			
			GEvent m_GEvent;
			Events m_prevEvent;

			unsigned long* m_iconPixels;
			int m_iconPixelsCount;
			
#if defined(GWINDOW_DEBUG_LINUX_OUTPUT_EVENTS)
			void DebugOutputGWindowEvent(EVENT_DATA _eventData)
			{
				switch (_eventData.eventFlags)
				{
				case Events::MINIMIZE: 			printf("GWindowEvent: MINIMIZE(%d)\n", static_cast<int>(_eventData.eventFlags)); 			break;
				case Events::MAXIMIZE: 			printf("GWindowEvent: MAXIMIZE(%d)\n", static_cast<int>(_eventData.eventFlags));			break;
				case Events::RESIZE: 			printf("GWindowEvent: RESIZE(%d)\n", static_cast<int>(_eventData.eventFlags));				break;
				case Events::MOVE: 				printf("GWindowEvent: MOVE(%d)\n", static_cast<int>(_eventData.eventFlags));				break;
				case Events::DISPLAY_CLOSED: 	printf("GWindowEvent: DISPLAY_CLOSED(%d)\n", static_cast<int>(_eventData.eventFlags));		break;
#if defined(GWINDOW_DEBUG_LINUX_OUTPUT_EVENTS_EVENTS_PROCESSED)
				case Events::EVENTS_PROCESSED:	printf("GWindowEvent: EVENTS_PROCESSED(%d)\n", static_cast<int>(_eventData.eventFlags));	break;
#endif
				case Events::DESTROY: 			printf("GWindowEvent: DESTROY(%d)\n", static_cast<int>(_eventData.eventFlags));				break;
				default: 
					break;
				}
				
#if defined(GWINDOW_DEBUG_LINUX_OUTPUT_EVENT_DATA)
				if (_eventData.eventFlags != Events::EVENTS_PROCESSED)
				{
					printf("x:%-5d y:%-5d width:%-5u height:%-5u clientWidth:%-5u clientHeight:%-5u\n",
						   _eventData.windowX,
						   _eventData.windowY,
						   _eventData.width,
						   _eventData.height,
						   _eventData.clientWidth,
						   _eventData.clientHeight);
				}
#endif
			}
#else
			void DebugOutputGWindowEvent(EVENT_DATA _eventData) {}
#endif

#if defined(GWINDOW_DEBUG_LINUX_OUTPUT_X11_EVENTS)
			void DebugOutputX11Event(XEvent& _event)
			{
				switch (_event.type)
				{
					case Expose: 			printf("X11 XEvent: Expose(%d)\n", _event.type);			break;
					case SelectionClear: 	printf("X11 XEvent: SelectionClear(%d)\n", _event.type);	break;
					case SelectionNotify: 	printf("X11 XEvent: SelectionNotify(%d)\n", _event.type);	break;
					case SelectionRequest: 	printf("X11 XEvent: SelectionRequest(%d)\n", _event.type);	break;
					case NoExpose: 			printf("X11 XEvent: NoExpose(%d)\n", _event.type);			break;
					case ButtonPress: 		printf("X11 XEvent: ButtonPress(%d)\n", _event.type);		break;
					case PropertyNotify:
					{
						Atom actual_type = 0;
						int actual_format = 0;
						unsigned long nitems = 0;
						unsigned long bytes_after = 0;
						unsigned char* propRet = nullptr;
						
						int status = XGetWindowProperty(_event.xproperty.display, _event.xproperty.window, prop_type, 0L, sizeof(Atom),
							false, AnyPropertyType, &actual_type, &actual_format, &nitems, &bytes_after, &propRet);
						
						if (status == Success && propRet && nitems > 0)
						{
							Atom prop = reinterpret_cast<Atom*>(propRet)[0];
							XFree(propRet);
							
							if (prop == prop_hidden)
								printf("X11 XEvent: PropertyNotify(%d), Atom: prop_hidden(%d)\n", _event.type, prop);
							else if (prop == prop_full)
								printf("X11 XEvent: PropertyNotify(%d), Atom: prop_full(%d)\n", _event.type, prop);
							else if (prop == prop_hMax)
								printf("X11 XEvent: PropertyNotify(%d), Atom: prop_hMax(%d)\n", _event.type, prop);
							else if (prop == prop_vMax)
								printf("X11 XEvent: PropertyNotify(%d), Atom: prop_vMax(%d)\n", _event.type, prop);
							else
								printf("X11 XEvent: PropertyNotify(%d), Atom: unknown(%d)\n", _event.type, prop);
						}
						else
						{
							printf("X11 XEvent: PropertyNotify(%d)\n", _event.type);
						}
						break;
					}
					case ConfigureNotify:
						printf("X11 XEvent: ConfigureNotify(%d)\n", _event.type);
						break;
					case ClientMessage:
					{
						if (_event.xclient.message_type == prop_hidden)
							printf("X11 XEvent: ClientMessage(%d), message_type: prop_hidden(%d)\n", _event.type, _event.xclient.message_type);
						else if (_event.xclient.message_type == prop_full)
							printf("X11 XEvent: ClientMessage(%d), message_type: prop_full(%d)\n", _event.type, _event.xclient.message_type);
						else if (_event.xclient.data.l[0] == wmDeleteMessage)
							printf("X11 XEvent: ClientMessage(%d), data.l[0]: wmDeleteMessage(%d)\n", _event.type, _event.xclient.data.l[0]);
						else
							printf("X11 XEvent: ClientMessage(%d), message_type: unknown(%d), data.l[0]: unknown(%d)\n", _event.type, _event.xclient.message_type, _event.xclient.data.l[0]);
						break;
					}
					default:
						break;
				}
			}
#else
			void DebugOutputX11Event(XEvent& _event) {}
#endif

			void SetInteralData(int _x, int _y, int _width, int _height, SYSTEM::GWindowStyle _style)
			{
				m_WindowX = _x;
				m_WindowY = _y;
				m_WindowWidth = _width;
				m_WindowHeight = _height;
				m_WindowStyle = _style;
			}

			GReturn OpenWindow()
			{
				if (display && window)
					return GReturn::REDUNDANT;
				
				XInitThreads();
				XSetWindowAttributes attributes;
				XSizeHints rect;
				
				display = XOpenDisplay(NULL);
				if (!display)
					return GReturn::FAILURE;
					
				int screen = DefaultScreen(display);
				int depth = DefaultDepth(display, screen);
				
				unsigned long valueMask = CWBackPixel | CWBorderPixel | CWEventMask;
								
				attributes.background_pixel = XWhitePixel(display, 0);
				attributes.border_pixel = XBlackPixel(display, 0);
				attributes.event_mask = SubstructureNotifyMask | PropertyChangeMask | ExposureMask | StructureNotifyMask;

				m_iconPixels = nullptr;
				m_iconPixelsCount = 0;

// If OpenGL is enabled then we need to make sure we create a window with a 32-bit color buffer.
#if defined(GATEWARE_ENABLE_GRAPHICS) && !defined(GATEWARE_DISABLE_GOPENGLSURFACE)
				
				constexpr int colorBufferSize = 32;
				
				XVisualInfo visualTemplate;
				visualTemplate.screen = screen;
				
				int visualListCount = 0;
				XVisualInfo *visualList = XGetVisualInfo(display, VisualScreenMask, &visualTemplate, &visualListCount);
				
				// Search through the list of visuals for a match with our target depth and color buffer.
				XVisualInfo* visualInfo = nullptr;
				for (int i = 0; i < visualListCount; ++i)
				{
					if (visualList[i].depth == depth)
					{
						int bufferSizeAtIndex;
						glXGetConfig(display, &visualList[i], GLX_BUFFER_SIZE, &bufferSizeAtIndex);
						
						if (bufferSizeAtIndex == colorBufferSize)
						{
							visualInfo = &visualList[i];
							break;
						}
					}						
				}
				
				if (!visualInfo)
				{
					XFree(visualList);
					XCloseDisplay(display);
					return GReturn::FAILURE;
				}

				valueMask |= CWColormap;
				attributes.colormap = XCreateColormap(display, XDefaultRootWindow(display), visualInfo->visual, AllocNone);

				window = XCreateWindow(display, XRootWindow(display, screen), m_WindowX, m_WindowY, m_WindowWidth, m_WindowHeight, 5,
					visualInfo->depth, InputOutput, visualInfo->visual, valueMask, &attributes);
				
				// No longer need visual info
				XFree(visualList);
				visualInfo = nullptr;
				
#else // Use the color buffer size from the parent if OpenGL is not being used.

				window = XCreateWindow(display, XRootWindow(display, screen), m_WindowX, m_WindowY, m_WindowWidth, m_WindowHeight, 5,
					depth, InputOutput, CopyFromParent, valueMask, &attributes);

#endif
				
				if (!window)
				{
					XCloseDisplay(display);
					return GReturn::FAILURE;
				}
				
				prevX = m_WindowX;
				prevY = m_WindowY;
				prevWidth = m_WindowWidth;
				prevHeight = m_WindowHeight;

#ifdef _DEBUG
#define GATEWARE_WINDOW_NAME GATEWARE_VERSION_STRING_LONG
#else
#define GATEWARE_WINDOW_NAME GATEWARE_VERSION_STRING
#endif
				XStoreName(display, window, GATEWARE_WINDOW_NAME);
#undef GATEWARE_WINDOW_NAME

				// Set rect hints
				memset(&rect, 0, sizeof(rect));
				rect.flags = PSize | PPosition;
				
				XSetWMNormalHints(display, window, &rect);

				if (XMapWindow(display, window))
				{
					m_prevEvent = Events::EVENTS_PROCESSED;
					SetupAtom();

					// The window manager may not create the window at the desired position.
					// This call to XMoveWindow ensures that the window ends up at the desired positon.
					XMoveWindow(display, window, m_WindowX, m_WindowY);
					
					if (m_WindowStyle == SYSTEM::GWindowStyle::WINDOWEDLOCKED)
					{
						memset(&rect, 0, sizeof(rect));
						rect.flags = PMinSize | PMaxSize;
						rect.min_width = rect.max_width = m_WindowWidth;
						rect.min_height = rect.max_height = m_WindowHeight;
						XSetWMNormalHints(display, window, &rect);
					}
					else if (m_WindowStyle == SYSTEM::GWindowStyle::WINDOWEDBORDERLESS || m_WindowStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERLESS)
					{						
						hint.flags = 2; //2
						hint.decorations = 0; //0
						XChangeProperty(display, window, prop_hints, prop_hints, 32, PropModeReplace, (unsigned char*)&hint, 5);
					}
					else if (m_WindowStyle == SYSTEM::GWindowStyle::MINIMIZED)
					{
						if (!XIconifyWindow(display, window, DefaultScreen(display)))
							return GReturn::FAILURE;
					}
					
					if (m_WindowStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERED || m_WindowStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERLESS)
					{
						Screen* screen = DefaultScreenOfDisplay(display);
						if (!XMoveResizeWindow(display, window, 0, 0, screen->width, screen->height))
							return GReturn::FAILURE;
					}
					
					XSetWMProtocols(display, window, &wmDeleteMessage, 1);
					XSetErrorHandler(HandleError);

					windowIsRunning = true;
					destroyEventIsSentByXButton = false;
					return GReturn::SUCCESS;
				}
				else
				{
					XCloseDisplay(display);
					return GReturn::FAILURE;
				}
			}
			
			// Handles errors reported by X. This is needed to capture unsuccessful calls
			// to XQueryTree and prevent the error from terminating the program.
			static int HandleError(Display* _display, XErrorEvent* _errorEvent)
			{
#if defined(GWINDOW_DEBUG_LINUX_OUTPUT_XERROREVENTS)
				constexpr unsigned int MSG_LEN = 256;
				char msg[MSG_LEN];
				XGetErrorText(_display, _errorEvent->error_code, msg, MSG_LEN);
				printf("XErrorEvent(): %s\n", msg);
#endif
				return 0;
			}
			
			void SetupAtom()
			{
				prop_type = XInternAtom(display, "_NET_WM_STATE", False);
				prop_full = XInternAtom(display, "_NET_WM_STATE_FULLSCREEN", False);
				prop_hMax = XInternAtom(display, "_NET_WM_STATE_MAXIMIZED_HORZ", False);
				prop_vMax = XInternAtom(display, "_NET_WM_STATE_MAXIMIZED_VERT", False);
				prop_strut = XInternAtom(display, "_NET_WM_STRUT", False);
				// These aren't needed now but might be needed in the future.
				//prop_strutPartial = XInternAtom(display, "_NET_WM_STRUT_PARTIAL", False);
				//prop_workArea = XInternAtom(display, "_NET_WM_WORKAREA", False);
				prop_client = XInternAtom(display, "_NET_CLIENT_LIST", False);
				prop_hints = XInternAtom(display, "_MOTIF_WM_HINTS", False);
				prop_hidden = XInternAtom(display, "_NET_WM_STATE_HIDDEN", False);
				prop_active = XInternAtom(display, "_NET_ACTIVE_WINDOW", True);
				prop_extents = XInternAtom(display, "_NET_FRAME_EXTENTS", False);
				prop_close = XInternAtom(display, "WM_DESTROY_WINDOW", False);
				wmDeleteMessage = XInternAtom(display, "WM_DELETE_WINDOW", False);
						
#if defined(GWINDOW_DEBUG_LINUX_OUTPUT_SETUPATOM)
				printf("SetupAtom() prop_type:%lu prop_full:%lu prop_hMax:%lu prop_vMax:%lu\n"
					   "            prop_strut:%lu prop_client:%lu prop_hints:%lu prop_hidden:%lu\n"
					   "            prop_active:%lu prop_extents:%lu prop_close:%lu wmDeleteMessage:%lu\n", 
						prop_type,
						prop_full,
						prop_hMax,
						prop_vMax,
						prop_strut,
						prop_client,
						prop_hints,
						prop_hidden,
						prop_active,
						prop_extents,
						prop_close,
						wmDeleteMessage);
#endif
			}
			
			// Brings the window out of the minimize (aka iconified) state to the restore state only
			// if necessary. Returns if successful.
			bool UnminimizeWindow()
			{
				XClientMessageEvent evUnMinEvent;
				memset(&evUnMinEvent, 0, sizeof evUnMinEvent);
				evUnMinEvent.type = ClientMessage;
				evUnMinEvent.window = window;
				evUnMinEvent.message_type = prop_active;
				evUnMinEvent.format = 32;
				evUnMinEvent.data.l[0] = 1;
				evUnMinEvent.data.l[1] = CurrentTime;
				evUnMinEvent.data.l[2] = evUnMinEvent.data.l[3] = evUnMinEvent.data.l[4] = 0;

				return static_cast<bool>(XSendEvent(
					display, 
					RootWindow(display, XDefaultScreen(display)), 
					False,
					SubstructureRedirectMask | SubstructureNotifyMask, 
					(XEvent*)&evUnMinEvent
				));
			}
			
			// Brings the window out of the maximize state to the restore state if necessary. 
			// Returns if successful.
			bool UnmaximizeWindow()
			{
				XEvent unMaxEvent;
				unMaxEvent.type = ClientMessage;
				unMaxEvent.xclient.window = window;
				unMaxEvent.xclient.message_type = prop_type;
				unMaxEvent.xclient.format = 32;
				unMaxEvent.xclient.data.l[0] = 0;
				unMaxEvent.xclient.data.l[1] = prop_hMax;
				unMaxEvent.xclient.data.l[2] = prop_vMax;
				unMaxEvent.xclient.data.l[3] = 0;
				unMaxEvent.xclient.data.l[4] = 0;

				return static_cast<bool>(XSendEvent(
					display, 
					RootWindow(display, XDefaultScreen(display)), 
					False,
					SubstructureRedirectMask | SubstructureNotifyMask, 
					&unMaxEvent
				));
			}
			
			// Changes the decorations of the window depending on the given style. Returns if successful.
			bool StylizeWindow(SYSTEM::GWindowStyle _style)
			{
				// Minimized does not change the appearance of the window.
				if (_style == SYSTEM::GWindowStyle::MINIMIZED)
					return false;
				
				memset(&hint, 0, sizeof(hint));
				
				switch (_style)
				{
				case SYSTEM::GWindowStyle::WINDOWEDBORDERED:
				case SYSTEM::GWindowStyle::FULLSCREENBORDERED:
				case SYSTEM::GWindowStyle::WINDOWEDLOCKED:
				{
					hint.flags = 2;
					hint.decorations = 5;
					break;
				}
				case SYSTEM::GWindowStyle::WINDOWEDBORDERLESS:
				case SYSTEM::GWindowStyle::FULLSCREENBORDERLESS:
				{
					hint.flags = 2;
					hint.decorations = 0;
					break;
				}
				}

				return static_cast<bool>(XChangeProperty(
					display,
					window,
					prop_hints,
					prop_hints,
					32,
					PropModeReplace,
					(unsigned char*)&hint,
					5
				));
			}
			
			// Permits the window to be resized by mouse or programmatically.
			void EnableWindowResizing()
			{				
				XSizeHints rect;
				memset(&rect, 0, sizeof(rect));
				rect.flags = PMinSize | PMaxSize;
				rect.min_width = rect.min_height = 0;
				rect.max_width = rect.max_height = std::numeric_limits<int>::max(); // max int value
				XSetWMNormalHints(display, window, &rect); // Returns void, so hopefully x does this for us.
			}
			
			// Restricts resizing of the window by mouse or programmatically.
			void DisableWindowResizing()
			{				
				XSizeHints rect;
				memset(&rect, 0, sizeof(rect));
				rect.flags = PMinSize | PMaxSize;
				rect.min_width = rect.max_width = m_WindowWidth;
				rect.min_height = rect.max_height = m_WindowHeight;
				XSetWMNormalHints(display, window, &rect);
			}
			
			// Minimizes the window. Returns if successful.
			bool MinimizeWindow()
			{				
				XEvent ev;
				memset(&ev, 0, sizeof ev);
				ev.type = PropertyNotify;
				ev.xclient.window = window;
				ev.xclient.message_type = prop_hidden;
				ev.xclient.format = 32;
				ev.xclient.data.l[0] = 1; // _NET_WM_STATE_ADD
				ev.xclient.data.l[1] = prop_hidden;
				
				return static_cast<bool>(XSendEvent(
					display, 
					window, 
					False, 
					PropertyChangeMask, 
					&ev
				));
			}
			
			// Maximizes the window. Returns if successful.
			bool MaximizeWindow()
			{
				XEvent ev;
				memset(&ev, 0, sizeof ev);
				ev.type = ClientMessage;
				ev.xclient.window = window;
				ev.xclient.message_type = prop_type;
				ev.xclient.format = 32;
				ev.xclient.data.l[0] = 1; // _NET_WM_STATE_ADD
				ev.xclient.data.l[1] = prop_hMax;
				ev.xclient.data.l[2] = prop_vMax;
				
				return static_cast<bool>(XSendEvent(
					display, 
					DefaultRootWindow(display), 
					False, 
					SubstructureNotifyMask, 
					&ev
				));
			}
			
			// Moves and resize the window. Returns if successful.
			bool MoveAndResizeWindow(int _x, int _y, int _width, int _height)
			{	
				return static_cast<bool>(XMoveResizeWindow(
					display, 
					window, 
					_x, 
					_y, 
					_width, 
					_height
				));
			}
			
			// Gets the window border sizes. Returns if successful.
			bool GetWindowBorderSizes(long& _titleBarHeight, long& _bottomBorderHeight, 
										  long& _leftBorderWidth, long& _rightBorderWidth) const
			{
				if (!windowIsRunning || !display || !window)
					return false;
				
				// On Ubuntu, even if we remove the border of the window, GetWindowProperty() will
				// return a titlebar height greater than 0. To get around this we'll just set every
				// thing to 0 when we know we're using a borderless window style.
				if (m_WindowStyle == SYSTEM::GWindowStyle::WINDOWEDBORDERLESS ||
					m_WindowStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERLESS)
				{
					_leftBorderWidth = 0;
					_rightBorderWidth = 0;
					_titleBarHeight = 0;
					_bottomBorderHeight = 0;
				}
				else
				{
					// Get the window frame dimensions.
					Atom actualType;
					int actualFormat;
					unsigned long nItems;
					unsigned long bytesAfter;
					unsigned char* extents = nullptr;				
					int result = XGetWindowProperty(display, window, prop_extents, 
													0L, 4L, false, 
													AnyPropertyType, &actualType, &actualFormat,
													&nItems, &bytesAfter, &extents);
					
					if (result != Success || nItems != 4 || bytesAfter != 0 || !extents)
					{
	#if defined(GWINDOW_DEBUG_LINUX_OUTPUT_GETWINDOWBORDERSIZES)
						printf("GetWindowBorderSizes() Call to XGetWindowProperty() failed %d \n", result);
	#endif
						return false;
					}
					
					_leftBorderWidth = reinterpret_cast<long*>(extents)[0];
					_rightBorderWidth = reinterpret_cast<long*>(extents)[1];
					_titleBarHeight = reinterpret_cast<long*>(extents)[2];
					_bottomBorderHeight = reinterpret_cast<long*>(extents)[3];
					XFree(extents);
				}
				
#if defined(GWINDOW_DEBUG_LINUX_OUTPUT_GETWINDOWBORDERSIZES)
				printf("GetWindowBorderSizes() titlebar:%d left:%d right:%d bottom:%d\n", 
						_titleBarHeight,
						_leftBorderWidth,
						_rightBorderWidth,
						_bottomBorderHeight);
#endif
				
				return true;
			}
			
			// Gets the window frame and client position and dimensions data. Returns if successful.
			bool GetWindowPositionAndSize(int& _frameX, int& _frameY, unsigned int& _frameWidth, unsigned int& _frameHeight, 
										  int& _clientX, int& _clientY, unsigned int& _clientWidth, unsigned int& _clientHeight) const
			{
				if (!windowIsRunning || !display || !window)
					return false;
				
				// Get the root.
				int x, y;
				unsigned int borderWidth, depth;
				Window child, root;
				if (!XGetGeometry(display, window, &root, &x, &y, &_clientWidth, &_clientHeight, &borderWidth, &depth))
				{
#if defined(GWINDOW_DEBUG_LINUX_OUTPUT_GETWINDOWPOSITIONANDSIZE)
					printf("GetWindowPositionAndSize() call to XGetGeometry() failed%d\n", 0);
#endif
					return false;
				}
					
				// Bring the window coordinates into root space.
				if (!XTranslateCoordinates(display, window, root, 0, 0, &_clientX, &_clientY, &child))					
				{
#if defined(GWINDOW_DEBUG_LINUX_OUTPUT_GETWINDOWPOSITIONANDSIZE)
					printf("XTranslateCoordinates() call to XGetGeometry() failed%d\n", 0);
#endif
					return false;
				}
				
				// Get the window frame dimensions.
				Atom actualType;
				int actualFormat;
				unsigned long nItems;
				unsigned long bytesAfter;
				unsigned char* extents = nullptr;				
				int result = XGetWindowProperty(display, window, prop_extents, 
												0L, 4L, false, 
												AnyPropertyType, &actualType, &actualFormat,
												&nItems, &bytesAfter, &extents);
				
				if (result != Success || nItems != 4 || bytesAfter != 0 || !extents)
				{
#if defined(GWINDOW_DEBUG_LINUX_OUTPUT_GETWINDOWPOSITIONANDSIZE)
					printf("GetWindowPositionAndSize() call to XGetWindowProperty() failed%d\n", 0);
#endif
					return false;
				}
				
				long leftBorderWidth = reinterpret_cast<long*>(extents)[0];
				long rightBorderWidth = reinterpret_cast<long*>(extents)[1];
				long titleBarHeight = reinterpret_cast<long*>(extents)[2];
				long bottomBorderHeight = reinterpret_cast<long*>(extents)[3];
				XFree(extents);
				
				// X and y are at client area's top-left at the moment. We need to subtract the border to
				// get the top-left position of the frame.
				_frameX = _clientX - static_cast<int>(leftBorderWidth);
				_frameY = _clientY - static_cast<int>(titleBarHeight);
				_frameWidth =  static_cast<unsigned int>(leftBorderWidth) + _clientWidth + static_cast<unsigned int>(rightBorderWidth);
				_frameHeight = static_cast<unsigned int>(titleBarHeight) + _clientHeight + static_cast<unsigned int>(bottomBorderHeight);
				
				// On Ubuntu, even if we remove the border of the window, XGetGeometry() will
				// set _clientWidth/Height as if there were a border. To get around this we'll
				// adjust those values to what they should be. This should be okay if we know
				// we're using a borderless window style.
				if (m_WindowStyle == SYSTEM::GWindowStyle::WINDOWEDBORDERLESS ||
					m_WindowStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERLESS)
				{
					_frameWidth = _clientWidth;
					_frameHeight = _clientHeight;
				}
				
#if defined(GWINDOW_DEBUG_LINUX_OUTPUT_GETWINDOWPOSITIONANDSIZE)
				printf("GetWindowPositionAndSize() frameX:%d frameY:%d frameWidth:%u frameHeight:%u\n"
					   "                           clientX:%d clientY:%d clientWidth:%u clientHeight:%u\n", 
					   _frameX, _frameY, _frameWidth, _frameHeight,
					   _clientX, _clientY, _clientWidth, _clientHeight);
#endif

				return true;
			}
			
			// Gets the client position and dimensions data. Returns if successful.
			bool GetClientPositionAndSize(int& _clientX, int& _clientY, unsigned int& _clientWidth, unsigned int& _clientHeight) const
			{
				if (!windowIsRunning || !display || !window)
					return false;
				
				// Get the root.
				int x, y;
				unsigned int borderWidth, depth;
				Window child, root;
				if (!XGetGeometry(display, window, &root, &x, &y, &_clientWidth, &_clientHeight, &borderWidth, &depth))					
					return false;
					
				// Bring the window coordinates into root space.
				if (!XTranslateCoordinates(display, window, root, 0, 0, &_clientX, &_clientY, &child))					
					return false;
				
				return true;
			}
			
			// Compares previous window properties with those passed into the funtion and returns true if any are different.
			bool IsWindowDifferent(int& _frameX, int& _frameY, unsigned int& _clientWidth, unsigned int& _clientHeight) const
			{
#if defined(GWINDOW_DEBUG_LINUX_OUTPUT_ISWINDOWDIFFERENT)
				printf("IsWindowDifferent(): %d\n", 
					  (_frameX != prevX || 
				       _frameY != prevY || 
				       _clientWidth != prevWidth || 
				       _clientHeight != prevHeight));
#endif

				return _frameX != prevX || 
				       _frameY != prevY || 
				       _clientWidth != prevWidth || 
				       _clientHeight != prevHeight;
			}
			
			// Recursive preorder traversal of a window's children.
			bool TraverseWindowTreeForReservedSpace(
				Window _window, unsigned int _depthLimit, 
				unsigned int& _reservedLeft, unsigned int& _reservedRight, 
				unsigned int& _reservedTop, unsigned int& _reservedBottom,
				unsigned int _depth = 0
			) const
			{
				if (!display || !window || !_window)
					return false;
				
				Window root, parent;
				Window* children;
				unsigned int numChildren;				
				if (XQueryTree(display, _window, &root, &parent, &children, &numChildren) == 0)
					return false;
				
#if defined (GWINDOW_DEBUG_LINUX_OUTPUT_TRAVERSEWINDOWTREEFORRESERVEDSPACE)
				printf("TraverseWindowTreeForReservedSpace(): numChildren:%u\n", numChildren);
#endif
				
				for (int i = 0; i < numChildren; ++i)
				{
					Atom actualType;
					int actualFormat;
					unsigned long nItems, bytesAfter;
					unsigned char* extents = nullptr;
					int status = XGetWindowProperty(display, _window, prop_strut, 
													0, 12, False, XA_CARDINAL,
													&actualType, &actualFormat, &nItems, &bytesAfter, &extents);

#if defined (GWINDOW_DEBUG_LINUX_OUTPUT_TRAVERSEWINDOWTREEFORRESERVEDSPACE)
					if (actualType == XA_CARDINAL)
						printf("TraverseWindowTreeForReservedSpace(): i:%u, status:%d, actualType:%d, actualFormat:%d, nItems:%u\n", i, status, static_cast<int>(actualType), actualFormat, nItems);
#endif
					if (status == Success && actualType == XA_CARDINAL && actualFormat == 32 && nItems >= 4)
					{
#if defined (GWINDOW_DEBUG_LINUX_OUTPUT_TRAVERSEWINDOWTREEFORRESERVEDSPACE)
						printf("TraverseWindowTreeForReservedSpace(): calculating space %d\n", 0);
#endif

						unsigned long* struts = reinterpret_cast<unsigned long*>(extents);
						unsigned int spaceReservedLeft = static_cast<unsigned int>(struts[0]);
						unsigned int spaceReservedRight = static_cast<unsigned int>(struts[1]);
						unsigned int spaceReservedTop = static_cast<unsigned int>(struts[2]);
						unsigned int spaceReservedBottom = static_cast<unsigned int>(struts[3]);
						
						if (spaceReservedLeft > _reservedLeft) 		_reservedLeft = spaceReservedLeft;
						if (spaceReservedRight > _reservedRight) 	_reservedRight = spaceReservedRight;
						if (spaceReservedTop > _reservedTop) 		_reservedTop = spaceReservedTop;
						if (spaceReservedBottom > _reservedBottom) 	_reservedBottom = spaceReservedBottom;
					}
					
					if (extents)
						XFree(extents);
					
#if defined (GWINDOW_DEBUG_LINUX_OUTPUT_TRAVERSEWINDOWTREEFORRESERVEDSPACE)
					if (actualType == XA_CARDINAL)
						printf("TraverseWindowTreeForReservedSpace(): _depth:%u\n", _depth);
#endif

					if (_depth < _depthLimit)
					{
						TraverseWindowTreeForReservedSpace(
							children[i], _depthLimit, 
							_reservedLeft, _reservedRight, 
							_reservedTop, _reservedBottom,
							_depth + 1
						);
					}
				}
				
				return true;
			}
			
			// Reserved space is the area occupied by the things like the taskbar or dock. Therefore, unreserved
			// space is where our window is primarily within. This function provides the screen coordinates and
			// size of the unresereved space. It returns true, if the operation was successful.
			bool GetUnreservedSpace(int& _x, int& _y, unsigned int& _width, unsigned int& _height) const
			{
				if (!windowIsRunning || !display || !window)
					return false;
				
				// In tests, the strut information was only at a depth of 3. However, this may be different
				// depending on someone's Linux installation.
				constexpr unsigned int DEPTH_LIMIT = 5;
				
				unsigned int reservedLeft = 0, reservedRight = 0, reservedTop = 0, reservedBottom = 0;
				
				bool success = TraverseWindowTreeForReservedSpace(
					RootWindow(display, XDefaultScreen(display)),
					DEPTH_LIMIT,
					reservedLeft, reservedRight,
					reservedTop, reservedBottom
				);
				
				if (!success)
					return false;
				
				Screen* screen = DefaultScreenOfDisplay(display);
				
				_x = reservedLeft;
				_y = reservedTop;
				_width = screen->width - reservedLeft - reservedRight;
				_height = screen->height - reservedTop - reservedBottom;

#if defined(GWINDOW_DEBUG_LINUX_OUTPUT_GETUNRESERVEDSPACE)
				printf("GetUnreservedSpace() x:%d y:%d width:%u height:%u\n", _x, _y, _width, _height);
#endif
				
				return true;
			}
			
		public:
			~GWindowImplementation()
			{
				if (!windowIsRunning)
					return;
				
				if (!destroyEventIsSentByXButton)
				{
					//Delete icon
					if (m_iconPixels)
					{
						delete m_iconPixels;
						m_iconPixels = nullptr;
						m_iconPixelsCount = 0;
					}

					//Send Event Data for DESTROY
					int windowFrameX = 0, windowFrameY = 0, windowClientX = 0, windowClientY = 0;
					unsigned int windowFrameWidth = 0, windowFrameHeight = 0, windowClientWidth = 0, windowClientHeight = 0;
						
					GetWindowPositionAndSize(windowFrameX, windowFrameY, windowFrameWidth, windowFrameHeight, 
											 windowClientX, windowClientY, windowClientWidth, windowClientHeight);
											 
					windowIsRunning = false;
					
					EVENT_DATA eventData;
					eventData.eventFlags = Events::DESTROY;
					eventData.width = windowFrameWidth;
					eventData.height = windowFrameHeight;
					eventData.clientWidth = windowClientWidth;
					eventData.clientHeight = windowClientHeight;
					eventData.windowX = windowFrameX;
					eventData.windowY = windowFrameY;
					eventData.windowHandle = display;
					DebugOutputGWindowEvent(eventData);
					SetInteralData(eventData.windowX, eventData.windowY, eventData.width, eventData.height, m_WindowStyle);
					m_GEvent.Write(eventData.eventFlags, eventData);
					Push(m_GEvent);

					//Close Window and Display
					XDestroyWindow(display, window);
					XCloseDisplay(display);
					window = 0;
					display = nullptr;

					//Send Event Data for DISPLAY_CLOSED
					eventData.eventFlags = Events::DISPLAY_CLOSED;
					eventData.width = 0;
					eventData.height = 0;
					eventData.clientWidth = 0;
					eventData.clientHeight = 0;
					eventData.windowX = 0;
					eventData.windowY = 0;
					eventData.windowHandle = 0;
					DebugOutputGWindowEvent(eventData);
					SetInteralData(eventData.windowX, eventData.windowY, eventData.width, eventData.height, m_WindowStyle);
					m_GEvent.Write(eventData.eventFlags, eventData);
					Push(m_GEvent);
				}
				else
					windowIsRunning = false;
			}

			GReturn Create(int _x, int _y, int _width, int _height, SYSTEM::GWindowStyle _style)
			{
				this->SetInteralData(_x, _y, _width, _height, _style);
				return OpenWindow();
			}

			GReturn ProcessWindowEvents() override
			{
				if (!windowIsRunning || !display)
					return GReturn::FAILURE;
				
				XEvent xEvent;
				EVENT_DATA eventData;
				
				while (XPending(display) > 0)
				{
					//ZeroMemory the structs
					memset(&xEvent, 0, sizeof(xEvent));
					memset(&eventData, 0, sizeof(eventData));
					
					eventData.eventFlags = Events::DESTROY; // ensure we don't spam
					
					// Flushes the request buffer if xlib's queue does not contain an event and waits for an event to arrive from server connection
					XNextEvent(display, &xEvent);
					
					DebugOutputX11Event(xEvent);
					
					switch (xEvent.type)
					{
					default:
						break;
					case Expose: //Expose, when a window becomes visible on the screen, after being obscured or unmapped.
					case SelectionClear: //Clients losing ownership of a selection.
					case SelectionNotify: //A response to a ConvertSelection request when there is no owner for the selection
					case SelectionRequest: //A client requests a selection conversion by calling XConvertSelection() for the owned selection.
					case NoExpose: //Generates this event whenever a destination region could not be computed due to an obscured or out-of-bounds source region.
					case ButtonPress: //Respond to button press
						break;

					case PropertyNotify:
					{
						// Ensure we have a window and display
						if (!display || !window)
							break;
						
						Atom actual_type = 0;
						int actual_format = 0;
						unsigned long nitems = 0;
						unsigned long bytes_after = 0;
						unsigned char* propRet = nullptr;
						
						// PropertyNotify, when a client wants info about property changes for a specified window.
						int status = XGetWindowProperty(xEvent.xproperty.display, xEvent.xproperty.window, prop_type, 0L, sizeof(Atom),
							false, AnyPropertyType, &actual_type, &actual_format, &nitems, &bytes_after, &propRet);
						
						if (status == Success && propRet && nitems > 0)
						{
							// TODO: We are not reporting events for when the window is maximized and 
							//		 then minimize by the user's mouse click. X11 does report the
							//		 event with a type of PropertyNotify. However, in my tests prop
							//		 is given a value of prop_hMax, prop_vMax, or prop_full which 
							//		 can all be mistaken for Maximize events with our current logic.
							//		 Prop can also be 362 which I believe is an event for reporting
							//		 the user clicks something on the window frame. For the record, 
							//		 X11 is a headache.
							Atom prop = reinterpret_cast<Atom*>(propRet)[0];
							XFree(propRet);
							
							int windowFrameX, windowFrameY, windowClientX, windowClientY;
							unsigned int windowFrameWidth, windowFrameHeight, windowClientWidth, windowClientHeight;
								
							if (!GetWindowPositionAndSize(windowFrameX, windowFrameY, windowFrameWidth, windowFrameHeight, 
														  windowClientX, windowClientY, windowClientWidth, windowClientHeight))
								break;
								
							if (!IsWindowDifferent(windowFrameX, windowFrameY, windowClientWidth, windowClientHeight) && 
								prop != prop_hidden && xEvent.xclient.message_type != prop_hidden) // Don't break if we're minimizing.
								break;
							
							if ((prop == prop_hidden && m_prevEvent != Events::MINIMIZE) || xEvent.xclient.message_type == prop_hidden) // Minimize button pressed.
								eventData.eventFlags = Events::MINIMIZE;
							else if (prop == 362 || // This seems to be received whenever the user clicking on any window frame button.
									prop == prop_full || // Received the the frame fills the unreserved screen space.
									prop == prop_hMax || // Received the horizontal area of the frame fills the unreserved screen space.
									prop == prop_vMax) // Received the vertical area of the frame fills the unreserved screen space.
							{
								int unreservedX, unreservedY;
								unsigned int unreservedWidth, unreservedHeight;
								GetUnreservedSpace(unreservedX, unreservedY, unreservedWidth, unreservedHeight);
								
								if (windowFrameX == unreservedX && windowFrameY == unreservedY && windowFrameWidth == unreservedWidth && windowFrameHeight == unreservedHeight)
									eventData.eventFlags = Events::MAXIMIZE;
								else if (prop == 362)
								{
									if (prevHeight != windowClientHeight || prevWidth != windowClientWidth)
										eventData.eventFlags = Events::RESIZE;
									else if (prevX != windowFrameX || prevY != windowFrameY)
										eventData.eventFlags = Events::MOVE;
									else
										break;
								}
								else
									eventData.eventFlags = Events::MAXIMIZE;
							}
							else if (prevHeight != windowClientHeight || prevWidth != windowClientWidth)
								eventData.eventFlags = Events::RESIZE;
							else if (prevX != windowFrameX || prevY != windowFrameY)
								eventData.eventFlags = Events::MOVE;
							else
								break; // Should never reach this point based on the above checks.

							eventData.width = windowFrameWidth;
							eventData.height = windowFrameHeight;
							eventData.clientWidth = windowClientWidth;
							eventData.clientHeight = windowClientHeight;
							eventData.windowX = windowFrameX;
							eventData.windowY = windowFrameY;
							eventData.windowHandle = display;
							
							prevX = windowFrameX; 
							prevY = windowFrameY; 
							prevHeight = windowClientHeight; 
							prevWidth = windowClientWidth;
						}
						else
							XFree(propRet);
					}
					break;

					case ConfigureNotify:
					{
						int windowFrameX, windowFrameY, windowClientX, windowClientY;
						unsigned int windowFrameWidth, windowFrameHeight, windowClientWidth, windowClientHeight;
							
						if (!GetWindowPositionAndSize(windowFrameX, windowFrameY, windowFrameWidth, windowFrameHeight, 
													  windowClientX, windowClientY, windowClientWidth, windowClientHeight))
							break;
								
						if (!IsWindowDifferent(windowFrameX, windowFrameY, windowClientWidth, windowClientHeight))
							break;
						
						int unreservedX, unreservedY;
						unsigned int unreservedWidth, unreservedHeight;
						GetUnreservedSpace(unreservedX, unreservedY, unreservedWidth, unreservedHeight);
						
						if (windowFrameX == unreservedX && windowFrameY == unreservedY && windowFrameWidth == unreservedWidth && windowFrameHeight == unreservedHeight)
							eventData.eventFlags = Events::MAXIMIZE;
						else if (prevHeight != windowClientHeight || prevWidth != windowClientWidth)
							eventData.eventFlags = Events::RESIZE;
						else if (prevX != windowFrameX || prevY != windowFrameY)
							eventData.eventFlags = Events::MOVE;
						else
							break; // Should never reach this point based on the above checks.
						
						eventData.width = windowFrameWidth;
						eventData.height = windowFrameHeight;
						eventData.clientWidth = windowClientWidth;
						eventData.clientHeight = windowClientHeight;
						eventData.windowX = windowFrameX;
						eventData.windowY = windowFrameY;
						eventData.windowHandle = display;
						
						prevX = windowFrameX; 
						prevY = windowFrameY; 
						prevHeight = windowClientHeight; 
						prevWidth = windowClientWidth;
					}
					break;

					case ClientMessage:
					{
						// Primarily used for transferring selection data,
						// also might be used in a private interclient
						// protocol
						if (xEvent.xclient.message_type == prop_hidden)
						{
							int windowFrameX, windowFrameY, windowClientX, windowClientY;
							unsigned int windowFrameWidth, windowFrameHeight, windowClientWidth, windowClientHeight;
								
							if (!GetWindowPositionAndSize(windowFrameX, windowFrameY, windowFrameWidth, windowFrameHeight, 
														  windowClientX, windowClientY, windowClientWidth, windowClientHeight))
								break;
						
							eventData.eventFlags = Events::MINIMIZE;
							eventData.width = windowFrameWidth;
							eventData.height = windowFrameHeight;
							eventData.clientWidth = windowClientWidth;
							eventData.clientHeight = windowClientHeight;
							eventData.windowX = windowFrameX;
							eventData.windowY = windowFrameY;
							eventData.windowHandle = display;
							
							prevX = windowFrameX; 
							prevY = windowFrameY; 
							prevHeight = windowClientHeight; 
							prevWidth = windowClientWidth;
						}
						else if (xEvent.xclient.message_type == prop_full)
						{
							int windowFrameX, windowFrameY, windowClientX, windowClientY;
							unsigned int windowFrameWidth, windowFrameHeight, windowClientWidth, windowClientHeight;
								
							if (!GetWindowPositionAndSize(windowFrameX, windowFrameY, windowFrameWidth, windowFrameHeight, 
														  windowClientX, windowClientY, windowClientWidth, windowClientHeight))
								break;
								
							if (!IsWindowDifferent(windowFrameX, windowFrameY, windowClientWidth, windowClientHeight))
								break;
						
							int unreservedX, unreservedY;
							unsigned int unreservedWidth, unreservedHeight;
							GetUnreservedSpace(unreservedX, unreservedY, unreservedWidth, unreservedHeight);
							
							if (windowFrameX == unreservedX && windowFrameY == unreservedY && windowFrameWidth == unreservedWidth && windowFrameHeight == unreservedHeight)
								eventData.eventFlags = Events::MAXIMIZE;
							else
								break; // Should never reach this point based on the above checks.
							
							eventData.width = windowFrameWidth;
							eventData.height = windowFrameHeight;
							eventData.clientWidth = windowClientWidth;
							eventData.clientHeight = windowClientHeight;
							eventData.windowX = windowFrameX;
							eventData.windowY = windowFrameY;
							eventData.windowHandle = display;
							
							prevX = windowFrameX; 
							prevY = windowFrameY; 
							prevHeight = windowClientHeight; 
							prevWidth = windowClientWidth;							
						}
						else if (xEvent.xclient.data.l[0] == wmDeleteMessage)
						{							
							windowIsRunning = false;
							destroyEventIsSentByXButton = true;
							
							int windowFrameX, windowFrameY, windowClientX, windowClientY;
							unsigned int windowFrameWidth, windowFrameHeight, windowClientWidth, windowClientHeight;
								
							GetWindowPositionAndSize(windowFrameX, windowFrameY, windowFrameWidth, windowFrameHeight, 
													 windowClientX, windowClientY, windowClientWidth, windowClientHeight);
						
							prevX = windowFrameX; prevY = windowFrameY; prevHeight = windowClientHeight; prevWidth = windowClientWidth;
							
							eventData.eventFlags = Events::DESTROY;
							eventData.width = windowFrameWidth;
							eventData.height = windowFrameHeight;
							eventData.clientWidth = windowClientWidth;
							eventData.clientHeight = windowClientHeight;
							eventData.windowX = windowFrameX;
							eventData.windowY = windowFrameY;
							eventData.windowHandle = display;
							DebugOutputGWindowEvent(eventData);
							SetInteralData(eventData.windowX, eventData.windowY, eventData.width, eventData.height, m_WindowStyle);
							m_GEvent.Write(eventData.eventFlags, eventData);
							Push(m_GEvent);
							XDestroyWindow(display, window);
							XCloseDisplay(display);
							window = 0;
							display = nullptr;


							//Send Event Data for DISPLAY_CLOSED
							eventData.eventFlags = Events::DISPLAY_CLOSED;
							eventData.width = 0;
							eventData.height = 0;
							eventData.clientWidth = 0;
							eventData.clientHeight = 0;
							eventData.windowX = 0;
							eventData.windowY = 0;
							eventData.windowHandle = 0;
							DebugOutputGWindowEvent(eventData);
							SetInteralData(eventData.windowX, eventData.windowY, eventData.width, eventData.height, m_WindowStyle);
							m_GEvent.Write(eventData.eventFlags, eventData);
							Push(m_GEvent);
							
							return GReturn::FAILURE;
						}
						else if (eventData.eventFlags == Events::DESTROY)
						{
							int windowFrameX, windowFrameY, windowClientX, windowClientY;
							unsigned int windowFrameWidth, windowFrameHeight, windowClientWidth, windowClientHeight;
								
							if (!GetWindowPositionAndSize(windowFrameX, windowFrameY, windowFrameWidth, windowFrameHeight, 
														  windowClientX, windowClientY, windowClientWidth, windowClientHeight))
								break;
							
							Screen* screen = DefaultScreenOfDisplay(display);
							
							eventData.width = windowFrameWidth;
							eventData.height = windowFrameHeight;
							eventData.clientWidth = windowClientWidth;
							eventData.clientHeight = windowClientHeight;
							eventData.windowX = windowFrameX;
							eventData.windowY = windowFrameY;
							eventData.windowHandle = display;
						}
					}
					break;
					}

					if (eventData.eventFlags != Events::DESTROY)
					{
						m_prevEvent = eventData.eventFlags; // Previous event saved so Minimize isn't spammed.
						DebugOutputGWindowEvent(eventData);
						SetInteralData(eventData.windowX, eventData.windowY, eventData.width, eventData.height, m_WindowStyle);
						m_GEvent.Write(eventData.eventFlags, eventData);
						Push(m_GEvent);
					}
				}
				
				eventData.eventFlags = Events::EVENTS_PROCESSED;
				DebugOutputGWindowEvent(eventData);
				m_GEvent.Write(eventData.eventFlags, eventData);
				Push(m_GEvent);
				
				return GReturn::SUCCESS;
			}

			GReturn ReconfigureWindow(int _x, int _y, int _width, int _height, SYSTEM::GWindowStyle _style) override
			{
				if (!windowIsRunning || !display || !window)
					return GReturn::FAILURE;

				SYSTEM::GWindowStyle previousStyle = m_WindowStyle;
				int previousX = m_WindowX;
				int previousY = m_WindowY;
				int previousWidth = m_WindowWidth;
				int previousHeight = m_WindowHeight;
				
				// If the style parameter is the same as the previous style, the all we need to do is move or resize.
				if (previousStyle == _style)
				{						
					if (previousX != _x || previousY != _y || previousWidth != _width || previousHeight != _height)
					{
						if (MoveAndResizeWindow(_x, _y, _width, _height))
							return GReturn::SUCCESS;
						else
							return GReturn::FAILURE;
					}
					
					// Nothing needs to change because all parameters match existing position, size, and style.
					return GReturn::REDUNDANT;
				}
				else // Otherwise we restyle.
				{
					SetInteralData(_x, _y, _width, _height, _style);
					
					switch (m_WindowStyle)
					{
					case SYSTEM::GWindowStyle::WINDOWEDBORDERED:
					{
						if (!UnminimizeWindow()) 
							return GReturn::FAILURE;
						
						if (!UnmaximizeWindow()) 
							return GReturn::FAILURE;
						
						if (!StylizeWindow(SYSTEM::GWindowStyle::WINDOWEDBORDERED))
							return GReturn::FAILURE;

						EnableWindowResizing();
						
						if (!MoveAndResizeWindow(_x, _y, _width, _height))
							return GReturn::FAILURE;
					}
					break;

					case SYSTEM::GWindowStyle::WINDOWEDBORDERLESS:
					{
						if (!UnminimizeWindow()) 
							return GReturn::FAILURE;
						
						if (!UnmaximizeWindow()) 
							return GReturn::FAILURE;
						
						if (!StylizeWindow(SYSTEM::GWindowStyle::WINDOWEDBORDERLESS))
							return GReturn::FAILURE;

						EnableWindowResizing();
						
						if (!MoveAndResizeWindow(_x, _y, _width, _height))
							return GReturn::FAILURE;
					}
					break;
					
					case SYSTEM::GWindowStyle::WINDOWEDLOCKED:
					{
						if (!UnminimizeWindow()) 
							return GReturn::FAILURE;
						
						if (!UnmaximizeWindow()) 
							return GReturn::FAILURE;
						
						EnableWindowResizing();
						
						if (!MoveAndResizeWindow(_x, _y, _width, _height))
							return GReturn::FAILURE;
						
						if (!StylizeWindow(SYSTEM::GWindowStyle::WINDOWEDLOCKED)) 
							return GReturn::FAILURE;
						
						DisableWindowResizing();
					}
					break;

					case SYSTEM::GWindowStyle::FULLSCREENBORDERED:
					{
						if (!UnminimizeWindow()) 
							return GReturn::FAILURE;
						
						EnableWindowResizing();
												
						if (!StylizeWindow(SYSTEM::GWindowStyle::FULLSCREENBORDERED)) 
							return GReturn::FAILURE;
						
						if (!MaximizeWindow()) 
							return GReturn::FAILURE;
					}
					break;

					case SYSTEM::GWindowStyle::FULLSCREENBORDERLESS:
					{
						if (!UnminimizeWindow()) 
							return GReturn::FAILURE;
						
						EnableWindowResizing();
						
						if (!StylizeWindow(SYSTEM::GWindowStyle::FULLSCREENBORDERLESS)) 
							return GReturn::FAILURE;
						
						if (!MaximizeWindow()) 
							return GReturn::FAILURE;
					}
					break;

					case SYSTEM::GWindowStyle::MINIMIZED:
					{
						if (!XIconifyWindow(display, window, DefaultScreen(display)))
							return GReturn::FAILURE;
						
						if (!MinimizeWindow()) 
							return GReturn::FAILURE;
					}
					break;
					}
				}
				
				return GReturn::SUCCESS;
			}

			GReturn SetWindowName(const char* _newName) override
			{
				if (_newName == nullptr)
					return GReturn::INVALID_ARGUMENT;

				if (!windowIsRunning || !display || !window)
					return GReturn::FAILURE;

				return XStoreName(display, window, _newName) != 0 ? GReturn::SUCCESS : GReturn::FAILURE;
			}

			GReturn SetIcon(int _width, int _height, const unsigned int* _argbPixels) override
			{
				if (!display || !window)
					return GReturn::FAILURE;
				
				if (_argbPixels == nullptr)
					return GReturn::INVALID_ARGUMENT;
				else if (_width <= 0 || _height <= 0)
					return GReturn::INVALID_ARGUMENT;
				
				Atom netWMIcon = XInternAtom(display, "_NET_WM_ICON", false);
				if (!netWMIcon)
					return GReturn::FAILURE;
				
				Atom cardinal = XInternAtom(display, "CARDINAL", false);
				if (!cardinal)
					return GReturn::FAILURE;
				
				const int convertedLength = 2 + _width * _height;
				unsigned long convertedPixels[convertedLength] = { 
					static_cast<unsigned long>(_width), 
					static_cast<unsigned long>(_height) 
				}; // The pixels array of the icon is prepended with the icon size.
				
				for (int i = 2; i < convertedLength; ++i)
					convertedPixels[i] = static_cast<unsigned long>(_argbPixels[i - 2]);
				
				if (!m_iconPixels)
				{
					m_iconPixelsCount = convertedLength;
					m_iconPixels = new unsigned long[m_iconPixelsCount];
					
					memcpy(m_iconPixels, convertedPixels, sizeof(unsigned long) * m_iconPixelsCount);
				}
				else
				{
					int iconStartIndex = 0;
					int existingIconWidth, existingIconHeight;
					bool iconSizeExists = false;
					
					// Search for an existing icon of the same size.
					while (iconStartIndex < m_iconPixelsCount)
					{
						existingIconWidth = m_iconPixels[iconStartIndex];
						existingIconHeight = m_iconPixels[iconStartIndex + 1];
						
						if (existingIconWidth == _width && existingIconHeight == _height)
						{
							iconSizeExists = true;
							break;
						}
						else
							iconStartIndex += 2 + existingIconWidth * existingIconHeight;
					}
					
					// Overwrite the icon if the same size icon exists.
					if (iconSizeExists)
					{
						for (int i = 2; i < convertedLength; ++i)
							m_iconPixels[iconStartIndex + i] = convertedPixels[i];
					}
					else // Otherwise, append the new icon to the existing array.
					{
						const int tempPixelsCount = m_iconPixelsCount + convertedLength;
						unsigned long* tempPixels = new unsigned long[tempPixelsCount];
						
						memcpy(tempPixels, m_iconPixels, sizeof(unsigned long) * m_iconPixelsCount);
						
						for (int i = 0; i < convertedLength; ++i)
							tempPixels[m_iconPixelsCount + i] = convertedPixels[i];
						
						delete m_iconPixels;
						
						m_iconPixels = tempPixels;
						m_iconPixelsCount = tempPixelsCount;
					}
				}
				
				// The window system will choose the icon whose size is closest to the icon display area. 
				// Icons will automatically be stretched or squashed as needed.
				XChangeProperty(display, window, netWMIcon, cardinal, 32, PropModeReplace, (const unsigned char*)m_iconPixels, m_iconPixelsCount);
				
				return GReturn::SUCCESS;
			}

			GReturn MoveWindow(int _x, int _y) override
			{
				if (!windowIsRunning || !display || !window)
					return GReturn::FAILURE;

				SetInteralData(_x, _y, m_WindowWidth, m_WindowHeight, m_WindowStyle);
				if (XMoveWindow(display, window, m_WindowX, m_WindowY))
				{
					if (m_WindowStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERED)
						m_WindowStyle = SYSTEM::GWindowStyle::WINDOWEDBORDERED;
					else if (m_WindowStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERLESS)
						m_WindowStyle = SYSTEM::GWindowStyle::WINDOWEDBORDERLESS;
					
					XEvent ev;
					memset(&ev, 0, sizeof ev);
					ev.type = PropertyNotify;
					ev.xclient.window = window;
					ev.xclient.message_type = prop_type;
					ev.xclient.format = 32;
					
					XSendEvent(display, window, False, PropertyChangeMask, &ev);
					return GReturn::SUCCESS;
				}
				return  GReturn::FAILURE;
			}

			GReturn ResizeWindow(int _width, int _height) override
			{
				if (!windowIsRunning || !display || !window)
					return GReturn::FAILURE;

				SetInteralData(m_WindowX, m_WindowY, _width, _height, m_WindowStyle);
				if (XResizeWindow(display, window, m_WindowWidth, m_WindowHeight))
				{
					if (m_WindowStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERED)
						m_WindowStyle = SYSTEM::GWindowStyle::WINDOWEDBORDERED;
					else if (m_WindowStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERLESS)
						m_WindowStyle = SYSTEM::GWindowStyle::WINDOWEDBORDERLESS;

					return GReturn::SUCCESS;
				}
				return  GReturn::FAILURE;
			}

			GReturn Maximize() override
			{
				if (m_WindowStyle == SYSTEM::GWindowStyle::WINDOWEDBORDERED || m_WindowStyle == SYSTEM::GWindowStyle::MINIMIZED)
					return ChangeWindowStyle(SYSTEM::GWindowStyle::FULLSCREENBORDERED);
				else if (m_WindowStyle == SYSTEM::GWindowStyle::WINDOWEDBORDERLESS)
					return ChangeWindowStyle(SYSTEM::GWindowStyle::FULLSCREENBORDERLESS);
				return  GReturn::REDUNDANT;
			}

			GReturn Minimize() override
			{
				return ChangeWindowStyle(SYSTEM::GWindowStyle::MINIMIZED);
			}

			GReturn ChangeWindowStyle(SYSTEM::GWindowStyle _style) override
			{
				return ReconfigureWindow(m_WindowX, m_WindowY, m_WindowWidth, m_WindowHeight, _style);
			}

			GReturn GetWidth(unsigned int& _outWidth) const override
			{
				int frameX, frameY, clientX, clientY;
				unsigned int frameWidth, frameHeight, clientWidth, clientHeight;
				
				G_RETRY_IF_FAILED(GetWindowPositionAndSize(frameX, frameY, frameWidth, frameHeight, clientX, clientY, clientWidth, clientHeight));
				
#if defined(GWINDOW_DEBUG_LINUX_OUTPUT_RETRIES)
				if (g_retries > 0)
					printf("GetWidth() GetWindowPositionAndSize() retry:%u\n", g_retries);
#endif

				if (g_success)
				{
					_outWidth = static_cast<unsigned int>(frameWidth);
					return GReturn::SUCCESS;
				}
				
				return GReturn::FAILURE;
			}

			GReturn GetHeight(unsigned int& _outHeight) const override
			{
				int frameX, frameY, clientX, clientY;
				unsigned int frameWidth, frameHeight, clientWidth, clientHeight;
				
				G_RETRY_IF_FAILED(GetWindowPositionAndSize(frameX, frameY, frameWidth, frameHeight, clientX, clientY, clientWidth, clientHeight));
				
#if defined(GWINDOW_DEBUG_LINUX_OUTPUT_RETRIES)
				if (g_retries > 0)
					printf("GetHeight() GetWindowPositionAndSize() retry:%u\n", g_retries);
#endif
				
				if (g_success)
				{
					_outHeight = static_cast<unsigned int>(frameHeight);
					return GReturn::SUCCESS;
				}
				
				return GReturn::FAILURE;
			}

			GReturn GetClientWidth(unsigned int& _outClientWidth) const override
			{
				int clientX, clientY;
				unsigned int clientWidth, clientHeight;
				
				G_RETRY_IF_FAILED(GetClientPositionAndSize(clientX, clientY, clientWidth, clientHeight));
				
#if defined(GWINDOW_DEBUG_LINUX_OUTPUT_RETRIES)
				if (g_retries > 0)
					printf("GetClientWidth() GetClientPositionAndSize() retry:%u\n", g_retries);
#endif
				
				if (g_success)
				{
					_outClientWidth = static_cast<unsigned int>(clientWidth);
					return GReturn::SUCCESS;
				}
				
				return GReturn::FAILURE;
			}

			GReturn GetClientHeight(unsigned int& _outClientHeight) const override
			{
				int clientX, clientY;
				unsigned int clientWidth, clientHeight;
				
				G_RETRY_IF_FAILED(GetClientPositionAndSize(clientX, clientY, clientWidth, clientHeight));
				
#if defined(GWINDOW_DEBUG_LINUX_OUTPUT_RETRIES)
				if (g_retries > 0)
					printf("GetClientHeight() GetClientPositionAndSize() retry:%u\n", g_retries);
#endif
				
				if (g_success)
				{
					_outClientHeight = static_cast<unsigned int>(clientHeight);
					return GReturn::SUCCESS;
				}
				
				return GReturn::FAILURE;
			}

			GReturn GetX(unsigned int& _outX) const override
			{
				int frameX, frameY, clientX, clientY;
				unsigned int frameWidth, frameHeight, clientWidth, clientHeight;
				
				G_RETRY_IF_FAILED(GetWindowPositionAndSize(frameX, frameY, frameWidth, frameHeight, clientX, clientY, clientWidth, clientHeight));
				
#if defined(GWINDOW_DEBUG_LINUX_OUTPUT_RETRIES)
				if (g_retries > 0)
					printf("GetX() GetWindowPositionAndSize() retry:%u\n", g_retries);
#endif
				
				if (g_success)
				{
					_outX = static_cast<unsigned int>(frameX);
					return GReturn::SUCCESS;
				}
				
				return GReturn::FAILURE;
			}

			GReturn GetY(unsigned int& _outY) const override
			{
				int frameX, frameY, clientX, clientY;
				unsigned int frameWidth, frameHeight, clientWidth, clientHeight;
				
				G_RETRY_IF_FAILED(GetWindowPositionAndSize(frameX, frameY, frameWidth, frameHeight, clientX, clientY, clientWidth, clientHeight));
				
#if defined(GWINDOW_DEBUG_LINUX_OUTPUT_RETRIES)
				if (g_retries > 0)
					printf("GetY() GetWindowPositionAndSize() retry:%u\n", g_retries);
#endif
				
				if (g_success)
				{
					_outY = static_cast<unsigned int>(frameY);
					return GReturn::SUCCESS;
				}
				
				return GReturn::FAILURE;
			}

			GReturn GetClientTopLeft(unsigned int& _outX, unsigned int& _outY) const override
			{
				long _titleBarHeight, _bottomBorderHeight, _leftBorderWidth, _rightBorderWidth;
				
				G_RETRY_IF_FAILED(GetWindowBorderSizes(_titleBarHeight, _bottomBorderHeight, _leftBorderWidth, _rightBorderWidth));
				
#if defined(GWINDOW_DEBUG_LINUX_OUTPUT_RETRIES)
				if (g_retries > 0)
					printf("GetClientTopLeft() GetWindowBorderSizes() retry:%u\n", g_retries);
#endif
				
				if (g_success)
				{
					_outX = static_cast<unsigned int>(_leftBorderWidth);
					_outY = static_cast<unsigned int>(_titleBarHeight);
#if defined(GWINDOW_DEBUG_LINUX_OUTPUT_GETCLIENTTOPLEFT)
					printf("GetClientTopLeft() x:%u y:%u\n", _outX, _outY);
#endif
					return GReturn::SUCCESS;
				}
				
#if defined(GWINDOW_DEBUG_LINUX_OUTPUT_GETCLIENTTOPLEFT)
				printf("GetClientTopLeft() Failed%u\n", 0);
#endif
				return GReturn::FAILURE;
			}

			GReturn GetWindowHandle(SYSTEM::UNIVERSAL_WINDOW_HANDLE& _outUniversalWindowHandle) const override
			{
				if (!windowIsRunning || !display || !window)
					return GReturn::FAILURE;

				_outUniversalWindowHandle.window = (void*)(&window);
				_outUniversalWindowHandle.display = (void*)(display);
				return  GReturn::SUCCESS;
			}

			GReturn IsFullscreen(bool& _outIsFullscreen) const override
			{
				int frameX, frameY, clientX, clientY;
				unsigned int frameWidth, frameHeight, clientWidth, clientHeight;
				
				G_RETRY_IF_FAILED(GetWindowPositionAndSize(frameX, frameY, frameWidth, frameHeight, clientX, clientY, clientWidth, clientHeight));
				
#if defined(GWINDOW_DEBUG_LINUX_OUTPUT_RETRIES)
				if (g_retries > 0)
					printf("IsFullscreen() GetWindowPositionAndSize() retry:%u\n", g_retries);
#endif
				
				if (g_success)
				{
					Screen* screen = DefaultScreenOfDisplay(display);
					_outIsFullscreen = (frameWidth == screen->width && frameHeight == screen->height);
					
					return GReturn::SUCCESS;
				}
				
				return GReturn::FAILURE;
			}

			GReturn IsFocus(bool& _outIsFocus) const override
			{
				if (!windowIsRunning || !display || !window)
					return  GReturn::FAILURE;
				int revert;
				Window focus;
				XGetInputFocus(display, &focus, &revert);
				_outIsFocus = (window == focus);
				return GReturn::SUCCESS;
			}
		};
	}
}


#elif defined(_WIN32)
    #define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <string>

// This file is automatically generated by our CMake build scripts.
// Authors: Gerard Vega (original CMake build system) & Yangjie Yao(Wolfram auto-versioning)

#ifndef GVERSION_HPP
#define GVERSION_HPP

// Ensure developers are only building Gateware on x64 platforms.
static_assert(sizeof(void*) == 8, "Gateware supports x64 platforms only.");

// The Major version is increased when a new library is added.(minor & patch are reset)
#define GATEWARE_MAJOR 2
// The Minor version is increased whenever an interface is altered.(patch is reset)
#define GATEWARE_MINOR 0
// The Patch version is increased whenever a bug or leak is fixed.(nothing is reset)
#define GATEWARE_PATCH 'b'
// Pulled directly from GIT  
#define GATEWARE_BRANCH "master"
// Pulled directly from GIT
#define GATEWARE_COMMIT_HASH 0x96078a9
// Standard Window Title Bar
#define GATEWARE_VERSION_STRING "Gateware v2.0b"
// Window Title Bar displayed in DEBUG builds
#define GATEWARE_VERSION_STRING_LONG "Gateware v2.0b (master) [96078a9]"

#endif



namespace GW
{
	namespace I
	{
		class GWindowImplementation :	public virtual GWindowInterface,
										public GEventGeneratorImplementation
		{
		private:
			HWND wndHandle = nullptr;
			std::wstring className;
			bool destroyEventIsSentByWndProc = false;
			int m_WindowX = -1;
			int m_WindowY = -1;
			int m_WindowWidth = -1;
			int m_WindowHeight = -1;
			SYSTEM::GWindowStyle m_WindowStyle = SYSTEM::GWindowStyle::WINDOWEDBORDERED;

			GEvent m_GEvent;
			EVENT_DATA m_EventData;

			HICON m_IconSmall = NULL;
			HICON m_IconBig = NULL;

			void SetInteralData(int _x, int _y, int _width, int _height, SYSTEM::GWindowStyle _style)
			{
				m_WindowWidth = _width;
				m_WindowHeight = _height;
				m_WindowX = _x;
				m_WindowY = _y;
				m_WindowStyle = _style;
			}

			LRESULT DispatchEventAndData(UINT uMsg, WPARAM wParam, LPARAM lParam)
			{
				RECT windowRect;
				::GetWindowRect(wndHandle, &windowRect);

				switch (uMsg)
				{
				case WM_SIZE:
				{
					if (wParam == SIZE_MAXHIDE || wParam == SIZE_MAXSHOW) 
					{
						break;
					}

					m_EventData.height = windowRect.bottom - windowRect.top;
					m_EventData.width = windowRect.right - windowRect.left;
					m_EventData.clientHeight = (unsigned int)HIWORD(lParam);
					m_EventData.clientWidth = (unsigned int)LOWORD(lParam);
					m_EventData.windowX = windowRect.left;
					m_EventData.windowY = windowRect.top;
					m_EventData.windowHandle = wndHandle;

					switch (wParam)
					{
					case SIZE_MAXIMIZED: { m_EventData.eventFlags = Events::MAXIMIZE; } break;
					case SIZE_MINIMIZED: { m_EventData.eventFlags = Events::MINIMIZE; } break;
					case SIZE_RESTORED: { m_EventData.eventFlags = Events::RESIZE; } break;
					}

					m_GEvent.Write(m_EventData.eventFlags, m_EventData);
					Push(m_GEvent);
				}
				break;

				case WM_MOVE:
				{
					RECT clientRect;
					::GetClientRect(wndHandle, &clientRect);

					m_EventData.eventFlags = Events::MOVE;
					m_EventData.height = windowRect.bottom - windowRect.top;
					m_EventData.width = windowRect.right - windowRect.left;
					m_EventData.clientHeight = clientRect.bottom - clientRect.top;
					m_EventData.clientWidth = clientRect.right - clientRect.left;
					m_EventData.windowX = windowRect.left;
					m_EventData.windowY = windowRect.top;
					m_EventData.windowHandle = wndHandle;

					m_GEvent.Write(m_EventData.eventFlags, m_EventData);
					Push(m_GEvent);
				}
				break;

				case WM_CLOSE:
				{
					RECT clientRect;
					::GetClientRect(wndHandle, &clientRect);

					m_EventData.eventFlags = Events::DESTROY;
					m_EventData.height = windowRect.bottom - windowRect.top;
					m_EventData.width = windowRect.right - windowRect.left;
					m_EventData.clientHeight = clientRect.bottom - clientRect.top;
					m_EventData.clientWidth = clientRect.right - clientRect.left;
					m_EventData.windowX = windowRect.left;
					m_EventData.windowY = windowRect.top;
					m_EventData.windowHandle = wndHandle;

					m_GEvent.Write(m_EventData.eventFlags, m_EventData);
					Push(m_GEvent);
					destroyEventIsSentByWndProc = true;
				}
				break;

				case WM_DESTROY: { ::PostQuitMessage(0); } break;
				default: { return ::DefWindowProc(wndHandle, uMsg, wParam, lParam); }
				}
				return ::DefWindowProc(wndHandle, uMsg, wParam, lParam);
			}

			static LRESULT CALLBACK GWindowProcedure(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
			{
				GWindowImplementation* self;
				if (uMsg == WM_NCCREATE)
				{
					LPCREATESTRUCT lpcs = reinterpret_cast<LPCREATESTRUCT>(lParam);
					self = reinterpret_cast<GWindowImplementation*>(lpcs->lpCreateParams);
					self->wndHandle = hwnd;
					::SetWindowLongPtr(hwnd, GWLP_USERDATA, reinterpret_cast<LPARAM>(self));
				}
				else
				{
					self = reinterpret_cast<GWindowImplementation*>(::GetWindowLongPtr(hwnd, GWLP_USERDATA));
				}
				if (self)
				{
					return self->DispatchEventAndData(uMsg, wParam, lParam);
				}
				else
				{
					return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
				}
			}

			GReturn OpenWindow()
			{
				if (wndHandle)
					return GReturn::REDUNDANT;

				auto hasGUI = GetDesktopWindow();
				if (!hasGUI)
					return GReturn::INTERFACE_UNSUPPORTED;

				destroyEventIsSentByWndProc = false;
				WNDCLASSEX winClass;
				ZeroMemory(&winClass, sizeof(WNDCLASSEX));

				// Generate random string based on a given length. This is because if the end-user want to create multiple GWindow instances,
				// class name have to be unique to the GWindow.
				auto randomString = [](size_t length) -> std::string
				{
					auto randchar = []() -> char
					{
						const char charset[] =
							"0123456789"
							"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
							"abcdefghijklmnopqrstuvwxyz";
						const size_t max_index = (sizeof(charset) - 1);
						return charset[rand() % max_index];
					};
					std::string str(length, 0);
					std::generate_n(str.begin(), length, randchar);
					return str;
				};
				std::string randName = randomString(9);
				std::wstring wcharName = L"GatewareWindow:";
				wcharName += std::wstring(randName.begin(), randName.end());
				className = std::move(wcharName);

				// Icon members are not set to the default icon (IDI_APPLICATION) because shared icons should not be destroyed.
				ZeroMemory(&m_IconSmall, sizeof(HICON));
				m_IconSmall = NULL;
				ZeroMemory(&m_IconBig, sizeof(HICON));
				m_IconBig = NULL;

				winClass.cbSize = sizeof(WNDCLASSEX);
				winClass.hbrBackground = (HBRUSH)COLOR_WINDOW;
				winClass.hCursor = LoadCursorW(NULL, IDC_ARROW);
				winClass.hIcon = LoadIconW(0, IDI_APPLICATION);
				winClass.lpfnWndProc = GWindowProcedure;
				winClass.lpszClassName = className.data();
				winClass.style = CS_OWNDC | CS_HREDRAW | CS_VREDRAW;
				winClass.hInstance = GetModuleHandleW(0);

				if (!::RegisterClassExW(&winClass))
				{
					::printf("RegisterClassExW Error : %d \n", GetLastError());
					return GReturn::INTERFACE_UNSUPPORTED;
				}

				DWORD windowsStyle = GetWindowsStyle(m_WindowStyle);
				RECT adjustedRect = { 0, 0, m_WindowWidth, m_WindowHeight };
				if (::AdjustWindowRect(&adjustedRect, windowsStyle, FALSE) == 0) // Creates a rect for a window frame that can fit the desired client size.
				{
					::printf("AdjustWindowRect Error Message : %d \n", GetLastError());
					return GReturn::FAILURE;
				}

#ifndef NDEBUG
#define GATEWARE_WINDOW_NAME GATEWARE_VERSION_STRING_LONG
#else
#define GATEWARE_WINDOW_NAME GATEWARE_VERSION_STRING
#endif
				wndHandle = ::CreateWindowW(className.data(), L"" GATEWARE_WINDOW_NAME, windowsStyle, m_WindowX, m_WindowY, adjustedRect.right - adjustedRect.left, adjustedRect.bottom - adjustedRect.top, NULL, NULL, GetModuleHandleW(0), this);
#undef GATEWARE_WINDOW_NAME

				if (wndHandle && (m_WindowStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERED || m_WindowStyle == SYSTEM::GWindowStyle::FULLSCREENBORDERLESS))
				{
					if (::ShowWindow(wndHandle, SW_MAXIMIZE) != 0)
					{
						::printf("ShowWindow Error Message : %d \n", GetLastError());
						return GReturn::FAILURE;
					}
					else
					{
						return GReturn::SUCCESS;
					}
				}
				else if (wndHandle && m_WindowStyle != SYSTEM::GWindowStyle::MINIMIZED)
				{
					if (::ShowWindow(wndHandle, SW_SHOWDEFAULT) != 0)
					{
						::printf("ShowWindow Error Message : %d \n", GetLastError());
						return GReturn::FAILURE;
					}
					else
					{
						return GReturn::SUCCESS;
					}
				}
				else if (wndHandle && m_WindowStyle == SYSTEM::GWindowStyle::MINIMIZED)
				{
					::ShowWindow(wndHandle, SW_MINIMIZE);
					return GReturn::SUCCESS;
				}
				return GReturn::FAILURE;
			}

			DWORD GetWindowsStyle(GW::SYSTEM::GWindowStyle _style)
			{
				switch (m_WindowStyle)
				{
				case GW::SYSTEM::GWindowStyle::WINDOWEDBORDERED:
				case GW::SYSTEM::GWindowStyle::FULLSCREENBORDERED:
					return WS_OVERLAPPEDWINDOW;

				case GW::SYSTEM::GWindowStyle::WINDOWEDBORDERLESS:
				case GW::SYSTEM::GWindowStyle::FULLSCREENBORDERLESS:
					return WS_POPUP;

				case GW::SYSTEM::GWindowStyle::MINIMIZED:
					return WS_MINIMIZE;

				case GW::SYSTEM::GWindowStyle::WINDOWEDLOCKED:
					return  WS_OVERLAPPEDWINDOW ^ WS_SIZEBOX ^ WS_MAXIMIZEBOX;
				}
				return 0;
			}

		public:
			~GWindowImplementation()
			{
				if (!destroyEventIsSentByWndProc)
				{
					if (m_IconBig)
						DestroyIcon(m_IconBig);

					if (m_IconSmall)
						DestroyIcon(m_IconSmall);

					RECT windowRect = { 0,0,0,0 };
					RECT clientRect = { 0,0,0,0 };
					if (wndHandle)
					{
						::GetWindowRect(wndHandle, &windowRect);
						::GetClientRect(wndHandle, &clientRect);
					}

					m_EventData.eventFlags = Events::DESTROY;
					m_EventData.height = windowRect.bottom - windowRect.top;
					m_EventData.width = windowRect.right - windowRect.left;
					m_EventData.clientHeight = clientRect.bottom - clientRect.top;
					m_EventData.clientWidth = clientRect.right - clientRect.left;
					m_EventData.windowX = windowRect.left;
					m_EventData.windowY = windowRect.top;
					m_EventData.windowHandle = wndHandle;

					m_GEvent.Write(m_EventData.eventFlags, m_EventData);
					Push(m_GEvent);
				}
				if (!wndHandle)
					return;
				::SetWindowLongPtr(wndHandle, GWLP_USERDATA, reinterpret_cast<LPARAM>(nullptr));
				::DestroyWindow(wndHandle);
				wndHandle = nullptr;
				if (!::UnregisterClassW(className.data(), GetModuleHandleW(0)))
				{
					::printf("UnregisterClassW Error Message : %d \n", GetLastError());
				}
			}

			GReturn Create(int _x, int _y, int _width, int _height, SYSTEM::GWindowStyle _style)
			{
				this->SetInteralData(_x, _y, _width, _height, _style);
				return OpenWindow();
			}

			GReturn ProcessWindowEvents() override
			{
				if (!wndHandle)
					return GReturn::FAILURE;

				if (destroyEventIsSentByWndProc)
					return GReturn::FAILURE;

				MSG msg;
				ZeroMemory(&msg, sizeof(MSG));
				// Processes all messages in the current queue 
				while (PeekMessage(&msg, wndHandle, 0, 0, PM_REMOVE))
				{
					//Translate messages
					TranslateMessage(&msg);
					//Send to WindowProc
					DispatchMessage(&msg);
				}

				m_EventData.eventFlags = Events::EVENTS_PROCESSED;
				m_GEvent.Write(m_EventData.eventFlags, m_EventData);
				Push(m_GEvent);

				return GReturn::SUCCESS;
			}

			GReturn ReconfigureWindow(int _x, int _y, int _width, int _height, SYSTEM::GWindowStyle _style) override
			{
				if (!wndHandle)
					return GReturn::FAILURE;

				SYSTEM::GWindowStyle previousStyle = m_WindowStyle;
				SetInteralData(_x, _y, _width, _height, _style);

				switch (m_WindowStyle)
				{
				case SYSTEM::GWindowStyle::WINDOWEDBORDERED:
				{
					bool reconfiguringFromMinimizedState = (previousStyle == SYSTEM::GWindowStyle::MINIMIZED);

					if (reconfiguringFromMinimizedState)
						::ShowWindow(wndHandle, SW_RESTORE); // Restore the window prior to making changes to it. Otherwise, they may not take effect.

					DWORD windowsStyle = GetWindowsStyle(m_WindowStyle);
					::SetWindowLongPtr(wndHandle, GWL_STYLE, windowsStyle);

					RECT adjustedRect = { 0, 0, m_WindowWidth, m_WindowHeight };
					if (::AdjustWindowRect(&adjustedRect, windowsStyle, FALSE) == 0)
					{
						::printf("AdjustWindowRect Error Message : %d \n", GetLastError());
						return GReturn::FAILURE;
					}

					BOOL winRet = ::SetWindowPos(wndHandle, nullptr, m_WindowX, m_WindowY, adjustedRect.right - adjustedRect.left, adjustedRect.bottom - adjustedRect.top, SWP_SHOWWINDOW | SWP_FRAMECHANGED);
					if (winRet == 0)
					{
						::printf("SetWindowPos Error : %d \n", GetLastError());
						return  GReturn::FAILURE;
					}

					if (!reconfiguringFromMinimizedState)
						::ShowWindow(wndHandle, SW_SHOW);
					SetInteralData(m_WindowX, m_WindowY, m_WindowWidth, m_WindowHeight, SYSTEM::GWindowStyle::WINDOWEDBORDERED);
				}
				break;

				case SYSTEM::GWindowStyle::WINDOWEDBORDERLESS:
				{
					bool reconfiguringFromMinimizedState = (previousStyle == SYSTEM::GWindowStyle::MINIMIZED);

					if (reconfiguringFromMinimizedState)
						::ShowWindow(wndHandle, SW_RESTORE);

					DWORD windowsStyle = GetWindowsStyle(m_WindowStyle);
					::SetWindowLongPtr(wndHandle, GWL_STYLE, windowsStyle);

					RECT adjustedRect = { 0, 0, m_WindowWidth, m_WindowHeight };
					if (::AdjustWindowRect(&adjustedRect, windowsStyle, FALSE) == 0)
					{
						::printf("AdjustWindowRect Error Message : %d \n", GetLastError());
						return GReturn::FAILURE;
					}

					BOOL winRet = ::SetWindowPos(wndHandle, nullptr, m_WindowX, m_WindowY, adjustedRect.right - adjustedRect.left, adjustedRect.bottom - adjustedRect.top, SWP_SHOWWINDOW);
					if (winRet == 0)
					{
						::printf("SetWindowPos Error : %d \n", GetLastError());
						return  GReturn::FAILURE;
					}

					if (!reconfiguringFromMinimizedState)
						::ShowWindow(wndHandle, SW_SHOW);
					SetInteralData(m_WindowX, m_WindowY, m_WindowWidth, m_WindowHeight, SYSTEM::GWindowStyle::WINDOWEDBORDERLESS);
				}
				break;

				case SYSTEM::GWindowStyle::WINDOWEDLOCKED:
				{
					bool reconfiguringFromMinimizedState = (previousStyle == SYSTEM::GWindowStyle::MINIMIZED);

					if (reconfiguringFromMinimizedState)
						::ShowWindow(wndHandle, SW_RESTORE);

					DWORD windowsStyle = GetWindowsStyle(m_WindowStyle);
					::SetWindowLongPtr(wndHandle, GWL_STYLE, windowsStyle);

					RECT adjustedRect = { 0, 0, m_WindowWidth, m_WindowHeight };
					if (::AdjustWindowRect(&adjustedRect, windowsStyle, FALSE) == 0)
					{
						::printf("AdjustWindowRect Error Message : %d \n", GetLastError());
						return GReturn::FAILURE;
					}

					BOOL winRet = ::SetWindowPos(wndHandle, nullptr, m_WindowX, m_WindowY, adjustedRect.right - adjustedRect.left, adjustedRect.bottom - adjustedRect.top, SWP_SHOWWINDOW | SWP_FRAMECHANGED);
					if (winRet == 0)
					{
						::printf("SetWindowPos Error : %d \n", GetLastError());
						return  GReturn::FAILURE;
					}

					if (!reconfiguringFromMinimizedState)
						::ShowWindow(wndHandle, SW_SHOW);
					SetInteralData(m_WindowX, m_WindowY, m_WindowWidth, m_WindowHeight, SYSTEM::GWindowStyle::WINDOWEDLOCKED);
				}
				break;

				case SYSTEM::GWindowStyle::FULLSCREENBORDERED:
				{
					RECT windowRect;
					::GetWindowRect(wndHandle, &windowRect);

					::SetWindowLongPtr(wndHandle, GWL_STYLE, WS_OVERLAPPEDWINDOW);
					BOOL winRet = ::SetWindowPos(wndHandle, nullptr, windowRect.left, windowRect.top, windowRect.right - windowRect.left, windowRect.bottom - windowRect.top, SWP_NOREDRAW);
					if (winRet == 0)
						return  GReturn::FAILURE;

					::ShowWindow(wndHandle, SW_MAXIMIZE);
					::GetWindowRect(wndHandle, &windowRect);
					SetInteralData(0, 0, windowRect.right - windowRect.left, windowRect.bottom - windowRect.top, SYSTEM::GWindowStyle::FULLSCREENBORDERED);
				}
				break;

				case SYSTEM::GWindowStyle::FULLSCREENBORDERLESS:
				{
					RECT windowRect;
					::GetWindowRect(wndHandle, &windowRect);

					::SetWindowLongPtr(wndHandle, GWL_STYLE, WS_POPUP);
					BOOL winRet = ::SetWindowPos(wndHandle, nullptr, windowRect.left, windowRect.top, windowRect.right - windowRect.left, windowRect.bottom - windowRect.top, SWP_NOREDRAW);
					if (winRet == 0)
						return  GReturn::FAILURE;

					::ShowWindow(wndHandle, SW_MAXIMIZE);
					::GetWindowRect(wndHandle, &windowRect);
					SetInteralData(0, 0, windowRect.right - windowRect.left, windowRect.bottom - windowRect.top, SYSTEM::GWindowStyle::FULLSCREENBORDERLESS);
				}
				break;

				case SYSTEM::GWindowStyle::MINIMIZED:
				{
					::ShowWindow(wndHandle, SW_MINIMIZE);
					SetInteralData(0, 0, m_WindowWidth, m_WindowHeight, SYSTEM::GWindowStyle::MINIMIZED);
				}
				break;
				}
				return  GReturn::SUCCESS;
			}

			GReturn SetWindowName(const char* _newName) override
			{
				if (_newName == nullptr)
					return GReturn::INVALID_ARGUMENT;

				if (wndHandle == nullptr)
					return GReturn::FAILURE;

				return ::SetWindowTextW(wndHandle, INTERNAL::G_TO_UTF16(_newName).c_str()) ? GReturn::SUCCESS : GReturn::FAILURE;
			}

			GReturn SetIcon(int _width, int _height, const unsigned int* _argbPixels) override
			{
				if (!wndHandle)
					return GReturn::FAILURE;

				if (_argbPixels == nullptr)
					return GReturn::INVALID_ARGUMENT;
				else if (_width <= 0 || _height <= 0)
					return GReturn::INVALID_ARGUMENT;

				const bool usingBigIcon = _width > 16 || _height > 16;

				if (usingBigIcon)
				{
					if (m_IconBig)
					{
						DestroyIcon(m_IconBig);
						ZeroMemory(&m_IconBig, sizeof(HICON));
					}
				}
				else
				{
					if (m_IconSmall)
					{
						DestroyIcon(m_IconSmall);
						ZeroMemory(&m_IconSmall, sizeof(HICON));
					}
				}

				ICONINFO iconInfo = { TRUE, NULL, NULL, NULL, NULL };

				iconInfo.hbmColor = CreateBitmap(_width, _height, 1, 32, _argbPixels);
				if (!iconInfo.hbmColor)
					return GReturn::FAILURE;

				HDC dc = GetDC(wndHandle);
				iconInfo.hbmMask = CreateCompatibleBitmap(dc, _width, _height);
				DeleteDC(dc);

				if (!iconInfo.hbmMask)
					return GReturn::FAILURE;

				if (usingBigIcon)
				{
					m_IconBig = CreateIconIndirect(&iconInfo);

					if (!m_IconBig)
					{
						ZeroMemory(&m_IconBig, sizeof(HICON));
						return GReturn::FAILURE;
					}

					SendMessage(wndHandle, WM_SETICON, ICON_BIG, (LPARAM)m_IconBig);

					// This fixes a few issues that occur if m_IconSmall icon is set.
					if (m_IconSmall)
					{						
						SendMessage(wndHandle, WM_SETICON, ICON_SMALL, NULL); // Needed so the taskbar icon will change to m_IconBig.
						SendMessage(wndHandle, WM_SETICON, ICON_SMALL, (LPARAM)m_IconSmall); // Needed to keep the window icon as m_IconSmall.
					}
				}
				else
				{
					m_IconSmall = CreateIconIndirect(&iconInfo);

					if (!m_IconSmall)
					{
						ZeroMemory(&m_IconSmall, sizeof(HICON));
						return GReturn::FAILURE;
					}

					SendMessage(wndHandle, WM_SETICON, ICON_SMALL, (LPARAM)m_IconSmall);
				}

				return GReturn::SUCCESS;
			}

			GReturn MoveWindow(int _x, int _y) override
			{
				if (!wndHandle)
					return  GReturn::FAILURE;

				DWORD windowsStyle = GetWindowsStyle(m_WindowStyle);
				RECT adjustedRect = { 0, 0, m_WindowWidth, m_WindowHeight };
				if (::AdjustWindowRect(&adjustedRect, windowsStyle, FALSE) == 0)
				{
					::printf("AdjustWindowRect Error Message : %d \n", GetLastError());
					return GReturn::FAILURE;
				}

				SetInteralData(_x, _y, m_WindowWidth, m_WindowHeight, m_WindowStyle);
				return ::SetWindowPos(wndHandle, nullptr, m_WindowX, m_WindowY, adjustedRect.right - adjustedRect.left, adjustedRect.bottom - adjustedRect.top, SWP_SHOWWINDOW) ? GReturn::SUCCESS : GReturn::FAILURE;
			}

			GReturn ResizeWindow(int _width, int _height) override
			{
				if (!wndHandle)
					return  GReturn::FAILURE;

				DWORD windowsStyle = GetWindowsStyle(m_WindowStyle);
				RECT adjustedRect = { 0, 0, _width, _height };
				if (::AdjustWindowRect(&adjustedRect, windowsStyle, FALSE) == 0)
				{
					::printf("AdjustWindowRect Error Message : %d \n", GetLastError());
					return GReturn::FAILURE;
				}

				SetInteralData(m_WindowX, m_WindowY, _width, _height, m_WindowStyle);
				return ::SetWindowPos(wndHandle, nullptr, m_WindowX, m_WindowY, adjustedRect.right - adjustedRect.left, adjustedRect.bottom - adjustedRect.top, SWP_SHOWWINDOW) ? GReturn::SUCCESS : GReturn::FAILURE;
			}

			GReturn Maximize() override
			{
				if (m_WindowStyle == SYSTEM::GWindowStyle::WINDOWEDBORDERED || 
					m_WindowStyle == SYSTEM::GWindowStyle::MINIMIZED || 
					m_WindowStyle == SYSTEM::GWindowStyle::WINDOWEDLOCKED)
					return ChangeWindowStyle(SYSTEM::GWindowStyle::FULLSCREENBORDERED);
				else if (m_WindowStyle == SYSTEM::GWindowStyle::WINDOWEDBORDERLESS)
					return ChangeWindowStyle(SYSTEM::GWindowStyle::FULLSCREENBORDERLESS);
				return GReturn::REDUNDANT;
			}

			GReturn Minimize() override
			{
				return ChangeWindowStyle(SYSTEM::GWindowStyle::MINIMIZED);
			}

			GReturn ChangeWindowStyle(SYSTEM::GWindowStyle _style) override
			{
				return ReconfigureWindow(m_WindowX, m_WindowY, m_WindowWidth, m_WindowHeight, _style);
			}

			GReturn GetWidth(unsigned int& _outWidth) const override
			{
				if (!wndHandle)
					return  GReturn::FAILURE;

				RECT windowRect;
				::GetWindowRect(wndHandle, &windowRect);
				_outWidth = windowRect.right - windowRect.left;
				return  GReturn::SUCCESS;
			}

			GReturn GetHeight(unsigned int& _outHeight) const override
			{
				if (!wndHandle)
					return GReturn::FAILURE;

				RECT windowRect;
				::GetWindowRect(wndHandle, &windowRect);
				_outHeight = windowRect.bottom - windowRect.top;
				return GReturn::SUCCESS;
			}

			GReturn GetClientWidth(unsigned int& _outClientWidth) const override
			{
				if (!wndHandle)
					return GReturn::FAILURE;

				RECT clientRect;
				::GetClientRect(wndHandle, &clientRect);
				_outClientWidth = clientRect.right - clientRect.left;
				return GReturn::SUCCESS;
			}

			GReturn GetClientHeight(unsigned int& _outClientHeight) const override
			{
				if (!wndHandle)
					return GReturn::FAILURE;

				RECT clientRect;
				::GetClientRect(wndHandle, &clientRect);
				_outClientHeight = clientRect.bottom - clientRect.top;
				return GReturn::SUCCESS;
			}

			GReturn GetX(unsigned int& _outX) const override
			{
				if (!wndHandle)
					return GReturn::FAILURE;

				RECT windowRect;
				::GetWindowRect(wndHandle, &windowRect);
				_outX = windowRect.left;
				return GReturn::SUCCESS;
			}

			GReturn GetY(unsigned int& _outY) const override
			{
				if (!wndHandle)
					return GReturn::FAILURE;

				RECT windowRect;
				::GetWindowRect(wndHandle, &windowRect);
				_outY = windowRect.top;
				return GReturn::SUCCESS;
			}

			GReturn GetClientTopLeft(unsigned int& _outX, unsigned int& _outY) const override
			{
				if (!wndHandle)
					return GReturn::FAILURE;

				POINT clientAreaTopLeft = { 0, 0 };
				::ClientToScreen(wndHandle, &clientAreaTopLeft);
				unsigned int x;
				unsigned int y;
				GetX(x);
				GetY(y);
				_outX = clientAreaTopLeft.x - x;
				_outY = clientAreaTopLeft.y - y;
				return GReturn::SUCCESS;
			}

			GReturn GetWindowHandle(SYSTEM::UNIVERSAL_WINDOW_HANDLE& _outUniversalWindowHandle) const override
			{
				if (!wndHandle)
					return GReturn::FAILURE;

				_outUniversalWindowHandle.window = wndHandle;
				_outUniversalWindowHandle.display = nullptr;
				return GReturn::SUCCESS;
			}

			GReturn IsFullscreen(bool& _outIsFullscreen) const override
			{
				if (!wndHandle)
					return GReturn::FAILURE;

				unsigned int height = 0;
				unsigned int width = 0;
				int mainWindowWidth = 0;
				int mainWindowHeight = 0;
				int borderHeight = 0;
				int resizeBarWidth = 0;
				int resizeBarHeight = 0;

				if (G_FAIL(GetWidth(width)) || G_FAIL(GetHeight(height)))
				{
					return GReturn::FAILURE;
				}
				// mainWindowWidth and mainWindowHeight does not refer to application window,
				// but the main desktop window
				mainWindowWidth = ::GetSystemMetrics(SM_CXFULLSCREEN);
				mainWindowHeight = ::GetSystemMetrics(SM_CYFULLSCREEN);
				borderHeight = ::GetSystemMetrics(SM_CYCAPTION);
				resizeBarWidth = ::GetSystemMetrics(SM_CXBORDER);
				resizeBarHeight = ::GetSystemMetrics(SM_CYBORDER);

				if (((int)width + resizeBarWidth) >= mainWindowWidth && ((int)height + borderHeight + resizeBarHeight) >= mainWindowHeight)
					_outIsFullscreen = true;
				else
					_outIsFullscreen = false;

				return GReturn::SUCCESS;
			}

			GReturn IsFocus(bool& _outIsFocus) const override
			{
				if (!wndHandle)
					return GReturn::FAILURE;
				// determine if HWND is the foreground window
				_outIsFocus = (wndHandle == GetForegroundWindow());
				return GReturn::SUCCESS;
			}
		};
	}
}

#endif


namespace GW
{
	namespace SYSTEM
	{
		class GWindow final
			: public I::GProxy<I::GWindowInterface, I::GWindowImplementation, int, int, int, int, GW::SYSTEM::GWindowStyle>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GWindow)
			GATEWARE_TYPEDEF(Events)
			GATEWARE_TYPEDEF(EVENT_DATA)
			GATEWARE_FUNCTION(ProcessWindowEvents)
			GATEWARE_FUNCTION(ReconfigureWindow)
			GATEWARE_FUNCTION(SetWindowName)
			GATEWARE_FUNCTION(SetIcon)
			GATEWARE_FUNCTION(MoveWindow)
			GATEWARE_FUNCTION(ResizeWindow)
			GATEWARE_FUNCTION(Maximize)
			GATEWARE_FUNCTION(Minimize)
			GATEWARE_FUNCTION(ChangeWindowStyle)
			GATEWARE_CONST_FUNCTION(GetWidth)
			GATEWARE_CONST_FUNCTION(GetHeight)
			GATEWARE_CONST_FUNCTION(GetClientWidth)
			GATEWARE_CONST_FUNCTION(GetClientHeight)
			GATEWARE_CONST_FUNCTION(GetX)
			GATEWARE_CONST_FUNCTION(GetY)
			GATEWARE_CONST_FUNCTION(GetClientTopLeft)
			GATEWARE_CONST_FUNCTION(GetWindowHandle)
			GATEWARE_CONST_FUNCTION(IsFullscreen)
			GATEWARE_CONST_FUNCTION(IsFocus)

			// reimplemented functions from GEventGenerator
			GATEWARE_FUNCTION(Register)
			GATEWARE_CONST_FUNCTION(Observers)
			GATEWARE_FUNCTION(Push)
			

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	};
}
#endif // GWINDOW_H

/*---------------------------------
|	End of GWindow.h
----------------------------------*/


/*---------------------------------
|	Begin of GVector.h
----------------------------------*/
#ifndef GVECTOR_H
#define GVECTOR_H





namespace GW
{
	namespace I
	{
		class GVectorInterface : public virtual GInterfaceInterface
		{
		public:
			// Floats
			static GReturn AddVectorF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, MATH::GVECTORF& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SubtractVectorF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, MATH::GVECTORF& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ScaleF(MATH::GVECTORF _vector, float _scalar, MATH::GVECTORF& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn DotF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, float& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn CrossVector2F(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, float& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn CrossVector3F(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, MATH::GVECTORF& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn VectorXMatrixF(MATH::GVECTORF _vector, MATH::GMATRIXF _matrix, MATH::GVECTORF& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TransformF(MATH::GVECTORF _vector, MATH::GMATRIXF _matrix, MATH::GVECTORF& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MagnitudeF(MATH::GVECTORF _vector, float& _outMagnitude) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn NormalizeF(MATH::GVECTORF _vector, MATH::GVECTORF& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn LerpF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, float _ratio, MATH::GVECTORF& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SplineF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, MATH::GVECTORF _vector3, MATH::GVECTORF _vector4, float _ratio, MATH::GVECTORF& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Upgrade(MATH::GVECTORF _vectorF, MATH::GVECTORD& _outVectorD) { return GReturn::NO_IMPLEMENTATION; }
			// Doubles
			static GReturn AddVectorD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, MATH::GVECTORD& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SubtractVectorD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, MATH::GVECTORD& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ScaleD(MATH::GVECTORD _vector, double _scalar, MATH::GVECTORD& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn DotD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, double& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn CrossVector2D(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, double& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn CrossVector3D(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, MATH::GVECTORD& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn VectorXMatrixD(MATH::GVECTORD _vector, MATH::GMATRIXD _matrix, MATH::GVECTORD& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TransformD(MATH::GVECTORD _vector, MATH::GMATRIXD _matrix, MATH::GVECTORD& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MagnitudeD(MATH::GVECTORD _vector, double& _outMagnitude) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn NormalizeD(MATH::GVECTORD _vector, MATH::GVECTORD& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn LerpD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, double _ratio, MATH::GVECTORD& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SplineD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, MATH::GVECTORD _vector3, MATH::GVECTORD _vector4, double _ratio, MATH::GVECTORD& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Downgrade(MATH::GVECTORD _vectorD, MATH::GVECTORF& _outVectorF) { return GReturn::NO_IMPLEMENTATION; }
		};
	}
}

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GVector.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_MATH) || defined(GATEWARE_DISABLE_GVECTOR) || \
    (defined(GATEWARE_ENABLE_MATH) && !defined(GATEWARE_DISABLE_GVECTOR) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
	namespace I
	{
		class GVectorImplementation : public virtual GVectorInterface,
			private GInterfaceImplementation
		{
		public:
			GReturn Create()
			{
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			//float vector
			static GReturn AddVectorF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, MATH::GVECTORF& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn SubtractVectorF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, MATH::GVECTORF& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn ScaleF(MATH::GVECTORF _vector, float _scalar, MATH::GVECTORF& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn DotF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, float& _outValue)
			{
				return GReturn::FAILURE;
			}
			static GReturn CrossVector2F(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, float& _outValue)
			{
				return GReturn::FAILURE;
			}
			static GReturn CrossVector3F(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, MATH::GVECTORF& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn VectorXMatrixF(MATH::GVECTORF _vector, MATH::GMATRIXF _matrix, MATH::GVECTORF& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn TransformF(MATH::GVECTORF _vector, MATH::GMATRIXF _matrix, MATH::GVECTORF& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn MagnitudeF(MATH::GVECTORF _vector, float& _outMagnitude)
			{
				return GReturn::FAILURE;
			}
			static GReturn NormalizeF(MATH::GVECTORF _vector, MATH::GVECTORF& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn LerpF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, float _ratio, MATH::GVECTORF& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn SplineF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, MATH::GVECTORF _vector3, MATH::GVECTORF _vector4, float _ratio, MATH::GVECTORF& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn Upgrade(MATH::GVECTORF _vectorF, MATH::GVECTORD& _outVectorD) 
			{
				return GReturn::FAILURE; 
			}

			//double vector
			static GReturn AddVectorD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, MATH::GVECTORD& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn SubtractVectorD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, MATH::GVECTORD& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn ScaleD(MATH::GVECTORD _vector, double _scalar, MATH::GVECTORD& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn DotD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, double& _outValue)
			{
				return GReturn::FAILURE;
			}
			static GReturn CrossVector2D(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, double& _outValue)
			{
				return GReturn::FAILURE;
			}
			static GReturn CrossVector3D(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, MATH::GVECTORD& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn VectorXMatrixD(MATH::GVECTORD _vector, MATH::GMATRIXD _matrix, MATH::GVECTORD& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn TransformD(MATH::GVECTORD _vector, MATH::GMATRIXD _matrix, MATH::GVECTORD& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn MagnitudeD(MATH::GVECTORD _vector, double& _outMagnitude)
			{
				return GReturn::FAILURE;
			}
			static GReturn NormalizeD(MATH::GVECTORD _vector, MATH::GVECTORD& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn LerpD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, double _ratio, MATH::GVECTORD& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn SplineD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, MATH::GVECTORD _vector3, MATH::GVECTORD _vector4, double _ratio, MATH::GVECTORD& _outVector) 
			{
				return GReturn::FAILURE;
			}
			static GReturn Downgrade(MATH::GVECTORD _vectorD, MATH::GVECTORF& _outVectorF) 
			{
				return GReturn::FAILURE; 
			}
		};
	}
}

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
    #include <cmath>

namespace GW
{
	namespace I
	{
		class GVectorImplementation : public virtual GVectorInterface,
			private GInterfaceImplementation
		{
		public:

			GReturn Create()
			{
				return GReturn::SUCCESS;
			}

			//float vector
			static GReturn AddVectorF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, MATH::GVECTORF& _outVector)
			{
				_outVector.x = _vector1.x + _vector2.x;
				_outVector.y = _vector1.y + _vector2.y;
				_outVector.z = _vector1.z + _vector2.z;
				_outVector.w = _vector1.w + _vector2.w;

				return GReturn::SUCCESS;
			}
			static GReturn SubtractVectorF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, MATH::GVECTORF& _outVector)
			{
				_outVector.x = _vector1.x - _vector2.x;
				_outVector.y = _vector1.y - _vector2.y;
				_outVector.z = _vector1.z - _vector2.z;
				_outVector.w = _vector1.w - _vector2.w;

				return GReturn::SUCCESS;
			}
			static GReturn ScaleF(MATH::GVECTORF _vector, float _scalar, MATH::GVECTORF& _outVector)
			{
				_outVector.x = _scalar * _vector.x;
				_outVector.y = _scalar * _vector.y;
				_outVector.z = _scalar * _vector.z;
				_outVector.w = _scalar * _vector.w;

				return GReturn::SUCCESS;
			}
			static GReturn DotF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, float& _outValue)
			{
				_outValue = (_vector1.x * _vector2.x) + (_vector1.y * _vector2.y) + (_vector1.z * _vector2.z) + (_vector1.w * _vector2.w);

				return GReturn::SUCCESS;
			}
			static GReturn CrossVector2F(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, float& _outValue)
			{
				_outValue = (_vector1.x * _vector2.y) - (_vector1.y * _vector2.x);

				return GReturn::SUCCESS;
			}
			static GReturn CrossVector3F(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, MATH::GVECTORF& _outVector)
			{
				MATH::GVECTORF _v1 = _vector1;
				MATH::GVECTORF _v2 = _vector2;
				_outVector.x = (_v1.y * _v2.z) - (_v1.z * _v2.y);
				_outVector.y = (_v1.z * _v2.x) - (_v1.x * _v2.z);
				_outVector.z = (_v1.x * _v2.y) - (_v1.y * _v2.x);
				_outVector.w = 0.0f;

				return GReturn::SUCCESS;
			}
			static GReturn VectorXMatrixF(MATH::GVECTORF _vector, MATH::GMATRIXF _matrix, MATH::GVECTORF& _outVector)
			{
				MATH::GVECTORF _v = _vector;

				_outVector.x = (_v.x * _matrix.row1.x) + (_v.y * _matrix.row2.x) + (_v.z * _matrix.row3.x) + (_v.w * _matrix.row4.x);
				_outVector.y = (_v.x * _matrix.row1.y) + (_v.y * _matrix.row2.y) + (_v.z * _matrix.row3.y) + (_v.w * _matrix.row4.y);
				_outVector.z = (_v.x * _matrix.row1.z) + (_v.y * _matrix.row2.z) + (_v.z * _matrix.row3.z) + (_v.w * _matrix.row4.z);
				_outVector.w = (_v.x * _matrix.row1.w) + (_v.y * _matrix.row2.w) + (_v.z * _matrix.row3.w) + (_v.w * _matrix.row4.w);

				return GReturn::SUCCESS;
			}
			static GReturn TransformF(MATH::GVECTORF _vector, MATH::GMATRIXF _matrix, MATH::GVECTORF& _outVector)
			{
				MATH::GVECTORF _v = _vector;

				_outVector.x = (_v.x * _matrix.row1.x) + (_v.y * _matrix.row2.x) + (_v.z * _matrix.row3.x) + (_v.w * 0.0f);
				_outVector.y = (_v.x * _matrix.row1.y) + (_v.y * _matrix.row2.y) + (_v.z * _matrix.row3.y) + (_v.w * 0.0f);
				_outVector.z = (_v.x * _matrix.row1.z) + (_v.y * _matrix.row2.z) + (_v.z * _matrix.row3.z) + (_v.w * 0.0f);
				_outVector.w = 1.0f;

				return GReturn::SUCCESS;
			}
			static GReturn MagnitudeF(MATH::GVECTORF _vector, float& _outMagnitude)
			{
				_outMagnitude = sqrtf((_vector.x * _vector.x) + (_vector.y * _vector.y) + (_vector.z * _vector.z) + (_vector.w * _vector.w));
				if(G_COMPARISON_STANDARD_F( _outMagnitude, 0 ))
					return GReturn::FAILURE;
				return GReturn::SUCCESS;
			}
			static GReturn NormalizeF(MATH::GVECTORF _vector, MATH::GVECTORF& _outVector)
			{
				float magnitude = 0.0f;
				if(MagnitudeF( _vector, magnitude ) != GReturn::SUCCESS)
					return GReturn::FAILURE;

				_outVector.x = _vector.x / magnitude;
				_outVector.y = _vector.y / magnitude;
				_outVector.z = _vector.z / magnitude;
				_outVector.w = _vector.w / magnitude;

				return GReturn::SUCCESS;
			}
			static GReturn LerpF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, float _ratio, MATH::GVECTORF& _outVector)
			{
				_outVector.x = G_LERP(_vector1.x, _vector2.x, _ratio);
				_outVector.y = G_LERP(_vector1.y, _vector2.y, _ratio);
				_outVector.z = G_LERP(_vector1.z, _vector2.z, _ratio);
				_outVector.w = G_LERP(_vector1.w, _vector2.w, _ratio);

				return GReturn::SUCCESS;
			}
			static GReturn SplineF(MATH::GVECTORF _vector1, MATH::GVECTORF _vector2, MATH::GVECTORF _vector3, MATH::GVECTORF _vector4, float _ratio, MATH::GVECTORF& _outVector)
			{
				MATH::GVECTORF p0 = _vector1;
				MATH::GVECTORF p1 = _vector2;
				MATH::GVECTORF p2 = _vector3;
				MATH::GVECTORF p3 = _vector4;

				float t0 = 0.0f;
				float t1 = powf(sqrtf(powf((p1.x - p0.x), 2) + powf((p1.y - p0.y), 2) + powf((p1.z - p0.z), 2)), 0.5f) + t0;
				float t2 = powf(sqrtf(powf((p2.x - p1.x), 2) + powf((p2.y - p1.y), 2) + powf((p2.z - p1.z), 2)), 0.5f) + t1;
				float t3 = powf(sqrtf(powf((p3.x - p2.x), 2) + powf((p3.y - p2.y), 2) + powf((p3.z - p2.z), 2)), 0.5f) + t2;

				MATH::GVECTORF A1;
				MATH::GVECTORF A2;
				MATH::GVECTORF A3;
				MATH::GVECTORF B1;
				MATH::GVECTORF B2;

				float t = t1 + (t2 - t1) * _ratio;

				for (int i = 0; i < 3; i++)
				{
					A1.data[i] = (t1 - t) / (t1 - t0) * p0.data[i] + (t - t0) / (t1 - t0) * p1.data[i];
					A2.data[i] = (t2 - t) / (t2 - t1) * p1.data[i] + (t - t1) / (t2 - t1) * p2.data[i];
					A3.data[i] = (t3 - t) / (t3 - t2) * p2.data[i] + (t - t2) / (t3 - t2) * p3.data[i];

					B1.data[i] = (t2 - t) / (t2 - t0) * A1.data[i] + (t - t0) / (t2 - t0) * A2.data[i];
					B2.data[i] = (t3 - t) / (t3 - t1) * A2.data[i] + (t - t1) / (t3 - t1) * A3.data[i];

					_outVector.data[i] = (t2 - t) / (t2 - t1) * B1.data[i] + (t - t1) / (t2 - t1) * B2.data[i];
				}
				_outVector.w = 0;

				return GReturn::SUCCESS;
			}
			static GReturn Upgrade(MATH::GVECTORF _vectorF, MATH::GVECTORD& _outVectorD)
			{
				_outVectorD.x = static_cast<double>(_vectorF.x);
				_outVectorD.y = static_cast<double>(_vectorF.y);
				_outVectorD.z = static_cast<double>(_vectorF.z);
				_outVectorD.w = static_cast<double>(_vectorF.w);

				return GReturn::SUCCESS;
			}





			//double vector
			static GReturn AddVectorD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, MATH::GVECTORD& _outVector)
			{
				_outVector.x = _vector1.x + _vector2.x;
				_outVector.y = _vector1.y + _vector2.y;
				_outVector.z = _vector1.z + _vector2.z;
				_outVector.w = _vector1.w + _vector2.w;

				return GReturn::SUCCESS;
			}
			static GReturn SubtractVectorD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, MATH::GVECTORD& _outVector)
			{
				_outVector.x = _vector1.x - _vector2.x;
				_outVector.y = _vector1.y - _vector2.y;
				_outVector.z = _vector1.z - _vector2.z;
				_outVector.w = _vector1.w - _vector2.w;

				return GReturn::SUCCESS;
			}
			static GReturn ScaleD(MATH::GVECTORD _vector, double _scalar, MATH::GVECTORD& _outVector)
			{
				_outVector.x = _scalar * _vector.x;
				_outVector.y = _scalar * _vector.y;
				_outVector.z = _scalar * _vector.z;
				_outVector.w = _scalar * _vector.w;

				return GReturn::SUCCESS;
			}
			static GReturn DotD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, double& _outValue)
			{
				_outValue = (_vector1.x * _vector2.x) + (_vector1.y * _vector2.y) + (_vector1.z * _vector2.z) + (_vector1.w * _vector2.w);

				return GReturn::SUCCESS;
			}
			static GReturn CrossVector2D(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, double& _outValue)
			{
				_outValue = (_vector1.x * _vector2.y) - (_vector1.y * _vector2.x);

				return GReturn::SUCCESS;
			}
			static GReturn CrossVector3D(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, MATH::GVECTORD& _outVector)
			{
				MATH::GVECTORD _v1 = _vector1;
				MATH::GVECTORD _v2 = _vector2;
				_outVector.x = (_v1.y * _v2.z) - (_v1.z * _v2.y);
				_outVector.y = (_v1.z * _v2.x) - (_v1.x * _v2.z);
				_outVector.z = (_v1.x * _v2.y) - (_v1.y * _v2.x);
				_outVector.w = 0.0f;

				return GReturn::SUCCESS;
			}
			static GReturn VectorXMatrixD(MATH::GVECTORD _vector, MATH::GMATRIXD _matrix, MATH::GVECTORD& _outVector)
			{
				MATH::GVECTORD _v = _vector;
				_outVector.x = (_v.x * _matrix.row1.x) + (_v.y * _matrix.row2.x) + (_v.z * _matrix.row3.x) + (_v.w * _matrix.row4.x);
				_outVector.y = (_v.x * _matrix.row1.y) + (_v.y * _matrix.row2.y) + (_v.z * _matrix.row3.y) + (_v.w * _matrix.row4.y);
				_outVector.z = (_v.x * _matrix.row1.z) + (_v.y * _matrix.row2.z) + (_v.z * _matrix.row3.z) + (_v.w * _matrix.row4.z);
				_outVector.w = (_v.x * _matrix.row1.w) + (_v.y * _matrix.row2.w) + (_v.z * _matrix.row3.w) + (_v.w * _matrix.row4.w);

				return GReturn::SUCCESS;
			}
			static GReturn TransformD(MATH::GVECTORD _vector, MATH::GMATRIXD _matrix, MATH::GVECTORD& _outVector)
			{
				MATH::GVECTORD _v = _vector;
				_outVector.x = (_v.x * _matrix.row1.x) + (_v.y * _matrix.row2.x) + (_v.z * _matrix.row3.x) + (_v.w * 0.0f);
				_outVector.y = (_v.x * _matrix.row1.y) + (_v.y * _matrix.row2.y) + (_v.z * _matrix.row3.y) + (_v.w * 0.0f);
				_outVector.z = (_v.x * _matrix.row1.z) + (_v.y * _matrix.row2.z) + (_v.z * _matrix.row3.z) + (_v.w * 0.0f);
				_outVector.w = 1.0;

				return GReturn::SUCCESS;
			}
			static GReturn MagnitudeD(MATH::GVECTORD _vector, double& _outMagnitude)
			{
				_outMagnitude = sqrt((_vector.x * _vector.x) + (_vector.y * _vector.y) + (_vector.z * _vector.z) + (_vector.w * _vector.w));
				if (G_COMPARISON_STANDARD_D(_outMagnitude, 0))
					return GReturn::FAILURE;
				return GReturn::SUCCESS;
			}
			static GReturn NormalizeD(MATH::GVECTORD _vector, MATH::GVECTORD& _outVector)
			{
				double magnitude = 0.0;
				if (MagnitudeD(_vector, magnitude) != GReturn::SUCCESS)
				{
					return GReturn::FAILURE;
				}

				_outVector.x = _vector.x / magnitude;
				_outVector.y = _vector.y / magnitude;
				_outVector.z = _vector.z / magnitude;
				_outVector.w = _vector.w / magnitude;

				return GReturn::SUCCESS;
			}
			static GReturn LerpD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, double _ratio, MATH::GVECTORD& _outVector)
			{
				_outVector.x = G_LERP(_vector1.x, _vector2.x, _ratio);
				_outVector.y = G_LERP(_vector1.y, _vector2.y, _ratio);
				_outVector.z = G_LERP(_vector1.z, _vector2.z, _ratio);
				_outVector.w = G_LERP(_vector1.w, _vector2.w, _ratio);

				return GReturn::SUCCESS;
			}
			static GReturn SplineD(MATH::GVECTORD _vector1, MATH::GVECTORD _vector2, MATH::GVECTORD _vector3, MATH::GVECTORD _vector4, double _ratio, MATH::GVECTORD& _outVector)
			{
				MATH::GVECTORD p0 = _vector1;
				MATH::GVECTORD p1 = _vector2;
				MATH::GVECTORD p2 = _vector3;
				MATH::GVECTORD p3 = _vector4;

				double t0 = 0.0;
				double t1 = t1 = pow(sqrt(pow((p1.x - p0.x), 2.0) + pow((p1.y - p0.y), 2.0) + pow((p1.z - p0.z), 2.0)), 0.5) + t0;
				double t2 = t2 = pow(sqrt(pow((p2.x - p1.x), 2.0) + pow((p2.y - p1.y), 2.0) + pow((p2.z - p1.z), 2.0)), 0.5) + t1;
				double t3 = t3 = pow(sqrt(pow((p3.x - p2.x), 2.0) + pow((p3.y - p2.y), 2.0) + pow((p3.z - p2.z), 2.0)), 0.5) + t2;

				MATH::GVECTORD A1;
				MATH::GVECTORD A2;
				MATH::GVECTORD A3;
				MATH::GVECTORD B1;
				MATH::GVECTORD B2;

				double t = t1 + (t2 - t1) * _ratio;

				for (int i = 0; i < 3; i++)
				{
					A1.data[i] = (t1 - t) / (t1 - t0) * p0.data[i] + (t - t0) / (t1 - t0) * p1.data[i];
					A2.data[i] = (t2 - t) / (t2 - t1) * p1.data[i] + (t - t1) / (t2 - t1) * p2.data[i];
					A3.data[i] = (t3 - t) / (t3 - t2) * p2.data[i] + (t - t2) / (t3 - t2) * p3.data[i];

					B1.data[i] = (t2 - t) / (t2 - t0) * A1.data[i] + (t - t0) / (t2 - t0) * A2.data[i];
					B2.data[i] = (t3 - t) / (t3 - t1) * A2.data[i] + (t - t1) / (t3 - t1) * A3.data[i];

					_outVector.data[i] = (t2 - t) / (t2 - t1) * B1.data[i] + (t - t1) / (t2 - t1) * B2.data[i];
				}
				_outVector.w = 0;
				return GReturn::SUCCESS;
			}
			static GReturn Downgrade(MATH::GVECTORD _vectorD, MATH::GVECTORF& _outVectorF)
			{
				_outVectorF.x = static_cast<float>(_vectorD.x);
				_outVectorF.y = static_cast<float>(_vectorD.y);
				_outVectorF.z = static_cast<float>(_vectorD.z);
				_outVectorF.w = static_cast<float>(_vectorD.w);

				return GReturn::SUCCESS;
			}
		};
	}
}

#endif


namespace GW
{
	namespace MATH
	{
		class GVector final
			: public I::GProxy<I::GVectorInterface, I::GVectorImplementation>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GVector)
			GATEWARE_STATIC_FUNCTION(AddVectorF)
			GATEWARE_STATIC_FUNCTION(SubtractVectorF)
			GATEWARE_STATIC_FUNCTION(ScaleF)
			GATEWARE_STATIC_FUNCTION(DotF)
			GATEWARE_STATIC_FUNCTION(CrossVector2F)
			GATEWARE_STATIC_FUNCTION(CrossVector3F)
			GATEWARE_STATIC_FUNCTION(VectorXMatrixF)
			GATEWARE_STATIC_FUNCTION(TransformF)
			GATEWARE_STATIC_FUNCTION(MagnitudeF)
			GATEWARE_STATIC_FUNCTION(NormalizeF)
			GATEWARE_STATIC_FUNCTION(LerpF)
			GATEWARE_STATIC_FUNCTION(SplineF)
			GATEWARE_STATIC_FUNCTION(Upgrade)

			// doubles
			GATEWARE_STATIC_FUNCTION(AddVectorD)
			GATEWARE_STATIC_FUNCTION(SubtractVectorD)
			GATEWARE_STATIC_FUNCTION(ScaleD)
			GATEWARE_STATIC_FUNCTION(DotD)
			GATEWARE_STATIC_FUNCTION(CrossVector2D)
			GATEWARE_STATIC_FUNCTION(CrossVector3D)
			GATEWARE_STATIC_FUNCTION(VectorXMatrixD)
			GATEWARE_STATIC_FUNCTION(TransformD)
			GATEWARE_STATIC_FUNCTION(MagnitudeD)
			GATEWARE_STATIC_FUNCTION(NormalizeD)
			GATEWARE_STATIC_FUNCTION(LerpD)
			GATEWARE_STATIC_FUNCTION(SplineD)
			GATEWARE_STATIC_FUNCTION(Downgrade)
				
			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GVECTOR_H

/*---------------------------------
|	End of GVector.h
----------------------------------*/


/*---------------------------------
|	Begin of GMatrix.h
----------------------------------*/
#ifndef GMATRIX_H
#define GMATRIX_H





namespace GW
{
	namespace I
	{
		class GMatrixInterface : public virtual GInterfaceInterface
		{
		public:
			// Floats
			static GReturn AddMatrixF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SubtractMatrixF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MultiplyMatrixF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn VectorXMatrixF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GVECTORF& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ConvertQuaternionF(GW::MATH::GQUATERNIONF _quaternion, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MultiplyNumF(GW::MATH::GMATRIXF _matrix, float _scalar, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn DeterminantF(GW::MATH::GMATRIXF _matrix, float& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TransposeF(GW::MATH::GMATRIXF _matrix, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn InverseF(GW::MATH::GMATRIXF _matrix, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IdentityF(GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetRotationF(GW::MATH::GMATRIXF _matrix, GW::MATH::GQUATERNIONF& _outQuaternion) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetTranslationF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetScaleF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateXGlobalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateXLocalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateYGlobalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateYLocalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateZGlobalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateZLocalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotationYawPitchRollF(float _yaw, float _pitch, float _roll, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotationByVectorF(GW::MATH::GVECTORF _vector, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TranslateGlobalF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TranslateLocalF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ScaleGlobalF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ScaleLocalF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn LerpF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, float _ratio, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ProjectionDirectXLHF(float _fovY, float _aspect, float _zn, float _zf, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ProjectionOpenGLRHF(float _fovY, float _aspect, float _zn, float _zf, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ProjectionVulkanLHF(float _fovY, float _aspect, float _zn, float _zf, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ProjectionVulkanRHF(float _fovY, float _aspect, float _zn, float _zf, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn LookAtLHF(GW::MATH::GVECTORF _eye, GW::MATH::GVECTORF _at, GW::MATH::GVECTORF _up, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MakeRelativeF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MakeSeparateF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Upgrade(GW::MATH::GMATRIXF _matrixF, GW::MATH::GMATRIXD& _outMatrixD) { return GReturn::NO_IMPLEMENTATION; }

			// Doubles
			static GReturn AddMatrixD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SubtractMatrixD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MultiplyMatrixD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn VectorXMatrixD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GVECTORD& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ConvertQuaternionD(GW::MATH::GQUATERNIOND _quaternion, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MultiplyNumD(GW::MATH::GMATRIXD _matrix, double _scalar, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn DeterminantD(GW::MATH::GMATRIXD _matrix, double& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TransposeD(GW::MATH::GMATRIXD _matrix, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn InverseD(GW::MATH::GMATRIXD _matrix, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IdentityD(GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetRotationD(GW::MATH::GMATRIXD _matrix, GW::MATH::GQUATERNIOND& _outQuaternion) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetTranslationD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetScaleD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateXGlobalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateXLocalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateYGlobalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateYLocalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateZGlobalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateZLocalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotationYawPitchRollD(double _yaw, double _pitch, double _roll, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotationByVectorD(GW::MATH::GVECTORD _vector, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TranslateGlobalD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TranslateLocalD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ScaleGlobalD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GMATRIXD& _outMatirx) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ScaleLocalD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GMATRIXD& _outMatirx) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn LerpD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, double _ratio, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ProjectionDirectXLHD(double _fovY, double _aspect, double _zn, double _zf, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ProjectionOpenGLRHD(double _fovY, double _aspect, double _zn, double _zf, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ProjectionVulkanLHD(double _fovY, double _aspect, double _zn, double _zf, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ProjectionVulkanRHD(double _fovY, double _aspect, double _zn, double _zf, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn LookAtLHD(GW::MATH::GVECTORD _eye, GW::MATH::GVECTORD _at, GW::MATH::GVECTORD _up, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MakeRelativeD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MakeSeparateD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Downgrade(GW::MATH::GMATRIXD _matrixD, GW::MATH::GMATRIXF& _outMatrixF) { return GReturn::NO_IMPLEMENTATION; }
		};
	}// end CORE namespace
}// end GW namespace

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GMatrix.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_MATH) || defined(GATEWARE_DISABLE_GMATRIX) || \
    (defined(GATEWARE_ENABLE_MATH) && !defined(GATEWARE_DISABLE_GMATRIX) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
	namespace I
	{

		class GMatrixImplementation : public virtual GMatrixInterface,
			private GInterfaceImplementation
		{
		public:
			GReturn Create() { return GReturn::FEATURE_UNSUPPORTED; }
			// Floats
			static GReturn AddMatrixF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn SubtractMatrixF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MultiplyMatrixF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn VectorXMatrixF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GVECTORF& _outVector) { return GReturn::FAILURE; }
			static GReturn ConvertQuaternionF(GW::MATH::GQUATERNIONF _quaternion, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MultiplyNumF(GW::MATH::GMATRIXF _matrix, float _scalar, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn DeterminantF(GW::MATH::GMATRIXF _matrix, float& _outValue) { return GReturn::FAILURE; }
			static GReturn TransposeF(GW::MATH::GMATRIXF _matrix, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn InverseF(GW::MATH::GMATRIXF _matrix, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn IdentityF(GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn GetRotationF(GW::MATH::GMATRIXF _matrix, GW::MATH::GQUATERNIONF& _outQuaternion) { return GReturn::FAILURE; }
			static GReturn GetTranslationF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF& _outVector) { return GReturn::FAILURE; }
			static GReturn GetScaleF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF& _outVector) { return GReturn::FAILURE; }
			static GReturn RotateXGlobalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateXLocalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateYGlobalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateYLocalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateZGlobalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateZLocalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotationYawPitchRollF(float _yaw, float _pitch, float _roll, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotationByVectorF(GW::MATH::GVECTORF _vector, float _radian, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn TranslateGlobalF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn TranslateLocalF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ScaleGlobalF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ScaleLocalF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn LerpF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, float _ratio, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ProjectionDirectXLHF(float _fovY, float _aspect, float _zn, float _zf, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ProjectionOpenGLRHF(float _fovY, float _aspect, float _zn, float _zf, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ProjectionVulkanLHF(float _fovY, float _aspect, float _zn, float _zf, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ProjectionVulkanRHF(float _fovY, float _aspect, float _zn, float _zf, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn LookAtLHF(GW::MATH::GVECTORF _eye, GW::MATH::GVECTORF _at, GW::MATH::GVECTORF _up, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MakeRelativeF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MakeSeparateF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Upgrade(GW::MATH::GMATRIXF _matrixF, GW::MATH::GMATRIXD& _outMatrixD) { return GReturn::FAILURE; }

			// Doubles
			static GReturn AddMatrixD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn SubtractMatrixD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MultiplyMatrixD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn VectorXMatrixD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GVECTORD& _outVector) { return GReturn::FAILURE; }
			static GReturn ConvertQuaternionD(GW::MATH::GQUATERNIOND _quaternion, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MultiplyNumD(GW::MATH::GMATRIXD _matrix, double _scalar, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn DeterminantD(GW::MATH::GMATRIXD _matrix, double& _outValue) { return GReturn::FAILURE; }
			static GReturn TransposeD(GW::MATH::GMATRIXD _matrix, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn InverseD(GW::MATH::GMATRIXD _matrix, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn IdentityD(GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn GetRotationD(GW::MATH::GMATRIXD _matrix, GW::MATH::GQUATERNIOND& _outQuaternion) { return GReturn::FAILURE; }
			static GReturn GetTranslationD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD& _outVector) { return GReturn::FAILURE; }
			static GReturn GetScaleD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD& _outVector) { return GReturn::FAILURE; }
			static GReturn RotateXGlobalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateXLocalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateYGlobalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateYLocalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateZGlobalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateZLocalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotationYawPitchRollD(double _yaw, double _pitch, double _roll, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotationByVectorD(GW::MATH::GVECTORD _vector, double _radian, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn TranslateGlobalD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn TranslateLocalD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ScaleGlobalD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GMATRIXD& _outMatirx) { return GReturn::FAILURE; }
			static GReturn ScaleLocalD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GMATRIXD& _outMatirx) { return GReturn::FAILURE; }
			static GReturn LerpD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, double _ratio, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ProjectionDirectXLHD(double _fovY, double _aspect, double _zn, double _zf, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ProjectionOpenGLRHD(double _fovY, double _aspect, double _zn, double _zf, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ProjectionVulkanLHD(double _fovY, double _aspect, double _zn, double _zf, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ProjectionVulkanRHD(double _fovY, double _aspect, double _zn, double _zf, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn LookAtLHD(GW::MATH::GVECTORD _eye, GW::MATH::GVECTORD _at, GW::MATH::GVECTORD _up, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MakeRelativeD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MakeSeparateD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Downgrade(GW::MATH::GMATRIXD _matrixD, GW::MATH::GMATRIXF& _outMatrixF) { return GReturn::FAILURE; }
		};
	}
}

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
    #include <cmath>

namespace GW
{
	namespace I
	{
		class GMatrixImplementation : public virtual GMatrixInterface,
			private GInterfaceImplementation
		{
		public:
			GReturn Create()
			{
				return GReturn::SUCCESS;
			}
			// Floats
			static GReturn AddMatrixF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix)
			{
				GW::MATH::GMATRIXF _m1 = _matrix1;
				GW::MATH::GMATRIXF _m2 = _matrix2;
				for(int i = 0; i < 16; i++)
				{
					_outMatrix.data[i] = _m1.data[i] + _m2.data[i];
				}
				return GW::GReturn::SUCCESS;
			}
			static GReturn SubtractMatrixF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix)
			{
				GW::MATH::GMATRIXF _m1 = _matrix1;
				GW::MATH::GMATRIXF _m2 = _matrix2;
				for(int i = 0; i < 16; i++)
				{
					_outMatrix.data[i] = _m1.data[i] - _m2.data[i];
				}
				return GW::GReturn::SUCCESS;
			}
			static GReturn MultiplyMatrixF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix)
			{
				GW::MATH::GMATRIXF _m1 = _matrix1;
				GW::MATH::GMATRIXF _m2 = _matrix2;

				_outMatrix.data[0] = _m1.data[0] * _m2.data[0] + _m1.data[1] * _m2.data[4] + _m1.data[2] * _m2.data[8] + _m1.data[3] * _m2.data[12];
				_outMatrix.data[1] = _m1.data[0] * _m2.data[1] + _m1.data[1] * _m2.data[5] + _m1.data[2] * _m2.data[9] + _m1.data[3] * _m2.data[13];
				_outMatrix.data[2] = _m1.data[0] * _m2.data[2] + _m1.data[1] * _m2.data[6] + _m1.data[2] * _m2.data[10] + _m1.data[3] * _m2.data[14];
				_outMatrix.data[3] = _m1.data[0] * _m2.data[3] + _m1.data[1] * _m2.data[7] + _m1.data[2] * _m2.data[11] + _m1.data[3] * _m2.data[15];

				_outMatrix.data[4] = _m1.data[4] * _m2.data[0] + _m1.data[5] * _m2.data[4] + _m1.data[6] * _m2.data[8] + _m1.data[7] * _m2.data[12];
				_outMatrix.data[5] = _m1.data[4] * _m2.data[1] + _m1.data[5] * _m2.data[5] + _m1.data[6] * _m2.data[9] + _m1.data[7] * _m2.data[13];
				_outMatrix.data[6] = _m1.data[4] * _m2.data[2] + _m1.data[5] * _m2.data[6] + _m1.data[6] * _m2.data[10] + _m1.data[7] * _m2.data[14];
				_outMatrix.data[7] = _m1.data[4] * _m2.data[3] + _m1.data[5] * _m2.data[7] + _m1.data[6] * _m2.data[11] + _m1.data[7] * _m2.data[15];

				_outMatrix.data[8] = _m1.data[8] * _m2.data[0] + _m1.data[9] * _m2.data[4] + _m1.data[10] * _m2.data[8] + _m1.data[11] * _m2.data[12];
				_outMatrix.data[9] = _m1.data[8] * _m2.data[1] + _m1.data[9] * _m2.data[5] + _m1.data[10] * _m2.data[9] + _m1.data[11] * _m2.data[13];
				_outMatrix.data[10] = _m1.data[8] * _m2.data[2] + _m1.data[9] * _m2.data[6] + _m1.data[10] * _m2.data[10] + _m1.data[11] * _m2.data[14];
				_outMatrix.data[11] = _m1.data[8] * _m2.data[3] + _m1.data[9] * _m2.data[7] + _m1.data[10] * _m2.data[11] + _m1.data[11] * _m2.data[15];

				_outMatrix.data[12] = _m1.data[12] * _m2.data[0] + _m1.data[13] * _m2.data[4] + _m1.data[14] * _m2.data[8] + _m1.data[15] * _m2.data[12];
				_outMatrix.data[13] = _m1.data[12] * _m2.data[1] + _m1.data[13] * _m2.data[5] + _m1.data[14] * _m2.data[9] + _m1.data[15] * _m2.data[13];
				_outMatrix.data[14] = _m1.data[12] * _m2.data[2] + _m1.data[13] * _m2.data[6] + _m1.data[14] * _m2.data[10] + _m1.data[15] * _m2.data[14];
				_outMatrix.data[15] = _m1.data[12] * _m2.data[3] + _m1.data[13] * _m2.data[7] + _m1.data[14] * _m2.data[11] + _m1.data[15] * _m2.data[15];

				return GW::GReturn::SUCCESS;
			}
			static GReturn VectorXMatrixF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GVECTORF& _outVector)
			{
				GW::MATH::GVECTORF _v = _vector;

				_outVector.x = _v.data[0] * _matrix.data[0] + _v.data[1] * _matrix.data[4] + _v.data[2] * _matrix.data[8] + _v.data[3] * _matrix.data[12];
				_outVector.y = _v.data[0] * _matrix.data[1] + _v.data[1] * _matrix.data[5] + _v.data[2] * _matrix.data[9] + _v.data[3] * _matrix.data[13];
				_outVector.z = _v.data[0] * _matrix.data[2] + _v.data[1] * _matrix.data[6] + _v.data[2] * _matrix.data[10] + _v.data[3] * _matrix.data[14];
				_outVector.w = _v.data[0] * _matrix.data[3] + _v.data[1] * _matrix.data[7] + _v.data[2] * _matrix.data[11] + _v.data[3] * _matrix.data[15];

				return GW::GReturn::SUCCESS;
			}
			static GReturn ConvertQuaternionF(GW::MATH::GQUATERNIONF _quaternion, GW::MATH::GMATRIXF& _outMatrix)
			{
				float xx2 = 2 * _quaternion.x * _quaternion.x;
				float yy2 = 2 * _quaternion.y * _quaternion.y;
				float zz2 = 2 * _quaternion.z * _quaternion.z;

				float xy2 = 2 * _quaternion.x * _quaternion.y;
				float xz2 = 2 * _quaternion.x * _quaternion.z;
				float yz2 = 2 * _quaternion.y * _quaternion.z;

				float wx2 = 2 * _quaternion.w * _quaternion.x;
				float wy2 = 2 * _quaternion.w * _quaternion.y;
				float wz2 = 2 * _quaternion.w * _quaternion.z;

				_outMatrix.data[0] = 1.0f - yy2 - zz2;
				_outMatrix.data[1] = xy2 - wz2;
				_outMatrix.data[2] = xz2 + wy2;
				_outMatrix.data[3] = 0.0f;
				_outMatrix.data[4] = xy2 + wz2;
				_outMatrix.data[5] = 1.0f - xx2 - zz2;
				_outMatrix.data[6] = yz2 - wx2;
				_outMatrix.data[7] = 0.0f;
				_outMatrix.data[8] = xz2 - wy2;
				_outMatrix.data[9] = yz2 + wx2;
				_outMatrix.data[10] = 1.0f - xx2 - yy2;
				_outMatrix.data[11] = 0.0f;
				_outMatrix.data[12] = 0.0f;
				_outMatrix.data[13] = 0.0f;
				_outMatrix.data[14] = 0.0f;
				_outMatrix.data[15] = 1.0f;

				return GW::GReturn::SUCCESS;
			}
			static GReturn MultiplyNumF(GW::MATH::GMATRIXF _matrix, float _scalar, GW::MATH::GMATRIXF& _outMatrix)
			{
				GW::MATH::GMATRIXF _m = _matrix;
				for(int i = 0; i < 16; i++)
				{
					_outMatrix.data[i] = _m.data[i] * _scalar;
				}
				return GW::GReturn::SUCCESS;
			}
			static GReturn DeterminantF(GW::MATH::GMATRIXF _matrix, float& _outValue)
			{
				float a0 = _matrix.data[0] * _matrix.data[5] - _matrix.data[1] * _matrix.data[4];
				float a1 = _matrix.data[0] * _matrix.data[6] - _matrix.data[2] * _matrix.data[4];
				float a2 = _matrix.data[0] * _matrix.data[7] - _matrix.data[3] * _matrix.data[4];
				float a3 = _matrix.data[1] * _matrix.data[6] - _matrix.data[2] * _matrix.data[5];
				float a4 = _matrix.data[1] * _matrix.data[7] - _matrix.data[3] * _matrix.data[5];
				float a5 = _matrix.data[2] * _matrix.data[7] - _matrix.data[3] * _matrix.data[6];
				float b0 = _matrix.data[8] * _matrix.data[13] - _matrix.data[9] * _matrix.data[12];
				float b1 = _matrix.data[8] * _matrix.data[14] - _matrix.data[10] * _matrix.data[12];
				float b2 = _matrix.data[8] * _matrix.data[15] - _matrix.data[11] * _matrix.data[12];
				float b3 = _matrix.data[9] * _matrix.data[14] - _matrix.data[10] * _matrix.data[13];
				float b4 = _matrix.data[9] * _matrix.data[15] - _matrix.data[11] * _matrix.data[13];
				float b5 = _matrix.data[10] * _matrix.data[15] - _matrix.data[11] * _matrix.data[14];

				_outValue = a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0;

				return GW::GReturn::SUCCESS;
			}
			static GReturn TransposeF(GW::MATH::GMATRIXF _matrix, GW::MATH::GMATRIXF& _outMatrix)
			{
				GW::MATH::GMATRIXF _m = _matrix;

				_outMatrix.data[0] = _m.data[0];
				_outMatrix.data[1] = _m.data[4];
				_outMatrix.data[2] = _m.data[8];
				_outMatrix.data[3] = _m.data[12];
				_outMatrix.data[4] = _m.data[1];
				_outMatrix.data[5] = _m.data[5];
				_outMatrix.data[6] = _m.data[9];
				_outMatrix.data[7] = _m.data[13];
				_outMatrix.data[8] = _m.data[2];
				_outMatrix.data[9] = _m.data[6];
				_outMatrix.data[10] = _m.data[10];
				_outMatrix.data[11] = _m.data[14];
				_outMatrix.data[12] = _m.data[3];
				_outMatrix.data[13] = _m.data[7];
				_outMatrix.data[14] = _m.data[11];
				_outMatrix.data[15] = _m.data[15];
				return GW::GReturn::SUCCESS;
			}
			static GReturn InverseF(GW::MATH::GMATRIXF _matrix, GW::MATH::GMATRIXF& _outMatrix)
			{
				GW::MATH::GMATRIXF _m = _matrix;

				float det;
				float a0 = _m.data[0] * _m.data[5] - _m.data[1] * _m.data[4];
				float a1 = _m.data[0] * _m.data[6] - _m.data[2] * _m.data[4];
				float a2 = _m.data[0] * _m.data[7] - _m.data[3] * _m.data[4];
				float a3 = _m.data[1] * _m.data[6] - _m.data[2] * _m.data[5];
				float a4 = _m.data[1] * _m.data[7] - _m.data[3] * _m.data[5];
				float a5 = _m.data[2] * _m.data[7] - _m.data[3] * _m.data[6];
				float b0 = _m.data[8] * _m.data[13] - _m.data[9] * _m.data[12];
				float b1 = _m.data[8] * _m.data[14] - _m.data[10] * _m.data[12];
				float b2 = _m.data[8] * _m.data[15] - _m.data[11] * _m.data[12];
				float b3 = _m.data[9] * _m.data[14] - _m.data[10] * _m.data[13];
				float b4 = _m.data[9] * _m.data[15] - _m.data[11] * _m.data[13];
				float b5 = _m.data[10] * _m.data[15] - _m.data[11] * _m.data[14];

				det = a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0;
				if(G_COMPARISON_STANDARD_F(det, 0.0f))
				{
					return GW::GReturn::FAILURE;
				}
				_outMatrix.data[0] = _m.data[5] * b5 - _m.data[6] * b4 + _m.data[7] * b3;
				_outMatrix.data[1] = -_m.data[1] * b5 + _m.data[2] * b4 - _m.data[3] * b3;
				_outMatrix.data[2] = _m.data[13] * a5 - _m.data[14] * a4 + _m.data[15] * a3;
				_outMatrix.data[3] = -_m.data[9] * a5 + _m.data[10] * a4 - _m.data[11] * a3;

				_outMatrix.data[4] = -_m.data[4] * b5 + _m.data[6] * b2 - _m.data[7] * b1;
				_outMatrix.data[5] = _m.data[0] * b5 - _m.data[2] * b2 + _m.data[3] * b1;
				_outMatrix.data[6] = -_m.data[12] * a5 + _m.data[14] * a2 - _m.data[15] * a1;
				_outMatrix.data[7] = _m.data[8] * a5 - _m.data[10] * a2 + _m.data[11] * a1;

				_outMatrix.data[8] = _m.data[4] * b4 - _m.data[5] * b2 + _m.data[7] * b0;
				_outMatrix.data[9] = -_m.data[0] * b4 + _m.data[1] * b2 - _m.data[3] * b0;
				_outMatrix.data[10] = _m.data[12] * a4 - _m.data[13] * a2 + _m.data[15] * a0;
				_outMatrix.data[11] = -_m.data[8] * a4 + _m.data[9] * a2 - _m.data[11] * a0;

				_outMatrix.data[12] = -_m.data[4] * b3 + _m.data[5] * b1 - _m.data[6] * b0;
				_outMatrix.data[13] = _m.data[0] * b3 - _m.data[1] * b1 + _m.data[2] * b0;
				_outMatrix.data[14] = -_m.data[12] * a3 + _m.data[13] * a1 - _m.data[14] * a0;
				_outMatrix.data[15] = _m.data[8] * a3 - _m.data[9] * a1 + _m.data[10] * a0;

				MultiplyNumF(_outMatrix, 1.0f / det, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn IdentityF(GW::MATH::GMATRIXF& _outMatrix)
			{
				_outMatrix = GW::MATH::GIdentityMatrixF;
				return GW::GReturn::SUCCESS;
			}
			static GReturn GetRotationF(GW::MATH::GMATRIXF _matrix, GW::MATH::GQUATERNIONF& _outQuaternion)
			{
				GW::MATH::GMATRIXF _m = _matrix;

				float det;
				float sx = sqrt(_m.data[0] * _m.data[0] + _m.data[4] * _m.data[4] + _m.data[8] * _m.data[8]);
				float sy = sqrt(_m.data[1] * _m.data[1] + _m.data[5] * _m.data[5] + _m.data[9] * _m.data[9]);
				float sz = sqrt(_m.data[2] * _m.data[2] + _m.data[6] * _m.data[6] + _m.data[10] * _m.data[10]);
				DeterminantF(_m, det);

				if(G_COMPARISON_STANDARD_F(det, 0.0f))
					return GW::GReturn::FAILURE;

				if(det < 0)
				{
					sx = -sx;
				}

				GW::MATH::GMATRIXF Rotation = _m;
				Rotation.data[0] /= sx;
				Rotation.data[4] /= sx;
				Rotation.data[8] /= sx;
				Rotation.data[1] /= sy;
				Rotation.data[5] /= sy;
				Rotation.data[9] /= sy;
				Rotation.data[2] /= sz;
				Rotation.data[6] /= sz;
				Rotation.data[10] /= sz;


				float trace = Rotation.data[0] + Rotation.data[5] + Rotation.data[10] + 1;

				if(trace > G_EPSILON_F)
				{
					float s = 0.5f / sqrt(trace);
					_outQuaternion.x = (Rotation.row3.y - Rotation.row2.z) * s;
					_outQuaternion.y = (Rotation.row1.z - Rotation.row3.x) * s;
					_outQuaternion.z = (Rotation.row2.x - Rotation.row1.y) * s;
					_outQuaternion.w = 0.25f / s;
				}
				else
				{
					if(Rotation.row1.x > Rotation.row2.y&& Rotation.row1.x > Rotation.row3.z)
					{
						float s = 0.5f / sqrt(1.0f + Rotation.row1.x - Rotation.row2.y - Rotation.row3.z);
						_outQuaternion.x = 0.25f / s;
						_outQuaternion.y = (Rotation.row1.y + Rotation.row2.x) * s;
						_outQuaternion.z = (Rotation.row1.z + Rotation.row3.x) * s;
						_outQuaternion.w = (Rotation.row3.y - Rotation.row2.z) * s;
					}
					else if(Rotation.row2.y > Rotation.row3.z)
					{
						float s = 0.5f / sqrt(1.0f + Rotation.row2.y - Rotation.row1.x - Rotation.row3.z);
						_outQuaternion.x = (Rotation.row1.y + Rotation.row2.x) * s;
						_outQuaternion.y = 0.25f / s;
						_outQuaternion.z = (Rotation.row2.z + Rotation.row3.y) * s;
						_outQuaternion.w = (Rotation.row1.z - Rotation.row3.x) * s;
					}
					else
					{
						float s = 0.5f / sqrt(1.0f + Rotation.row3.z - Rotation.row1.x - Rotation.row2.y);
						_outQuaternion.x = (Rotation.row1.z + Rotation.row3.x) * s;
						_outQuaternion.y = (Rotation.row2.z + Rotation.row3.y) * s;
						_outQuaternion.z = 0.25f / s;
						_outQuaternion.w = (Rotation.row2.x - Rotation.row1.y) * s;
					}
				}

				return GW::GReturn::SUCCESS;
			}
			static GReturn GetTranslationF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF& _outVector)
			{
				_outVector = _matrix.row4;
				_outVector.w = 0;
				return GW::GReturn::SUCCESS;
			}
			static GReturn GetScaleF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF& _outVector)
			{
				float det;

				_outVector.x = sqrt(_matrix.data[0] * _matrix.data[0] + _matrix.data[4] * _matrix.data[4] + _matrix.data[8] * _matrix.data[8]);
				_outVector.y = sqrt(_matrix.data[1] * _matrix.data[1] + _matrix.data[5] * _matrix.data[5] + _matrix.data[9] * _matrix.data[9]);
				_outVector.z = sqrt(_matrix.data[2] * _matrix.data[2] + _matrix.data[6] * _matrix.data[6] + _matrix.data[10] * _matrix.data[10]);
				_outVector.w = 0;

				DeterminantF(_matrix, det);
				if(det < 0)
				{
					_outVector.x = -_outVector.x;
				}

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotateXGlobalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix)
			{
				float c = cos(_radian);
				float s = sin(_radian);
				GW::MATH::GMATRIXF Rotation = GW::MATH::GIdentityMatrixF;
				Rotation.data[5] = c;
				Rotation.data[6] = s;
				Rotation.data[9] = -s;
				Rotation.data[10] = c;

				// store translation
				GW::MATH::GVECTORF translation = _matrix.row4;

				MultiplyMatrixF(_matrix, Rotation, _outMatrix);

				// restore translation
				_outMatrix.row4 = translation;

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotateXLocalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) {
				float c = cos(_radian);
				float s = sin(_radian);
				GW::MATH::GMATRIXF Rotation = GW::MATH::GIdentityMatrixF;
				Rotation.data[5] = c;
				Rotation.data[6] = s;
				Rotation.data[9] = -s;
				Rotation.data[10] = c;

				MultiplyMatrixF(Rotation, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotateYGlobalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix)
			{
				float c = cos(_radian);
				float s = sin(_radian);
				GW::MATH::GMATRIXF Rotation = GW::MATH::GIdentityMatrixF;
				Rotation.data[0] = c;
				Rotation.data[2] = -s;
				Rotation.data[8] = s;
				Rotation.data[10] = c;

				// store translation
				GW::MATH::GVECTORF translation = _matrix.row4;

				MultiplyMatrixF(_matrix, Rotation, _outMatrix);

				// restore translation
				_outMatrix.row4 = translation;

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotateYLocalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) {
				float c = cos(_radian);
				float s = sin(_radian);
				GW::MATH::GMATRIXF Rotation = GW::MATH::GIdentityMatrixF;
				Rotation.data[0] = c;
				Rotation.data[2] = -s;
				Rotation.data[8] = s;
				Rotation.data[10] = c;

				MultiplyMatrixF(Rotation, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotateZGlobalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix)
			{
				float c = cos(_radian);
				float s = sin(_radian);
				GW::MATH::GMATRIXF Rotation = GW::MATH::GIdentityMatrixF;
				Rotation.data[0] = c;
				Rotation.data[1] = s;
				Rotation.data[4] = -s;
				Rotation.data[5] = c;

				// store translation
				GW::MATH::GVECTORF translation = _matrix.row4;

				MultiplyMatrixF(_matrix, Rotation, _outMatrix);

				// restore translation
				_outMatrix.row4 = translation;

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotateZLocalF(GW::MATH::GMATRIXF _matrix, float _radian, GW::MATH::GMATRIXF& _outMatrix) {
				float c = cos(_radian);
				float s = sin(_radian);
				GW::MATH::GMATRIXF Rotation = GW::MATH::GIdentityMatrixF;
				Rotation.data[0] = c;
				Rotation.data[1] = s;
				Rotation.data[4] = -s;
				Rotation.data[5] = c;

				MultiplyMatrixF(Rotation, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotationYawPitchRollF(float _yaw, float _pitch, float _roll, GW::MATH::GMATRIXF& _outMatrix)
			{
				_outMatrix = GW::MATH::GIdentityMatrixF;
				GW::MATH::GMATRIXF RotationX;
				GW::MATH::GMATRIXF RotationY;
				GW::MATH::GMATRIXF RotationZ;
				GW::MATH::GMATRIXF reuslt;
				RotateZGlobalF(GW::MATH::GIdentityMatrixF, _roll, RotationZ);
				RotateXGlobalF(GW::MATH::GIdentityMatrixF, _pitch, RotationX);
				RotateYGlobalF(GW::MATH::GIdentityMatrixF, _yaw, RotationY);

				MultiplyMatrixF(RotationX, RotationY, reuslt);
				MultiplyMatrixF(RotationZ, reuslt, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotationByVectorF(GW::MATH::GVECTORF _vector, float _radian, GW::MATH::GMATRIXF& _outMatrix)
			{
				float x = _vector.x;
				float y = _vector.y;
				float z = _vector.z;

				float magnitude = x * x + y * y + z * z;
				if(!G_COMPARISON_STANDARD_F(magnitude, 1))
				{
					magnitude = sqrt(magnitude);
					if(!G_COMPARISON_STANDARD_F(magnitude, 0))
					{
						magnitude = 1.0f / magnitude;
						x = x * magnitude;
						y = y * magnitude;
						z = z * magnitude;
					}
					else return GW::GReturn::FAILURE;
				}
				float c = cos(_radian);
				float s = sin(_radian);

				float t = 1.0f - c;
				float tx = t * x;
				float ty = t * y;
				float tz = t * z;
				float txy = tx * y;
				float txz = tx * z;
				float tyz = ty * z;
				float sx = s * x;
				float sy = s * y;
				float sz = s * z;

				_outMatrix.data[0] = c + tx * x;
				_outMatrix.data[1] = txy + sz;
				_outMatrix.data[2] = txz - sy;
				_outMatrix.data[3] = 0.0f;

				_outMatrix.data[4] = txy - sz;
				_outMatrix.data[5] = c + ty * y;
				_outMatrix.data[6] = tyz + sx;
				_outMatrix.data[7] = 0.0f;

				_outMatrix.data[8] = txz + sy;
				_outMatrix.data[9] = tyz - sx;
				_outMatrix.data[10] = c + tz * z;
				_outMatrix.data[11] = 0.0f;

				_outMatrix.data[12] = 0.0f;
				_outMatrix.data[13] = 0.0f;
				_outMatrix.data[14] = 0.0f;
				_outMatrix.data[15] = 1.0f;

				return GW::GReturn::SUCCESS;
			}
			static GReturn TranslateGlobalF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GMATRIXF& _outMatrix) {
				GW::MATH::GMATRIXF Translation = GW::MATH::GIdentityMatrixF;
				Translation.data[12] = _vector.x;
				Translation.data[13] = _vector.y;
				Translation.data[14] = _vector.z;

				MultiplyMatrixF(_matrix, Translation, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn TranslateLocalF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GMATRIXF& _outMatrix)
			{
				GW::MATH::GMATRIXF Translation = GW::MATH::GIdentityMatrixF;
				Translation.data[12] = _vector.x;
				Translation.data[13] = _vector.y;
				Translation.data[14] = _vector.z;

				MultiplyMatrixF(Translation, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn ScaleGlobalF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GMATRIXF& _outMatrix)
			{
				GW::MATH::GMATRIXF Scale = GW::MATH::GIdentityMatrixF;
				Scale.data[0] = _vector.x;
				Scale.data[5] = _vector.y;
				Scale.data[10] = _vector.z;

				// store translation
				GW::MATH::GVECTORF translation = _matrix.row4;

				MultiplyMatrixF(_matrix, Scale, _outMatrix);

				// restore translation
				_outMatrix.row4 = translation;

				return GW::GReturn::SUCCESS;
			}
			static GReturn ScaleLocalF(GW::MATH::GMATRIXF _matrix, GW::MATH::GVECTORF _vector, GW::MATH::GMATRIXF& _outMatrix) {
				GW::MATH::GMATRIXF Scale = GW::MATH::GIdentityMatrixF;
				Scale.data[0] = _vector.x;
				Scale.data[5] = _vector.y;
				Scale.data[10] = _vector.z;

				MultiplyMatrixF(Scale, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn LerpF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, float _ratio, GW::MATH::GMATRIXF& _outMatrix)
			{
				GW::MATH::GMATRIXF _m1 = _matrix1;
				GW::MATH::GMATRIXF _m2 = _matrix2;

				for(int i = 0; i < 16; i++)
				{
					_outMatrix.data[i] = G_LERP(_m1.data[i], _m2.data[i], _ratio);
				}
				return GW::GReturn::SUCCESS;
			}
			static GReturn ProjectionDirectXLHF(float _fovY, float _aspect, float _zn, float _zf, GW::MATH::GMATRIXF& _outMatrix)
			{
				if(G_COMPARISON_STANDARD_F(_aspect, 0.0f)) return GW::GReturn::FAILURE;

				float yScale = 1.0f / tanf(_fovY / 2.0f);
				float z = _zf / (_zf - _zn);

				_outMatrix = {};
				_outMatrix.row1.data[0] = yScale / _aspect;
				_outMatrix.row2.data[1] = yScale;
				_outMatrix.row3.data[2] = z;
				_outMatrix.row3.data[3] = 1.0f;
				_outMatrix.row4.data[2] = -_zn * z;

				return GW::GReturn::SUCCESS;
			}
			static GReturn ProjectionOpenGLRHF(float _fovY, float _aspect, float _zn, float _zf, GW::MATH::GMATRIXF& _outMatrix)
			{
				if(G_COMPARISON_STANDARD_F(_aspect, 0.0f)) return GW::GReturn::FAILURE;

				float yScale = 1.0f / tanf(_fovY / 0.5f);
				float z = _zf / (_zf - _zn);

				_outMatrix = {};
				_outMatrix.row1.data[0] = yScale / _aspect;
				_outMatrix.row2.data[1] = yScale;
				_outMatrix.row3.data[2] = -(_zf + _zn) * z;
				_outMatrix.row3.data[3] = (-2.0f * _zf * _zn) * z;
				_outMatrix.row4.data[2] = -1.0f;

				return GW::GReturn::SUCCESS;
			}
			static GReturn ProjectionVulkanLHF(float _fovY, float _aspect, float _zn, float _zf, GW::MATH::GMATRIXF& _outMatrix)
			{
				if(G_COMPARISON_STANDARD_F(_aspect, 0.0f)) return GW::GReturn::FAILURE;

				float yScale = 1.0f / tanf(_fovY * 0.5f);
				float z = _zf / (_zf - _zn);

				_outMatrix = {};
				_outMatrix.row1.data[0] = yScale / _aspect;
				_outMatrix.row2.data[1] = -yScale;
				_outMatrix.row3.data[2] = z;
				_outMatrix.row3.data[3] = 1.0f;
				_outMatrix.row4.data[2] = -(_zf * _zn) / (_zf - _zn);

				return GW::GReturn::SUCCESS;
			}
			static GReturn ProjectionVulkanRHF(float _fovY, float _aspect, float _zn, float _zf, GW::MATH::GMATRIXF& _outMatrix)
			{
				if(G_COMPARISON_STANDARD_F(_aspect, 0.0f)) return GW::GReturn::FAILURE;

				float yScale = 1.0f / tanf(_fovY * 0.5f);
				float z = _zf / (_zn - _zf);

				_outMatrix = {};
				_outMatrix.row1.data[0] = yScale / _aspect;
				_outMatrix.row2.data[1] = -yScale;
				_outMatrix.row3.data[2] = z;
				_outMatrix.row3.data[3] = -1.0f;
				_outMatrix.row4.data[2] = _zn * z;

				return GW::GReturn::SUCCESS;
			}
			static GReturn LookAtLHF(GW::MATH::GVECTORF _eye, GW::MATH::GVECTORF _at, GW::MATH::GVECTORF _up, GW::MATH::GMATRIXF& _outMatrix)
			{
				_outMatrix = GW::MATH::GIdentityMatrixF;
				GW::MATH::GVECTORF temp;
				GW::MATH::GVECTORF camDir;	  //zaxis
				GW::MATH::GVECTORF camRight;	  //xaxis
				GW::MATH::GVECTORF camUp;		  //yaxis
				float magnitudeX;
				float magnitudeZ;

				camDir.x = _at.x - _eye.x;
				camDir.y = _at.y - _eye.y;
				camDir.z = _at.z - _eye.z;

				magnitudeZ = sqrt((camDir.x * camDir.x) + (camDir.y * camDir.y) + (camDir.z * camDir.z));
				if(G_COMPARISON_STANDARD_F(magnitudeZ, 0.0f)) return GW::GReturn::FAILURE;


				camDir.x /= magnitudeZ;
				camDir.y /= magnitudeZ;
				camDir.z /= magnitudeZ;


				camRight.x = (_up.y * camDir.z) - (_up.z * camDir.y);
				camRight.y = (_up.z * camDir.x) - (_up.x * camDir.z);
				camRight.z = (_up.x * camDir.y) - (_up.y * camDir.x);

				magnitudeX = sqrt((camRight.x * camRight.x) + (camRight.y * camRight.y) + (camRight.z * camRight.z));
				if(G_COMPARISON_STANDARD_F(magnitudeX, 0.0f)) return GW::GReturn::FAILURE;


				camRight.x /= magnitudeX;
				camRight.y /= magnitudeX;
				camRight.z /= magnitudeX;


				camUp.x = (camDir.y * camRight.z) - (camDir.z * camRight.y);
				camUp.y = (camDir.z * camRight.x) - (camDir.x * camRight.z);
				camUp.z = (camDir.x * camRight.y) - (camDir.y * camRight.x);

				temp.x = camRight.x * _eye.x + camRight.y * _eye.y + camRight.z * _eye.z;
				temp.y = camUp.x * _eye.x + camUp.y * _eye.y + camUp.z * _eye.z;
				temp.z = camDir.x * _eye.x + camDir.y * _eye.y + camDir.z * _eye.z;

				_outMatrix.data[0] = camRight.x;
				_outMatrix.data[4] = camRight.y;
				_outMatrix.data[8] = camRight.z;
				_outMatrix.data[12] = -temp.x;

				_outMatrix.data[1] = camUp.x;
				_outMatrix.data[5] = camUp.y;
				_outMatrix.data[9] = camUp.z;
				_outMatrix.data[13] = -temp.y;

				_outMatrix.data[2] = camDir.x;
				_outMatrix.data[6] = camDir.y;
				_outMatrix.data[10] = camDir.z;
				_outMatrix.data[14] = -temp.z;
				return GW::GReturn::SUCCESS;
			}
			static GReturn MakeRelativeF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix)
			{
				GW::MATH::GMATRIXF inverseMatrix2; 
				InverseF(_matrix2, inverseMatrix2);

				MultiplyMatrixF(_matrix1, inverseMatrix2, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn MakeSeparateF(GW::MATH::GMATRIXF _matrix1, GW::MATH::GMATRIXF _matrix2, GW::MATH::GMATRIXF& _outMatrix) 
			{
				MultiplyMatrixF(_matrix1, _matrix2, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn Upgrade(GW::MATH::GMATRIXF _matrixF, GW::MATH::GMATRIXD& _outMatrixD) 
			{
				for (int i = 0; i < 16; i++)
				{
					_outMatrixD.data[i] = static_cast<double>(_matrixF.data[i]);
				}

				return GReturn::SUCCESS;
			}




			// Doubles
			static GReturn AddMatrixD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix)
			{
				GW::MATH::GMATRIXD _m1 = _matrix1;
				GW::MATH::GMATRIXD _m2 = _matrix2;
				for(int i = 0; i < 16; i++)
				{
					_outMatrix.data[i] = _m1.data[i] + _m2.data[i];
				}
				return GW::GReturn::SUCCESS;
			}
			static GReturn SubtractMatrixD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix)
			{
				GW::MATH::GMATRIXD _m1 = _matrix1;
				for(int i = 0; i < 16; i++)
				{
					_outMatrix.data[i] = _m1.data[i] - _matrix2.data[i];
				}
				return GW::GReturn::SUCCESS;
			}
			static GReturn MultiplyMatrixD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix)
			{
				GW::MATH::GMATRIXD _m1 = _matrix1;
				GW::MATH::GMATRIXD _m2 = _matrix2;
				_outMatrix.data[0] = _m1.data[0] * _m2.data[0] + _m1.data[1] * _m2.data[4] + _m1.data[2] * _m2.data[8] + _m1.data[3] * _m2.data[12];
				_outMatrix.data[1] = _m1.data[0] * _m2.data[1] + _m1.data[1] * _m2.data[5] + _m1.data[2] * _m2.data[9] + _m1.data[3] * _m2.data[13];
				_outMatrix.data[2] = _m1.data[0] * _m2.data[2] + _m1.data[1] * _m2.data[6] + _m1.data[2] * _m2.data[10] + _m1.data[3] * _m2.data[14];
				_outMatrix.data[3] = _m1.data[0] * _m2.data[3] + _m1.data[1] * _m2.data[7] + _m1.data[2] * _m2.data[11] + _m1.data[3] * _m2.data[15];

				_outMatrix.data[4] = _m1.data[4] * _m2.data[0] + _m1.data[5] * _m2.data[4] + _m1.data[6] * _m2.data[8] + _m1.data[7] * _m2.data[12];
				_outMatrix.data[5] = _m1.data[4] * _m2.data[1] + _m1.data[5] * _m2.data[5] + _m1.data[6] * _m2.data[9] + _m1.data[7] * _m2.data[13];
				_outMatrix.data[6] = _m1.data[4] * _m2.data[2] + _m1.data[5] * _m2.data[6] + _m1.data[6] * _m2.data[10] + _m1.data[7] * _m2.data[14];
				_outMatrix.data[7] = _m1.data[4] * _m2.data[3] + _m1.data[5] * _m2.data[7] + _m1.data[6] * _m2.data[11] + _m1.data[7] * _m2.data[15];

				_outMatrix.data[8] = _m1.data[8] * _m2.data[0] + _m1.data[9] * _m2.data[4] + _m1.data[10] * _m2.data[8] + _m1.data[11] * _m2.data[12];
				_outMatrix.data[9] = _m1.data[8] * _m2.data[1] + _m1.data[9] * _m2.data[5] + _m1.data[10] * _m2.data[9] + _m1.data[11] * _m2.data[13];
				_outMatrix.data[10] = _m1.data[8] * _m2.data[2] + _m1.data[9] * _m2.data[6] + _m1.data[10] * _m2.data[10] + _m1.data[11] * _m2.data[14];
				_outMatrix.data[11] = _m1.data[8] * _m2.data[3] + _m1.data[9] * _m2.data[7] + _m1.data[10] * _m2.data[11] + _m1.data[11] * _m2.data[15];

				_outMatrix.data[12] = _m1.data[12] * _m2.data[0] + _m1.data[13] * _m2.data[4] + _m1.data[14] * _m2.data[8] + _m1.data[15] * _m2.data[12];
				_outMatrix.data[13] = _m1.data[12] * _m2.data[1] + _m1.data[13] * _m2.data[5] + _m1.data[14] * _m2.data[9] + _m1.data[15] * _m2.data[13];
				_outMatrix.data[14] = _m1.data[12] * _m2.data[2] + _m1.data[13] * _m2.data[6] + _m1.data[14] * _m2.data[10] + _m1.data[15] * _m2.data[14];
				_outMatrix.data[15] = _m1.data[12] * _m2.data[3] + _m1.data[13] * _m2.data[7] + _m1.data[14] * _m2.data[11] + _m1.data[15] * _m2.data[15];

				return GW::GReturn::SUCCESS;
			}
			static GReturn VectorXMatrixD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GVECTORD& _outVector)
			{
				GW::MATH::GMATRIXD _m = _matrix;
				_outVector.x = _vector.data[0] * _m.data[0] + _vector.data[1] * _m.data[4] + _vector.data[2] * _m.data[8] + _vector.data[3] * _m.data[12];
				_outVector.y = _vector.data[0] * _m.data[1] + _vector.data[1] * _m.data[5] + _vector.data[2] * _m.data[9] + _vector.data[3] * _m.data[13];
				_outVector.z = _vector.data[0] * _m.data[2] + _vector.data[1] * _m.data[6] + _vector.data[2] * _m.data[10] + _vector.data[3] * _m.data[14];
				_outVector.w = _vector.data[0] * _m.data[3] + _vector.data[1] * _m.data[7] + _vector.data[2] * _m.data[11] + _vector.data[3] * _m.data[15];

				return GW::GReturn::SUCCESS;
			}
			static GReturn ConvertQuaternionD(GW::MATH::GQUATERNIOND _quaternion, GW::MATH::GMATRIXD& _outMatrix)
			{
				double xx2 = 2 * _quaternion.x * _quaternion.x;
				double yy2 = 2 * _quaternion.y * _quaternion.y;
				double zz2 = 2 * _quaternion.z * _quaternion.z;

				double xy2 = 2 * _quaternion.x * _quaternion.y;
				double xz2 = 2 * _quaternion.x * _quaternion.z;
				double yz2 = 2 * _quaternion.y * _quaternion.z;

				double wx2 = 2 * _quaternion.w * _quaternion.x;
				double wy2 = 2 * _quaternion.w * _quaternion.y;
				double wz2 = 2 * _quaternion.w * _quaternion.z;

				_outMatrix.data[0] = 1.0f - yy2 - zz2;
				_outMatrix.data[1] = xy2 - wz2;
				_outMatrix.data[2] = xz2 + wy2;
				_outMatrix.data[3] = 0.0f;
				_outMatrix.data[4] = xy2 + wz2;
				_outMatrix.data[5] = 1.0f - xx2 - zz2;
				_outMatrix.data[6] = yz2 - wx2;
				_outMatrix.data[7] = 0.0f;
				_outMatrix.data[8] = xz2 - wy2;
				_outMatrix.data[9] = yz2 + wx2;
				_outMatrix.data[10] = 1.0f - xx2 - yy2;
				_outMatrix.data[11] = 0.0f;
				_outMatrix.data[12] = 0.0f;
				_outMatrix.data[13] = 0.0f;
				_outMatrix.data[14] = 0.0f;
				_outMatrix.data[15] = 1.0f;

				return GW::GReturn::SUCCESS;
			}
			static GReturn MultiplyNumD(GW::MATH::GMATRIXD _matrix, double _scalar, GW::MATH::GMATRIXD& _outMatrix)
			{
				GW::MATH::GMATRIXD _m = _matrix;
				for(int i = 0; i < 16; i++)
				{
					_outMatrix.data[i] = _m.data[i] * _scalar;
				}
				return GW::GReturn::SUCCESS;
			}
			static GReturn DeterminantD(GW::MATH::GMATRIXD _matrix, double& _outValue)
			{
				double a0 = _matrix.data[0] * _matrix.data[5] - _matrix.data[1] * _matrix.data[4];
				double a1 = _matrix.data[0] * _matrix.data[6] - _matrix.data[2] * _matrix.data[4];
				double a2 = _matrix.data[0] * _matrix.data[7] - _matrix.data[3] * _matrix.data[4];
				double a3 = _matrix.data[1] * _matrix.data[6] - _matrix.data[2] * _matrix.data[5];
				double a4 = _matrix.data[1] * _matrix.data[7] - _matrix.data[3] * _matrix.data[5];
				double a5 = _matrix.data[2] * _matrix.data[7] - _matrix.data[3] * _matrix.data[6];
				double b0 = _matrix.data[8] * _matrix.data[13] - _matrix.data[9] * _matrix.data[12];
				double b1 = _matrix.data[8] * _matrix.data[14] - _matrix.data[10] * _matrix.data[12];
				double b2 = _matrix.data[8] * _matrix.data[15] - _matrix.data[11] * _matrix.data[12];
				double b3 = _matrix.data[9] * _matrix.data[14] - _matrix.data[10] * _matrix.data[13];
				double b4 = _matrix.data[9] * _matrix.data[15] - _matrix.data[11] * _matrix.data[13];
				double b5 = _matrix.data[10] * _matrix.data[15] - _matrix.data[11] * _matrix.data[14];

				_outValue = a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0;

				return GW::GReturn::SUCCESS;
			}
			static GReturn TransposeD(GW::MATH::GMATRIXD _matrix, GW::MATH::GMATRIXD& _outMatrix)
			{
				GW::MATH::GMATRIXD _m = _matrix;
				_outMatrix.data[0] = _m.data[0];
				_outMatrix.data[1] = _m.data[4];
				_outMatrix.data[2] = _m.data[8];
				_outMatrix.data[3] = _m.data[12];
				_outMatrix.data[4] = _m.data[1];
				_outMatrix.data[5] = _m.data[5];
				_outMatrix.data[6] = _m.data[9];
				_outMatrix.data[7] = _m.data[13];
				_outMatrix.data[8] = _m.data[2];
				_outMatrix.data[9] = _m.data[6];
				_outMatrix.data[10] = _m.data[10];
				_outMatrix.data[11] = _m.data[14];
				_outMatrix.data[12] = _m.data[3];
				_outMatrix.data[13] = _m.data[7];
				_outMatrix.data[14] = _m.data[11];
				_outMatrix.data[15] = _m.data[15];
				return GW::GReturn::SUCCESS;
			}
			static GReturn InverseD(GW::MATH::GMATRIXD _matrix, GW::MATH::GMATRIXD& _outMatrix)
			{
				GW::MATH::GMATRIXD _m = _matrix;
				double det;
				double a0 = _m.data[0] * _m.data[5] - _m.data[1] * _m.data[4];
				double a1 = _m.data[0] * _m.data[6] - _m.data[2] * _m.data[4];
				double a2 = _m.data[0] * _m.data[7] - _m.data[3] * _m.data[4];
				double a3 = _m.data[1] * _m.data[6] - _m.data[2] * _m.data[5];
				double a4 = _m.data[1] * _m.data[7] - _m.data[3] * _m.data[5];
				double a5 = _m.data[2] * _m.data[7] - _m.data[3] * _m.data[6];
				double b0 = _m.data[8] * _m.data[13] - _m.data[9] * _m.data[12];
				double b1 = _m.data[8] * _m.data[14] - _m.data[10] * _m.data[12];
				double b2 = _m.data[8] * _m.data[15] - _m.data[11] * _m.data[12];
				double b3 = _m.data[9] * _m.data[14] - _m.data[10] * _m.data[13];
				double b4 = _m.data[9] * _m.data[15] - _m.data[11] * _m.data[13];
				double b5 = _m.data[10] * _m.data[15] - _m.data[11] * _m.data[14];

				det = a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0;
				if(G_COMPARISON_STANDARD_D(det, 0))
				{
					return GW::GReturn::FAILURE;
				}
				_outMatrix.data[0] = _m.data[5] * b5 - _m.data[6] * b4 + _m.data[7] * b3;
				_outMatrix.data[1] = -_m.data[1] * b5 + _m.data[2] * b4 - _m.data[3] * b3;
				_outMatrix.data[2] = _m.data[13] * a5 - _m.data[14] * a4 + _m.data[15] * a3;
				_outMatrix.data[3] = -_m.data[9] * a5 + _m.data[10] * a4 - _m.data[11] * a3;

				_outMatrix.data[4] = -_m.data[4] * b5 + _m.data[6] * b2 - _m.data[7] * b1;
				_outMatrix.data[5] = _m.data[0] * b5 - _m.data[2] * b2 + _m.data[3] * b1;
				_outMatrix.data[6] = -_m.data[12] * a5 + _m.data[14] * a2 - _m.data[15] * a1;
				_outMatrix.data[7] = _m.data[8] * a5 - _m.data[10] * a2 + _m.data[11] * a1;

				_outMatrix.data[8] = _m.data[4] * b4 - _m.data[5] * b2 + _m.data[7] * b0;
				_outMatrix.data[9] = -_m.data[0] * b4 + _m.data[1] * b2 - _m.data[3] * b0;
				_outMatrix.data[10] = _m.data[12] * a4 - _m.data[13] * a2 + _m.data[15] * a0;
				_outMatrix.data[11] = -_m.data[8] * a4 + _m.data[9] * a2 - _m.data[11] * a0;

				_outMatrix.data[12] = -_m.data[4] * b3 + _m.data[5] * b1 - _m.data[6] * b0;
				_outMatrix.data[13] = _m.data[0] * b3 - _m.data[1] * b1 + _m.data[2] * b0;
				_outMatrix.data[14] = -_m.data[12] * a3 + _m.data[13] * a1 - _m.data[14] * a0;
				_outMatrix.data[15] = _m.data[8] * a3 - _m.data[9] * a1 + _m.data[10] * a0;

				MultiplyNumD(_outMatrix, 1.0f / det, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn IdentityD(GW::MATH::GMATRIXD& _outMatrix)
			{
				_outMatrix = GW::MATH::GIdentityMatrixD;
				return GW::GReturn::SUCCESS;
			}
			static GReturn GetRotationD(GW::MATH::GMATRIXD _matrix, GW::MATH::GQUATERNIOND& _outQuaternion)
			{
				double det;
				double sx = sqrt(_matrix.data[0] * _matrix.data[0] + _matrix.data[4] * _matrix.data[4] + _matrix.data[8] * _matrix.data[8]);
				double sy = sqrt(_matrix.data[1] * _matrix.data[1] + _matrix.data[5] * _matrix.data[5] + _matrix.data[9] * _matrix.data[9]);
				double sz = sqrt(_matrix.data[2] * _matrix.data[2] + _matrix.data[6] * _matrix.data[6] + _matrix.data[10] * _matrix.data[10]);
				DeterminantD(_matrix, det);
				if(G_COMPARISON_STANDARD_D(det, 0))
				{
					return GW::GReturn::FAILURE;
				}
				if(det < 0)
				{
					sx = -sx;
				}
				GW::MATH::GMATRIXD Rotation = _matrix;
				Rotation.data[0] /= sx;
				Rotation.data[1] /= sy;
				Rotation.data[2] /= sz;
				Rotation.data[4] /= sx;
				Rotation.data[5] /= sy;
				Rotation.data[6] /= sz;
				Rotation.data[8] /= sx;
				Rotation.data[9] /= sy;
				Rotation.data[10] /= sz;

				double trace = Rotation.data[0] + Rotation.data[5] + Rotation.data[10] + 1;

				if(trace > G_EPSILON_D)
				{
					double s = 0.5 / sqrt(trace);
					_outQuaternion.x = (Rotation.row3.y - Rotation.row2.z) * s;
					_outQuaternion.y = (Rotation.row1.z - Rotation.row3.x) * s;
					_outQuaternion.z = (Rotation.row2.x - Rotation.row1.y) * s;
					_outQuaternion.w = 0.25 / s;
				}
				else
				{
					if(Rotation.row1.x > Rotation.row2.y&& Rotation.row1.x > Rotation.row3.z)
					{
						double s = 0.5f / sqrt(1.0 + Rotation.row1.x - Rotation.row2.y - Rotation.row3.z);
						_outQuaternion.x = 0.25 / s;
						_outQuaternion.y = (Rotation.row1.y + Rotation.row2.x) * s;
						_outQuaternion.z = (Rotation.row1.z + Rotation.row3.x) * s;
						_outQuaternion.w = (Rotation.row3.y - Rotation.row2.z) * s;
					}
					else if(Rotation.row2.y > Rotation.row3.z)
					{
						double s = 0.5 / sqrt(1.0 + Rotation.row2.y - Rotation.row1.x - Rotation.row3.z);
						_outQuaternion.x = (Rotation.row1.y + Rotation.row2.x) * s;
						_outQuaternion.y = 0.25 / s;
						_outQuaternion.z = (Rotation.row2.z + Rotation.row3.y) * s;
						_outQuaternion.w = (Rotation.row1.z - Rotation.row3.x) * s;
					}
					else
					{
						double s = 0.5 / sqrt(1.0 + Rotation.row3.z - Rotation.row1.x - Rotation.row2.y);
						_outQuaternion.x = (Rotation.row1.z + Rotation.row3.x) * s;
						_outQuaternion.y = (Rotation.row2.z + Rotation.row3.y) * s;
						_outQuaternion.z = 0.25 / s;
						_outQuaternion.w = (Rotation.row2.x - Rotation.row1.y) * s;
					}
				}

				return GW::GReturn::SUCCESS;
			}
			static GReturn GetTranslationD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD& _outVector)
			{
				_outVector = _matrix.row4;
				_outVector.w = 0;
				return GW::GReturn::SUCCESS;
			}
			static GReturn GetScaleD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD& _outVector)
			{
				double det;

				_outVector.x = sqrt(_matrix.data[0] * _matrix.data[0] + _matrix.data[4] * _matrix.data[4] + _matrix.data[8] * _matrix.data[8]);
				_outVector.y = sqrt(_matrix.data[1] * _matrix.data[1] + _matrix.data[5] * _matrix.data[5] + _matrix.data[9] * _matrix.data[9]);
				_outVector.z = sqrt(_matrix.data[2] * _matrix.data[2] + _matrix.data[6] * _matrix.data[6] + _matrix.data[10] * _matrix.data[10]);
				_outVector.w = 0;

				DeterminantD(_matrix, det);
				if(det < 0)
				{
					_outVector.x = -_outVector.x;
				}

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotateXGlobalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix)
			{
				double c = cos(_radian);
				double s = sin(_radian);
				GW::MATH::GMATRIXD Rotation = GW::MATH::GIdentityMatrixD;
				Rotation.data[5] = c;
				Rotation.data[6] = s;
				Rotation.data[9] = -s;
				Rotation.data[10] = c;

				// store translation
				GW::MATH::GVECTORD Translation = _matrix.row4;

				MultiplyMatrixD(_matrix, Rotation, _outMatrix);

				// restore translation
				_outMatrix.row4 = Translation;

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotateXLocalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix)
			{
				double c = cos(_radian);
				double s = sin(_radian);
				GW::MATH::GMATRIXD Rotation = GW::MATH::GIdentityMatrixD;
				Rotation.data[5] = c;
				Rotation.data[6] = s;
				Rotation.data[9] = -s;
				Rotation.data[10] = c;

				MultiplyMatrixD(Rotation, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotateYGlobalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix)
			{
				double c = cos(_radian);
				double s = sin(_radian);
				GW::MATH::GMATRIXD Rotation = GW::MATH::GIdentityMatrixD;
				Rotation.data[0] = c;
				Rotation.data[2] = -s;
				Rotation.data[8] = s;
				Rotation.data[10] = c;

				// store translation
				GW::MATH::GVECTORD Translation = _matrix.row4;

				MultiplyMatrixD(_matrix, Rotation, _outMatrix);

				// restore translation
				_outMatrix.row4 = Translation;

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotateYLocalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix)
			{
				double c = cos(_radian);
				double s = sin(_radian);
				GW::MATH::GMATRIXD Rotation = GW::MATH::GIdentityMatrixD;
				Rotation.data[0] = c;
				Rotation.data[2] = -s;
				Rotation.data[8] = s;
				Rotation.data[10] = c;

				MultiplyMatrixD(Rotation, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotateZGlobalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix)
			{
				double c = cos(_radian);
				double s = sin(_radian);
				GW::MATH::GMATRIXD Rotation = GW::MATH::GIdentityMatrixD;
				Rotation.data[0] = c;
				Rotation.data[1] = s;
				Rotation.data[4] = -s;
				Rotation.data[5] = c;

				// store translation
				GW::MATH::GVECTORD Translation = _matrix.row4;

				MultiplyMatrixD(_matrix, Rotation, _outMatrix);

				// restore translation
				_outMatrix.row4 = Translation;

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotateZLocalD(GW::MATH::GMATRIXD _matrix, double _radian, GW::MATH::GMATRIXD& _outMatrix)
			{
				double c = cos(_radian);
				double s = sin(_radian);
				GW::MATH::GMATRIXD Rotation = GW::MATH::GIdentityMatrixD;
				Rotation.data[0] = c;
				Rotation.data[1] = s;
				Rotation.data[4] = -s;
				Rotation.data[5] = c;

				MultiplyMatrixD(Rotation, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotationYawPitchRollD(double _yaw, double _pitch, double _roll, GW::MATH::GMATRIXD& _outMatrix)
			{
				_outMatrix = GW::MATH::GIdentityMatrixD;
				GW::MATH::GMATRIXD RotationX;
				GW::MATH::GMATRIXD RotationY;
				GW::MATH::GMATRIXD RotationZ;
				GW::MATH::GMATRIXD reuslt;
				RotateZGlobalD(GW::MATH::GIdentityMatrixD, _roll, RotationZ);
				RotateXGlobalD(GW::MATH::GIdentityMatrixD, _pitch, RotationX);
				RotateYGlobalD(GW::MATH::GIdentityMatrixD, _yaw, RotationY);

				MultiplyMatrixD(RotationX, RotationY, reuslt);
				MultiplyMatrixD(RotationZ, reuslt, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn RotationByVectorD(GW::MATH::GVECTORD _vector, double _radian, GW::MATH::GMATRIXD& _outMatrix)
			{
				double x = _vector.x;
				double y = _vector.y;
				double z = _vector.z;

				double magnitude = x * x + y * y + z * z;
				if(!G_COMPARISON_STANDARD_D(magnitude, 1))
				{
					magnitude = sqrt(magnitude);
					if(!G_COMPARISON_STANDARD_D(magnitude, 0))
					{
						magnitude = 1.0 / magnitude;
						x = x * magnitude;
						y = y * magnitude;
						z = z * magnitude;
					}
					else return GW::GReturn::FAILURE;
				}
				double c = cos(_radian);
				double s = sin(_radian);

				double t = 1.0f - c;
				double tx = t * x;
				double ty = t * y;
				double tz = t * z;
				double txy = tx * y;
				double txz = tx * z;
				double tyz = ty * z;
				double sx = s * x;
				double sy = s * y;
				double sz = s * z;

				_outMatrix.data[0] = c + tx * x;
				_outMatrix.data[1] = txy + sz;
				_outMatrix.data[2] = txz - sy;
				_outMatrix.data[3] = 0.0f;

				_outMatrix.data[4] = txy - sz;
				_outMatrix.data[5] = c + ty * y;
				_outMatrix.data[6] = tyz + sx;
				_outMatrix.data[7] = 0.0f;

				_outMatrix.data[8] = txz + sy;
				_outMatrix.data[9] = tyz - sx;
				_outMatrix.data[10] = c + tz * z;
				_outMatrix.data[11] = 0.0f;

				_outMatrix.data[12] = 0.0f;
				_outMatrix.data[13] = 0.0f;
				_outMatrix.data[14] = 0.0f;
				_outMatrix.data[15] = 1.0f;

				return GW::GReturn::SUCCESS;
			}
			static GReturn TranslateGlobalD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GMATRIXD& _outMatrix)
			{
				GW::MATH::GMATRIXD Translation = GW::MATH::GIdentityMatrixD;

				Translation.data[12] = _vector.x;
				Translation.data[13] = _vector.y;
				Translation.data[14] = _vector.z;

				MultiplyMatrixD(_matrix, Translation, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn TranslateLocalD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GMATRIXD& _outMatrix)
			{
				GW::MATH::GMATRIXD Translation = GW::MATH::GIdentityMatrixD;

				Translation.data[12] = _vector.x;
				Translation.data[13] = _vector.y;
				Translation.data[14] = _vector.z;

				MultiplyMatrixD(Translation, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn ScaleGlobalD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GMATRIXD& _outMatrix)
			{
				GW::MATH::GMATRIXD Scale = GW::MATH::GIdentityMatrixD;
				Scale.data[0] = _vector.x;
				Scale.data[5] = _vector.y;
				Scale.data[10] = _vector.z;

				// store translation
				GW::MATH::GVECTORD Translation = _matrix.row4;

				MultiplyMatrixD(_matrix, Scale, _outMatrix);

				// restore translation
				_outMatrix.row4 = Translation;

				return GW::GReturn::SUCCESS;
			}
			static GReturn ScaleLocalD(GW::MATH::GMATRIXD _matrix, GW::MATH::GVECTORD _vector, GW::MATH::GMATRIXD& _outMatrix)
			{
				GW::MATH::GMATRIXD Scale = GW::MATH::GIdentityMatrixD;
				Scale.data[0] = _vector.x;
				Scale.data[5] = _vector.y;
				Scale.data[10] = _vector.z;

				MultiplyMatrixD(Scale, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn LerpD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, double _ratio, GW::MATH::GMATRIXD& _outMatrix)
			{
				GW::MATH::GMATRIXD _m1 = _matrix1;
				GW::MATH::GMATRIXD _m2 = _matrix2;
				for(int i = 0; i < 16; i++)
				{
					_outMatrix.data[i] = G_LERP(_m1.data[i], _m2.data[i], _ratio);
				}
				return GW::GReturn::SUCCESS;
			}
			static GReturn ProjectionDirectXLHD(double _fovY, double _aspect, double _zn, double _zf, GW::MATH::GMATRIXD& _outMatrix)
			{
				if(G_COMPARISON_STANDARD_D(_aspect, 0)) return GW::GReturn::FAILURE;

				double yScale = 1.0 / tan(_fovY / 2.0);
				double z = _zf / (_zf - _zn);

				_outMatrix = {};
				_outMatrix.row1.data[0] = yScale / _aspect;
				_outMatrix.row2.data[1] = yScale;
				_outMatrix.row3.data[2] = z;
				_outMatrix.row3.data[3] = 1.0;
				_outMatrix.row4.data[2] = -_zn * z;

				return GW::GReturn::SUCCESS;
			}
			static GReturn ProjectionOpenGLRHD(double _fovY, double _aspect, double _zn, double _zf, GW::MATH::GMATRIXD& _outMatrix)
			{
				if(G_COMPARISON_STANDARD_D(_aspect, 0)) return GW::GReturn::FAILURE;

				double yScale = 1.0 / tan(_fovY / 0.5);
				double z = _zf / (_zf - _zn);

				_outMatrix = {};
				_outMatrix.row1.data[0] = yScale / _aspect;
				_outMatrix.row2.data[1] = yScale;
				_outMatrix.row3.data[2] = -(_zf + _zn) * z;
				_outMatrix.row3.data[3] = (-2.0 * _zf * _zn) * z;
				_outMatrix.row4.data[2] = -1.0;

				return GW::GReturn::SUCCESS;
			}
			static GReturn ProjectionVulkanLHD(double _fovY, double _aspect, double _zn, double _zf, GW::MATH::GMATRIXD& _outMatrix)
			{
				if(G_COMPARISON_STANDARD_D(_aspect, 0)) return GW::GReturn::FAILURE;

				double yScale = 1.0 / tan(_fovY * 0.5);
				double z = _zf / (_zf - _zn);

				_outMatrix = {};
				_outMatrix.row1.data[0] = yScale / _aspect;
				_outMatrix.row2.data[1] = -yScale;
				_outMatrix.row3.data[2] = z;
				_outMatrix.row3.data[3] = 1.0;
				_outMatrix.row4.data[2] = -(_zf * _zn) / (_zf - _zn);

				return GW::GReturn::SUCCESS;
			}
			static GReturn ProjectionVulkanRHD(double _fovY, double _aspect, double _zn, double _zf, GW::MATH::GMATRIXD& _outMatrix)
			{
				if(G_COMPARISON_STANDARD_D(_aspect, 0)) return GW::GReturn::FAILURE;

				double yScale = 1.0 / tan(_fovY * 0.5);
				double z = _zf / (_zn - _zf);

				_outMatrix = {};
				_outMatrix.row1.data[0] = yScale / _aspect;
				_outMatrix.row2.data[1] = -yScale;
				_outMatrix.row3.data[2] = z;
				_outMatrix.row3.data[3] = -1.0;
				_outMatrix.row4.data[2] = _zn * z;

				return GW::GReturn::SUCCESS;
			}
			static GReturn LookAtLHD(GW::MATH::GVECTORD _eye, GW::MATH::GVECTORD _at, GW::MATH::GVECTORD _up, GW::MATH::GMATRIXD& _outMatrix)
			{
				_outMatrix = GW::MATH::GIdentityMatrixD;
				GW::MATH::GVECTORD temp;
				GW::MATH::GVECTORD camDir;	  //zaxis
				GW::MATH::GVECTORD camRight;	  //xaxis
				GW::MATH::GVECTORD camUp;		  //yaxis
				double magnitudeX;
				double magnitudeZ;

				camDir.x = _at.x - _eye.x;
				camDir.y = _at.y - _eye.y;
				camDir.z = _at.z - _eye.z;

				magnitudeZ = sqrt((camDir.x * camDir.x) + (camDir.y * camDir.y) + (camDir.z * camDir.z));
				if(G_COMPARISON_STANDARD_F(static_cast<float>(magnitudeZ), 0)) return GW::GReturn::FAILURE;

				camDir.x /= magnitudeZ;
				camDir.y /= magnitudeZ;
				camDir.z /= magnitudeZ;


				camRight.x = (_up.y * camDir.z) - (_up.z * camDir.y);
				camRight.y = (_up.z * camDir.x) - (_up.x * camDir.z);
				camRight.z = (_up.x * camDir.y) - (_up.y * camDir.x);

				magnitudeX = sqrt((camRight.x * camRight.x) + (camRight.y * camRight.y) + (camRight.z * camRight.z));
				if(G_COMPARISON_STANDARD_F(static_cast<float>(magnitudeX), 0)) return GW::GReturn::FAILURE;


				camRight.x /= magnitudeX;
				camRight.y /= magnitudeX;
				camRight.z /= magnitudeX;


				camUp.x = (camDir.y * camRight.z) - (camDir.z * camRight.y);
				camUp.y = (camDir.z * camRight.x) - (camDir.x * camRight.z);
				camUp.z = (camDir.x * camRight.y) - (camDir.y * camRight.x);

				temp.x = camRight.x * _eye.x + camRight.y * _eye.y + camRight.z * _eye.z;
				temp.y = camUp.x * _eye.x + camUp.y * _eye.y + camUp.z * _eye.z;
				temp.z = camDir.x * _eye.x + camDir.y * _eye.y + camDir.z * _eye.z;

				_outMatrix.data[0] = camRight.x;
				_outMatrix.data[4] = camRight.y;
				_outMatrix.data[8] = camRight.z;
				_outMatrix.data[12] = -temp.x;

				_outMatrix.data[1] = camUp.x;
				_outMatrix.data[5] = camUp.y;
				_outMatrix.data[9] = camUp.z;
				_outMatrix.data[13] = -temp.y;

				_outMatrix.data[2] = camDir.x;
				_outMatrix.data[6] = camDir.y;
				_outMatrix.data[10] = camDir.z;
				_outMatrix.data[14] = -temp.z;

				return GW::GReturn::SUCCESS;
			}
			static GReturn MakeRelativeD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix)
			{
				GW::MATH::GMATRIXD inverseMatrix2;
				InverseD(_matrix2, inverseMatrix2);

				MultiplyMatrixD(_matrix1, inverseMatrix2, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn MakeSeparateD(GW::MATH::GMATRIXD _matrix1, GW::MATH::GMATRIXD _matrix2, GW::MATH::GMATRIXD& _outMatrix)
			{
				MultiplyMatrixD(_matrix1, _matrix2, _outMatrix);

				return GW::GReturn::SUCCESS;
			}
			static GReturn Downgrade(GW::MATH::GMATRIXD _matrixD, GW::MATH::GMATRIXF& _outMatrixF) 
			{
				for (int i = 0; i < 16; i++)
				{
					_outMatrixF.data[i] = static_cast<float>(_matrixD.data[i]);
				}

				return GReturn::SUCCESS;
			}
		};
	}
}


#endif


namespace GW
{
	namespace MATH
	{
		class GMatrix final
			: public I::GProxy<I::GMatrixInterface, I::GMatrixImplementation>
		{
		public:
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GMatrix)
			GATEWARE_STATIC_FUNCTION(AddMatrixF)
			GATEWARE_STATIC_FUNCTION(SubtractMatrixF)
			GATEWARE_STATIC_FUNCTION(MultiplyMatrixF)
			GATEWARE_STATIC_FUNCTION(VectorXMatrixF)
			GATEWARE_STATIC_FUNCTION(ConvertQuaternionF)
			GATEWARE_STATIC_FUNCTION(MultiplyNumF)
			GATEWARE_STATIC_FUNCTION(DeterminantF)
			GATEWARE_STATIC_FUNCTION(TransposeF)
			GATEWARE_STATIC_FUNCTION(InverseF)
			GATEWARE_STATIC_FUNCTION(IdentityF)
			GATEWARE_STATIC_FUNCTION(GetRotationF)
			GATEWARE_STATIC_FUNCTION(GetTranslationF)
			GATEWARE_STATIC_FUNCTION(GetScaleF)
			GATEWARE_STATIC_FUNCTION(RotateXGlobalF)
			GATEWARE_STATIC_FUNCTION(RotateXLocalF)
			GATEWARE_STATIC_FUNCTION(RotateYGlobalF)
			GATEWARE_STATIC_FUNCTION(RotateYLocalF)
			GATEWARE_STATIC_FUNCTION(RotateZGlobalF)
			GATEWARE_STATIC_FUNCTION(RotateZLocalF)
			GATEWARE_STATIC_FUNCTION(RotationYawPitchRollF)
			GATEWARE_STATIC_FUNCTION(RotationByVectorF)
			GATEWARE_STATIC_FUNCTION(TranslateGlobalF)
			GATEWARE_STATIC_FUNCTION(TranslateLocalF)
			GATEWARE_STATIC_FUNCTION(ScaleGlobalF)
			GATEWARE_STATIC_FUNCTION(ScaleLocalF)
			GATEWARE_STATIC_FUNCTION(LerpF)
			GATEWARE_STATIC_FUNCTION(ProjectionDirectXLHF)
			GATEWARE_STATIC_FUNCTION(ProjectionOpenGLRHF)
			GATEWARE_STATIC_FUNCTION(ProjectionVulkanLHF)
			GATEWARE_STATIC_FUNCTION(ProjectionVulkanRHF)
			GATEWARE_STATIC_FUNCTION(LookAtLHF)
			GATEWARE_STATIC_FUNCTION(MakeRelativeF)
			GATEWARE_STATIC_FUNCTION(MakeSeparateF)
			GATEWARE_STATIC_FUNCTION(Upgrade)


			GATEWARE_STATIC_FUNCTION(AddMatrixD)
			GATEWARE_STATIC_FUNCTION(SubtractMatrixD)
			GATEWARE_STATIC_FUNCTION(MultiplyMatrixD)
			GATEWARE_STATIC_FUNCTION(VectorXMatrixD)
			GATEWARE_STATIC_FUNCTION(ConvertQuaternionD)
			GATEWARE_STATIC_FUNCTION(MultiplyNumD)
			GATEWARE_STATIC_FUNCTION(DeterminantD)
			GATEWARE_STATIC_FUNCTION(TransposeD)
			GATEWARE_STATIC_FUNCTION(InverseD)
			GATEWARE_STATIC_FUNCTION(IdentityD)
			GATEWARE_STATIC_FUNCTION(GetRotationD)
			GATEWARE_STATIC_FUNCTION(GetTranslationD)
			GATEWARE_STATIC_FUNCTION(GetScaleD)
			GATEWARE_STATIC_FUNCTION(RotateXGlobalD)
			GATEWARE_STATIC_FUNCTION(RotateXLocalD)
			GATEWARE_STATIC_FUNCTION(RotateYGlobalD)
			GATEWARE_STATIC_FUNCTION(RotateYLocalD)
			GATEWARE_STATIC_FUNCTION(RotateZGlobalD)
			GATEWARE_STATIC_FUNCTION(RotateZLocalD)
			GATEWARE_STATIC_FUNCTION(RotationYawPitchRollD)
			GATEWARE_STATIC_FUNCTION(RotationByVectorD)
			GATEWARE_STATIC_FUNCTION(TranslateGlobalD)
			GATEWARE_STATIC_FUNCTION(TranslateLocalD)
			GATEWARE_STATIC_FUNCTION(ScaleGlobalD)
			GATEWARE_STATIC_FUNCTION(ScaleLocalD)
			GATEWARE_STATIC_FUNCTION(LerpD)
			GATEWARE_STATIC_FUNCTION(ProjectionDirectXLHD)
			GATEWARE_STATIC_FUNCTION(ProjectionOpenGLRHD)
			GATEWARE_STATIC_FUNCTION(ProjectionVulkanLHD)
			GATEWARE_STATIC_FUNCTION(ProjectionVulkanRHD)
			GATEWARE_STATIC_FUNCTION(LookAtLHD)
			GATEWARE_STATIC_FUNCTION(MakeRelativeD)
			GATEWARE_STATIC_FUNCTION(MakeSeparateD)
			GATEWARE_STATIC_FUNCTION(Downgrade)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GMATRIX_H

/*---------------------------------
|	End of GMatrix.h
----------------------------------*/


/*---------------------------------
|	Begin of GCollision2D.h
----------------------------------*/
#ifndef GCOLLISION2D_H
#define GCOLLISION2D_H





namespace GW
{
	namespace I
	{
		class GCollision2DInterface : public virtual GInterfaceInterface
		{
		public:
			enum class GCollisionCheck2D
			{
				ERROR_NO_RESULT = -3,
				ABOVE = -2,
				BELOW = -1,
				NO_COLLISION = 0,
				COLLISION = 1
			};

			// Floats
			static GReturn ImplicitLineEquationF(MATH2D::GVECTOR2F _point, MATH2D::GLINE2F _line, float& _outEquationResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToLine2F(MATH2D::GVECTOR2F _point, MATH2D::GLINE2F _line, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToRectangle2F(MATH2D::GVECTOR2F _point, MATH2D::GRECTANGLE2F _rectangle, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToPolygon2F(MATH2D::GVECTOR2F _point, MATH2D::GVECTOR2F* _polygon, unsigned int _numVerts, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToLine2F(MATH2D::GVECTOR2F _point, MATH2D::GLINE2F _line, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToCircle2F(MATH2D::GVECTOR2F _point, MATH2D::GCIRCLE2F _circle, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToRectangle2F(MATH2D::GVECTOR2F _point, MATH2D::GRECTANGLE2F _rectangle, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToPolygon2F(MATH2D::GVECTOR2F _point, MATH2D::GVECTOR2F* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToLine2F(MATH2D::GLINE2F _line1, MATH2D::GLINE2F _line2, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToCircle2F(MATH2D::GLINE2F _line, MATH2D::GCIRCLE2F _circle, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToRectangle2F(MATH2D::GLINE2F _line, MATH2D::GRECTANGLE2F _rectangle, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToPolygon2F(MATH2D::GLINE2F _line, MATH2D::GVECTOR2F* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestCircleToCircle2F(MATH2D::GCIRCLE2F _circle1, MATH2D::GCIRCLE2F _circle2, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRectangleToRectangle2F(MATH2D::GRECTANGLE2F _rectangle1, MATH2D::GRECTANGLE2F _rectangle2, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRectangleToPolygon2F(MATH2D::GRECTANGLE2F _rectangle, MATH2D::GVECTOR2F* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPolygonToPolygon2F(MATH2D::GVECTOR2F* _polygon1, unsigned int _numVerts1, MATH2D::GVECTOR2F* _polygon2, unsigned int _numVerts2, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn FindBarycentricF(MATH2D::GVECTOR2F _point, MATH2D::GVECTOR2F _trianglePoint1, MATH2D::GVECTOR2F _trianglePoint2, MATH2D::GVECTOR2F _trianglePoint3, MATH2D::GBARYCENTRICF& _outBarycentric) { return GReturn::NO_IMPLEMENTATION; }
			// Doubles
			static GReturn ImplicitLineEquationD(MATH2D::GVECTOR2D _point, MATH2D::GLINE2D _line, double& _outEquationResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToLine2D(MATH2D::GVECTOR2D _point, MATH2D::GLINE2D _line, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToRectangle2D(MATH2D::GVECTOR2D _point, MATH2D::GRECTANGLE2D _rectangle, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToPolygon2D(MATH2D::GVECTOR2D _point, MATH2D::GVECTOR2D* _polygon, unsigned int _numVerts, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToLine2D(MATH2D::GVECTOR2D _point, MATH2D::GLINE2D _line, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToCircle2D(MATH2D::GVECTOR2D _point, MATH2D::GCIRCLE2D _circle, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToRectangle2D(MATH2D::GVECTOR2D _point, MATH2D::GRECTANGLE2D _rectangle, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToPolygon2D(MATH2D::GVECTOR2D _point, MATH2D::GVECTOR2D* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToLine2D(MATH2D::GLINE2D _line1, MATH2D::GLINE2D _line2, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToCircle2D(MATH2D::GLINE2D _line, MATH2D::GCIRCLE2D _circle, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToRectangle2D(MATH2D::GLINE2D _line, MATH2D::GRECTANGLE2D _rectangle, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToPolygon2D(MATH2D::GLINE2D _line, MATH2D::GVECTOR2D* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestCircleToCircle2D(MATH2D::GCIRCLE2D _circle1, MATH2D::GCIRCLE2D _circle2, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRectangleToRectangle2D(MATH2D::GRECTANGLE2D _rectangle1, MATH2D::GRECTANGLE2D _rectangle2, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRectangleToPolygon2D(MATH2D::GRECTANGLE2D _rectangle, MATH2D::GVECTOR2D* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPolygonToPolygon2D(MATH2D::GVECTOR2D* _polygon1, unsigned int _numVerts1, MATH2D::GVECTOR2D* _polygon2, unsigned int _numVerts2, GCollisionCheck2D& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn FindBarycentricD(MATH2D::GVECTOR2D _point, MATH2D::GVECTOR2D _trianglePoint1, MATH2D::GVECTOR2D _trianglePoint2, MATH2D::GVECTOR2D _trianglePoint3, MATH2D::GBARYCENTRICD& _outBarycentric) { return GReturn::NO_IMPLEMENTATION; }
		};
	}
}


// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GCollision2D.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are separated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_MATH2D) || defined(GATEWARE_DISABLE_GCOLLISION2D) || \
    (defined(GATEWARE_ENABLE_MATH2D) && !defined(GATEWARE_DISABLE_GCOLLISION2D) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
	namespace I
	{
		class GCollision2DImplementation : public virtual GCollision2DInterface,
			private GInterfaceImplementation
		{
		public:
			GReturn Create()
			{
				return GReturn::INTERFACE_UNSUPPORTED;
			}

			// Floats
			static GReturn ImplicitLineEquationF(MATH2D::GVECTOR2F _point, MATH2D::GLINE2F _line, float& _outEquationResult) { return GReturn::FAILURE; }
			static GReturn SqDistancePointToLine2F(MATH2D::GVECTOR2F _point, MATH2D::GLINE2F _line, float& _outDistance) { return GReturn::FAILURE; }
			static GReturn SqDistancePointToRectangle2F(MATH2D::GVECTOR2F _point, MATH2D::GRECTANGLE2F _rectangle, float& _outDistance) { return GReturn::FAILURE; }
			static GReturn SqDistancePointToPolygon2F(MATH2D::GVECTOR2F _point, MATH2D::GVECTOR2F* _polygon, unsigned int _numVerts, float& _outDistance) { return GReturn::FAILURE; }
			static GReturn TestPointToLine2F(MATH2D::GVECTOR2F _point, MATH2D::GLINE2F _line, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestPointToCircle2F(MATH2D::GVECTOR2F _point, MATH2D::GCIRCLE2F _circle, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestPointToRectangle2F(MATH2D::GVECTOR2F _point, MATH2D::GRECTANGLE2F _rectangle, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestPointToPolygon2F(MATH2D::GVECTOR2F _point, MATH2D::GVECTOR2F* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestLineToLine2F(MATH2D::GLINE2F _line1, MATH2D::GLINE2F _line2, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestLineToCircle2F(MATH2D::GLINE2F _line, MATH2D::GCIRCLE2F _circle, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestLineToRectangle2F(MATH2D::GLINE2F _line, MATH2D::GRECTANGLE2F _rectangle, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestLineToPolygon2F(MATH2D::GLINE2F _line, MATH2D::GVECTOR2F* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestCircleToCircle2F(MATH2D::GCIRCLE2F _circle1, MATH2D::GCIRCLE2F _circle2, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestRectangleToRectangle2F(MATH2D::GRECTANGLE2F _rectangle1, MATH2D::GRECTANGLE2F _rectangle2, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestRectangleToPolygon2F(MATH2D::GRECTANGLE2F _rectangle, MATH2D::GVECTOR2F* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestPolygonToPolygon2F(MATH2D::GVECTOR2F* _polygon1, unsigned int _numVerts1, MATH2D::GVECTOR2F* _polygon2, unsigned int _numVerts2, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn FindBarycentricF(MATH2D::GVECTOR2F _point, MATH2D::GVECTOR2F _trianglePoint1, MATH2D::GVECTOR2F _trianglePoint2, MATH2D::GVECTOR2F _trianglePoint3, MATH2D::GBARYCENTRICF& _outBarycentric) { return GReturn::FAILURE; }
			// Doubles
			static GReturn ImplicitLineEquationD(MATH2D::GVECTOR2D _point, MATH2D::GLINE2D _line, double& _outEquationResult) { return GReturn::FAILURE; }
			static GReturn SqDistancePointToLine2D(MATH2D::GVECTOR2D _point, MATH2D::GLINE2D _line, double& _outDistance) { return GReturn::FAILURE; }
			static GReturn SqDistancePointToRectangle2D(MATH2D::GVECTOR2D _point, MATH2D::GRECTANGLE2D _rectangle, double& _outDistance) { return GReturn::FAILURE; }
			static GReturn SqDistancePointToPolygon2D(MATH2D::GVECTOR2D _point, MATH2D::GVECTOR2D* _polygon, unsigned int _numVerts, double& _outDistance) { return GReturn::FAILURE; }
			static GReturn TestPointToLine2D(MATH2D::GVECTOR2D _point, MATH2D::GLINE2D _line, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestPointToCircle2D(MATH2D::GVECTOR2D _point, MATH2D::GCIRCLE2D _circle, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestPointToRectangle2D(MATH2D::GVECTOR2D _point, MATH2D::GRECTANGLE2D _rectangle, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestPointToPolygon2D(MATH2D::GVECTOR2D _point, MATH2D::GVECTOR2D* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestLineToLine2D(MATH2D::GLINE2D _line1, MATH2D::GLINE2D _line2, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestLineToCircle2D(MATH2D::GLINE2D _line, MATH2D::GCIRCLE2D _circle, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestLineToRectangle2D(MATH2D::GLINE2D _line, MATH2D::GRECTANGLE2D _rectangle, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestLineToPolygon2D(MATH2D::GLINE2D _line, MATH2D::GVECTOR2D* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestCircleToCircle2D(MATH2D::GCIRCLE2D _circle1, MATH2D::GCIRCLE2D _circle2, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestRectangleToRectangle2D(MATH2D::GRECTANGLE2D _rectangle1, MATH2D::GRECTANGLE2D _rectangle2, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestRectangleToPolygon2D(MATH2D::GRECTANGLE2D _rectangle, MATH2D::GVECTOR2D* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn TestPolygonToPolygon2D(MATH2D::GVECTOR2D* _polygon1, unsigned int _numVerts1, MATH2D::GVECTOR2D* _polygon2, unsigned int _numVerts2, GCollisionCheck2D& _outResult) { return GReturn::FAILURE; }
			static GReturn FindBarycentricD(MATH2D::GVECTOR2D _point, MATH2D::GVECTOR2D _trianglePoint1, MATH2D::GVECTOR2D _trianglePoint2, MATH2D::GVECTOR2D _trianglePoint3, MATH2D::GBARYCENTRICD& _outBarycentric) { return GReturn::FAILURE; }
		};
	}
}

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
namespace GW
{
	namespace I
	{
		class GCollision2DImplementation : public virtual GCollision2DInterface, private GInterfaceImplementation
		{
		public:
			GReturn Create()
			{
				return GReturn::SUCCESS;
			}

			// Floats
			static GReturn ImplicitLineEquationF(MATH2D::GVECTOR2F _point, MATH2D::GLINE2F _line, float& _outEquationResult)
			{
				//									A				      x                       B                    y                                       C
				_outEquationResult = ((_line.start.y - _line.end.y) * _point.x) + ((_line.end.x - _line.start.x) * _point.y) + ((_line.start.x * _line.end.y) - (_line.start.y * _line.end.x));

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToLine2F(MATH2D::GVECTOR2F _point, MATH2D::GLINE2F _line, float& _outDistance)
			{
				float sqLineLength = SqDistancePointToPointF(_line.start, _line.end);

				// _line.start == _line.end case
				if (G2D_COMPARISON_STANDARD_F(sqLineLength, 0.0f))
				{
					_outDistance = SqDistancePointToPointF(_point, _line.start);
					return GReturn::SUCCESS;
				}

				// Consider the line extending the segment vw, parameterized as: v + t(w - v).
				// We find projection of _point onto the line.
				// It falls at t where t = dot((p-v), (w-v)) / ||w-v||^2
				// We clamp t from 0-1 to handle points outside the segment vw.

				MATH2D::GVECTOR2F PminusV{ _point.x - _line.start.x, _point.y - _line.start.y };
				MATH2D::GVECTOR2F WminusV{ _line.end.x - _line.start.x, _line.end.y - _line.start.y };

				float dot = (PminusV.x * WminusV.x) + (PminusV.y * WminusV.y);

				// clamp t
				float t = G2D_MAX(0.0f, G2D_MIN(1.0f, dot / sqLineLength));

				// projection falls on the segment
				MATH2D::GVECTOR2F projection{ (WminusV.x * t) + _line.start.x, (WminusV.y * t) + _line.start.y };

				_outDistance = SqDistancePointToPointF(_point, projection);

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToRectangle2F(MATH2D::GVECTOR2F _point, MATH2D::GRECTANGLE2F _rectangle, float& _outDistance)
			{
				// implementation is based around the fact that our rectangles are axis-aligned

				// center of rectangle
				MATH2D::GVECTOR2F c = { (_rectangle.min.x + _rectangle.max.x) / 2.0f, (_rectangle.min.y + _rectangle.max.y) / 2.0f };
				float width = G2D_ABS(_rectangle.min.x - _rectangle.max.x);
				float height = G2D_ABS(_rectangle.min.y - _rectangle.min.y);

				float dx = G2D_MAX(G2D_ABS(_point.x - c.x) - width / 2.0f, 0.0f);
				float dy = G2D_MAX(G2D_ABS(_point.y - c.y) - height / 2.0f, 0.0f);

				_outDistance = dx * dx + dy * dy;

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToPolygon2F(MATH2D::GVECTOR2F _point, MATH2D::GVECTOR2F* _polygon, unsigned int _numVerts, float& _outDistance)
			{
				GCollisionCheck2D collisionResult;
				TestPointToPolygon2F(_point, _polygon, _numVerts, collisionResult);

				if (collisionResult == GCollisionCheck2D::COLLISION)
				{
					_outDistance = 0.0f;
					return GReturn::SUCCESS;
				}

				unsigned int j = _numVerts - 1;
				float smallestDistance = 3.402823466e+38F; // float max
				float temp;
				for (unsigned int i = 0; i < _numVerts; j = i++)
				{
					SqDistancePointToLine2F(_point, { _polygon[i], _polygon[j] }, temp);
					smallestDistance = G2D_MIN(smallestDistance, temp);
				}

				_outDistance = smallestDistance;

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToLine2F(MATH2D::GVECTOR2F _point, MATH2D::GLINE2F _line, GCollisionCheck2D& _outResult)
			{
				// handle cases where point is at start or end of line and where line is actually a point
				if (PointsAreEqualF(_point, _line.start) || PointsAreEqualF(_point, _line.end))
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				float equationResult;
				ImplicitLineEquationF(_point, _line, equationResult);

				GCollisionCheck2D collisionResult = GCollisionCheck2D::NO_COLLISION;
				if (G2D_COMPARISON_STANDARD_F(equationResult, 0.0f)) // if the point is on the vector of the line
				{
					if (_line.start.x == _line.end.x) // if its a vertical line with undefined slope
					{
						if (_line.start.y < _line.end.y) // if the slope would be positive
						{
							if (_line.start.y < _point.y && _point.y < _line.end.y) // if our point is between the start and end points, its on the line segment
							{
								collisionResult = GCollisionCheck2D::COLLISION;
							}
						}
						else // the slope would be negative so swap the start and end points in the next comparision
						{
							if (_line.end.y < _point.y && _point.y < _line.start.y)
							{
								collisionResult = GCollisionCheck2D::COLLISION;
							}
						}
					}
					else // if its a horizontal line with 0 slope, or any other line
					{
						if (_line.start.x < _line.end.x) // if the slope would be positive
						{
							if (_line.start.x < _point.x && _point.x < _line.end.x) // if our point is between the start and end points, its on the line segment
							{
								collisionResult = GCollisionCheck2D::COLLISION;
							}
						}
						else // the slope would be negative so swap the start and end points in the next comparision
						{
							if (_line.end.x < _point.x && _point.x < _line.start.x)
							{
								collisionResult = GCollisionCheck2D::COLLISION;
							}
						}
					}
				}
				else if (equationResult > 0.0f) { collisionResult = GCollisionCheck2D::ABOVE; }
				else { collisionResult = GCollisionCheck2D::BELOW; }

				_outResult = collisionResult;

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToCircle2F(MATH2D::GVECTOR2F _point, MATH2D::GCIRCLE2F _circle, GCollisionCheck2D& _outResult)
			{
				_outResult = SqDistancePointToPointF(_point, _circle.pos) <= (_circle.radius * _circle.radius)
					? GCollisionCheck2D::COLLISION
					: GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToRectangle2F(MATH2D::GVECTOR2F _point, MATH2D::GRECTANGLE2F _rectangle, GCollisionCheck2D& _outResult)
			{
				// find bottom left and top right corners of rectangle
				MATH2D::GVECTOR2F botLeft{ G2D_MIN(_rectangle.min.x, _rectangle.max.x), G2D_MIN(_rectangle.min.y, _rectangle.max.y) };
				MATH2D::GVECTOR2F topRight{ G2D_MAX(_rectangle.min.x, _rectangle.max.x), G2D_MAX(_rectangle.min.y, _rectangle.max.y) };

				if (_point.x >= botLeft.x &&
					_point.x <= topRight.x &&
					_point.y >= botLeft.y &&
					_point.y <= topRight.y)
				{
					_outResult = GCollisionCheck2D::COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck2D::NO_COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToPolygon2F(MATH2D::GVECTOR2F _point, MATH2D::GVECTOR2F* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult)
			{
				bool collision = false;
				unsigned int j = _numVerts - 1;
				for (unsigned int i = 0; i < _numVerts; j = i++)
				{
					// in any compiler that implements C, when executing the code a && b, if a is false, then b must not be evaluated, which means we dont have to check for devide-by-zero
					if (((_polygon[i].y > _point.y) != (_polygon[j].y > _point.y)) &&
						(_point.x < (_polygon[j].x - _polygon[i].x) * (_point.y - _polygon[i].y) / (_polygon[j].y - _polygon[i].y) + _polygon[i].x))
					{
						collision = !collision;
					}
				}

				_outResult = collision == true ? GCollisionCheck2D::COLLISION : GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToLine2F(MATH2D::GLINE2F _line1, MATH2D::GLINE2F _line2, GCollisionCheck2D& _outResult)
			{
				// line equation for line1: Ax + By = C
				float A1 = _line1.end.y - _line1.start.y;
				float B1 = _line1.start.x - _line1.end.x;
				float C1 = A1 * _line1.start.x + B1 * _line1.start.y;

				// line equation for line2
				float A2 = _line2.end.y - _line2.start.y;
				float B2 = _line2.start.x - _line2.end.x;
				float C2 = A2 * _line2.start.x + B2 * _line2.start.y;

				float det = A1 * B2 - A2 * B1;

				if (det == 0) // lines are parallel. need to check if one line is a subsegment of the other
				{
					if (A1 * _line2.start.x + B1 * _line2.start.y == C1 ||
						A1 * _line2.end.x + B1 * _line2.end.y == C1 ||
						A2 * _line1.start.x + B2 * _line1.start.y == C2 ||
						A2 * _line1.end.x + B2 * _line1.end.y == C2)
					{
						_outResult = GCollisionCheck2D::COLLISION;
					}
					else
					{
						_outResult = GCollisionCheck2D::NO_COLLISION;
					}
				}
				else
				{
					// lines are not parallel, find the intersection
					float x = (B2 * C1 - B1 * C2) / det;
					float y = (A1 * C2 - A2 * C1) / det;

					// find minXY and maxXY for both lines
					MATH2D::GVECTOR2F min1{ G2D_MIN(_line1.start.x, _line1.end.x), G2D_MIN(_line1.start.y, _line1.end.y) };
					MATH2D::GVECTOR2F max1{ G2D_MAX(_line1.start.x, _line1.end.x), G2D_MAX(_line1.start.y, _line1.end.y) };
					MATH2D::GVECTOR2F min2{ G2D_MIN(_line2.start.x, _line2.end.x), G2D_MIN(_line2.start.y, _line2.end.y) };
					MATH2D::GVECTOR2F max2{ G2D_MAX(_line2.start.x, _line2.end.x), G2D_MAX(_line2.start.y, _line2.end.y) };

					// test if the intersection falls within both line segments
					if (x >= min1.x &&
						x >= min2.x &&
						x <= max1.x &&
						x <= max2.x &&
						y >= min1.y &&
						y >= min2.y &&
						y <= max1.y &&
						y <= max2.y)
					{
						_outResult = GCollisionCheck2D::COLLISION;
					}
					else
					{
						_outResult = GCollisionCheck2D::NO_COLLISION;
					}
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToCircle2F(MATH2D::GLINE2F _line, MATH2D::GCIRCLE2F _circle, GCollisionCheck2D& _outResult)
			{
				float sqDistanceToLine;
				SqDistancePointToLine2F(_circle.pos, _line, sqDistanceToLine);

				_outResult = sqDistanceToLine <= _circle.radius * _circle.radius
					? GCollisionCheck2D::COLLISION
					: GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToRectangle2F(MATH2D::GLINE2F _line, MATH2D::GRECTANGLE2F _rectangle, GCollisionCheck2D& _outResult)
			{
				// handle case where both start and/or end of _line are inside _rectangle
				float distanceFromStartToRect, distanceFromEndToRect;

				SqDistancePointToRectangle2F(_line.start, _rectangle, distanceFromStartToRect);
				if (G2D_COMPARISON_STANDARD_F(distanceFromStartToRect, 0.0f))
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				SqDistancePointToRectangle2F(_line.end, _rectangle, distanceFromEndToRect);
				if (G2D_COMPARISON_STANDARD_F(distanceFromEndToRect, 0.0f))
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}



				// handle everything else
				GCollisionCheck2D left, right, top, bottom;

				TestLineToLine2F(_line, { _rectangle.min, {_rectangle.min.x, _rectangle.max.y} }, left);
				if (left == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				TestLineToLine2F(_line, { {_rectangle.max.x, _rectangle.min.y}, _rectangle.max }, right);
				if (right == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				TestLineToLine2F(_line, { {_rectangle.min.x, _rectangle.max.y}, _rectangle.max }, top);
				if (top == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				TestLineToLine2F(_line, { _rectangle.min, {_rectangle.max.x, _rectangle.min.y} }, bottom);
				if (bottom == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToPolygon2F(MATH2D::GLINE2F _line, MATH2D::GVECTOR2F* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult)
			{
				// handle case where start and/or end of _line are inside _polygon
				GCollisionCheck2D cStart, cEnd;

				TestPointToPolygon2F(_line.start, _polygon, _numVerts, cStart);
				if (cStart == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				TestPointToPolygon2F(_line.start, _polygon, _numVerts, cEnd);
				if (cEnd == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}


				// handle everything else
				unsigned int j = _numVerts - 1;
				GCollisionCheck2D lineCollision;
				for (unsigned int i = 0; i < _numVerts; j = i++)
				{
					TestLineToLine2F(_line, { _polygon[i], _polygon[j] }, lineCollision);
					if (lineCollision == GCollisionCheck2D::COLLISION)
					{
						_outResult = GCollisionCheck2D::COLLISION;
						return GReturn::SUCCESS;
					}
				}

				_outResult = GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestCircleToCircle2F(MATH2D::GCIRCLE2F _circle1, MATH2D::GCIRCLE2F _circle2, GCollisionCheck2D& _outResult)
			{
				_outResult = SqDistancePointToPointF(_circle1.pos, _circle2.pos) <= (_circle1.radius + _circle2.radius) * (_circle1.radius + _circle2.radius)
					? GCollisionCheck2D::COLLISION
					: GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestRectangleToRectangle2F(MATH2D::GRECTANGLE2F _rectangle1, MATH2D::GRECTANGLE2F _rectangle2, GCollisionCheck2D& _outResult)
			{
				// find bottom left and top right corners of rectangles and width and height
				MATH2D::GVECTOR2F botLeft1{ G2D_MIN(_rectangle1.min.x, _rectangle1.max.x), G2D_MIN(_rectangle1.min.y, _rectangle1.max.y) };
				MATH2D::GVECTOR2F topRight1{ G2D_MAX(_rectangle1.min.x, _rectangle1.max.x), G2D_MAX(_rectangle1.min.y, _rectangle1.max.y) };
				MATH2D::GVECTOR2F botLeft2{ G2D_MIN(_rectangle2.min.x, _rectangle2.max.x), G2D_MIN(_rectangle2.min.y, _rectangle2.max.y) };
				MATH2D::GVECTOR2F topRight2{ G2D_MAX(_rectangle2.min.x, _rectangle2.max.x), G2D_MAX(_rectangle2.min.y, _rectangle2.max.y) };

				if (botLeft1.x > topRight2.x ||
					topRight1.x < botLeft2.x ||
					botLeft1.y > topRight2.y ||
					topRight1.y < botLeft2.y)
				{
					_outResult = GCollisionCheck2D::NO_COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck2D::COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestRectangleToPolygon2F(MATH2D::GRECTANGLE2F _rectangle, MATH2D::GVECTOR2F* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult)
			{
				GCollisionCheck2D collisionResult;
				// rectangle could be inside polygon
				TestPointToPolygon2F(_rectangle.min, _polygon, _numVerts, collisionResult);
				if (collisionResult == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				// polygon could be inside rectangle
				TestPointToRectangle2F(_polygon[0], _rectangle, collisionResult);
				if (collisionResult == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				// test the rectangle to every edge of the polygon
				unsigned int j = _numVerts - 1;
				for (unsigned int i = 0; i < _numVerts; j = i++)
				{
					TestLineToRectangle2F({ _polygon[i], _polygon[j] }, _rectangle, collisionResult);
					if (collisionResult == GCollisionCheck2D::COLLISION)
					{
						_outResult = GCollisionCheck2D::COLLISION;
						return GReturn::SUCCESS;
					}
				}

				_outResult = GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestPolygonToPolygon2F(MATH2D::GVECTOR2F* _polygon1, unsigned int _numVerts1, MATH2D::GVECTOR2F* _polygon2, unsigned int _numVerts2, GCollisionCheck2D& _outResult)
			{
				GCollisionCheck2D collisionResult;
				// polygon2 could be inside polygon1
				TestPointToPolygon2F(_polygon2[0], _polygon1, _numVerts1, collisionResult);
				if (collisionResult == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				// test the edges of polygon1 to polygon2
				unsigned int j = _numVerts1 - 1;
				for (unsigned int i = 0; i < _numVerts1; j = i++)
				{
					TestLineToPolygon2F({ _polygon1[i], _polygon1[j] }, _polygon2, _numVerts2, collisionResult);
					if (collisionResult == GCollisionCheck2D::COLLISION)
					{
						_outResult = GCollisionCheck2D::COLLISION;
						return GReturn::SUCCESS;
					}
				}

				_outResult = GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn FindBarycentricF(MATH2D::GVECTOR2F _point, MATH2D::GVECTOR2F _trianglePoint1, MATH2D::GVECTOR2F _trianglePoint2, MATH2D::GVECTOR2F _trianglePoint3, MATH2D::GBARYCENTRICF& _outBarycentric)
			{
				float rectArea;
				ImplicitLineEquationF(_trianglePoint1, { _trianglePoint3, _trianglePoint2 }, rectArea);

				if (G2D_COMPARISON_STANDARD_F(rectArea, 0.0f))
				{
					return GReturn::FAILURE; // would get a devide-by-zero error
				}

				float a, b;
				ImplicitLineEquationF(_point, { _trianglePoint3, _trianglePoint2 }, a);
				ImplicitLineEquationF(_point, { _trianglePoint1, _trianglePoint3 }, b);

				_outBarycentric.alpha = a / rectArea;
				_outBarycentric.beta = b / rectArea;
				_outBarycentric.gamma = 1.0f - _outBarycentric.alpha - _outBarycentric.beta;

				return GReturn::SUCCESS;
			}




			// Doubles
			static GReturn ImplicitLineEquationD(MATH2D::GVECTOR2D _point, MATH2D::GLINE2D _line, double& _outEquationResult)
			{
				//									A				      x                       B                    y                                       C
				_outEquationResult = ((_line.start.y - _line.end.y) * _point.x) + ((_line.end.x - _line.start.x) * _point.y) + ((_line.start.x * _line.end.y) - (_line.start.y * _line.end.x));

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToLine2D(MATH2D::GVECTOR2D _point, MATH2D::GLINE2D _line, double& _outDistance)
			{
				double sqLineLength = SqDistancePointToPointD(_line.start, _line.end);

				// _line.start == _line.end case
				if (G2D_COMPARISON_STANDARD_D(sqLineLength, 0.0))
				{
					_outDistance = SqDistancePointToPointD(_point, _line.start);
					return GReturn::SUCCESS;
				}

				// Consider the line extending the segment vw, parameterized as: v + t(w - v).
				// We find projection of _point onto the line.
				// It falls at t where t = dot((p-v), (w-v)) / ||w-v||^2
				// We clamp t from 0-1 to handle points outside the segment vw.

				MATH2D::GVECTOR2D PminusV{ _point.x - _line.start.x, _point.y - _line.start.y };
				MATH2D::GVECTOR2D WminusV{ _line.end.x - _line.start.x, _line.end.y - _line.start.y };

				double dot = (PminusV.x * WminusV.x) + (PminusV.y * WminusV.y);

				// clamp t
				double t = G2D_MAX(0.0, G2D_MIN(1.0, dot / sqLineLength));

				// projection falls on the segment
				MATH2D::GVECTOR2D projection{ (WminusV.x * t) + _line.start.x, (WminusV.y * t) + _line.start.y };

				_outDistance = SqDistancePointToPointD(_point, projection);

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToRectangle2D(MATH2D::GVECTOR2D _point, MATH2D::GRECTANGLE2D _rectangle, double& _outDistance)
			{
				// implementation is based around the fact that our rectangles are axis-aligned

				// center of rectangle
				MATH2D::GVECTOR2D c = { (_rectangle.min.x + _rectangle.max.x) / 2.0, (_rectangle.min.y + _rectangle.max.y) / 2.0 };
				double width = G2D_ABS(_rectangle.min.x - _rectangle.max.x);
				double height = G2D_ABS(_rectangle.min.y - _rectangle.min.y);

				double dx = G2D_MAX(G2D_ABS(_point.x - c.x) - width / 2.0, 0.0);
				double dy = G2D_MAX(G2D_ABS(_point.y - c.y) - height / 2.0, 0.0);

				_outDistance = dx * dx + dy * dy;

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToPolygon2D(MATH2D::GVECTOR2D _point, MATH2D::GVECTOR2D* _polygon, unsigned int _numVerts, double& _outDistance)
			{
				GCollisionCheck2D collisionResult;
				TestPointToPolygon2D(_point, _polygon, _numVerts, collisionResult);

				if (collisionResult == GCollisionCheck2D::COLLISION)
				{
					_outDistance = 0.0;
					return GReturn::SUCCESS;
				}

				unsigned int j = _numVerts - 1;
				double smallestDistance = 1.7976931348623158e+308; // double max
				double temp;
				for (unsigned int i = 0; i < _numVerts; j = i++)
				{
					SqDistancePointToLine2D(_point, { _polygon[i], _polygon[j] }, temp);
					smallestDistance = G2D_MIN(smallestDistance, temp);
				}

				_outDistance = smallestDistance;

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToLine2D(MATH2D::GVECTOR2D _point, MATH2D::GLINE2D _line, GCollisionCheck2D& _outResult)
			{
				if (PointsAreEqualD(_point, _line.start) || PointsAreEqualD(_point, _line.end))
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				double equationResult;
				ImplicitLineEquationD(_point, _line, equationResult);

				GCollisionCheck2D collisionResult = GCollisionCheck2D::NO_COLLISION;
				if (G2D_COMPARISON_STANDARD_D(equationResult, 0.0)) // if the point is on the vector of the line
				{
					if (_line.start.x == _line.end.x) // if its a vertical line with undefined slope
					{
						if (_line.start.y < _line.end.y) // if the slope would be positive
						{
							if (_line.start.y < _point.y && _point.y < _line.end.y) // if our point is between the start and end points, its on the line segment
							{
								collisionResult = GCollisionCheck2D::COLLISION;
							}
						}
						else // the slope would be negative so swap the start and end points in the next comparision
						{
							if (_line.end.y < _point.y && _point.y < _line.start.y)
							{
								collisionResult = GCollisionCheck2D::COLLISION;
							}
						}
					}
					else // if its a horizontal line with 0 slope, or any other line
					{
						if (_line.start.x < _line.end.x) // if the slope would be positive
						{
							if (_line.start.x < _point.x && _point.x < _line.end.x) // if our point is between the start and end points, its on the line segment
							{
								collisionResult = GCollisionCheck2D::COLLISION;
							}
						}
						else // the slope would be negative so swap the start and end points in the next comparision
						{
							if (_line.end.x < _point.x && _point.x < _line.start.x)
							{
								collisionResult = GCollisionCheck2D::COLLISION;
							}
						}
					}
				}
				else if (equationResult > 0.0) { collisionResult = GCollisionCheck2D::ABOVE; }
				else { collisionResult = GCollisionCheck2D::BELOW; }

				_outResult = collisionResult;

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToCircle2D(MATH2D::GVECTOR2D _point, MATH2D::GCIRCLE2D _circle, GCollisionCheck2D& _outResult)
			{
				_outResult = SqDistancePointToPointD(_point, _circle.pos) <= (_circle.radius * _circle.radius)
					? GCollisionCheck2D::COLLISION
					: GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToRectangle2D(MATH2D::GVECTOR2D _point, MATH2D::GRECTANGLE2D _rectangle, GCollisionCheck2D& _outResult)
			{
				// find bottom left and top right corners of rectangle
				MATH2D::GVECTOR2D botLeft{ G2D_MIN(_rectangle.min.x, _rectangle.max.x), G2D_MIN(_rectangle.min.y, _rectangle.max.y) };
				MATH2D::GVECTOR2D topRight{ G2D_MAX(_rectangle.min.x, _rectangle.max.x), G2D_MAX(_rectangle.min.y, _rectangle.max.y) };

				if (_point.x >= botLeft.x &&
					_point.x <= topRight.x &&
					_point.y >= botLeft.y &&
					_point.y <= topRight.y)
				{
					_outResult = GCollisionCheck2D::COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck2D::NO_COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToPolygon2D(MATH2D::GVECTOR2D _point, MATH2D::GVECTOR2D* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult)
			{
				bool collision = false;
				unsigned int j = _numVerts - 1;
				for (unsigned int i = 0; i < _numVerts; j = i++)
				{
					// when executing the code a && b, if a is false, then b must not be evaluated, which means we dont have to check for devide-by-zero
					if (((_polygon[i].y > _point.y) != (_polygon[j].y > _point.y)) &&
						(_point.x < (_polygon[j].x - _polygon[i].x) * (_point.y - _polygon[i].y) / (_polygon[j].y - _polygon[i].y) + _polygon[i].x))
					{
						collision = !collision;
					}
				}

				_outResult = collision == true ? GCollisionCheck2D::COLLISION : GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToLine2D(MATH2D::GLINE2D _line1, MATH2D::GLINE2D _line2, GCollisionCheck2D& _outResult)
			{
				// line equation for line1: Ax + By = C
				double A1 = _line1.end.y - _line1.start.y;
				double B1 = _line1.start.x - _line1.end.x;
				double C1 = A1 * _line1.start.x + B1 * _line1.start.y;

				// line equation for line2
				double A2 = _line2.end.y - _line2.start.y;
				double B2 = _line2.start.x - _line2.end.x;
				double C2 = A2 * _line2.start.x + B2 * _line2.start.y;

				double det = A1 * B2 - A2 * B1;

				if (det == 0) // lines are parallel. need to check if one line is a subsegment of the other
				{
					if (A1 * _line2.start.x + B1 * _line2.start.y == C1 ||
						A1 * _line2.end.x + B1 * _line2.end.y == C1 ||
						A2 * _line1.start.x + B2 * _line1.start.y == C2 ||
						A2 * _line1.end.x + B2 * _line1.end.y == C2)
					{
						_outResult = GCollisionCheck2D::COLLISION;
					}
					else
					{
						_outResult = GCollisionCheck2D::NO_COLLISION;
					}
				}
				else
				{
					// lines are not parallel, find the intersection
					double x = (B2 * C1 - B1 * C2) / det;
					double y = (A1 * C2 - A2 * C1) / det;

					// find minXY and maxXY for both lines
					MATH2D::GVECTOR2D min1{ G2D_MIN(_line1.start.x, _line1.end.x), G2D_MIN(_line1.start.y, _line1.end.y) };
					MATH2D::GVECTOR2D max1{ G2D_MAX(_line1.start.x, _line1.end.x), G2D_MAX(_line1.start.y, _line1.end.y) };
					MATH2D::GVECTOR2D min2{ G2D_MIN(_line2.start.x, _line2.end.x), G2D_MIN(_line2.start.y, _line2.end.y) };
					MATH2D::GVECTOR2D max2{ G2D_MAX(_line2.start.x, _line2.end.x), G2D_MAX(_line2.start.y, _line2.end.y) };

					// test if the intersection falls within both line segments
					if (x >= min1.x &&
						x >= min2.x &&
						x <= max1.x &&
						x <= max2.x &&
						y >= min1.y &&
						y >= min2.y &&
						y <= max1.y &&
						y <= max2.y)
					{
						_outResult = GCollisionCheck2D::COLLISION;
					}
					else
					{
						_outResult = GCollisionCheck2D::NO_COLLISION;
					}
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToCircle2D(MATH2D::GLINE2D _line, MATH2D::GCIRCLE2D _circle, GCollisionCheck2D& _outResult)
			{
				double sqDistanceToLine;
				SqDistancePointToLine2D(_circle.pos, _line, sqDistanceToLine);

				_outResult = sqDistanceToLine <= _circle.radius * _circle.radius
					? GCollisionCheck2D::COLLISION
					: GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToRectangle2D(MATH2D::GLINE2D _line, MATH2D::GRECTANGLE2D _rectangle, GCollisionCheck2D& _outResult)
			{
				// handle case where both start and/or end of _line are inside _rectangle
				double distanceFromStartToRect, distanceFromEndToRect;

				SqDistancePointToRectangle2D(_line.start, _rectangle, distanceFromStartToRect);
				if (G2D_COMPARISON_STANDARD_D(distanceFromStartToRect, 0.0))
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				SqDistancePointToRectangle2D(_line.end, _rectangle, distanceFromEndToRect);
				if (G2D_COMPARISON_STANDARD_D(distanceFromEndToRect, 0.0))
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}


				// handle everything else
				GCollisionCheck2D left, right, top, bottom;

				TestLineToLine2D(_line, { _rectangle.min, {_rectangle.min.x, _rectangle.max.y} }, left);
				if (left == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				TestLineToLine2D(_line, { {_rectangle.max.x, _rectangle.min.y}, _rectangle.max }, right);
				if (right == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				TestLineToLine2D(_line, { {_rectangle.min.x, _rectangle.max.y}, _rectangle.max }, top);
				if (top == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				TestLineToLine2D(_line, { _rectangle.min, {_rectangle.max.x, _rectangle.min.y} }, bottom);
				if (bottom == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToPolygon2D(MATH2D::GLINE2D _line, MATH2D::GVECTOR2D* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult)
			{
				// handle case where start and/or end of _line are inside _polygon
				GCollisionCheck2D cStart, cEnd;

				TestPointToPolygon2D(_line.start, _polygon, _numVerts, cStart);
				if (cStart == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				TestPointToPolygon2D(_line.start, _polygon, _numVerts, cEnd);
				if (cEnd == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}


				// handle everything else
				unsigned int j = _numVerts - 1;
				GCollisionCheck2D lineCollision;
				for (unsigned int i = 0; i < _numVerts; j = i++)
				{
					TestLineToLine2D(_line, { _polygon[i], _polygon[j] }, lineCollision);
					if (lineCollision == GCollisionCheck2D::COLLISION)
					{
						_outResult = GCollisionCheck2D::COLLISION;
						return GReturn::SUCCESS;
					}
				}

				_outResult = GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestCircleToCircle2D(MATH2D::GCIRCLE2D _circle1, MATH2D::GCIRCLE2D _circle2, GCollisionCheck2D& _outResult)
			{
				_outResult = SqDistancePointToPointD(_circle1.pos, _circle2.pos) <= (_circle1.radius + _circle2.radius) * (_circle1.radius + _circle2.radius)
					? GCollisionCheck2D::COLLISION
					: GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestRectangleToRectangle2D(MATH2D::GRECTANGLE2D _rectangle1, MATH2D::GRECTANGLE2D _rectangle2, GCollisionCheck2D& _outResult)
			{
				// find bottom left and top right corners of rectangles and width and height
				MATH2D::GVECTOR2D botLeft1{ G2D_MIN(_rectangle1.min.x, _rectangle1.max.x), G2D_MIN(_rectangle1.min.y, _rectangle1.max.y) };
				MATH2D::GVECTOR2D topRight1{ G2D_MAX(_rectangle1.min.x, _rectangle1.max.x), G2D_MAX(_rectangle1.min.y, _rectangle1.max.y) };
				MATH2D::GVECTOR2D botLeft2{ G2D_MIN(_rectangle2.min.x, _rectangle2.max.x), G2D_MIN(_rectangle2.min.y, _rectangle2.max.y) };
				MATH2D::GVECTOR2D topRight2{ G2D_MAX(_rectangle2.min.x, _rectangle2.max.x), G2D_MAX(_rectangle2.min.y, _rectangle2.max.y) };

				if (botLeft1.x > topRight2.x ||
					topRight1.x < botLeft2.x ||
					botLeft1.y > topRight2.y ||
					topRight1.y < botLeft2.y)
				{
					_outResult = GCollisionCheck2D::NO_COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck2D::COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestRectangleToPolygon2D(MATH2D::GRECTANGLE2D _rectangle, MATH2D::GVECTOR2D* _polygon, unsigned int _numVerts, GCollisionCheck2D& _outResult)
			{
				GCollisionCheck2D collisionResult;
				// rectangle could be inside polygon
				TestPointToPolygon2D(_rectangle.min, _polygon, _numVerts, collisionResult);
				if (collisionResult == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				// polygon could be inside rectangle
				TestPointToRectangle2D(_polygon[0], _rectangle, collisionResult);
				if (collisionResult == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				// test the rectangle to every edge of the polygon
				unsigned int j = _numVerts - 1;
				for (unsigned int i = 0; i < _numVerts; j = i++)
				{
					TestLineToRectangle2D({ _polygon[i], _polygon[j] }, _rectangle, collisionResult);
					if (collisionResult == GCollisionCheck2D::COLLISION)
					{
						_outResult = GCollisionCheck2D::COLLISION;
						return GReturn::SUCCESS;
					}
				}

				_outResult = GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestPolygonToPolygon2D(MATH2D::GVECTOR2D* _polygon1, unsigned int _numVerts1, MATH2D::GVECTOR2D* _polygon2, unsigned int _numVerts2, GCollisionCheck2D& _outResult)
			{
				GCollisionCheck2D collisionResult;
				// polygon2 could be inside polygon1
				TestPointToPolygon2D(_polygon2[0], _polygon1, _numVerts1, collisionResult);
				if (collisionResult == GCollisionCheck2D::COLLISION)
				{
					_outResult = GCollisionCheck2D::COLLISION;
					return GReturn::SUCCESS;
				}

				// test the edges of polygon1 to polygon2
				unsigned int j = _numVerts1 - 1;
				for (unsigned int i = 0; i < _numVerts1; j = i++)
				{
					TestLineToPolygon2D({ _polygon1[i], _polygon1[j] }, _polygon2, _numVerts2, collisionResult);
					if (collisionResult == GCollisionCheck2D::COLLISION)
					{
						_outResult = GCollisionCheck2D::COLLISION;
						return GReturn::SUCCESS;
					}
				}

				_outResult = GCollisionCheck2D::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn FindBarycentricD(MATH2D::GVECTOR2D _point, MATH2D::GVECTOR2D _trianglePoint1, MATH2D::GVECTOR2D _trianglePoint2, MATH2D::GVECTOR2D _trianglePoint3, MATH2D::GBARYCENTRICD& _outBarycentric)
			{
				double rectArea;
				ImplicitLineEquationD(_trianglePoint1, { _trianglePoint3, _trianglePoint2 }, rectArea);

				if (G2D_COMPARISON_STANDARD_D(rectArea, 0.0))
				{
					return GReturn::FAILURE; // would get a devide-by-zero error
				}

				double a, b;
				ImplicitLineEquationD(_point, { _trianglePoint3, _trianglePoint2 }, a);
				ImplicitLineEquationD(_point, { _trianglePoint1, _trianglePoint3 }, b);

				_outBarycentric.alpha = a / rectArea;
				_outBarycentric.beta = b / rectArea;
				_outBarycentric.gamma = 1.0 - _outBarycentric.alpha - _outBarycentric.beta;

				return GReturn::SUCCESS;

				return GReturn::SUCCESS;
			}

		private:
			static bool PointsAreEqualF(MATH2D::GVECTOR2F _p1, MATH2D::GVECTOR2F _p2)
			{
				return (G2D_COMPARISON_STANDARD_F(_p1.x, _p2.x) && G2D_COMPARISON_STANDARD_F(_p1.y, _p2.y));
			}

			static bool PointsAreEqualD(MATH2D::GVECTOR2D _p1, MATH2D::GVECTOR2D _p2)
			{
				return (G2D_COMPARISON_STANDARD_D(_p1.x, _p2.x) && G2D_COMPARISON_STANDARD_D(_p1.y, _p2.y));
			}

			static float SqDistancePointToPointF(MATH2D::GVECTOR2F _p1, MATH2D::GVECTOR2F _p2)
			{
				return ((_p2.x - _p1.x) * (_p2.x - _p1.x)) + ((_p2.y - _p1.y) * (_p2.y - _p1.y));
			}

			static double SqDistancePointToPointD(MATH2D::GVECTOR2D _p1, MATH2D::GVECTOR2D _p2)
			{
				return ((_p2.x - _p1.x) * (_p2.x - _p1.x)) + ((_p2.y - _p1.y) * (_p2.y - _p1.y));
			}
		};
	}
}

#endif


namespace GW
{
	namespace MATH2D
	{
		class GCollision2D final
			: public I::GProxy<I::GCollision2DInterface, I::GCollision2DImplementation>
		{
		public:
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GCollision2D)
			GATEWARE_TYPEDEF(GCollisionCheck2D)
			// floats
			GATEWARE_STATIC_FUNCTION(ImplicitLineEquationF)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToLine2F)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToRectangle2F)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToPolygon2F)
			GATEWARE_STATIC_FUNCTION(TestPointToLine2F)
			GATEWARE_STATIC_FUNCTION(TestPointToCircle2F)
			GATEWARE_STATIC_FUNCTION(TestPointToRectangle2F)
			GATEWARE_STATIC_FUNCTION(TestPointToPolygon2F)
			GATEWARE_STATIC_FUNCTION(TestLineToLine2F)
			GATEWARE_STATIC_FUNCTION(TestLineToCircle2F)
			GATEWARE_STATIC_FUNCTION(TestLineToRectangle2F)
			GATEWARE_STATIC_FUNCTION(TestLineToPolygon2F)
			GATEWARE_STATIC_FUNCTION(TestCircleToCircle2F)
			GATEWARE_STATIC_FUNCTION(TestRectangleToRectangle2F)
			GATEWARE_STATIC_FUNCTION(TestRectangleToPolygon2F)
			GATEWARE_STATIC_FUNCTION(TestPolygonToPolygon2F)
			GATEWARE_STATIC_FUNCTION(FindBarycentricF)
			// doubles
			GATEWARE_STATIC_FUNCTION(ImplicitLineEquationD)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToLine2D)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToRectangle2D)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToPolygon2D)
			GATEWARE_STATIC_FUNCTION(TestPointToLine2D)
			GATEWARE_STATIC_FUNCTION(TestPointToCircle2D)
			GATEWARE_STATIC_FUNCTION(TestPointToRectangle2D)
			GATEWARE_STATIC_FUNCTION(TestPointToPolygon2D)
			GATEWARE_STATIC_FUNCTION(TestLineToLine2D)
			GATEWARE_STATIC_FUNCTION(TestLineToCircle2D)
			GATEWARE_STATIC_FUNCTION(TestLineToRectangle2D)
			GATEWARE_STATIC_FUNCTION(TestLineToPolygon2D)
			GATEWARE_STATIC_FUNCTION(TestCircleToCircle2D)
			GATEWARE_STATIC_FUNCTION(TestRectangleToRectangle2D)
			GATEWARE_STATIC_FUNCTION(TestRectangleToPolygon2D)
			GATEWARE_STATIC_FUNCTION(TestPolygonToPolygon2D)
			GATEWARE_STATIC_FUNCTION(FindBarycentricD)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GCOLLISION2D_H

/*---------------------------------
|	End of GCollision2D.h
----------------------------------*/


/*---------------------------------
|	Begin of GCollision.h
----------------------------------*/
#ifndef GCOLLISION_H
#define GCOLLISION_H







namespace GW
{
	namespace I
	{
		class GCollisionInterface : public virtual GInterfaceInterface
		{
		public:

			enum class GCollisionCheck
			{
				ERROR_NO_RESULT = -3,
				ABOVE = -2,
				BELOW = -1,
				NO_COLLISION = 0,
				COLLISION = 1
			};

			// float
			static GReturn ConvertAABBCEToAABBMMF(const MATH::GAABBCEF _aabbCE, MATH::GAABBMMF& _outAABBMM) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ConvertAABBMMToAABBCEF(const MATH::GAABBMMF _aabbMM, MATH::GAABBCEF& _outAABCE) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ComputePlaneF(const MATH::GVECTORF _planePositionA, const MATH::GVECTORF _planePositionB, const MATH::GVECTORF _planePositionC, MATH::GPLANEF& _outPlane) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IsTriangleF(const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToConvexPolygonF(const MATH::GVECTORF _queryPoint, const MATH::GVECTORF* _polygonPoints, const unsigned int _pointsCount, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToLineF(const MATH::GLINEF _line, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointsToLineFromLineF(const MATH::GLINEF _line1, const MATH::GLINEF _line2, MATH::GVECTORF& _outPoint1, MATH::GVECTORF& _outPoint2) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToRayF(const MATH::GRAYF _ray, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToTriangleF(const MATH::GTRIANGLEF _triangle, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToPlaneF(const MATH::GPLANEF _plane, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToSphereF(const MATH::GSPHEREF _sphere, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToCapsuleF(const MATH::GCAPSULEF _capsule, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToAABBF(const MATH::GAABBMMF _aabb, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToOBBF(const MATH::GOBBF _obb, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ComputeSphereFromPointsF(const MATH::GVECTORF* _pointCloud, const unsigned int _pointsCount, MATH::GSPHEREF& _outSphere) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ComputeAABBFromPointsF(const MATH::GVECTORF* _pointCloud, const unsigned int _pointsCount, MATH::GAABBMMF& _outAABB) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToLineF(const MATH::GVECTORF _point, const MATH::GLINEF _line, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToRayF(const MATH::GVECTORF _point, const MATH::GRAYF _ray, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToTriangleF(const MATH::GVECTORF _point, const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult, MATH::GVECTORF* _outBarycentric) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToPlaneF(const MATH::GVECTORF _point, const MATH::GPLANEF _plane, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToSphereF(const MATH::GVECTORF _point, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToCapsuleF(const MATH::GVECTORF _point, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToAABBF(const MATH::GVECTORF _point, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToOBBF(const MATH::GVECTORF _point, const MATH::GOBBF _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToLineF(const MATH::GLINEF _line1, const MATH::GLINEF _line2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToRayF(const MATH::GLINEF _line, const MATH::GRAYF _ray, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToTriangleF(const MATH::GLINEF _line, const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult, MATH::GVECTORF* _outBarycentric) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToPlaneF(const MATH::GLINEF _line, const MATH::GPLANEF _plane, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToSphereF(const MATH::GLINEF _line, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToCapsuleF(const MATH::GLINEF _line, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToAABBF(const MATH::GLINEF _line, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToOBBF(const MATH::GLINEF _line, const MATH::GOBBF _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRayToTriangleF(const MATH::GRAYF _ray, const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult, MATH::GVECTORF* _outBarycentric) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRayToPlaneF(const MATH::GRAYF _ray, const MATH::GPLANEF _plane, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRayToSphereF(const MATH::GRAYF _ray, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRayToCapsuleF(const MATH::GRAYF _ray, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRayToAABBF(const MATH::GRAYF _ray, const MATH::GAABBMMF _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRayToOBBF(const MATH::GRAYF _ray, const MATH::GOBBF _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestTriangleToTriangleF(const MATH::GTRIANGLEF _triangle1, const MATH::GTRIANGLEF _triangle2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestTriangleToPlaneF(const MATH::GTRIANGLEF _triangle, const MATH::GPLANEF _plane, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestTriangleToSphereF(const MATH::GTRIANGLEF _triangle, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestTriangleToCapsuleF(const MATH::GTRIANGLEF _triangle, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestTriangleToAABBF(const MATH::GTRIANGLEF _triangle, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestTriangleToOBBF(const MATH::GTRIANGLEF _triangle, const MATH::GOBBF _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPlaneToPlaneF(const MATH::GPLANEF _plane1, const MATH::GPLANEF _plane2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPlaneToSphereF(const MATH::GPLANEF _plane, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPlaneToCapsuleF(const MATH::GPLANEF _plane, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPlaneToAABBF(const MATH::GPLANEF _plane, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPlaneToOBBF(const MATH::GPLANEF _plane, const MATH::GOBBF _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestSphereToSphereF(const MATH::GSPHEREF _sphere1, const MATH::GSPHEREF _sphere2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestSphereToCapsuleF(const MATH::GSPHEREF _sphere, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestSphereToAABBF(const MATH::GSPHEREF _sphere, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestSphereToOBBF(const MATH::GSPHEREF _sphere, const MATH::GOBBF _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestCapsuleToCapsuleF(const MATH::GCAPSULEF _capsule1, const MATH::GCAPSULEF _capsule2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestCapsuleToAABBF(const MATH::GCAPSULEF _capsule, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestCapsuleToOBBF(const MATH::GCAPSULEF _capsule, const MATH::GOBBF _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestAABBToAABBF(const MATH::GAABBCEF _aabb1, const MATH::GAABBCEF _aabb2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestAABBToOBBF(const MATH::GAABBCEF _aabb, const MATH::GOBBF _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestOBBToOBBF(const MATH::GOBBF _obb1, const MATH::GOBBF _obb2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectLineToTriangleF(const MATH::GLINEF _line, const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF* _outBarycentric, MATH::GVECTORF& _outDirection, float& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectLineToPlaneF(const MATH::GLINEF _line, const MATH::GPLANEF _plane, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection, float& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectLineToSphereF(const MATH::GLINEF _line, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection, float& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectLineToCapsuleF(const MATH::GLINEF _line, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection, float& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectLineToAABBF(const MATH::GLINEF _line, const MATH::GAABBMMF _aabb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection, float& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectLineToOBBF(const MATH::GLINEF _line, const MATH::GOBBF _obb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection, float& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectRayToTriangleF(const MATH::GRAYF _ray, const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF* _outBarycentric, float& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectRayToPlaneF(const MATH::GRAYF _ray, const MATH::GPLANEF _plane, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, float& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectRayToSphereF(const MATH::GRAYF _ray, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, float& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectRayToCapsuleF(const MATH::GRAYF _ray, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, float& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectRayToAABBF(const MATH::GRAYF _ray, const MATH::GAABBMMF _aabb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, float& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectRayToOBBF(const MATH::GRAYF _ray, const MATH::GOBBF _obb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, float& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectSphereToSphereF(const MATH::GSPHEREF _sphere1, const MATH::GSPHEREF _sphere2, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectSphereToCapsuleF(const MATH::GSPHEREF _sphere, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectSphereToAABBF(const MATH::GSPHEREF _sphere, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectSphereToOBBF(const MATH::GSPHEREF _sphere, const MATH::GOBBF _obb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectCapsuleToCapsuleF(const MATH::GCAPSULEF _capsule1, const MATH::GCAPSULEF _capsule2, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectCapsuleToAABBF(const MATH::GCAPSULEF _capsule, const MATH::GAABBMMF _aabb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectCapsuleToOBBF(const MATH::GCAPSULEF _capsule, const MATH::GOBBF _obb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectAABBToAABBF(const MATH::GAABBCEF _aabb1, const MATH::GAABBCEF _aabb2, GCollisionCheck& _outResult, MATH::GAABBCEF& _outContactAABB, MATH::GVECTORF& _outDirection, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToLineF(const MATH::GVECTORF _point, const MATH::GLINEF _line, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToRayF(const MATH::GVECTORF _point, const MATH::GRAYF _ray, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToTriangleF(const MATH::GVECTORF _point, const MATH::GTRIANGLEF _triangle, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToPlaneF(const MATH::GVECTORF _point, const MATH::GPLANEF _plane, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToSphereF(const MATH::GVECTORF _point, const MATH::GSPHEREF _sphere, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToCapsuleF(const MATH::GVECTORF _point, const MATH::GCAPSULEF _capsule, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToAABBF(const MATH::GVECTORF _point, const MATH::GAABBMMF _aabb, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToOBBF(const MATH::GVECTORF _point, const MATH::GOBBF _obb, float& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn BarycentricF(const MATH::GVECTORF _a, const MATH::GVECTORF _b, const MATH::GVECTORF _c, const MATH::GVECTORF _p, MATH::GVECTORF& _outBarycentric) { return GReturn::NO_IMPLEMENTATION; }
			// double
			static GReturn ConvertAABBCEToAABBMMD(const MATH::GAABBCED _aabbCE, MATH::GAABBMMD& _outAABBMM) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ConvertAABBMMToAABBCED(const MATH::GAABBMMD _aabbMM, MATH::GAABBCED& _outAABCE) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ComputePlaneD(const MATH::GVECTORD _planePositionA, const MATH::GVECTORD _planePositionB, const MATH::GVECTORD _planePositionC, MATH::GPLANED& _outPlane) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IsTriangleD(const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToConvexPolygonD(const MATH::GVECTORD _queryPoint, const MATH::GVECTORD* _polygonPoints, const unsigned int _pointsCount, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToLineD(const MATH::GLINED _line, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointsToLineFromLineD(const MATH::GLINED _line1, const MATH::GLINED _line2, MATH::GVECTORD& _outPoint1, MATH::GVECTORD& _outPoint2) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToRayD(const MATH::GRAYD _ray, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToTriangleD(const MATH::GTRIANGLED _triangle, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToPlaneD(const MATH::GPLANED _plane, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToSphereD(const MATH::GSPHERED _sphere, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToCapsuleD(const MATH::GCAPSULED _capsule, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToAABBD(const MATH::GAABBMMD _aabb, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ClosestPointToOBBD(const MATH::GOBBD _obb, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ComputeSphereFromPointsD(const MATH::GVECTORD* _pointCloud, const unsigned int _pointsCount, MATH::GSPHERED& _outSphere) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ComputeAABBFromPointsD(const MATH::GVECTORD* _pointCloud, const unsigned int _pointsCount, MATH::GAABBMMD& _outAABB) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToLineD(const MATH::GVECTORD _point, const MATH::GLINED _line, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToRayD(const MATH::GVECTORD _point, const MATH::GRAYD _ray, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToTriangleD(const MATH::GVECTORD _point, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD* _outBarycentric) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToPlaneD(const MATH::GVECTORD _point, const MATH::GPLANED _plane, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToSphereD(const MATH::GVECTORD _point, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToCapsuleD(const MATH::GVECTORD _point, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToAABBD(const MATH::GVECTORD _point, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPointToOBBD(const MATH::GVECTORD _point, const MATH::GOBBD _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToLineD(const MATH::GLINED _line1, const MATH::GLINED _line2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToRayD(const MATH::GLINED _line, const MATH::GRAYD _ray, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToTriangleD(const MATH::GLINED _line, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD* _outBarycentric) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToPlaneD(const MATH::GLINED _line, const MATH::GPLANED _plane, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToSphereD(const MATH::GLINED _line, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToCapsuleD(const MATH::GLINED _line, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToAABBD(const MATH::GLINED _line, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestLineToOBBD(const MATH::GLINED _line, const MATH::GOBBD _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRayToTriangleD(const MATH::GRAYD _ray, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD* _outBarycentric) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRayToPlaneD(const MATH::GRAYD _ray, const MATH::GPLANED _plane, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRayToSphereD(const MATH::GRAYD _ray, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRayToCapsuleD(const MATH::GRAYD _ray, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRayToAABBD(const MATH::GRAYD _ray, const MATH::GAABBMMD _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestRayToOBBD(const MATH::GRAYD _ray, const MATH::GOBBD _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestTriangleToTriangleD(const MATH::GTRIANGLED _triangle1, const MATH::GTRIANGLED _triangle2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestTriangleToPlaneD(const MATH::GTRIANGLED _triangle, const MATH::GPLANED _plane, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestTriangleToSphereD(const MATH::GTRIANGLED _triangle, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestTriangleToCapsuleD(const MATH::GTRIANGLED _triangle, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestTriangleToAABBD(const MATH::GTRIANGLED _triangle, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestTriangleToOBBD(const MATH::GTRIANGLED _triangle, const MATH::GOBBD _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPlaneToPlaneD(const MATH::GPLANED _plane1, const MATH::GPLANED _plane2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPlaneToSphereD(const MATH::GPLANED _plane, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPlaneToCapsuleD(const MATH::GPLANED _plane, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPlaneToAABBD(const MATH::GPLANED _plane, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestPlaneToOBBD(const MATH::GPLANED _plane, const MATH::GOBBD _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestSphereToSphereD(const MATH::GSPHERED _sphere1, const MATH::GSPHERED _sphere2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestSphereToCapsuleD(const MATH::GSPHERED _sphere, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestSphereToAABBD(const MATH::GSPHERED _sphere, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestSphereToOBBD(const MATH::GSPHERED _sphere, const MATH::GOBBD _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestCapsuleToCapsuleD(const MATH::GCAPSULED _capsule1, const MATH::GCAPSULED _capsule2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestCapsuleToAABBD(const MATH::GCAPSULED _capsule, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestCapsuleToOBBD(const MATH::GCAPSULED _capsule, const MATH::GOBBD _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestAABBToAABBD(const MATH::GAABBCED _aabb1, const MATH::GAABBCED _aabb2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestAABBToOBBD(const MATH::GAABBCED _aabb, const MATH::GOBBD _obb, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TestOBBToOBBD(const MATH::GOBBD _obb1, const MATH::GOBBD _obb2, GCollisionCheck& _outResult) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectLineToTriangleD(const MATH::GLINED _line, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD* _outBarycentric, MATH::GVECTORD& _outDirection, double& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectLineToPlaneD(const MATH::GLINED _line, const MATH::GPLANED _plane, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectLineToSphereD(const MATH::GLINED _line, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectLineToCapsuleD(const MATH::GLINED _line, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectLineToAABBD(const MATH::GLINED _line, const MATH::GAABBMMD _aabb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectLineToOBBD(const MATH::GLINED _line, const MATH::GOBBD _obb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectRayToTriangleD(const MATH::GRAYD _ray, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD* _outBarycentric, double& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectRayToPlaneD(const MATH::GRAYD _ray, const MATH::GPLANED _plane, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectRayToSphereD(const MATH::GRAYD _ray, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectRayToCapsuleD(const MATH::GRAYD _ray, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectRayToAABBD(const MATH::GRAYD _ray, const MATH::GAABBMMD _aabb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectRayToOBBD(const MATH::GRAYD _ray, const MATH::GOBBD _obb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectSphereToSphereD(const MATH::GSPHERED _sphere1, const MATH::GSPHERED _sphere2, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectSphereToCapsuleD(const MATH::GSPHERED _sphere, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectSphereToAABBD(const MATH::GSPHERED _sphere, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectSphereToOBBD(const MATH::GSPHERED _sphere, const MATH::GOBBD _obb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectCapsuleToCapsuleD(const MATH::GCAPSULED _capsule1, const MATH::GCAPSULED _capsule2, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectCapsuleToAABBD(const MATH::GCAPSULED _capsule, const MATH::GAABBMMD _aabb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectCapsuleToOBBD(const MATH::GCAPSULED _capsule, const MATH::GOBBD _obb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IntersectAABBToAABBD(const MATH::GAABBCED _aabb1, const MATH::GAABBCED _aabb2, GCollisionCheck& _outResult, MATH::GAABBCED& _outContactAABB, MATH::GVECTORD& _outDirection, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToLineD(const MATH::GVECTORD _point, const MATH::GLINED _line, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToRayD(const MATH::GVECTORD _point, const MATH::GRAYD _ray, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToTriangleD(const MATH::GVECTORD _point, const MATH::GTRIANGLED _triangle, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToPlaneD(const MATH::GVECTORD _point, const MATH::GPLANED _plane, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToSphereD(const MATH::GVECTORD _point, const MATH::GSPHERED _sphere, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToCapsuleD(const MATH::GVECTORD _point, const MATH::GCAPSULED _capsule, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToAABBD(const MATH::GVECTORD _point, const MATH::GAABBMMD _aabb, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SqDistancePointToOBBD(const MATH::GVECTORD _point, const MATH::GOBBD _obb, double& _outDistance) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn BarycentricD(const MATH::GVECTORD _a, const MATH::GVECTORD _b, const MATH::GVECTORD _c, const MATH::GVECTORD _p, MATH::GVECTORD& _outBarycentric) { return GReturn::NO_IMPLEMENTATION; }
		};
	}
}

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GCollision.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are separated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_MATH) || defined(GATEWARE_DISABLE_GCOLLISION) || \
    (defined(GATEWARE_ENABLE_MATH) && !defined(GATEWARE_DISABLE_GCOLLISION) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	namespace GW
{
	namespace I
	{
		class GCollisionImplementation : public virtual GCollisionInterface,
			private GInterfaceImplementation
		{
		public:
			GReturn Create()
			{
				return GReturn::INTERFACE_UNSUPPORTED;
			}

			// float
			static GReturn ConvertAABBCEToAABBMMF(const MATH::GAABBCEF _aabbCE, MATH::GAABBMMF& _outAABBMM)
			{
				return GReturn::FAILURE;
			}

			static GReturn ConvertAABBMMToAABBCEF(const MATH::GAABBMMF _aabbMM, MATH::GAABBCEF& _outAABCE)
			{
				return GReturn::FAILURE;
			}

			static GReturn ComputePlaneF(const MATH::GVECTORF _planePositionA, const MATH::GVECTORF _planePositionB, const MATH::GVECTORF _planePositionC, MATH::GPLANEF& _outPlane)
			{
				return GReturn::FAILURE;
			}

			static GReturn IsTriangleF(const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToConvexPolygonF(const MATH::GVECTORF _queryPoint, const MATH::GVECTORF* _polygonPoints, const unsigned int _pointsCount, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToLineF(const MATH::GLINEF _line, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointsToLineFromLineF(const MATH::GLINEF _line1, const MATH::GLINEF _line2, MATH::GVECTORF& _outPoint1, MATH::GVECTORF& _outPoint2)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToRayF(const MATH::GRAYF _ray, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToTriangleF(const MATH::GTRIANGLEF _triangle, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToPlaneF(const MATH::GPLANEF _plane, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToSphereF(const MATH::GSPHEREF _sphere, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToCapsuleF(const MATH::GCAPSULEF _capsule, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToAABBF(const MATH::GAABBMMF _aabb, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToOBBF(const MATH::GOBBF _obb, const MATH::GVECTORF _queryPoint, MATH::GVECTORF& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ComputeSphereFromPointsF(const MATH::GVECTORF* _pointCloud, const unsigned int _pointsCount, MATH::GSPHEREF& _outSphere)
			{
				return GReturn::FAILURE;
			}

			static GReturn ComputeAABBFromPointsF(const MATH::GVECTORF* _pointCloud, const unsigned int _pointsCount, MATH::GAABBMMF& _outAABB)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToLineF(const MATH::GVECTORF _point, const MATH::GLINEF _line, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToRayF(const MATH::GVECTORF _point, const MATH::GRAYF _ray, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToTriangleF(const MATH::GVECTORF _point, const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult, MATH::GVECTORF* _outBarycentric)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToPlaneF(const MATH::GVECTORF _point, const MATH::GPLANEF _plane, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToSphereF(const MATH::GVECTORF _point, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToCapsuleF(const MATH::GVECTORF _point, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToAABBF(const MATH::GVECTORF _point, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToOBBF(const MATH::GVECTORF _point, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToLineF(const MATH::GLINEF _line1, const MATH::GLINEF _line2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToRayF(const MATH::GLINEF _line, const MATH::GRAYF _ray, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToTriangleF(const MATH::GLINEF _line, const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult, MATH::GVECTORF* _outBarycentric)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToPlaneF(const MATH::GLINEF _line, const MATH::GPLANEF _plane, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToSphereF(const MATH::GLINEF _line, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToCapsuleF(const MATH::GLINEF _line, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToAABBF(const MATH::GLINEF _line, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToOBBF(const MATH::GLINEF _line, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestRayToTriangleF(const MATH::GRAYF _ray, const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult, MATH::GVECTORF* _outBarycentric)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestRayToPlaneF(const MATH::GRAYF _ray, const MATH::GPLANEF _plane, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestRayToSphereF(const MATH::GRAYF _ray, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestRayToCapsuleF(const MATH::GRAYF _ray, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestRayToAABBF(const MATH::GRAYF _ray, const MATH::GAABBMMF _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestRayToOBBF(const MATH::GRAYF _ray, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestTriangleToTriangleF(const MATH::GTRIANGLEF _triangle1, const MATH::GTRIANGLEF _triangle2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestTriangleToPlaneF(const MATH::GTRIANGLEF _triangle, const MATH::GPLANEF _plane, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestTriangleToSphereF(const MATH::GTRIANGLEF _triangle, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestTriangleToCapsuleF(const MATH::GTRIANGLEF _triangle, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestTriangleToAABBF(const MATH::GTRIANGLEF _triangle, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestTriangleToOBBF(const MATH::GTRIANGLEF _triangle, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPlaneToPlaneF(const MATH::GPLANEF _plane1, const MATH::GPLANEF _plane2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPlaneToSphereF(const MATH::GPLANEF _plane, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPlaneToCapsuleF(const MATH::GPLANEF _plane, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPlaneToAABBF(const MATH::GPLANEF _plane, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPlaneToOBBF(const MATH::GPLANEF _plane, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestSphereToSphereF(const MATH::GSPHEREF _sphere1, const MATH::GSPHEREF _sphere2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestSphereToCapsuleF(const MATH::GSPHEREF _sphere, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestSphereToAABBF(const MATH::GSPHEREF _sphere, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestSphereToOBBF(const MATH::GSPHEREF _sphere, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestCapsuleToCapsuleF(const MATH::GCAPSULEF _capsule1, const MATH::GCAPSULEF _capsule2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestCapsuleToAABBF(const MATH::GCAPSULEF _capsule, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestCapsuleToOBBF(const MATH::GCAPSULEF _capsule, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestAABBToAABBF(const MATH::GAABBCEF _aabb1, const MATH::GAABBCEF _aabb2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestAABBToOBBF(const MATH::GAABBCEF _aabb, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestOBBToOBBF(const MATH::GOBBF _obb1, const MATH::GOBBF _obb2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectLineToTriangleF(const MATH::GLINEF _line, const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF* _outBarycentric, MATH::GVECTORF& _outDirection, float& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectLineToPlaneF(const MATH::GLINEF _line, const MATH::GPLANEF _plane, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection, float& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectLineToSphereF(const MATH::GLINEF _line, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection, float& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectLineToCapsuleF(const MATH::GLINEF _line, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection, float& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectLineToAABBF(const MATH::GLINEF _line, const MATH::GAABBMMF _aabb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection, float& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectLineToOBBF(const MATH::GLINEF _line, const MATH::GOBBF _obb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection, float& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectRayToTriangleF(const MATH::GRAYF _ray, const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, MATH::GVECTORF* _outBarycentric, float& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectRayToPlaneF(const MATH::GRAYF _ray, const MATH::GPLANEF _plane, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, float& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectRayToSphereF(const MATH::GRAYF _ray, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, float& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectRayToCapsuleF(const MATH::GRAYF _ray, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, float& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectRayToAABBF(const MATH::GRAYF _ray, const MATH::GAABBMMF _aabb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, float& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectRayToOBBF(const MATH::GRAYF _ray, const MATH::GOBBF _obb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint, float& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectSphereToSphereF(const MATH::GSPHEREF _sphere1, const MATH::GSPHEREF _sphere2, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectSphereToCapsuleF(const MATH::GSPHEREF _sphere, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectSphereToAABBF(const MATH::GSPHEREF _sphere, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectSphereToOBBF(const MATH::GSPHEREF _sphere, const MATH::GOBBF _obb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectCapsuleToCapsuleF(const MATH::GCAPSULEF _capsule1, const MATH::GCAPSULEF _capsule2, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectCapsuleToAABBF(const MATH::GCAPSULEF _capsule, const MATH::GAABBMMF _aabb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectCapsuleToOBBF(const MATH::GCAPSULEF _capsule, const MATH::GOBBF _obb, GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectAABBToAABBF(const MATH::GAABBCEF _aabb1, const MATH::GAABBCEF _aabb2, GCollisionCheck& _outResult, MATH::GAABBCEF& _outContactAABB, MATH::GVECTORF& _outDirection, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToLineF(const MATH::GVECTORF _point, const MATH::GLINEF _line, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToRayF(const MATH::GVECTORF _point, const MATH::GRAYF _ray, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToTriangleF(const MATH::GVECTORF _point, const MATH::GTRIANGLEF _triangle, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToPlaneF(const MATH::GVECTORF _point, const MATH::GPLANEF _plane, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToSphereF(const MATH::GVECTORF _point, const MATH::GSPHEREF _sphere, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToCapsuleF(const MATH::GVECTORF _point, const MATH::GCAPSULEF _capsule, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToAABBF(const MATH::GVECTORF _point, const MATH::GAABBMMF _aabb, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToOBBF(const MATH::GVECTORF _point, const MATH::GOBBF _obb, float& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn BarycentricF(const MATH::GVECTORF _a, const MATH::GVECTORF _b, const MATH::GVECTORF _c, const MATH::GVECTORF _p, MATH::GVECTORF& _outBarycentric)
			{
				return GReturn::FAILURE;
			}

			//double

			static GReturn ConvertAABBCEToAABBMMD(const MATH::GAABBCED _aabbCE, MATH::GAABBMMD& _outAABBMM)
			{
				return GReturn::FAILURE;
			}

			static GReturn ConvertAABBMMToAABBCED(const MATH::GAABBMMD _aabbMM, MATH::GAABBCED& _outAABCE)
			{
				return GReturn::FAILURE;
			}

			static GReturn ComputePlaneD(const MATH::GVECTORD _planePositionA, const MATH::GVECTORD _planePositionB, const MATH::GVECTORD _planePositionC, MATH::GPLANED& _outPlane)
			{
				return GReturn::FAILURE;
			}

			static GReturn IsTriangleD(const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToConvexPolygonD(const MATH::GVECTORD _queryPoint, const MATH::GVECTORD* _polygonPoints, const unsigned int _pointsCount, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToLineD(const MATH::GLINED _line, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointsToLineFromLineD(const MATH::GLINED _line1, const MATH::GLINED _line2, MATH::GVECTORD& _outPoint1, MATH::GVECTORD& _outPoint2)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToRayD(const MATH::GRAYD _ray, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToTriangleD(const MATH::GTRIANGLED _triangle, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToPlaneD(const MATH::GPLANED _plane, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToSphereD(const MATH::GSPHERED _sphere, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToCapsuleD(const MATH::GCAPSULED _capsule, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToAABBD(const MATH::GAABBMMD _aabb, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ClosestPointToOBBD(const MATH::GOBBD _obb, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				return GReturn::FAILURE;
			}

			static GReturn ComputeSphereFromPointsD(const MATH::GVECTORD* _pointCloud, const unsigned int _pointsCount, MATH::GSPHERED& _outSphere)
			{
				return GReturn::FAILURE;
			}

			static GReturn ComputeAABBFromPointsD(const MATH::GVECTORD* _pointCloud, const unsigned int _pointsCount, MATH::GAABBMMD& _outAABB)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToLineD(const MATH::GVECTORD _point, const MATH::GLINED _line, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToRayD(const MATH::GVECTORD _point, const MATH::GRAYD _ray, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToTriangleD(const MATH::GVECTORD _point, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD* _outBarycentric)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToPlaneD(const MATH::GVECTORD _point, const MATH::GPLANED _plane, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToSphereD(const MATH::GVECTORD _point, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToCapsuleD(const MATH::GVECTORD _point, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToAABBD(const MATH::GVECTORD _point, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPointToOBBD(const MATH::GVECTORD _point, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToLineD(const MATH::GLINED _line1, const MATH::GLINED _line2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToRayD(const MATH::GLINED _line, const MATH::GRAYD _ray, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToTriangleD(const MATH::GLINED _line, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD* _outBarycentric)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToPlaneD(const MATH::GLINED _line, const MATH::GPLANED _plane, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToSphereD(const MATH::GLINED _line, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToCapsuleD(const MATH::GLINED _line, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToAABBD(const MATH::GLINED _line, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestLineToOBBD(const MATH::GLINED _line, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestRayToTriangleD(const MATH::GRAYD _ray, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD* _outBarycentric)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestRayToPlaneD(const MATH::GRAYD _ray, const MATH::GPLANED _plane, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestRayToSphereD(const MATH::GRAYD _ray, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestRayToCapsuleD(const MATH::GRAYD _ray, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestRayToAABBD(const MATH::GRAYD _ray, const MATH::GAABBMMD _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestRayToOBBD(const MATH::GRAYD _ray, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestTriangleToTriangleD(const MATH::GTRIANGLED _triangle1, const MATH::GTRIANGLED _triangle2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestTriangleToPlaneD(const MATH::GTRIANGLED _triangle, const MATH::GPLANED _plane, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestTriangleToSphereD(const MATH::GTRIANGLED _triangle, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestTriangleToCapsuleD(const MATH::GTRIANGLED _triangle, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestTriangleToAABBD(const MATH::GTRIANGLED _triangle, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestTriangleToOBBD(const MATH::GTRIANGLED _triangle, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPlaneToPlaneD(const MATH::GPLANED _plane1, const MATH::GPLANED _plane2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPlaneToSphereD(const MATH::GPLANED _plane, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPlaneToCapsuleD(const MATH::GPLANED _plane, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPlaneToAABBD(const MATH::GPLANED _plane, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestPlaneToOBBD(const MATH::GPLANED _plane, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestSphereToSphereD(const MATH::GSPHERED _sphere1, const MATH::GSPHERED _sphere2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestSphereToCapsuleD(const MATH::GSPHERED _sphere, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestSphereToAABBD(const MATH::GSPHERED _sphere, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestSphereToOBBD(const MATH::GSPHERED _sphere, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestCapsuleToCapsuleD(const MATH::GCAPSULED _capsule1, const MATH::GCAPSULED _capsule2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestCapsuleToAABBD(const MATH::GCAPSULED _capsule, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestCapsuleToOBBD(const MATH::GCAPSULED _capsule, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestAABBToAABBD(const MATH::GAABBCED _aabb1, const MATH::GAABBCED _aabb2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestAABBToOBBD(const MATH::GAABBCED _aabb, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn TestOBBToOBBD(const MATH::GOBBD _obb1, const MATH::GOBBD _obb2, GCollisionCheck& _outResult)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectLineToTriangleD(const MATH::GLINED _line, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD* _outBarycentric, MATH::GVECTORD& _outDirection, double& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectLineToPlaneD(const MATH::GLINED _line, const MATH::GPLANED _plane, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectLineToSphereD(const MATH::GLINED _line, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectLineToCapsuleD(const MATH::GLINED _line, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectLineToAABBD(const MATH::GLINED _line, const MATH::GAABBMMD _aabb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectLineToOBBD(const MATH::GLINED _line, const MATH::GOBBD _obb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectRayToTriangleD(const MATH::GRAYD _ray, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD* _outBarycentric, double& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectRayToPlaneD(const MATH::GRAYD _ray, const MATH::GPLANED _plane, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectRayToSphereD(const MATH::GRAYD _ray, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectRayToCapsuleD(const MATH::GRAYD _ray, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectRayToAABBD(const MATH::GRAYD _ray, const MATH::GAABBMMD _aabb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectRayToOBBD(const MATH::GRAYD _ray, const MATH::GOBBD _obb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectSphereToSphereD(const MATH::GSPHERED _sphere1, const MATH::GSPHERED _sphere2, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectSphereToCapsuleD(const MATH::GSPHERED _sphere, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectSphereToAABBD(const MATH::GSPHERED _sphere, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectSphereToOBBD(const MATH::GSPHERED _sphere, const MATH::GOBBD _obb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectCapsuleToCapsuleD(const MATH::GCAPSULED _capsule1, const MATH::GCAPSULED _capsule2, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectCapsuleToAABBD(const MATH::GCAPSULED _capsule, const MATH::GAABBMMD _aabb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectCapsuleToOBBD(const MATH::GCAPSULED _capsule, const MATH::GOBBD _obb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn IntersectAABBToAABBD(const MATH::GAABBCED _aabb1, const MATH::GAABBCED _aabb2, GCollisionCheck& _outResult, MATH::GAABBCED& _outContactAABB, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToLineD(const MATH::GVECTORD _point, const MATH::GLINED _line, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToRayD(const MATH::GVECTORD _point, const MATH::GRAYD _ray, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToTriangleD(const MATH::GVECTORD _point, const MATH::GTRIANGLED _triangle, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToPlaneD(const MATH::GVECTORD _point, const MATH::GPLANED _plane, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToSphereD(const MATH::GVECTORD _point, const MATH::GSPHERED _sphere, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToCapsuleD(const MATH::GVECTORD _point, const MATH::GCAPSULED _capsule, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToAABBD(const MATH::GVECTORD _point, const MATH::GAABBMMD _aabb, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn SqDistancePointToOBBD(const MATH::GVECTORD _point, const MATH::GOBBD _obb, double& _outDistance)
			{
				return GReturn::FAILURE;
			}

			static GReturn BarycentricD(const MATH::GVECTORD _a, const MATH::GVECTORD _b, const MATH::GVECTORD _c, const MATH::GVECTORD _p, MATH::GVECTORD& _outBarycentric)
			{
				return GReturn::FAILURE;
			}
		};
	}
}

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
	#include <cfloat>

namespace GW
{
	namespace I
	{
		class GCollisionImplementation : public virtual GCollisionInterface,
			private GInterfaceImplementation
		{
		public:
			GReturn Create()
			{
				return GReturn::SUCCESS;
			}

			static GReturn ConvertAABBCEToAABBMMF(const MATH::GAABBCEF _aabbCE, MATH::GAABBMMF& _outAABBMM)
			{
				_outAABBMM.min =
				{
					{
						{
							_aabbCE.center.x - _aabbCE.extent.x,
							_aabbCE.center.y - _aabbCE.extent.y,
							_aabbCE.center.z - _aabbCE.extent.z
						}
					}
				};

				_outAABBMM.max =
				{
					{
						{
							_aabbCE.center.x + _aabbCE.extent.x,
							_aabbCE.center.y + _aabbCE.extent.y,
							_aabbCE.center.z + _aabbCE.extent.z
						}
					}
				};

				return GReturn::SUCCESS;
			}

			static GReturn ConvertAABBMMToAABBCEF(const MATH::GAABBMMF _aabbMM, MATH::GAABBCEF& _outAABCE)
			{
				_outAABCE.center =
				{
					{
						{
							(_aabbMM.min.x + _aabbMM.max.x) * 0.5f,
							(_aabbMM.min.y + _aabbMM.max.y) * 0.5f,
							(_aabbMM.min.z + _aabbMM.max.z) * 0.5f
						}
					}
				};

				_outAABCE.extent =
				{
					{
						{
							_aabbMM.max.x - _outAABCE.center.x,
							_aabbMM.max.y - _outAABCE.center.y,
							_aabbMM.max.z - _outAABCE.center.z
						}
					}
				};

				return GReturn::SUCCESS;
			}

			static GReturn ComputePlaneF(const MATH::GVECTORF _planePositionA, const MATH::GVECTORF _planePositionB,
										 const MATH::GVECTORF _planePositionC, MATH::GPLANEF& _outPlane)
			{
				GW::MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					_planePositionB,
					_planePositionA,
					difference_ba);

				GW::MATH::GVECTORF difference_ca = {};
				GW::MATH::GVector::SubtractVectorF(
					_planePositionC,
					_planePositionA,
					difference_ca);

				GW::MATH::GVector::CrossVector3F(
					difference_ca,
					difference_ba,
					_outPlane.data);

				if(GW::MATH::GVector::NormalizeF(_outPlane.data, _outPlane.data) == GReturn::FAILURE)
				{
					 // ba and ca are parallel which degenerates to a line.
					return GReturn::FAILURE;
				}

				GW::MATH::GVector::DotF(
					_outPlane.data,
					_planePositionA.xyz(),
					_outPlane.distance);

				return GReturn::SUCCESS;
			}

			static GReturn IsTriangleF(const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult)
			{
				MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle.b,
					_triangle.a,
					difference_ba);

				MATH::GVECTORF difference_ca = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle.c,
					_triangle.a,
					difference_ca);

				MATH::GVECTORF triangle_normal = {};
				GW::MATH::GVector::CrossVector3F(
					difference_ba,
					difference_ca,
					triangle_normal);

				float triangle_area = 0.0f;
				GW::MATH::GVector::DotF(
					triangle_normal,
					triangle_normal,
					triangle_area);

				_outResult = (G_ABS(triangle_area) < 0.000001f) ? GCollisionCheck::NO_COLLISION : GCollisionCheck::COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToConvexPolygonF(const MATH::GVECTORF _queryPoint, const MATH::GVECTORF* _polygonPoints,
													 const unsigned int _pointsCount, GCollisionCheck& _outResult)
			{
				if(!_polygonPoints || _pointsCount < 3)
				{
					return GReturn::FAILURE;
				}

				auto Collinear = [&](const GW::MATH::GVECTORF p, const GW::MATH::GLINEF l)
				{
					if(p.x <= G_LARGER(l.start.x, l.end.x) && p.x <= G_SMALLER(l.start.x, l.end.x) &&
					   p.y <= G_LARGER(l.start.y, l.end.y) && p.y <= G_SMALLER(l.start.y, l.end.y))
					{
						return true;
					}

					return false;
				};

				auto Area2D = [&](const MATH::GVECTORF a, const MATH::GVECTORF b, const MATH::GVECTORF p)
				{
					float winding = 0;

					GW::MATH::GVECTORF difference_pa = {};
					GW::MATH::GVector::SubtractVectorF(
						p,
						a,
						difference_pa);

					GW::MATH::GVECTORF difference_ba = {};
					GW::MATH::GVector::SubtractVectorF(
						b,
						a,
						difference_ba);

					GW::MATH::GVector::CrossVector2F(
						difference_pa,
						difference_ba,
						winding);

					if(G_ABS(winding) < 0.000001f)
					{
						return 0;
					}
					else if(winding > 0.0f)
					{
						return 1;
					}
					else
					{
						return -1;
					}
				};

				auto IsCrossing = [&](const GW::MATH::GLINEF l1, const GW::MATH::GLINEF l2)
				{
					int winding1 = Area2D(l1.start, l1.end, l2.start);
					int winding2 = Area2D(l1.start, l1.end, l2.end);
					int winding3 = Area2D(l2.start, l2.end, l1.start);
					int winding4 = Area2D(l2.start, l2.end, l1.end);

					if(winding1 != winding2 && winding3 != winding4)
					{
						return true;
					}
					if(winding1 == 0 && Collinear(l2.start, l1))
					{
						return true;
					}
					if(winding2 == 0 && Collinear(l2.end, l1))
					{
						return true;
					}
					if(winding3 == 0 && Collinear(l1.start, l2))
					{
						return true;
					}
					if(winding4 == 0 && Collinear(l1.end, l2))
					{
						return true;
					}

					return false;
				};

				GW::MATH::GLINEF inf_line =
				{
					{
						{
							{{{_queryPoint.x , _queryPoint.y, 0.0f, 0.0f}}},
							{{{static_cast<float>(0xffffffff), _queryPoint.y}}}
						}
					}
				};

				int count = 0;
				int i = 0;

				do
				{
					GW::MATH::GLINEF side = {};
					side.start = _polygonPoints[i];
					side.end = _polygonPoints[(i + 1) % _pointsCount];

					if(IsCrossing(side, inf_line))
					{
						if(Area2D(side.start, _queryPoint, side.end) == 0)
						{
							_outResult = Collinear(_queryPoint, side) ? GCollisionCheck::COLLISION : GCollisionCheck::NO_COLLISION;
							return GReturn::SUCCESS;
						}
						count++;
					}

					i = (i + 1) % _pointsCount;
				}
				while(i != 0);

				_outResult = static_cast<GCollisionCheck>(count & 1);
				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToLineF(const MATH::GLINEF _line, const MATH::GVECTORF _queryPoint,
											   MATH::GVECTORF& _outPoint)
			{
				MATH::GVECTORF line_a = _line.start.xyz();

				MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					_line.end.xyz(),
					line_a,
					difference_ba);

				MATH::GVECTORF difference_pa = {};
				GW::MATH::GVector::SubtractVectorF(
					_queryPoint.xyz(),
					line_a,
					difference_pa);

				float interval = 0.0f;
				GW::MATH::GVector::DotF(
					difference_pa,
					difference_ba,
					interval);

				float sq_length = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					difference_ba,
					sq_length);

				// If line degenerates to point
				if(sq_length <= 0.000001f)
				{
					_outPoint = line_a;
					return GReturn::SUCCESS;
				}

				interval /= sq_length;

				interval = G_CLAMP(
					interval,
					0.0f,
					1.0f);

				GW::MATH::GVector::ScaleF(
					difference_ba,
					interval,
					_outPoint);

				GW::MATH::GVector::AddVectorF(
					line_a,
					_outPoint,
					_outPoint);

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointsToLineFromLineF(const MATH::GLINEF _line1, const MATH::GLINEF _line2,
														MATH::GVECTORF& _outPoint1, MATH::GVECTORF& _outPoint2)
			{
				MATH::GLINEF line1 =
				{
					{
						{
							_line1.start.xyz(),
							_line1.end.xyz()
						}
					}
				};

				MATH::GLINEF line2 =
				{
					{
						{
							_line2.start.xyz(),
							_line2.end.xyz()
						}
					}
				};

				MATH::GVECTORF direction1 = {};
				GW::MATH::GVector::SubtractVectorF(
					line1.end,
					line1.start,
					direction1);

				MATH::GVECTORF direction2 = {};
				GW::MATH::GVector::SubtractVectorF(
					line2.end,
					line2.start,
					direction2);

				MATH::GVECTORF distance = {};
				GW::MATH::GVector::SubtractVectorF(
					line1.start,
					line2.start,
					distance);

				float sq_length1 = 0.0f;
				GW::MATH::GVector::DotF(
					direction1,
					direction1,
					sq_length1);

				float sq_length2 = 0.0f;
				GW::MATH::GVector::DotF(
					direction2,
					direction2,
					sq_length2);

				float f = 0.0f;
				GW::MATH::GVector::DotF(
					direction2,
					distance,
					f);

				float interval1 = 0.0f;
				float interval2 = 0.0f;

				int use_cases = 0x00;

				// First line degenerates to a point.
				if(sq_length1 <= 0.000001f)
				{
					use_cases |= 0x01;
				}

				// Second line degenerates to a point.
				if(sq_length2 <= 0.000001f)
				{
					use_cases |= 0x02;
				}

				switch(use_cases)
				{
					// First line degenerates to a point.
					case 0x01:
					{
						interval2 = f / sq_length2;
						interval2 = G_CLAMP(
							interval2,
							0.0f,
							1.0f);
					}
					break;
					// Second line degenerates to a point.
					case 0x02:
					{
						float c = 0.0f;
						GW::MATH::GVector::DotF(
							direction1,
							distance,
							c);

						interval1 = G_CLAMP(
							-c / sq_length1,
							0.0f,
							1.0f);
					}
					break;
					// Both lines degenerate to a point.
					case 0x03:
					{
						_outPoint1 = line1.start.xyz();
						_outPoint2 = line2.start.xyz();
						return GReturn::SUCCESS;
					}
					break;
					default:
					{
						float c = 0.0f;
						GW::MATH::GVector::DotF(
							direction1,
							distance,
							c);

						float b = 0.0f;
						GW::MATH::GVector::DotF(
							direction1,
							direction2,
							b);

						float denom = sq_length1 * sq_length2 - b * b;

						// Get interval for the first line from the second line unless lines are parallel.
						if(denom != 0.0f)
						{
							interval1 = G_CLAMP(
								(b * f - c * sq_length2) / denom,
								0.0f,
								1.0f);
						}
						else
						{
							interval1 = 0.0f;
						}

						// Get interval for the second line.
						interval2 = (b * interval1 + f) / sq_length2;

						if(interval2 < 0.0f)
						{
							interval2 = 0.0f;

							interval1 = G_CLAMP(
								-c / sq_length1,
								0.0f,
								1.0f);
						}
						else if(interval2 > 1.0f)
						{
							interval2 = 1.0f;

							interval1 = G_CLAMP(
								(b - c) / sq_length1,
								0.0f,
								1.0f);
						}
					}
					break;
				}

				GW::MATH::GVector::ScaleF(
					direction1,
					interval1,
					direction1);

				GW::MATH::GVector::AddVectorF(
					line1.start,
					direction1,
					_outPoint1);

				GW::MATH::GVector::ScaleF(
					direction2,
					interval2,
					direction2);

				GW::MATH::GVector::AddVectorF(
					line2.start,
					direction2,
					_outPoint2);

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToRayF(const MATH::GRAYF _ray, const MATH::GVECTORF _queryPoint,
											  MATH::GVECTORF& _outPoint)
			{
				MATH::GVECTORF line_a = _ray.position.xyz();
				MATH::GVECTORF line_direction = _ray.direction.xyz();

				MATH::GVECTORF difference_pa = {};
				GW::MATH::GVector::SubtractVectorF(
					_queryPoint.xyz(),
					line_a,
					difference_pa);

				float interval = 0.0f;
				GW::MATH::GVector::DotF(
					difference_pa,
					line_direction,
					interval);

				float sq_length = 0.0f;
				GW::MATH::GVector::DotF(
					line_direction,
					line_direction,
					sq_length);

				// If line degenerates to point
				if(sq_length <= 0.000001f)
				{
					_outPoint = line_a;
					return GReturn::SUCCESS;
				}

				interval /= sq_length;

				interval = interval < 0.0f ? 0.0f : interval;

				GW::MATH::GVector::ScaleF(
					line_direction,
					interval,
					_outPoint);

				GW::MATH::GVector::AddVectorF(
					line_a,
					_outPoint,
					_outPoint);

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToTriangleF(const MATH::GTRIANGLEF _triangle, const MATH::GVECTORF _queryPoint,
												   MATH::GVECTORF& _outPoint)
			{
				GW::MATH::GVECTORF a = _triangle.a.xyz();
				GW::MATH::GVECTORF b = _triangle.b.xyz();
				GW::MATH::GVECTORF c = _triangle.c.xyz();
				GW::MATH::GVECTORF p = _queryPoint.xyz();

				MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					b,
					a,
					difference_ba);

				MATH::GVECTORF difference_ca = {};
				GW::MATH::GVector::SubtractVectorF(
					c,
					a,
					difference_ca);

				MATH::GVECTORF difference_pa = {};
				GW::MATH::GVector::SubtractVectorF(
					p,
					a,
					difference_pa);

				float dot1 = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					difference_pa,
					dot1);

				float dot2 = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ca,
					difference_pa,
					dot2);

				// p is closest to vertex a
				if(dot1 <= 0.000001f && dot2 <= 0.000001f)
				{
					_outPoint = a;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORF difference_pb = {};
				GW::MATH::GVector::SubtractVectorF(
					p,
					b,
					difference_pb);

				float dot3 = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					difference_pb,
					dot3);

				float dot4 = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ca,
					difference_pb,
					dot4);

				// p is closest to vertex b
				if(dot3 >= 0.000001f && dot4 <= dot3)
				{
					_outPoint = b;
					return GReturn::SUCCESS;
				}

				float vc = dot1 * dot4 - dot3 * dot2;

				// p is closest to edge ab
				if(vc <= 0.000001f && dot1 >= 0.000001f && dot3 <= 0.000001f)
				{
					float interval = dot1 / (dot1 - dot3);

					GW::MATH::GVector::ScaleF(
						difference_ba,
						interval,
						_outPoint);

					GW::MATH::GVector::AddVectorF(
						a,
						_outPoint,
						_outPoint);

					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORF difference_pc = {};
				GW::MATH::GVector::SubtractVectorF(
					p,
					c,
					difference_pc);

				float dot5 = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ca,
					difference_pc,
					dot5);

				float dot6 = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					difference_pc,
					dot6);

				// p is closest to vertex c
				if(dot5 >= 0.000001f && dot6 <= dot5)
				{
					_outPoint = c;
					return GReturn::SUCCESS;
				}

				float vb = dot6 * dot2 - dot1 * dot5;
				// p is closest to edge ac
				if(vb <= 0.000001f && dot2 >= 0.000001f && dot5 <= 0.000001f)
				{
					float interval = dot2 / (dot2 - dot5);

					GW::MATH::GVector::ScaleF(
						difference_ca,
						interval,
						_outPoint);

					GW::MATH::GVector::AddVectorF(
						a,
						_outPoint,
						_outPoint);

					return GReturn::SUCCESS;
				}

				float va = dot3 * dot5 - dot6 * dot4;
				// p is closest to edge bc
				if(va <= 0.000001f && (dot4 - dot3) >= 0.000001f && (dot6 - dot5) >= 0.000001f)
				{
					float h = dot4 - dot3;
					float interval = h / (h + dot6 - dot5);

					GW::MATH::GVector::SubtractVectorF(
						c,
						b,
						_outPoint);

					GW::MATH::GVector::ScaleF(
						_outPoint,
						interval,
						_outPoint);

					GW::MATH::GVector::AddVectorF(
						b,
						_outPoint,
						_outPoint);

					return GReturn::SUCCESS;
				}

				// p is closest to some point on the face
				float denom = 1.0f / (va + vb + vc);
				float v = vb * denom;
				float w = vc * denom;

				GW::MATH::GVector::ScaleF(
					difference_ba,
					v,
					_outPoint);

				GW::MATH::GVECTORF acw = {};
				GW::MATH::GVector::ScaleF(
					difference_ca,
					w,
					acw);

				GW::MATH::GVector::AddVectorF(
					acw,
					_outPoint,
					_outPoint);

				GW::MATH::GVector::AddVectorF(
					a,
					_outPoint,
					_outPoint);

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToPlaneF(const MATH::GPLANEF _plane, const MATH::GVECTORF _queryPoint,
												MATH::GVECTORF& _outPoint)
			{
				MATH::GVECTORF plane_normal = _plane.data.xyz();
				MATH::GVECTORF query_point = _queryPoint.xyz();

				float interval = 0.0f;
				GW::MATH::GVector::DotF(
					plane_normal,
					query_point,
					interval);

				interval -= _plane.distance;

				GW::MATH::GVector::ScaleF(
					plane_normal,
					interval,
					_outPoint);

				GW::MATH::GVector::SubtractVectorF(
					query_point,
					_outPoint,
					_outPoint);

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToSphereF(const MATH::GSPHEREF _sphere, const MATH::GVECTORF _queryPoint,
												 MATH::GVECTORF& _outPoint)
			{
				GW::MATH::GVECTORF direction = {};
				GW::MATH::GVector::SubtractVectorF(
					_queryPoint,
					_sphere.data,
					direction);

				if(GW::MATH::GVector::NormalizeF(direction.xyz(), direction) == GReturn::FAILURE)
				{
					_outPoint = _queryPoint;
					return GReturn::FAILURE;
				}

				GW::MATH::GVector::ScaleF(
					direction,
					_sphere.radius,
					direction);

				GW::MATH::GVector::AddVectorF(
					_sphere.data.xyz(),
					direction,
					_outPoint);

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToCapsuleF(const MATH::GCAPSULEF _capsule, const MATH::GVECTORF _queryPoint,
												  MATH::GVECTORF& _outPoint)
			{
				ClosestPointToLineF(
					{{{_capsule.data[0].xyz(), _capsule.data[1].xyz()}}},
					_queryPoint,
					_outPoint);

				return ClosestPointToSphereF(
					{{{_outPoint.x, _outPoint.y, _outPoint.z, _capsule.radius}}},
					_queryPoint,
					_outPoint);
			}

			static GReturn ClosestPointToAABBF(const MATH::GAABBMMF _aabb, const MATH::GVECTORF _queryPoint,
											   MATH::GVECTORF& _outPoint)
			{
				for(int i = 0; i < 3; i++)
				{
					_outPoint.data[i] = _queryPoint.data[i];

					_outPoint.data[i] = G_LARGER(
						_outPoint.data[i],
						_aabb.min.data[i]);

					_outPoint.data[i] = G_SMALLER(
						_outPoint.data[i],
						_aabb.max.data[i]);
				}

				if(G_ABS(_queryPoint.x - _outPoint.x) < 0.000001f &&
				   G_ABS(_queryPoint.y - _outPoint.y) < 0.000001f &&
				   G_ABS(_queryPoint.z - _outPoint.z) < 0.000001f)
				{
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToOBBF(const MATH::GOBBF _obb, const MATH::GVECTORF _queryPoint,
											  MATH::GVECTORF& _outPoint)
			{
				float xx2 = 2.0f * _obb.rotation.x * _obb.rotation.x;
				float yy2 = 2.0f * _obb.rotation.y * _obb.rotation.y;
				float zz2 = 2.0f * _obb.rotation.z * _obb.rotation.z;
				float xy2 = 2.0f * _obb.rotation.x * _obb.rotation.y;
				float xz2 = 2.0f * _obb.rotation.x * _obb.rotation.z;
				float yz2 = 2.0f * _obb.rotation.y * _obb.rotation.z;
				float wx2 = 2.0f * _obb.rotation.w * _obb.rotation.x;
				float wy2 = 2.0f * _obb.rotation.w * _obb.rotation.y;
				float wz2 = 2.0f * _obb.rotation.w * _obb.rotation.z;

				MATH::GVECTORF obb_rotation[3] =
				{
					{{{1.0f - yy2 - zz2, xy2 - wz2, xz2 + wy2}}},
					{{{xy2 + wz2, 1.0f - xx2 - zz2, yz2 - wx2}}},
					{{{xz2 - wy2, yz2 + wx2, 1.0f - xx2 - yy2}}}
				};

				MATH::GVECTORF difference = {};
				GW::MATH::GVector::SubtractVectorF(
					_queryPoint.xyz(),
					_obb.data->xyz(),
					difference);

				_outPoint = _obb.center.xyz();

				MATH::GVECTORF world_coord = {};

				float distance = 0.0f;

				for(int i = 0; i < 3; i++)
				{
					// Project the difference to this axis
					GW::MATH::GVector::DotF(
						difference,
						obb_rotation[i],
						distance);

					// Clamp to boundary
					distance = G_SMALLER(
						distance,
						_obb.extent.data[i]);

					distance = G_LARGER(
						distance,
						-_obb.extent.data[i]);

					GW::MATH::GVector::ScaleF(
						obb_rotation[i],
						distance,
						world_coord);

					GW::MATH::GVector::AddVectorF(
						_outPoint,
						world_coord,
						_outPoint);
				}

				if(G_ABS(_queryPoint.x - _outPoint.x) < 0.000001f &&
				   G_ABS(_queryPoint.y - _outPoint.y) < 0.000001f &&
				   G_ABS(_queryPoint.z - _outPoint.z) < 0.000001f)
				{
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn ComputeSphereFromPointsF(const MATH::GVECTORF* _pointCloud, const unsigned int _pointsCount, MATH::GSPHEREF& _outSphere)
			{
				if(!_pointCloud || _pointsCount < 2)
				{
					return GReturn::FAILURE;
				}

				// Find a good almost bounding sphere
				unsigned int min_x = 0;
				unsigned int max_x = 0;
				unsigned int min_y = 0;
				unsigned int max_y = 0;
				unsigned int min_z = 0;
				unsigned int max_z = 0;

				for(unsigned int i = 1; i < _pointsCount; i++)
				{
					if(_pointCloud[i].x < _pointCloud[min_x].x)
					{
						min_x = i;
					}
					if(_pointCloud[i].x > _pointCloud[max_x].x)
					{
						max_x = i;
					}

					if(_pointCloud[i].y < _pointCloud[min_y].y)
					{
						min_y = i;
					}
					if(_pointCloud[i].y > _pointCloud[max_y].y)
					{
						max_y = i;
					}

					if(_pointCloud[i].z < _pointCloud[min_z].z)
					{
						min_z = i;
					}
					if(_pointCloud[i].z > _pointCloud[max_z].z)
					{
						max_z = i;
					}
				}

				GW::MATH::GVECTORF difference = {};
				GW::MATH::GVector::SubtractVectorF(
					_pointCloud[max_x],
					_pointCloud[min_x],
					difference);

				float sq_distance_x = 0.0f;
				GW::MATH::GVector::DotF(
					difference,
					difference,
					sq_distance_x);

				GW::MATH::GVector::SubtractVectorF(
					_pointCloud[max_y],
					_pointCloud[min_y],
					difference);

				float sq_distance_y = 0.0f;
				GW::MATH::GVector::DotF(
					difference,
					difference,
					sq_distance_y);

				GW::MATH::GVector::SubtractVectorF(
					_pointCloud[max_z],
					_pointCloud[min_z],
					difference);

				float sq_distance_z = 0.0f;
				GW::MATH::GVector::DotF(
					difference,
					difference,
					sq_distance_z);

				int min = min_x;
				int max = max_x;

				if((sq_distance_y > sq_distance_x) && (sq_distance_y > sq_distance_z))
				{
					min = min_y;
					max = max_y;
				}

				if((sq_distance_z > sq_distance_x) && (sq_distance_z > sq_distance_y))
				{
					min = min_z;
					max = max_z;
				}

				GW::MATH::GVector::AddVectorF(
					_pointCloud[min].xyz(),
					_pointCloud[max].xyz(),
					_outSphere.data);

				GW::MATH::GVector::ScaleF(
					_outSphere.data,
					0.5f,
					_outSphere.data);

				GW::MATH::GVector::SubtractVectorF(
					_pointCloud[max].xyz(),
					_outSphere.data,
					difference);

				GW::MATH::GVector::DotF(
					difference,
					difference,
					_outSphere.radius);

				_outSphere.radius = sqrtf(_outSphere.radius);

				// Improve the bound and include all points
				auto UpdateSphereBounds = [&](const MATH::GVECTORF p, MATH::GSPHEREF& outSphere)
				{
					GW::MATH::GVECTORF difference = {};
					GW::MATH::GVector::SubtractVectorF(
						p.xyz(),
						outSphere.data.xyz(),
						difference);

					float sq_distance = 0.0f;
					GW::MATH::GVector::DotF(
						difference,
						difference,
						sq_distance);

					if(sq_distance > outSphere.radius* outSphere.radius)
					{
						float distance = sqrtf(sq_distance);
						float radius = (outSphere.radius + distance) * 0.5f;
						float increase = (radius - outSphere.radius) / distance;

						GW::MATH::GVector::ScaleF(
							difference,
							increase,
							difference);

						GW::MATH::GVector::AddVectorF(
							outSphere.data,
							difference,
							outSphere.data);

						outSphere.radius = radius;
					}
				};

				for(unsigned int i = 0; i < _pointsCount; i++)
				{
					UpdateSphereBounds(
						_pointCloud[i],
						_outSphere);
				}

				return GReturn::SUCCESS;
			}

			static GReturn ComputeAABBFromPointsF(const MATH::GVECTORF* _pointCloud, const unsigned int _pointsCount,
												  MATH::GAABBMMF& _outAABB)
			{
				if(!_pointCloud || _pointsCount == 0)
				{
					return GReturn::FAILURE;
				}

				_outAABB.min = _pointCloud[0];
				_outAABB.max = _pointCloud[0];

				for(unsigned int i = 1; i < _pointsCount; i++)
				{
					if(_outAABB.min.x > _pointCloud[i].x)
					{
						_outAABB.min.x = _pointCloud[i].x;
					}
					if(_outAABB.max.x < _pointCloud[i].x)
					{
						_outAABB.max.x = _pointCloud[i].x;
					}

					if(_outAABB.min.y > _pointCloud[i].y)
					{
						_outAABB.min.y = _pointCloud[i].y;
					}
					if(_outAABB.max.y < _pointCloud[i].y)
					{
						_outAABB.max.y = _pointCloud[i].y;
					}

					if(_outAABB.min.z > _pointCloud[i].z)
					{
						_outAABB.min.z = _pointCloud[i].z;
					}
					if(_outAABB.max.z < _pointCloud[i].z)
					{
						_outAABB.max.z = _pointCloud[i].z;
					}
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToLineF(const MATH::GVECTORF _point, const MATH::GLINEF _line, GCollisionCheck& _outResult)
			{
				MATH::GVECTORF point = _point.xyz();

				MATH::GLINEF line =
				{
					{
						{
							_line.start.xyz(),
							_line.end.xyz()
						}
					}
				};

				GW::MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					line.end,
					line.start,
					difference_ba);

				float distance_ba = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					difference_ba,
					distance_ba);
				distance_ba = sqrtf(distance_ba);

				GW::MATH::GVECTORF difference_pa = {};
				GW::MATH::GVector::SubtractVectorF(
					point,
					line.start,
					difference_pa);

				float distance_pa = 0.0f;
				GW::MATH::GVector::DotF(
					difference_pa,
					difference_pa,
					distance_pa);
				distance_pa = sqrtf(distance_pa);

				GW::MATH::GVECTORF difference_bp = {};
				GW::MATH::GVector::SubtractVectorF(
					line.end,
					point,
					difference_bp);

				float distance_bp = 0.0f;
				GW::MATH::GVector::DotF(
					difference_bp,
					difference_bp,
					distance_bp);
				distance_bp = sqrtf(distance_bp);

				_outResult = (G_COMPARISON_STANDARD_F(distance_ba, distance_pa + distance_bp)) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToRayF(const MATH::GVECTORF _point, const MATH::GRAYF _ray, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF difference_pa = {};
				GW::MATH::GVector::SubtractVectorF(
					_point.xyz(),
					_ray.position.xyz(),
					difference_pa);

				// Point is ray position
				if(GW::MATH::GVector::NormalizeF(difference_pa, difference_pa) == GReturn::FAILURE)
				{
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_ABS(difference_pa.x - _ray.direction.x) < 0.000001f &&
				   G_ABS(difference_pa.y - _ray.direction.y) < 0.000001f &&
				   G_ABS(difference_pa.z - _ray.direction.z) < 0.000001f)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck::NO_COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToTriangleF(const MATH::GVECTORF _point, const MATH::GTRIANGLEF _triangle,
												GCollisionCheck& _outResult, MATH::GVECTORF* _outBarycentric)
			{
				MATH::GPLANEF plane = {};
				if(ComputePlaneF(_triangle.a, _triangle.b, _triangle.c, plane) == GReturn::FAILURE)
				{
					// Degenerate triangle.
					return GReturn::FAILURE;
				}

				TestPointToPlaneF(
					_point,
					plane,
					_outResult);

				if(static_cast<int>(_outResult) > 0)
				{
					MATH::GVECTORF barycentric = {};
					// Compute plane already handles fail case of degenerate triangle.
					BarycentricF(_triangle.a, _triangle.b, _triangle.c, _point, barycentric);

					_outResult = (barycentric.y >= 0.0f && barycentric.z >= 0.0f && (barycentric.y + barycentric.z) <= 1.0f) ?
						GCollisionCheck::COLLISION :
						GCollisionCheck::NO_COLLISION;

					if(_outBarycentric)
					{
						*_outBarycentric = barycentric;
					}
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToPlaneF(const MATH::GVECTORF _point, const MATH::GPLANEF _plane, GCollisionCheck& _outResult)
			{
				float distance = 0.0f;
				GW::MATH::GVector::DotF(
					_point.xyz(),
					_plane.data.xyz(),
					distance);
				distance = distance - _plane.distance;

				if(distance < -0.000001f)
				{
					_outResult = GCollisionCheck::BELOW;
				}
				else if(G_ABS(distance) <= 0.000001f)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck::ABOVE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToSphereF(const MATH::GVECTORF _point, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					_point,
					_sphere.data.xyz(),
					difference_ba);

				float sq_distance = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					difference_ba,
					sq_distance);

				float sq_radius = _sphere.radius * _sphere.radius;

				_outResult = sq_distance <= sq_radius ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToCapsuleF(const MATH::GVECTORF _point, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult)
			{
				GW::MATH::GSPHEREF sphere = {};

				if(ClosestPointToCapsuleF(_capsule, _point, sphere.data) == GReturn::FAILURE)
				{
					// Point is center of capsule
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				sphere.radius = _capsule.radius;
				return TestPointToSphereF(
					_point,
					sphere,
					_outResult);
			}

			static GReturn TestPointToAABBF(const MATH::GVECTORF _point, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult)
			{
				if(G_ABS(_aabb.center.x - _point.x) - _aabb.extent.x > 0.000001f ||
				   G_ABS(_aabb.center.y - _point.y) - _aabb.extent.y > 0.000001f ||
				   G_ABS(_aabb.center.z - _point.z) - _aabb.extent.z > 0.000001f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck::COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToOBBF(const MATH::GVECTORF _point, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF closest_point = {};

				ClosestPointToOBBF(
					_obb,
					_point,
					closest_point);

				if(G_ABS(closest_point.x - _point.x) > 0.000001f ||
				   G_ABS(closest_point.y - _point.y) > 0.000001f ||
				   G_ABS(closest_point.z - _point.z) > 0.000001f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck::COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToLineF(const MATH::GLINEF _line1, const MATH::GLINEF _line2, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF closest_point1 = {};
				GW::MATH::GVECTORF closest_point2 = {};

				ClosestPointsToLineFromLineF(
					_line1,
					_line2,
					closest_point1,
					closest_point2);

				if(G_ABS(closest_point1.x - closest_point2.x) > 0.000001f ||
				   G_ABS(closest_point1.y - closest_point2.y) > 0.000001f ||
				   G_ABS(closest_point1.z - closest_point2.z) > 0.000001f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck::COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToRayF(const MATH::GLINEF _line, const MATH::GRAYF _ray, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF closest_point1 = {};
				ClosestPointToRayF(
					_ray,
					_line.start,
					closest_point1);

				GW::MATH::GVECTORF closest_point2 = {};
				ClosestPointToRayF(
					_ray,
					_line.end,
					closest_point2);

				return TestLineToLineF(
					_line,
					{{{closest_point1, closest_point2}}},
					_outResult);
			}

			static GReturn TestLineToTriangleF(const MATH::GLINEF _line, const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult,
											   MATH::GVECTORF* _outBarycentric)
			{
				MATH::GLINEF line =
				{
					{
						{
							_line.start.xyz(),
							_line.end.xyz()
						}
					}
				};

				MATH::GTRIANGLEF triangle =
				{
					{
						{
							_triangle.a.xyz(),
							_triangle.b.xyz(),
							_triangle.c.xyz()
						}
					}
				};

				GW::MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					triangle.b,
					triangle.a,
					difference_ba);

				GW::MATH::GVECTORF difference_ca = {};
				GW::MATH::GVector::SubtractVectorF(
					triangle.c,
					triangle.a,
					difference_ca);

				GW::MATH::GVECTORF norm = {};
				GW::MATH::GVector::CrossVector3F(
					difference_ca,
					difference_ba,
					norm);

				GW::MATH::GVECTORF difference_line = {};
				GW::MATH::GVector::SubtractVectorF(
					line.start,
					line.end,
					difference_line);

				float dot = 0.0f;
				GW::MATH::GVector::DotF(
					difference_line,
					norm,
					dot);

				// Segment is parallel to triangle
				if(dot <= 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORF difference_pa = {};
				GW::MATH::GVector::SubtractVectorF(
					line.start,
					triangle.a,
					difference_pa);

				float interval = 0.0f;
				GW::MATH::GVector::DotF(
					difference_pa,
					norm,
					interval);

				if(interval < 0.0f || interval > dot)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORF cross = {};
				GW::MATH::GVector::CrossVector3F(
					difference_line,
					difference_pa,
					cross);

				// Test to see if within bounds of barycentric coordinates.
				GW::MATH::GVECTORF barycentric = {};
				GW::MATH::GVector::DotF(
					difference_ca,
					cross,
					barycentric.y);
				barycentric.y = -barycentric.y;

				if(barycentric.y < 0.0f || barycentric.y > dot)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVector::DotF(
					difference_ba,
					cross,
					barycentric.z);

				if(barycentric.z < 0.0f || barycentric.y + barycentric.z > dot)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(_outBarycentric)
				{
					float over_denom = 1.0f / dot;

					barycentric.y *= over_denom;
					barycentric.z *= over_denom;

					*_outBarycentric =
					{
						{
							{
								1.0f - barycentric.y - barycentric.z,
								barycentric.y,
								barycentric.z
							}
						}
					};
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestLineToPlaneF(const MATH::GLINEF _line, const MATH::GPLANEF _plane, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					_line.end.xyz(),
					_line.start.xyz(),
					difference_ba);

				float denom = 0.0f;
				GW::MATH::GVector::DotF(
					_plane.data.xyz(),
					difference_ba,
					denom);

				float num = 0.0f;
				GW::MATH::GVector::DotF(
					_plane.data.xyz(),
					_line.start.xyz(),
					num);

				if(G_ABS(denom) < 0.000001f)
				{
					// Coplanar
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				float interval = (_plane.distance - num) / denom;

				if(interval >= 0.0f && interval <= 1.0f)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					// Half plane test
					num -= _plane.distance;
					_outResult = (num < 0.0f) ?
						_outResult = GCollisionCheck::BELOW :
						_outResult = GCollisionCheck::ABOVE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToSphereF(const MATH::GLINEF _line, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF closest_point = {};
				ClosestPointToLineF(
					_line,
					_sphere.data,
					closest_point);

				return TestPointToSphereF(
					closest_point,
					_sphere,
					_outResult);
			}

			static GReturn TestLineToCapsuleF(const MATH::GLINEF _line, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF closest_point1 = {};
				GW::MATH::GVECTORF closest_point2 = {};
				ClosestPointsToLineFromLineF(
					_line,
					{{{_capsule.data[0],_capsule.data[1]}}},
					closest_point1,
					closest_point2);

				return TestPointToSphereF(
					closest_point1,
					{{{closest_point2.x,closest_point2.y,closest_point2.z,_capsule.radius}}},
					_outResult);
			}

			static GReturn TestLineToAABBF(const MATH::GLINEF _line, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult)
			{
				MATH::GLINEF line =
				{
					{
						{
							_line.start.xyz(),
							_line.end.xyz()
						}
					}
				};

				GW::MATH::GVECTORF extent = _aabb.extent.xyz();

				GW::MATH::GVECTORF line_midpoint = {};
				GW::MATH::GVector::AddVectorF(
					line.start,
					line.end,
					line_midpoint);

				GW::MATH::GVector::ScaleF(
					line_midpoint,
					0.5f,
					line_midpoint);

				GW::MATH::GVECTORF line_mid_length = {};
				GW::MATH::GVector::SubtractVectorF(
					line.end,
					line_midpoint,
					line_mid_length);

				// Translate box and line to origin
				GW::MATH::GVECTORF origin = {};
				GW::MATH::GVector::SubtractVectorF(
					line_midpoint,
					_aabb.center.xyz(),
					origin);

				GW::MATH::GVECTORF axis =
				{
					{
						{
							G_ABS(line_mid_length.x),
							G_ABS(line_mid_length.y),
							G_ABS(line_mid_length.z)
						}
					}
				};

				// Separating axes
				for(int i = 0; i < 3; i++)
				{
					if(G_ABS(origin.data[i]) > extent.data[i] + axis.data[i])
					{
						_outResult = GCollisionCheck::NO_COLLISION;
						return GReturn::SUCCESS;
					}
				}

				axis.x += 0.000001f;
				axis.y += 0.000001f;
				axis.z += 0.000001f;

				if(G_ABS(origin.y * line_mid_length.z - origin.z * line_mid_length.y) >
				   extent.y* axis.z + extent.z * axis.y)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_ABS(origin.z * line_mid_length.x - origin.x * line_mid_length.z) >
				   extent.x* axis.z + extent.z * axis.x)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_ABS(origin.x * line_mid_length.z - origin.y * line_mid_length.x) >
				   extent.x* axis.y + extent.z * axis.x)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestLineToOBBF(const MATH::GLINEF _line, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				MATH::GLINEF line =
				{
					{
						{
							_line.start,
							_line.end
						}
					}
				};
				line.start.w = 1.0f;
				line.end.w = 1.0f;

				MATH::GMATRIXF obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionF(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXF obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0f}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0f}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0f}}},
							{{{0.0f, 0.0f, 0.0f, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					line.start,
					line.start);
				GW::MATH::GVector::AddVectorF(
					line.start,
					_obb.center,
					line.start);

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					line.end,
					line.end);
				GW::MATH::GVector::AddVectorF(
					line.end,
					_obb.center,
					line.end);

				return TestLineToAABBF(
					line,
					{{{_obb.center, _obb.extent}}},
					_outResult);
			}

			static GReturn TestRayToTriangleF(const MATH::GRAYF _ray, const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult,
											  MATH::GVECTORF* _outBarycentric)
			{
				MATH::GRAYF ray =
				{
					{
						{
						_ray.position.xyz(),
							_ray.direction.xyz()
						}
					}
				};

				MATH::GTRIANGLEF triangle =
				{
					{
						{
							_triangle.a.xyz(),
							_triangle.b.xyz(),
							_triangle.c.xyz()
						}
					}
				};

				GW::MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					triangle.b,
					triangle.a,
					difference_ba);

				GW::MATH::GVECTORF difference_ca = {};
				GW::MATH::GVector::SubtractVectorF(
					triangle.c,
					triangle.a,
					difference_ca);

				GW::MATH::GVECTORF q = {};
				GW::MATH::GVector::CrossVector3F(
					ray.direction,
					difference_ca,
					q);

				float det = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					q,
					det);

				// Ray is parallel to or points away from triangle
				if(G_ABS(det) < 0.000001f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				float denom = 1.0f / det;

				GW::MATH::GVECTORF s = {};
				GW::MATH::GVector::SubtractVectorF(
					ray.position,
					triangle.a,
					s);

				GW::MATH::GVECTORF barycentric = {};
				GW::MATH::GVector::DotF(
					s,
					q,
					barycentric.y);
				barycentric.y *= denom;

				if(barycentric.y < 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORF r = {};
				GW::MATH::GVector::CrossVector3F(
					s,
					difference_ba,
					r);

				GW::MATH::GVector::DotF(
					ray.direction,
					r,
					barycentric.z);
				barycentric.z *= denom;

				if(barycentric.z < 0.0f || barycentric.y + barycentric.z > 1.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(_outBarycentric)
				{
					*_outBarycentric = barycentric;
					_outBarycentric->x = 1.0f - barycentric.y - barycentric.z;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestRayToPlaneF(const MATH::GRAYF _ray, const MATH::GPLANEF _plane, GCollisionCheck& _outResult)
			{
				float denom = 0.0f;
				GW::MATH::GVector::DotF(
					_plane.data.xyz(),
					_ray.direction.xyz(),
					denom);

				if(G_ABS(denom) < 0.000001f)
				{
					// Ray is parallel
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				float num = 0.0f;
				GW::MATH::GVector::DotF(
					_plane.data.xyz(),
					_ray.position.xyz(),
					num);

				float interval = (_plane.distance - num) / denom;
				if(interval >= 0.0f)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					// Half plane test
					num -= _plane.distance;
					_outResult = (num < 0.0f) ?
						_outResult = GCollisionCheck::BELOW :
						_outResult = GCollisionCheck::ABOVE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestRayToSphereF(const MATH::GRAYF _ray, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult)
			{
				MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					_ray.position.xyz(),
					_sphere.data.xyz(),
					difference_ba);

				float c = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					difference_ba,
					c);
				c -= _sphere.radius * _sphere.radius;

				// At least one real root.
				if(c <= 0.0f)
				{
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				float b = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					_ray.direction.xyz(),
					b);

				// Ray is outside sphere and pointing away from it.
				if(b > 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// The discriminant determines if there were solutions or not.
				float discriminant = b * b - c;
				_outResult = (discriminant < 0.0f) ?
					GCollisionCheck::NO_COLLISION :
					GCollisionCheck::COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestRayToCapsuleF(const MATH::GRAYF _ray, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF closest_point1 = {};
				ClosestPointToRayF(
					_ray,
					_capsule.data[0],
					closest_point1);

				GW::MATH::GSPHEREF sphere = {};
				ClosestPointToRayF(
					_ray,
					_capsule.data[1],
					sphere.data);

				ClosestPointsToLineFromLineF(
					{{{closest_point1, sphere.data}}},
					{{{_capsule.data[0], _capsule.data[1]}}},
					closest_point1,
					sphere.data);

				sphere.radius = _capsule.radius;

				return TestPointToSphereF(
					closest_point1,
					sphere,
					_outResult);
			}

			static GReturn TestRayToAABBF(const MATH::GRAYF _ray, const MATH::GAABBMMF _aabb, GCollisionCheck& _outResult)
			{
				float interval1 = 0.0f;
				float interval2 = 0.0f;
				float interval3 = 0.0f;
				float interval4 = 0.0f;
				float interval5 = 0.0f;
				float interval6 = 0.0f;

				if(_ray.direction.x)
				{
					interval1 = (_aabb.min.x - _ray.position.x) / _ray.direction.x;
					interval2 = (_aabb.max.x - _ray.position.x) / _ray.direction.x;
				}
				else
				{
					interval1 = (_aabb.min.x - _ray.position.x) > 0.0f ?
						(FLT_MAX) : (FLT_MIN);
					interval2 = (_aabb.max.x - _ray.position.x) > 0.0f ?
						(FLT_MAX) : (FLT_MIN);
				}

				if(_ray.direction.y)
				{
					interval3 = (_aabb.min.y - _ray.position.y) / _ray.direction.y;
					interval4 = (_aabb.max.y - _ray.position.y) / _ray.direction.y;
				}
				else
				{
					interval3 = (_aabb.min.y - _ray.position.y) > 0.0f ?
						FLT_MAX : FLT_MIN;
					interval4 = (_aabb.max.y - _ray.position.y) > 0.0f ?
						FLT_MAX : FLT_MIN;
				}

				if(_ray.direction.z)
				{
					interval5 = (_aabb.min.z - _ray.position.z) / _ray.direction.z;
					interval6 = (_aabb.max.z - _ray.position.z) / _ray.direction.z;
				}
				else
				{
					interval5 = (_aabb.min.z - _ray.position.z) > 0.0f ?
						FLT_MAX : FLT_MIN;
					interval6 = (_aabb.max.z - _ray.position.z) > 0.0f ?
						FLT_MAX : FLT_MIN;
				}

				float interval_min = G_LARGER(G_LARGER(
					G_SMALLER(interval1, interval2),
					G_SMALLER(interval3, interval4)),
					G_SMALLER(interval5, interval6));

				float interval_max = G_SMALLER(G_SMALLER(
					G_LARGER(interval1, interval2),
					G_LARGER(interval3, interval4)),
					G_LARGER(interval5, interval6));

				if(interval_max < 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(interval_max < interval_min)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestRayToOBBF(const MATH::GRAYF _ray, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				MATH::GMATRIXF obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionF(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXF obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0f}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0f}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0f}}},
							{{{0.0f, 0.0f, 0.0f, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				MATH::GRAYF ray =
				{
					{
						{
							_ray.position,
							_ray.direction.xyz()
						}
					}
				};
				ray.position.w = 1.0f;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					_ray.position,
					ray.position);
				GW::MATH::GVector::AddVectorF(
					ray.position,
					_obb.center,
					ray.position);

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					_ray.direction,
					ray.direction);
				GW::MATH::GVector::NormalizeF(
					ray.direction,
					ray.direction);

				MATH::GAABBMMF mm = {};
				ConvertAABBCEToAABBMMF(
					{{{_obb.center, _obb.extent}}},
					mm);

				return TestRayToAABBF(
					ray,
					mm,
					_outResult);
			}

			static GReturn TestTriangleToTriangleF(const MATH::GTRIANGLEF _triangle1, const MATH::GTRIANGLEF _triangle2,
												   GCollisionCheck& _outResult)
			{
				// Half plane test if triangle1 lies completely on one side to triangle2 plane
				GW::MATH::GVECTORF difference_b2a2 = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle2.b.xyz(),
					_triangle2.a.xyz(),
					difference_b2a2);

				GW::MATH::GVECTORF difference_c2a2 = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle2.c.xyz(),
					_triangle2.a.xyz(),
					difference_c2a2);

				GW::MATH::GVECTORF plane2 = {};
				GW::MATH::GVector::CrossVector3F(
					difference_c2a2,
					difference_b2a2,
					plane2);

				GW::MATH::GVECTORF difference_a1a2 = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle1.a.xyz(),
					_triangle2.a.xyz(),
					difference_a1a2);

				GW::MATH::GVECTORF det1 = {};
				GW::MATH::GVector::DotF(
					difference_a1a2,
					plane2,
					det1.x);

				GW::MATH::GVECTORF difference_b1a2 = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle1.b.xyz(),
					_triangle2.a.xyz(),
					difference_b1a2);

				GW::MATH::GVector::DotF(
					difference_b1a2,
					plane2,
					det1.y);

				GW::MATH::GVECTORF difference_c1a2 = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle1.c.xyz(),
					_triangle2.a.xyz(),
					difference_c1a2);

				GW::MATH::GVector::DotF(
					difference_c1a2,
					plane2,
					det1.z);

				if(((det1.x * det1.y) > 0.0f) && ((det1.x * det1.z) > 0.0f))
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Half plane test if triangle2 lies completely on one side to triangle1 plane
				GW::MATH::GVECTORF difference_b1a1 = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle1.b.xyz(),
					_triangle1.a.xyz(),
					difference_b1a1);

				GW::MATH::GVECTORF difference_c1a1 = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle1.c.xyz(),
					_triangle1.a.xyz(),
					difference_c1a1);

				GW::MATH::GVECTORF plane1 = {};
				GW::MATH::GVector::CrossVector3F(
					difference_c1a1,
					difference_b1a1,
					plane1);

				GW::MATH::GVECTORF difference_a2a1 = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle2.a.xyz(),
					_triangle1.a.xyz(),
					difference_a2a1);

				GW::MATH::GVECTORF det2 = {};
				GW::MATH::GVector::DotF(
					difference_a2a1,
					plane1,
					det2.x);

				GW::MATH::GVECTORF difference_b2a1 = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle2.b.xyz(),
					_triangle1.a.xyz(),
					difference_b2a1);

				GW::MATH::GVector::DotF(
					difference_b2a1,
					plane1,
					det2.y);

				GW::MATH::GVECTORF difference_c2a1 = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle2.c.xyz(),
					_triangle1.a.xyz(),
					difference_c2a1);

				GW::MATH::GVector::DotF(
					difference_c2a1,
					plane1,
					det2.z);

				if(((det2.x * det2.y) > 0.0f) && ((det2.x * det2.z) > 0.0f))
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Bring both triangles into canonical form
				MATH::GTRIANGLEF triangle1 = {};
				MATH::GTRIANGLEF triangle2 = {};

				if(det1.x > 0.0f)
				{
					if(det1.y > 0.0f)
					{
						triangle1 =
						{
							{
								{
									_triangle1.c,
									_triangle1.a,
									_triangle1.b
								}
							}
						};

						triangle2 =
						{
							{
								{
									_triangle2.a,
									_triangle2.c,
							_triangle2.b
								}
							}
						};
					}
					else if(det1.z > 0.0f)
					{
						triangle1 =
						{
							{
								{
									_triangle1.b,
									_triangle1.c,
									_triangle1.a
								}
							}
						};

						triangle2 =
						{
							{
								{
									_triangle2.a,
									_triangle2.c,
									_triangle2.b
								}
							}
						};
					}
					else
					{
						triangle1 =
						{
							{
								{
									_triangle1.a,
									_triangle1.b,
									_triangle1.c
								}
							}
						};

						triangle2 =
						{
							{
								{
									_triangle2.a,
									_triangle2.b,
									_triangle2.c
								}
							}
						};
					}
				}
				else if(det1.x < 0.0f)
				{
					if(det1.y < 0.0f)
					{
						triangle1 =
						{
							{
								{
									_triangle1.c,
									_triangle1.a,
									_triangle1.b
								}
							}
						};

						triangle2 =
						{
							{
								{
									_triangle2.a,
									_triangle2.b,
									_triangle2.c
								}
							}
						};
					}
					else if(det1.z < 0.0f)
					{
						triangle1 =
						{
							{
								{
									_triangle1.b,
									_triangle1.c,
									_triangle1.a
								}
							}
						};

						triangle2 =
						{
							{
								{
									_triangle2.a,
									_triangle2.b,
									_triangle2.c
								}
							}
						};
					}
					else
					{
						triangle1 =
						{
							{
								{
									_triangle1.a,
									_triangle1.b,
									_triangle1.c
								}
							}
						};

						triangle2 =
						{
							{
								{
									_triangle2.a,
									_triangle2.c,
									_triangle2.b
								}
							}
						};
					}
				}
				else
				{
					if(det1.y < 0.0f)
					{
						if(det1.z >= 0.0f)
						{
							triangle1 =
							{
								{
									{
										_triangle1.b,
										_triangle1.c,
										_triangle1.a
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.c,
										_triangle2.b
									}
								}
							};
						}
						else
						{
							triangle1 =
							{
								{
									{
										_triangle1.a,
										_triangle1.b,
										_triangle1.c
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.b,
										_triangle2.c
									}
								}
							};
						}
					}
					else if(det1.y > 0.0f)
					{
						if(det1.z > 0.0f)
						{
							triangle1 =
							{
								{
									{
										_triangle1.a,
										_triangle1.b,
										_triangle1.c
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.c,
										_triangle2.b
									}
								}
							};
						}
						else
						{
							triangle1 =
							{
								{
									{
										_triangle1.b,
										_triangle1.c,
										_triangle1.a
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.b,
										_triangle2.c
									}
								}
							};
						}
					}
					else
					{
						if(det1.z > 0.0f)
						{
							triangle1 =
							{
								{
									{
										_triangle1.c,
										_triangle1.a,
										_triangle1.b
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.b,
										_triangle2.c
									}
								}
							};
						}
						else if(det1.z < 0.0f)
						{
							triangle1 =
							{
								{
									{
										_triangle1.c,
										_triangle1.a,
										_triangle1.b
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.c,
										_triangle2.b
									}
								}
							};
						}
						else
						{
							triangle1 =
							{
								{
									{
										_triangle1.a,
										_triangle1.b,
										_triangle1.c
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.b,
										_triangle2.c
									}
								}
							};

							// return coplanar result
							auto Orient2D = [](const float* a, const float* b, const float* c)
							{
								return ((a[0] - c[0]) * (b[1] - c[1]) - (a[1] - c[1]) * (b[0] - c[0]));
							};

							auto TestVertex2D = [&](
								const float* a1, const float* b1, const float* c1,
								const float* a2, const float* b2, const float* c2)
							{
								if(Orient2D(c2, a2, b1) >= 0.0f)
								{
									if(Orient2D(c2, b2, b1) <= 0.0f)
									{
										if(Orient2D(a1, a2, b1) > 0.0f)
										{
											return (Orient2D(a1, b2, b1) <= 0.0f) ? 1 : 0;
										}
										else
										{
											if(Orient2D(a1, a2, c1) >= 0.0f)
											{
												return (Orient2D(b1, c1, a2) >= 0.0f) ? 1 : 0;
											}
											else return 0;
										}
									}
									else
									{
										if(Orient2D(a1, b2, b1) <= 0.0f)
										{
											if(Orient2D(c2, b2, c1) <= 0.0f)
											{
												return (Orient2D(b1, c1, b2) >= 0.0f) ? 1 : 0;
											}
											else return 0;
										}
										else return 0;
									}
								}
								else
								{
									if(Orient2D(c2, a2, c1) >= 0.0f)
									{
										if(Orient2D(b1, c1, c2) >= 0.0f)
										{
											return (Orient2D(a1, a2, c1) >= 0.0f) ? 1 : 0;
										}
										else
										{
											if(Orient2D(b1, c1, b2) >= 0.0f)
											{
												return (Orient2D(c2, c1, b2) >= 0.0f) ? 1 : 0;
											}
											else return 0;
										}
									}
									else  return 0;
								}
							};

							auto TestEdge2D = [&](
								const float* a1, const float* b1, const float* c1,
								const float* a2, const float* b2, const float* c2)
							{
								if(Orient2D(c2, a2, b1) >= 0.0f)
								{
									if(Orient2D(a1, a2, b1) >= 0.0f)
									{
										return (Orient2D(a1, b1, c2) >= 0.0f) ? 1 : 0;
									}
									else
									{
										if(Orient2D(b1, c1, a2) >= 0.0f)
										{
											return (Orient2D(c1, a1, a2) >= 0.0f) ? 1 : 0;
										}
										else return 0;
									}
								}
								else
								{
									if(Orient2D(c2, a2, c1) >= 0.0f)
									{
										if(Orient2D(a1, a2, c1) >= 0.0f)
										{
											if(Orient2D(a1, c1, c2) >= 0.0f) return 1;
											else
											{
												return (Orient2D(b1, c1, c2) >= 0.0f) ? 1 : 0;
											}
										}
										else  return 0;
									}
									else return 0;
								}
							};

							auto TestTriangles2D = [&](
								const float* a1, const float* b1, const float* c1,
								const float* a2, const float* b2, const float* c2)
							{
								if(Orient2D(a2, b2, a1) >= 0.0f)
								{
									if(Orient2D(b2, c2, a1) >= 0.0f)
									{
										if(Orient2D(c2, a2, a1) >= 0.0f)
										{
											return 1;
										}
										else
										{
											return TestEdge2D(
												a1, b1, c1,
												a2, b2, c2);
										}
									}
									else
									{
										if(Orient2D(c2, a2, a1) >= 0.0f)
										{
											return TestEdge2D(
												a1, b1, c1,
												c2, a2, b2);
										}
										else
										{
											return TestVertex2D(
												a1, b1, c1,
												a2, b2, c2);
										}
									}
								}
								else
								{
									if(Orient2D(b2, c2, a1) >= 0.0f)
									{
										if(Orient2D(c2, a2, a1) >= 0.0f)
										{
											return TestEdge2D(
												a1, b1, c1,
												b2, c2, a2);
										}
										else
										{
											return TestVertex2D(
												a1, b1, c1,
												b2, c2, a2);
										}
									}
									else
									{
										return TestVertex2D(
											a1, b1, c1,
											c2, a2, b2);
									}
								}
							};

							GW::MATH::GVECTORF normal =
							{
								{
									{
										G_ABS(plane1.x),
										G_ABS(plane1.y),
										G_ABS(plane1.z)
									}
								}
							};

							GW::MATH::GTRIANGLEF tri2_1 = {};
							GW::MATH::GTRIANGLEF tri2_2 = {};

							if((normal.x > normal.z) && (normal.x >= normal.y))
							{
								// Project onto yz
								tri2_1.a.x = triangle1.b.z;
								tri2_1.a.y = triangle1.b.y;
								tri2_1.b.x = triangle1.a.z;
								tri2_1.b.y = triangle1.a.y;
								tri2_1.c.x = triangle1.c.z;
								tri2_1.c.y = triangle1.c.y;

								tri2_2.a.x = triangle2.b.z;
								tri2_2.a.y = triangle2.b.y;
								tri2_2.b.x = triangle2.a.z;
								tri2_2.b.y = triangle2.a.y;
								tri2_2.c.x = triangle2.c.z;
								tri2_2.c.y = triangle2.c.y;
							}
							else if((normal.y > normal.z) && (normal.y >= normal.x))
							{
								// Project onto xz
								tri2_1.a.x = triangle1.b.x;
								tri2_1.a.y = triangle1.b.z;
								tri2_1.b.x = triangle1.a.x;
								tri2_1.b.y = triangle1.a.z;
								tri2_1.c.x = triangle1.c.x;
								tri2_1.c.y = triangle1.c.z;

								tri2_2.a.x = triangle2.b.x;
								tri2_2.a.y = triangle2.b.z;
								tri2_2.b.x = triangle2.a.x;
								tri2_2.b.y = triangle2.a.z;
								tri2_2.c.x = triangle2.c.x;
								tri2_2.c.y = triangle2.c.z;
							}
							else
							{
								// Project onto xy
								tri2_1.a.x = triangle1.a.x;
								tri2_1.a.y = triangle1.a.y;
								tri2_1.b.x = triangle1.b.x;
								tri2_1.b.y = triangle1.b.y;
								tri2_1.c.x = triangle1.c.x;
								tri2_1.c.y = triangle1.c.y;

								tri2_2.a.x = triangle2.a.x;
								tri2_2.a.y = triangle2.a.y;
								tri2_2.b.x = triangle2.b.x;
								tri2_2.b.y = triangle2.b.y;
								tri2_2.c.x = triangle2.c.x;
								tri2_2.c.y = triangle2.c.y;
							}

							if(Orient2D(tri2_1.a.data, tri2_1.b.data, tri2_1.c.data) < 0.0f)
							{
								if(Orient2D(tri2_1.a.data, tri2_1.b.data, tri2_1.c.data) < 0.0f)
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data,
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data));
								}
								else
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data,
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data));
								}
							}
							else
							{
								if(Orient2D(tri2_2.a.data, tri2_2.b.data, tri2_2.c.data) < 0.0f)
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data,
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data));
								}
								else
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data,
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data));
								}
							}

							return GReturn::SUCCESS;
						}
					}
				}

				if(det2.x > 0.0f)
				{
					if(det2.y > 0.0f)
					{
						triangle1 =
						{
							{
								{
									triangle1.a,
									triangle1.c,
									triangle1.b
								}
							}
						};

						triangle2 =
						{
							{
								{
									triangle2.c,
									triangle2.a,
									triangle2.b
								}
							}
						};
					}
					else if(det2.z > 0.0f)
					{
						triangle1 =
						{
							{
								{
									triangle1.a,
									triangle1.c,
									triangle1.b
								}
							}
						};

						triangle2 =
						{
							{
								{
									triangle2.b,
									triangle2.c,
									triangle2.a
								}
							}
						};
					}
					else
					{
						triangle1 =
						{
							{
								{
									triangle1.a,
									triangle1.b,
									triangle1.c
								}
							}
						};

						triangle2 =
						{
							{
								{
									triangle2.a,
									triangle2.b,
									triangle2.c
								}
							}
						};
					}
				}
				else if(det2.x < 0.0f)
				{
					if(det2.y < 0.0f)
					{
						triangle1 =
						{
							{
								{
									triangle1.a,
									triangle1.b,
									triangle1.c
								}
							}
						};

						triangle2 =
						{
							{
								{
									triangle2.c,
									triangle2.a,
									triangle2.b
								}
							}
						};
					}
					else if(det2.z < 0.0f)
					{
						triangle1 =
						{
							{
								{
									triangle1.a,
									triangle1.b,
									triangle1.c
								}
							}
						};

						triangle2 =
						{
							{
								{
									triangle2.b,
									triangle2.c,
									triangle2.a
								}
							}
						};
					}
					else
					{
						triangle1 =
						{
							{
								{
									triangle1.a,
									triangle1.c,
									triangle1.b
								}
							}
						};

						triangle2 =
						{
							{
								{
									triangle2.a,
									triangle2.b,
									triangle2.c
								}
							}
						};
					}
				}
				else
				{
					if(det2.y < 0.0f)
					{
						if(det2.z >= 0.0f)
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.c,
										triangle1.b
									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.b,
										triangle2.c,
										triangle2.a
									}
								}
							};
						}
						else
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.b,
										triangle1.c
									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.a,
										triangle2.b,
										triangle2.c
									}
								}
							};
						}
					}
					else if(det2.y > 0.0f)
					{
						if(det2.z > 0.0f)
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.c,
										triangle1.b
									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.a,
										triangle2.b,
										triangle2.c
									}
								}
							};
						}
						else
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.b,
										triangle1.c
									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.b,
										triangle2.c,
										triangle2.a
									}
								}
							};
						}
					}
					else
					{
						if(det2.z > 0.0f)
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.b,
										triangle1.c
									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.c,
										triangle2.a,
										triangle2.b
									}
								}
							};
						}
						else if(det2.z < 0.0f)
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.c,
										triangle1.b
									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.c,
										triangle2.a,
										triangle2.b
									}
								}
							};
						}
						else
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.b,
										triangle1.c
									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.a,
										triangle2.b,
										triangle2.c
									}
								}
							};

							// return coplanar result
							auto Orient2D = [](const float* a, const float* b, const float* c)
							{
								return ((a[0] - c[0]) * (b[1] - c[1]) - (a[1] - c[1]) * (b[0] - c[0]));
							};

							auto TestVertex2D = [&](
								const float* a1, const float* b1, const float* c1,
								const float* a2, const float* b2, const float* c2)
							{
								if(Orient2D(c2, a2, b1) >= 0.0f)
								{
									if(Orient2D(c2, b2, b1) <= 0.0f)
									{
										if(Orient2D(a1, a2, b1) > 0.0f)
										{
											return (Orient2D(a1, b2, b1) <= 0.0f) ? 1 : 0;
										}
										else
										{
											if(Orient2D(a1, a2, c1) >= 0.0f)
											{
												return (Orient2D(b1, c1, a2) >= 0.0f) ? 1 : 0;
											}
											else return 0;
										}
									}
									else
									{
										if(Orient2D(a1, b2, b1) <= 0.0f)
										{
											if(Orient2D(c2, b2, c1) <= 0.0f)
											{
												return (Orient2D(b1, c1, b2) >= 0.0f) ? 1 : 0;
											}
											else return 0;
										}
										else return 0;
									}
								}
								else
								{
									if(Orient2D(c2, a2, c1) >= 0.0f)
									{
										if(Orient2D(b1, c1, c2) >= 0.0f)
										{
											return (Orient2D(a1, a2, c1) >= 0.0f) ? 1 : 0;
										}
										else
										{
											if(Orient2D(b1, c1, b2) >= 0.0f)
											{
												return (Orient2D(c2, c1, b2) >= 0.0f) ? 1 : 0;
											}
											else return 0;
										}
									}
									else  return 0;
								}
							};

							auto TestEdge2D = [&](
								const float* a1, const float* b1, const float* c1,
								const float* a2, const float* b2, const float* c2)
							{
								if(Orient2D(c2, a2, b1) >= 0.0f)
								{
									if(Orient2D(a1, a2, b1) >= 0.0f)
									{
										return (Orient2D(a1, b1, c2) >= 0.0f) ? 1 : 0;
									}
									else
									{
										if(Orient2D(b1, c1, a2) >= 0.0f)
										{
											return (Orient2D(c1, a1, a2) >= 0.0f) ? 1 : 0;
										}
										else return 0;
									}
								}
								else
								{
									if(Orient2D(c2, a2, c1) >= 0.0f)
									{
										if(Orient2D(a1, a2, c1) >= 0.0f)
										{
											if(Orient2D(a1, c1, c2) >= 0.0f) return 1;
											else
											{
												return (Orient2D(b1, c1, c2) >= 0.0f) ? 1 : 0;
											}
										}
										else  return 0;
									}
									else return 0;
								}
							};

							auto TestTriangles2D = [&](
								const float* a1, const float* b1, const float* c1,
								const float* a2, const float* b2, const float* c2)
							{
								if(Orient2D(a2, b2, a1) >= 0.0f)
								{
									if(Orient2D(b2, c2, a1) >= 0.0f)
									{
										if(Orient2D(c2, a2, a1) >= 0.0f)
										{
											return 1;
										}
										else
										{
											return TestEdge2D(
												a1, b1, c1,
												a2, b2, c2);
										}
									}
									else
									{
										if(Orient2D(c2, a2, a1) >= 0.0f)
										{
											return TestEdge2D(
												a1, b1, c1,
												c2, a2, b2);
										}
										else
										{
											return TestVertex2D(
												a1, b1, c1,
												a2, b2, c2);
										}
									}
								}
								else
								{
									if(Orient2D(b2, c2, a1) >= 0.0f)
									{
										if(Orient2D(c2, a2, a1) >= 0.0f)
										{
											return TestEdge2D(
												a1, b1, c1,
												b2, c2, a2);
										}
										else
										{
											return TestVertex2D(
												a1, b1, c1,
												b2, c2, a2);
										}
									}
									else
									{
										return TestVertex2D(
											a1, b1, c1,
											c2, a2, b2);
									}
								}
							};

							GW::MATH::GVECTORF normal =
							{
								{
									{
										G_ABS(plane1.x),
										G_ABS(plane1.y),
										G_ABS(plane1.z)
									}
								}
							};

							GW::MATH::GTRIANGLEF tri2_1 = {};
							GW::MATH::GTRIANGLEF tri2_2 = {};

							if((normal.x > normal.z) && (normal.x >= normal.y))
							{
								// Project onto yz
								tri2_1.a.x = triangle1.b.z;
								tri2_1.a.y = triangle1.b.y;
								tri2_1.b.x = triangle1.a.z;
								tri2_1.b.y = triangle1.a.y;
								tri2_1.c.x = triangle1.c.z;
								tri2_1.c.y = triangle1.c.y;

								tri2_2.a.x = triangle2.b.z;
								tri2_2.a.y = triangle2.b.y;
								tri2_2.b.x = triangle2.a.z;
								tri2_2.b.y = triangle2.a.y;
								tri2_2.c.x = triangle2.c.z;
								tri2_2.c.y = triangle2.c.y;
							}
							else if((normal.y > normal.z) && (normal.y >= normal.x))
							{
								// Project onto xz
								tri2_1.a.x = triangle1.b.x;
								tri2_1.a.y = triangle1.b.z;
								tri2_1.b.x = triangle1.a.x;
								tri2_1.b.y = triangle1.a.z;
								tri2_1.c.x = triangle1.c.x;
								tri2_1.c.y = triangle1.c.z;

								tri2_2.a.x = triangle2.b.x;
								tri2_2.a.y = triangle2.b.z;
								tri2_2.b.x = triangle2.a.x;
								tri2_2.b.y = triangle2.a.z;
								tri2_2.c.x = triangle2.c.x;
								tri2_2.c.y = triangle2.c.z;
							}
							else
							{
								// Project onto xy
								tri2_1.a.x = triangle1.a.x;
								tri2_1.a.y = triangle1.a.y;
								tri2_1.b.x = triangle1.b.x;
								tri2_1.b.y = triangle1.b.y;
								tri2_1.c.x = triangle1.c.x;
								tri2_1.c.y = triangle1.c.y;

								tri2_2.a.x = triangle2.a.x;
								tri2_2.a.y = triangle2.a.y;
								tri2_2.b.x = triangle2.b.x;
								tri2_2.b.y = triangle2.b.y;
								tri2_2.c.x = triangle2.c.x;
								tri2_2.c.y = triangle2.c.y;
							}

							if(Orient2D(tri2_1.a.data, tri2_1.b.data, tri2_1.c.data) < 0.0f)
							{
								if(Orient2D(tri2_1.a.data, tri2_1.b.data, tri2_1.c.data) < 0.0f)
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data,
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data));
								}
								else
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data,
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data));
								}
							}
							else
							{
								if(Orient2D(tri2_2.a.data, tri2_2.b.data, tri2_2.c.data) < 0.0f)
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data,
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data));
								}
								else
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data,
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data));
								}
							}

							return GReturn::SUCCESS;
						}
					}
				}

				// Edges confirmed to form a line where the triangle planes meet. Check if triangles are within an interval.
				GW::MATH::GVECTORF difference_a2b1 = {};
				GW::MATH::GVector::SubtractVectorF(
					triangle2.a,
					triangle1.b,
					difference_a2b1);

				GW::MATH::GVECTORF difference_a1b1 = {};
				GW::MATH::GVector::SubtractVectorF(
					triangle1.a,
					triangle1.b,
					difference_a1b1);

				GW::MATH::GVector::CrossVector3F(
					difference_a1b1,
					difference_a2b1,
					plane1);

				GW::MATH::GVECTORF difference_b2b1 = {};
				GW::MATH::GVector::SubtractVectorF(
					triangle2.b,
					triangle1.b,
					difference_b2b1);

				float dot1 = 0.0f;
				GW::MATH::GVector::DotF(
					difference_b2b1,
					plane1,
					dot1);

				if(dot1 > 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVector::SubtractVectorF(
					triangle2.a,
					triangle1.a,
					difference_a2a1);

				GW::MATH::GVector::SubtractVectorF(
					triangle1.c,
					triangle1.a,
					difference_c1a1);

				GW::MATH::GVector::CrossVector3F(
					difference_c1a1,
					difference_a2a1,
					plane1);

				GW::MATH::GVector::SubtractVectorF(
					triangle2.c,
					triangle1.a,
					difference_c2a1);

				GW::MATH::GVector::DotF(
					difference_c2a1,
					plane1,
					dot1);

				if(dot1 > 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestTriangleToPlaneF(const MATH::GTRIANGLEF _triangle, const MATH::GPLANEF _plane,
												GCollisionCheck& _outResult)
			{
				GCollisionCheck plane_test;

				TestPointToPlaneF(
					_triangle.a,
					_plane,
					plane_test);
				_outResult = plane_test;

				if (static_cast<int>(_outResult) > 0)
				{
					return GReturn::SUCCESS;
				}

				TestPointToPlaneF(
					_triangle.b,
					_plane,
					plane_test);

				if(_outResult != plane_test)
				{
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				TestPointToPlaneF(
					_triangle.c,
					_plane,
					plane_test);

				if(_outResult != plane_test)
				{
					_outResult = GCollisionCheck::COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestTriangleToSphereF(const MATH::GTRIANGLEF _triangle, const MATH::GSPHEREF _sphere,
												 GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF closest_point = {};
				ClosestPointToTriangleF(
					_triangle,
					_sphere.data,
					closest_point);

				return TestPointToSphereF(
					closest_point,
					_sphere,
					_outResult);
			}

			static GReturn TestTriangleToCapsuleF(const MATH::GTRIANGLEF _triangle, const MATH::GCAPSULEF _capsule,
												  GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF closest_point1 = {};
				ClosestPointToTriangleF(
					_triangle,
					_capsule.data[0],
					closest_point1);

				GW::MATH::GVECTORF closest_point2 = {};
				ClosestPointToTriangleF(
					_triangle,
					_capsule.data[1],
					closest_point2);

				return TestLineToCapsuleF(
					{{{closest_point1, closest_point2}}},
					_capsule,
					_outResult);
			}

			static GReturn TestTriangleToAABBF(const MATH::GTRIANGLEF _triangle, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF right = {{{1,0,0,0}}};
				GW::MATH::GVECTORF up = {{{0,1,0,0}}};
				GW::MATH::GVECTORF forward = {{{0,0,1,0}}};

				GW::MATH::GVECTORF v0 = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle.a.xyz(),
					_aabb.center.xyz(),
					v0);

				GW::MATH::GVECTORF v1 = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle.b.xyz(),
					_aabb.center.xyz(),
					v1);

				GW::MATH::GVECTORF v2 = {};
				GW::MATH::GVector::SubtractVectorF(
					_triangle.c.xyz(),
					_aabb.center.xyz(),
					v2);

				GW::MATH::GVECTORF f0 = {};
				GW::MATH::GVector::SubtractVectorF(
					v1,
					v0,
					f0);

				GW::MATH::GVECTORF f1 = {};
				GW::MATH::GVector::SubtractVectorF(
					v2,
					v1,
					f1);

				GW::MATH::GVECTORF f2 = {};
				GW::MATH::GVector::SubtractVectorF(
					v0,
					v2,
					f2);

				GW::MATH::GVECTORF axis[9] = {};

				GW::MATH::GVector::CrossVector3F(
					right,
					f0,
					axis[0]);

				GW::MATH::GVector::CrossVector3F(
					up,
					f0,
					axis[1]);

				GW::MATH::GVector::CrossVector3F(
					forward,
					f0,
					axis[2]);

				GW::MATH::GVector::CrossVector3F(
					right,
					f1,
					axis[3]);

				GW::MATH::GVector::CrossVector3F(
					up,
					f1,
					axis[4]);

				GW::MATH::GVector::CrossVector3F(
					forward,
					f1,
					axis[5]);

				GW::MATH::GVector::CrossVector3F(
					right,
					f2,
					axis[6]);

				GW::MATH::GVector::CrossVector3F(
					up,
					f2,
					axis[7]);

				GW::MATH::GVector::CrossVector3F(
					forward,
					f2,
					axis[8]);

				float p0 = 0.0f;
				float p1 = 0.0f;
				float p2 = 0.0f;
				float r = 0.0f;
				GW::MATH::GVECTORF dots = {};

				for(int i = 0; i < 9; i++)
				{
					GW::MATH::GVector::DotF(
						v0,
						axis[i],
						p0);
					GW::MATH::GVector::DotF(
						v1,
						axis[i],
						p1);
					GW::MATH::GVector::DotF(
						v2,
						axis[i],
						p2);

					GW::MATH::GVector::DotF(
						right,
						axis[i],
						dots.x);
					GW::MATH::GVector::DotF(
						up,
						axis[i],
						dots.y);
					GW::MATH::GVector::DotF(
						forward,
						axis[i],
						dots.z);

					r =
						_aabb.extent.x * G_ABS(dots.x) +
						_aabb.extent.y * G_ABS(dots.y) +
						_aabb.extent.z * G_ABS(dots.z);

					if(G_LARGER(-G_LARGER(p0, -G_LARGER(p1, p2)),
								G_SMALLER(p0, G_SMALLER(p1, p2))) > r)
					{
						_outResult = GCollisionCheck::NO_COLLISION;
						return GReturn::SUCCESS;
					}
				}

				// Test the 3 axis corresponding to the face normals of the AABB
				if(G_LARGER(v0.x, G_LARGER(v1.x, v2.x)) < -_aabb.extent.x ||
				   G_SMALLER(v0.x, G_SMALLER(v1.x, v2.x)) > _aabb.extent.x)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_LARGER(v0.y, G_LARGER(v1.y, v2.y)) < -_aabb.extent.y ||
				   G_SMALLER(v0.y, G_SMALLER(v1.y, v2.y)) > _aabb.extent.y)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_LARGER(v0.z, G_LARGER(v1.z, v2.z)) < -_aabb.extent.z ||
				   G_SMALLER(v0.z, G_SMALLER(v1.z, v2.z)) > _aabb.extent.z)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test separating axis to triangle face normal
				GW::MATH::GPLANEF plane;

				ComputePlaneF(
					_triangle.a,
					_triangle.b,
					_triangle.c,
					plane);

				return TestPlaneToAABBF(
					plane,
					_aabb,
					_outResult);
			}

			static GReturn TestTriangleToOBBF(const MATH::GTRIANGLEF _triangle, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				MATH::GMATRIXF obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionF(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXF obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0f}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0f}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0f}}},
							{{{0.0f, 0.0f, 0.0f, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				MATH::GTRIANGLEF triangle =
				{
					{
						{
							_triangle.a,
							_triangle.b,
							_triangle.c
						}
					}
				};
				triangle.a.w = 1.0f;
				triangle.b.w = 1.0f;
				triangle.c.w = 1.0f;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					triangle.a,
					triangle.a);
				GW::MATH::GVector::AddVectorF(
					triangle.a,
					_obb.center,
					triangle.a);

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					triangle.b,
					triangle.b);
				GW::MATH::GVector::AddVectorF(
					triangle.b,
					_obb.center,
					triangle.b);

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					triangle.c,
					triangle.c);
				GW::MATH::GVector::AddVectorF(
					triangle.c,
					_obb.center,
					triangle.c);

				return TestTriangleToAABBF(
					triangle,
					{{{_obb.center, _obb.extent}}},
					_outResult);
			}

			static GReturn TestPlaneToPlaneF(const MATH::GPLANEF _plane1, const MATH::GPLANEF _plane2, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF cross = {};
				GW::MATH::GVector::CrossVector3F(
					_plane1.data.xyz(),
					_plane2.data.xyz(),
					cross);

				float dot = 0.0f;
				GW::MATH::GVector::DotF(
					cross,
					cross,
					dot);

				_outResult = (dot < 0.000001f) ?
					GCollisionCheck::NO_COLLISION :
					GCollisionCheck::COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestPlaneToSphereF(const MATH::GPLANEF _plane, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult)
			{
				float distance = 0.0f;
				GW::MATH::GVector::DotF(
					_sphere.data.xyz(),
					_plane.data.xyz(),
					distance);
				distance -= _plane.distance;

				if(G_ABS(distance) <= _sphere.radius)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					_outResult = (distance > 0.0f) ?
						GCollisionCheck::ABOVE :
						GCollisionCheck::BELOW;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPlaneToCapsuleF(const MATH::GPLANEF _plane, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult)
			{
				float distance_start = 0.0f;
				GW::MATH::GVector::DotF(
					_capsule.data[0].xyz(),
					_plane.data.xyz(),
					distance_start);
				distance_start -= _plane.distance;

				float distance_end = 0.0f;
				GW::MATH::GVector::DotF(
					_capsule.data[1].xyz(),
					_plane.data.xyz(),
					distance_end);
				distance_end -= _plane.distance;

				if(distance_start * distance_end < 0.0f)
				{
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_ABS(distance_start) <= _capsule.radius || G_ABS(distance_end) <= _capsule.radius)
				{
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = (distance_start > 0.0f) ?
					GCollisionCheck::ABOVE :
					GCollisionCheck::BELOW;
				return GReturn::SUCCESS;

			}

			static GReturn TestPlaneToAABBF(const MATH::GPLANEF _plane, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF plane_normal = _plane.data.xyz();

				float interval =
					_aabb.extent.x * G_ABS(_plane.x) +
					_aabb.extent.y * G_ABS(_plane.y) +
					_aabb.extent.z * G_ABS(_plane.z);

				float distance = 0.0f;
				GW::MATH::GVector::DotF(
					plane_normal,
					_aabb.center.xyz(),
					distance);
				distance -= _plane.distance;

				if(G_ABS(distance) <= interval)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					_outResult = (distance > 0.0f) ?
						GCollisionCheck::ABOVE :
						GCollisionCheck::BELOW;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPlaneToOBBF(const MATH::GPLANEF _plane, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF plane_normal = _plane.data.xyz();

				float xx2 = 2.0f * _obb.rotation.x * _obb.rotation.x;
				float yy2 = 2.0f * _obb.rotation.y * _obb.rotation.y;
				float zz2 = 2.0f * _obb.rotation.z * _obb.rotation.z;

				float xy2 = 2.0f * _obb.rotation.x * _obb.rotation.y;
				float xz2 = 2.0f * _obb.rotation.x * _obb.rotation.z;
				float yz2 = 2.0f * _obb.rotation.y * _obb.rotation.z;

				float wx2 = 2.0f * _obb.rotation.w * _obb.rotation.x;
				float wy2 = 2.0f * _obb.rotation.w * _obb.rotation.y;
				float wz2 = 2.0f * _obb.rotation.w * _obb.rotation.z;

				MATH::GVECTORF obb_rotation[3] =
				{
					{{{1.0f - yy2 - zz2, xy2 - wz2, xz2 + wy2}}},
					{{{xy2 + wz2, 1.0f - xx2 - zz2, yz2 - wx2}}},
					{{{xz2 - wy2, yz2 + wx2, 1.0f - xx2 - yy2}}}
				};

				float interval = 0.0f;
				float s = 0.0f;

				for(int i = 0; i < 3; i++)
				{
					GW::MATH::GVector::DotF(
						plane_normal,
						obb_rotation[i],
						s);

					interval += _obb.extent.data[i] * G_ABS(s);
				}

				GW::MATH::GVector::DotF(
					plane_normal,
					_obb.center.xyz(),
					s);

				s -= _plane.distance;

				if(G_ABS(s) <= interval)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					_outResult = (s > 0.0f) ?
						GCollisionCheck::ABOVE :
						GCollisionCheck::BELOW;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestSphereToSphereF(const MATH::GSPHEREF _sphere1, const MATH::GSPHEREF _sphere2, GCollisionCheck& _outResult)
			{
				MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					_sphere1.data.xyz(),
					_sphere2.data.xyz(),
					difference_ba);

				float sq_distance = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					difference_ba,
					sq_distance);

				float sq_radii = _sphere1.radius + _sphere2.radius;
				sq_radii *= sq_radii;

				_outResult = (sq_distance <= sq_radii) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestSphereToCapsuleF(const MATH::GSPHEREF _sphere, const MATH::GCAPSULEF _capsule,
												GCollisionCheck& _outResult)
			{
				// Compute squared distance between the sphere center and capsule's start and end.
				float sq_distance = 0.0f;
				SqDistancePointToLineF(
					_sphere.data,
					{{{_capsule.data[0], _capsule.data[1]}}},
					sq_distance);

				float sq_radii = _sphere.radius + _capsule.radius;
				sq_radii *= sq_radii;

				_outResult = (sq_distance <= sq_radii) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestSphereToAABBF(const MATH::GSPHEREF _sphere, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult)
			{
				MATH::GAABBMMF mm = {};
				ConvertAABBCEToAABBMMF(
					_aabb,
					mm);

				float sq_distance = 0.0f;
				SqDistancePointToAABBF(
					_sphere.data.xyz(),
					mm,
					sq_distance);

				float sq_radius = _sphere.radius * _sphere.radius;

				_outResult = (sq_distance <= sq_radius) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestSphereToOBBF(const MATH::GSPHEREF _sphere, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORF closest_point = {};
				ClosestPointToOBBF(
					_obb,
					_sphere.data.xyz(),
					closest_point);

				GW::MATH::GVECTORF difference = {};
				GW::MATH::GVector::SubtractVectorF(
					closest_point,
					_sphere.data.xyz(),
					difference);

				float sq_radius = _sphere.radius * _sphere.radius;

				float sq_distance = 0.0f;
				GW::MATH::GVector::DotF(
					difference,
					difference,
					sq_distance);

				_outResult = (sq_distance <= sq_radius) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestCapsuleToCapsuleF(const MATH::GCAPSULEF _capsule1, const MATH::GCAPSULEF _capsule2,
												 GCollisionCheck& _outResult)
			{
				MATH::GVECTORF closest1 = {};
				MATH::GVECTORF closest2 = {};

				ClosestPointsToLineFromLineF(
					{{{_capsule1.data[0], _capsule1.data[1]}}},
					{{{_capsule2.data[0], _capsule2.data[1]}}},
					closest1,
					closest2);

				MATH::GVECTORF difference_ab = {};
				GW::MATH::GVector::SubtractVectorF(
					closest1,
					closest2,
					difference_ab);

				float sq_distance = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ab,
					difference_ab,
					sq_distance);

				float sq_radii = _capsule1.radius + _capsule2.radius;
				sq_radii *= sq_radii;

				_outResult = (sq_distance <= sq_radii) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestCapsuleToAABBF(const MATH::GCAPSULEF _capsule, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult)
			{
				// Expand AABB extents by capsule's radius.
				GW::MATH::GVECTORF center = _aabb.center.xyz();
				GW::MATH::GVECTORF extent = _aabb.extent.xyz();
				extent.x += _capsule.radius;
				extent.y += _capsule.radius;
				extent.z += _capsule.radius;

				GW::MATH::GVECTORF line_midpoint = {};
				GW::MATH::GVector::AddVectorF(
					_capsule.data[0].xyz(),
					_capsule.data[1].xyz(),
					line_midpoint);

				GW::MATH::GVector::ScaleF(
					line_midpoint,
					0.5f,
					line_midpoint);

				GW::MATH::GVECTORF line_mid_length = {};
				GW::MATH::GVector::SubtractVectorF(
					_capsule.data[1].xyz(),
					line_midpoint,
					line_mid_length);

				// Translate box and line to origin
				GW::MATH::GVECTORF o = {};
				GW::MATH::GVector::SubtractVectorF(
					line_midpoint,
					center,
					o);

				GW::MATH::GVECTORF axis =
				{
					{
						{
							G_ABS(line_mid_length.x),
							G_ABS(line_mid_length.y),
							G_ABS(line_mid_length.z)
						}
					}
				};

				// Separating axes
				for(int i = 0; i < 3; i++)
				{
					if(G_ABS(o.data[i]) > extent.data[i] + axis.data[i])
					{
						_outResult = GCollisionCheck::NO_COLLISION;
						return GReturn::SUCCESS;
					}
				}

				axis.x += 0.000001f;
				axis.y += 0.000001f;
				axis.z += 0.000001f;

				if(G_ABS(o.y * line_mid_length.z - o.z * line_mid_length.y) >
				   extent.y* axis.z + extent.z * axis.y)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_ABS(o.z * line_mid_length.x - o.x * line_mid_length.z) >
				   extent.x* axis.z + extent.z * axis.x)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_ABS(o.x * line_mid_length.z - o.y * line_mid_length.x) >
				   extent.x* axis.y + extent.z * axis.x)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestCapsuleToOBBF(const MATH::GCAPSULEF _capsule, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				MATH::GMATRIXF obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionF(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXF obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0f}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0f}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0f}}},
							{{{0.0f, 0.0f, 0.0f, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				MATH::GCAPSULEF capsule = {};
				capsule.data[0] = _capsule.data[0];
				capsule.data[0].w = 1.0f;
				capsule.data[1] = _capsule.data[1];
				capsule.data[1].w = 1.0f;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					capsule.data[0],
					capsule.data[0]);
				GW::MATH::GVector::AddVectorF(
					capsule.data[0],
					_obb.center,
					capsule.data[0]);

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					capsule.data[1],
					capsule.data[1]);
				GW::MATH::GVector::AddVectorF(
					capsule.data[1],
					_obb.center,
					capsule.data[1]);

				capsule.radius = _capsule.radius;

				return TestCapsuleToAABBF(
					capsule,
					{{{_obb.center, _obb.extent}}},
					_outResult);
			}

			static GReturn TestAABBToAABBF(const MATH::GAABBCEF _aabb1, const MATH::GAABBCEF _aabb2, GCollisionCheck& _outResult)
			{
				if(G_ABS(_aabb1.center.x - _aabb2.center.x) > (_aabb1.extent.x + _aabb2.extent.x) ||
				   G_ABS(_aabb1.center.y - _aabb2.center.y) > (_aabb1.extent.y + _aabb2.extent.y) ||
				   G_ABS(_aabb1.center.z - _aabb2.center.z) > (_aabb1.extent.z + _aabb2.extent.z))
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestAABBToOBBF(const MATH::GAABBCEF _aabb, const MATH::GOBBF _obb, GCollisionCheck& _outResult)
			{
				MATH::GOBBF obb =
				{
					{
						{
							_aabb.center,
							_aabb.extent,
							{{{0.0f, 0.0f, 0.0f, 1.0f}}}
						}
					}
				};

				return TestOBBToOBBF(
					obb,
					_obb,
					_outResult);
			}

			static GReturn TestOBBToOBBF(const MATH::GOBBF _obb1, const MATH::GOBBF _obb2, GCollisionCheck& _outResult)
			{
				// Convert quaternions into 3 axes for both OBB1 and OBB2.
				float xx2 = 2.0f * _obb1.rotation.x * _obb1.rotation.x;
				float yy2 = 2.0f * _obb1.rotation.y * _obb1.rotation.y;
				float zz2 = 2.0f * _obb1.rotation.z * _obb1.rotation.z;

				float xy2 = 2.0f * _obb1.rotation.x * _obb1.rotation.y;
				float xz2 = 2.0f * _obb1.rotation.x * _obb1.rotation.z;
				float yz2 = 2.0f * _obb1.rotation.y * _obb1.rotation.z;

				float wx2 = 2.0f * _obb1.rotation.w * _obb1.rotation.x;
				float wy2 = 2.0f * _obb1.rotation.w * _obb1.rotation.y;
				float wz2 = 2.0f * _obb1.rotation.w * _obb1.rotation.z;

				MATH::GVECTORF obb1_rotation[3] =
				{
					{{{1.0f - yy2 - zz2, xy2 - wz2, xz2 + wy2}}},
					{{{xy2 + wz2, 1.0f - xx2 - zz2, yz2 - wx2}}},
					{{{xz2 - wy2, yz2 + wx2, 1.0f - xx2 - yy2}}}
				};

				xx2 = 2.0f * _obb2.rotation.x * _obb2.rotation.x;
				yy2 = 2.0f * _obb2.rotation.y * _obb2.rotation.y;
				zz2 = 2.0f * _obb2.rotation.z * _obb2.rotation.z;

				xy2 = 2.0f * _obb2.rotation.x * _obb2.rotation.y;
				xz2 = 2.0f * _obb2.rotation.x * _obb2.rotation.z;
				yz2 = 2.0f * _obb2.rotation.y * _obb2.rotation.z;

				wx2 = 2.0f * _obb2.rotation.w * _obb2.rotation.x;
				wy2 = 2.0f * _obb2.rotation.w * _obb2.rotation.y;
				wz2 = 2.0f * _obb2.rotation.w * _obb2.rotation.z;

				MATH::GVECTORF obb2_rotation[3] =
				{
					{{{1.0f - yy2 - zz2, xy2 - wz2, xz2 + wy2}}},
					{{{xy2 + wz2, 1.0f - xx2 - zz2, yz2 - wx2}}},
					{{{xz2 - wy2, yz2 + wx2, 1.0f - xx2 - yy2}}}
				};

				float projected_radii = 0.0f;
				float projected_radii_1 = 0.0f;
				float projected_radii_2 = 0.0f;
				float test_axis = 0.0f;

				float rotation[3][3] = {};
				float abs_rotation[3][3] = {};

				for(int i = 0; i < 3; i++)
				{
					for(int j = 0; j < 3; j++)
					{
						GW::MATH::GVector::DotF(
							obb1_rotation[i],
							obb2_rotation[j],
							rotation[i][j]);
					}
				}

				// Get translation and then bring it into a's coordinate frame.
				MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					_obb2.center,
					_obb1.center,
					difference_ba);

				MATH::GVECTORF translation_vec = {};
				GW::MATH::GVector::DotF(
					difference_ba,
					obb1_rotation[0],
					translation_vec.x);

				GW::MATH::GVector::DotF(
					difference_ba,
					obb1_rotation[1],
					translation_vec.y);

				GW::MATH::GVector::DotF(
					difference_ba,
					obb1_rotation[2],
					translation_vec.z);

				// Get common values while maintaining numerical precision.
				for(int i = 0; i < 3; i++)
				{
					for(int j = 0; j < 3; j++)
					{
						abs_rotation[i][j] =
							G_ABS(rotation[i][j]) + 0.000001f;
					}
				}

				// Test axes for OBB1 x, y, z.
				for(int i = 0; i < 3; i++)
				{
					projected_radii_1 = _obb1.extent.data[i];

					projected_radii_2 =
						_obb2.extent.data[0] * abs_rotation[i][0] +
						_obb2.extent.data[1] * abs_rotation[i][1] +
						_obb2.extent.data[2] * abs_rotation[i][2];

					projected_radii = projected_radii_1 + projected_radii_2;

					test_axis = G_ABS(translation_vec.data[i]);

					if(test_axis > projected_radii)
					{
						_outResult = GCollisionCheck::NO_COLLISION;
						return GReturn::SUCCESS;
					}
				}

				// Test axes for OBB2 x, y, z.
				for(int i = 0; i < 3; i++)
				{
					projected_radii_1 =
						_obb1.extent.data[0] * abs_rotation[0][i] +
						_obb1.extent.data[1] * abs_rotation[1][i] +
						_obb1.extent.data[2] * abs_rotation[2][i];

					projected_radii_2 = _obb2.extent.data[i];

					projected_radii = projected_radii_1 + projected_radii_2;

					test_axis = G_ABS(
						translation_vec.data[0] * rotation[0][i] +
						translation_vec.data[1] * rotation[1][i] +
						translation_vec.data[2] * rotation[2][i]);

					if(test_axis > projected_radii)
					{
						_outResult = GCollisionCheck::NO_COLLISION;
						return GReturn::SUCCESS;
					}
				}

				// Test OBB1 x & OBB2 x
				projected_radii_1 =
					_obb1.extent.data[1] * abs_rotation[2][0] +
					_obb1.extent.data[2] * abs_rotation[1][0];

				projected_radii_2 =
					_obb2.extent.data[1] * abs_rotation[0][2] +
					_obb2.extent.data[2] * abs_rotation[0][1];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[2] * rotation[1][0] -
					translation_vec.data[1] * rotation[2][0]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 x & OBB2 y
				projected_radii_1 =
					_obb1.extent.data[1] * abs_rotation[2][1] +
					_obb1.extent.data[2] * abs_rotation[1][1];

				projected_radii_2 =
					_obb2.extent.data[0] * abs_rotation[0][2] +
					_obb2.extent.data[2] * abs_rotation[0][0];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[2] * rotation[1][1] -
					translation_vec.data[1] * rotation[2][1]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 x & OBB2 z
				projected_radii_1 =
					_obb1.extent.data[1] * abs_rotation[2][2] +
					_obb1.extent.data[2] * abs_rotation[1][2];

				projected_radii_2 =
					_obb2.extent.data[0] * abs_rotation[0][1] +
					_obb2.extent.data[1] * abs_rotation[0][0];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[2] * rotation[1][2] -
					translation_vec.data[1] * rotation[2][2]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 y & OBB2 x
				projected_radii_1 =
					_obb1.extent.data[0] * abs_rotation[2][0] +
					_obb1.extent.data[2] * abs_rotation[0][0];

				projected_radii_2 =
					_obb2.extent.data[1] * abs_rotation[1][2] +
					_obb2.extent.data[2] * abs_rotation[1][1];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[0] * rotation[2][0] -
					translation_vec.data[2] * rotation[0][0]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 y & OBB2 y
				projected_radii_1 =
					_obb1.extent.data[0] * abs_rotation[2][1] +
					_obb1.extent.data[2] * abs_rotation[0][1];

				projected_radii_2 =
					_obb2.extent.data[0] * abs_rotation[1][2] +
					_obb2.extent.data[2] * abs_rotation[1][0];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[0] * rotation[2][1] -
					translation_vec.data[2] * rotation[0][1]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 y & OBB2 z
				projected_radii_1 =
					_obb1.extent.data[0] * abs_rotation[2][2] +
					_obb1.extent.data[2] * abs_rotation[0][2];

				projected_radii_2 =
					_obb2.extent.data[0] * abs_rotation[1][1] +
					_obb2.extent.data[1] * abs_rotation[1][0];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[0] * rotation[2][2] -
					translation_vec.data[2] * rotation[0][2]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 z & OBB2 x
				projected_radii_1 =
					_obb1.extent.data[0] * abs_rotation[1][0] +
					_obb1.extent.data[1] * abs_rotation[0][0];

				projected_radii_2 =
					_obb2.extent.data[1] * abs_rotation[2][2] +
					_obb2.extent.data[2] * abs_rotation[2][1];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[1] * rotation[0][0] -
					translation_vec.data[0] * rotation[1][0]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 z & OBB2 y
				projected_radii_1 =
					_obb1.extent.data[0] * abs_rotation[1][1] +
					_obb1.extent.data[1] * abs_rotation[0][1];

				projected_radii_2 =
					_obb2.extent.data[0] * abs_rotation[2][2] +
					_obb2.extent.data[2] * abs_rotation[2][0];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[1] * rotation[0][1] -
					translation_vec.data[0] * rotation[1][1]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 z & OBB2 z
				projected_radii_1 =
					_obb1.extent.data[0] * abs_rotation[1][2] +
					_obb1.extent.data[1] * abs_rotation[0][2];

				projected_radii_2 =
					_obb2.extent.data[0] * abs_rotation[2][1] +
					_obb2.extent.data[1] * abs_rotation[2][0];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[1] * rotation[0][2] -
					translation_vec.data[0] * rotation[1][2]);

				_outResult = test_axis > projected_radii ?
					GCollisionCheck::NO_COLLISION :
					GCollisionCheck::COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn IntersectLineToTriangleF(const MATH::GLINEF _line, const MATH::GTRIANGLEF _triangle,
													GCollisionCheck& _outResult, MATH::GVECTORF& _outContactPoint,
													MATH::GVECTORF* _outBarycentric, MATH::GVECTORF& _outDirection,
													float& _outInterval)
			{
				MATH::GLINEF line =
				{
					{
						{
							_line.start.xyz(),
							_line.end.xyz()
						}
					}
				};

				MATH::GTRIANGLEF triangle =
				{
					{
						{
							_triangle.a.xyz(),
							_triangle.b.xyz(),
							_triangle.c.xyz()
						}
					}
				};

				GW::MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					triangle.b,
					triangle.a,
					difference_ba);

				GW::MATH::GVECTORF difference_ca = {};
				GW::MATH::GVector::SubtractVectorF(
					triangle.c,
					triangle.a,
					difference_ca);

				GW::MATH::GVECTORF norm = {};
				GW::MATH::GVector::CrossVector3F(
					difference_ca,
					difference_ba,
					norm);

				GW::MATH::GVECTORF difference_line = {};
				GW::MATH::GVector::SubtractVectorF(
					line.start,
					line.end,
					difference_line);

				float dot = 0.0f;
				GW::MATH::GVector::DotF(
					difference_line,
					norm,
					dot);

				// Segment is parallel to triangle
				if(dot <= 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORF difference_pa = {};
				GW::MATH::GVector::SubtractVectorF(
					line.start,
					triangle.a,
					difference_pa);

				float interval = 0.0f;
				GW::MATH::GVector::DotF(
					difference_pa,
					norm,
					interval);

				if(interval < 0.0f || interval > dot)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORF cross = {};
				GW::MATH::GVector::CrossVector3F(
					difference_line,
					difference_pa,
					cross);

				// Test to see if within bounds of barycentric coordinates.
				GW::MATH::GVECTORF barycentric = {};
				GW::MATH::GVector::DotF(
					difference_ca,
					cross,
					barycentric.y);
				barycentric.y = -barycentric.y;

				if(barycentric.y < 0.0f || barycentric.y > dot)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVector::DotF(
					difference_ba,
					cross,
					barycentric.z);

				if(barycentric.z < 0.0f || barycentric.y + barycentric.z > dot)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				float over_denom = 1.0f / dot;
				barycentric.y *= over_denom;
				barycentric.z *= over_denom;
				barycentric.x = 1.0f - barycentric.y - barycentric.z;
				_outInterval = interval * over_denom;

				_outContactPoint =
				{
					{
						{
							barycentric.x * _triangle.a.x + barycentric.y * _triangle.b.x + barycentric.z * _triangle.c.x,
						barycentric.x * _triangle.a.y + barycentric.y * _triangle.b.y + barycentric.z * _triangle.c.y,
						barycentric.x * _triangle.a.z + barycentric.y * _triangle.b.z + barycentric.z * _triangle.c.z
						}
					}
				};

				if(_outBarycentric)
				{
					*_outBarycentric = barycentric;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn IntersectLineToPlaneF(const MATH::GLINEF _line, const MATH::GPLANEF _plane, GCollisionCheck& _outResult,
												 MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection,
												 float& _outInterval)
			{
				GW::MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					_line.end.xyz(),
					_line.start.xyz(),
					difference_ba);

				float denom = 0.0f;
				GW::MATH::GVector::DotF(
					_plane.data.xyz(),
					difference_ba,
					denom);

				if(G_ABS(denom) < 0.000001f)
				{
					// Coplanar
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				float num = 0.0f;
				GW::MATH::GVector::DotF(
					_plane.data.xyz(),
					_line.start.xyz(),
					num);

				float interval = (_plane.distance - num) / denom;

				if(interval >= 0.0f && interval <= 1.0f)
				{
					_outResult = GCollisionCheck::COLLISION;

					_outDirection = difference_ba;
					GW::MATH::GVector::NormalizeF(
						_outDirection,
						_outDirection);

					GW::MATH::GVector::ScaleF(
						difference_ba,
						interval,
						_outContactPoint);

					GW::MATH::GVector::AddVectorF(
						_line.start.xyz(),
						_outContactPoint,
						_outContactPoint);

					_outInterval = interval;
				}
				else
				{
					num -= _plane.distance;

					_outResult = (num < 0.0f) ?
						_outResult = GCollisionCheck::BELOW :
						_outResult = GCollisionCheck::ABOVE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn IntersectLineToSphereF(const MATH::GLINEF _line, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult,
												  MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection,
												  float& _outInterval)
			{
				MATH::GLINEF line =
				{
					{
						{
							_line.start.xyz(),
							_line.end.xyz()
						}
					}
				};

				GW::MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					line.start,
					_sphere.data.xyz(),
					difference_ba);

				GW::MATH::GVECTORF dir = {};
				GW::MATH::GVector::SubtractVectorF(
					line.end,
					line.start,
					dir);

				float sq_length = 0.0f;
				GW::MATH::GVector::DotF(
					dir,
					dir,
					sq_length);

				if(GW::MATH::GVector::NormalizeF(dir, dir) == GReturn::FAILURE)
				{
					return GReturn::FAILURE;
				}

				float b = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					dir,
					b);

				float c = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					difference_ba,
					c);
				c -= _sphere.radius * _sphere.radius;

				if(c > 0.0f && b > 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				float discriminant = b * b - c;

				if(discriminant < 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outDirection = dir;
				_outInterval = -b - sqrtf(discriminant);

				if(_outInterval <= 0.0f)
				{
					// Line is contained in sphere.
					// Clamp to line start.
					_outInterval = 0.0f;
					_outContactPoint = line.start;
				}
				else if(_outInterval * _outInterval >= sq_length)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}
				else
				{
					GW::MATH::GVector::ScaleF(
						_outDirection,
						_outInterval,
						_outContactPoint);

					GW::MATH::GVector::AddVectorF(
						_outContactPoint,
						line.start,
						_outContactPoint);
				}

				_outResult = GCollisionCheck::COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn IntersectLineToCapsuleF(const MATH::GLINEF _line, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult,
												   MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection,
												   float& _outInterval)
			{
				GW::MATH::GVECTORF closest_point1 = {};
				GW::MATH::GVECTORF closest_point2 = {};
				ClosestPointsToLineFromLineF(
					_line,
					{{{_capsule.data[0], _capsule.data[1]}}},
					closest_point1,
					closest_point2);

				MATH::GSPHEREF sphere = {};
				sphere.data = closest_point2;
				sphere.radius = _capsule.radius;

				return IntersectLineToSphereF(
					_line,
					sphere,
					_outResult,
					_outContactPoint,
					_outDirection,
					_outInterval);
			}

			static GReturn IntersectLineToAABBF(const MATH::GLINEF _line, const MATH::GAABBMMF _aabb, GCollisionCheck& _outResult,
												MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection,
												float& _outInterval)
			{
				GW::MATH::GVector::SubtractVectorF(
					_line.end.xyz(),
					_line.start.xyz(),
					_outDirection);

				if(GW::MATH::GVector::NormalizeF(_outDirection, _outDirection) == GReturn::FAILURE)
				{
					return GReturn::FAILURE;
				}

				// TODO div by 0
				float interval1 = (_aabb.min.x - _line.start.x) / _outDirection.x;
				float interval2 = (_aabb.max.x - _line.start.x) / _outDirection.x;

				float interval3 = (_aabb.min.y - _line.start.y) / _outDirection.y;
				float interval4 = (_aabb.max.y - _line.start.y) / _outDirection.y;

				float interval5 = (_aabb.min.z - _line.start.z) / _outDirection.z;
				float interval6 = (_aabb.max.z - _line.start.z) / _outDirection.z;

				float interval_min = G_LARGER(G_LARGER(
					G_SMALLER(interval1, interval2),
					G_SMALLER(interval3, interval4)),
					G_SMALLER(interval5, interval6));

				float interval_max = G_SMALLER(G_SMALLER(
					G_LARGER(interval1, interval2),
					G_LARGER(interval3, interval4)),
					G_LARGER(interval5, interval6));

				if(interval_max < 0.0f || interval_min > 1.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(interval_max < interval_min)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outInterval = (interval_min < 0.0f) ?
					interval_max : interval_min;

				GW::MATH::GVector::ScaleF(
					_outDirection,
					_outInterval,
					_outContactPoint);

				GW::MATH::GVector::AddVectorF(
					_outContactPoint,
					_line.start.xyz(),
					_outContactPoint);

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn IntersectLineToOBBF(const MATH::GLINEF _line, const MATH::GOBBF _obb, GCollisionCheck& _outResult,
											   MATH::GVECTORF& _outContactPoint, MATH::GVECTORF& _outDirection,
											   float& _outInterval)
			{
				MATH::GLINEF line = {};
				line.start = _line.start;
				line.start.w = 1.0f;
				line.end = _line.end;
				line.end.w = 1.0f;

				MATH::GMATRIXF obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionF(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXF obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0f}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0f}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0f}}},
							{{{0.0f, 0.0f, 0.0f, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					line.start,
					line.start);
				GW::MATH::GVector::AddVectorF(
					line.start,
					_obb.center,
					line.start);

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					line.end,
					line.end);
				GW::MATH::GVector::AddVectorF(
					line.end,
					_obb.center,
					line.end);

				MATH::GAABBMMF mm = {};
				ConvertAABBCEToAABBMMF(
					{{{_obb.center, _obb.extent}}},
					mm);

				if(IntersectLineToAABBF(
					line,
					mm,
					_outResult,
					_outContactPoint,
					_outDirection,
					_outInterval) == GReturn::FAILURE)
				{
					return GReturn::FAILURE;
				}

				GMatrixImplementation::InverseF(
					obb_rotation_inverse,
					obb_rotation);

				GW::MATH::GVector::SubtractVectorF(
					_outContactPoint,
					_obb.center,
					_outContactPoint);

				_outContactPoint.w = 1.0F;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation,
					_outContactPoint,
					_outContactPoint);

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation,
					_outDirection.xyz(),
					_outDirection);

				_outContactPoint.w = 0.0F;

				return GReturn::SUCCESS;
			}

			static GReturn IntersectRayToTriangleF(const MATH::GRAYF _ray, const MATH::GTRIANGLEF _triangle, GCollisionCheck& _outResult,
												   MATH::GVECTORF& _outContactPoint, MATH::GVECTORF* _outBarycentric,
												   float& _outInterval)
			{
				MATH::GRAYF ray =
				{
					{
						{
							_ray.position.xyz(),
							_ray.direction.xyz()
						}
					}
				};

				MATH::GTRIANGLEF triangle =
				{
					{
						{
							_triangle.a.xyz(),
							_triangle.b.xyz(),
							_triangle.c.xyz()
						}
					}
				};

				GW::MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					triangle.b,
					triangle.a,
					difference_ba);

				GW::MATH::GVECTORF difference_ca = {};
				GW::MATH::GVector::SubtractVectorF(
					triangle.c,
					triangle.a,
					difference_ca);

				GW::MATH::GVECTORF q = {};
				GW::MATH::GVector::CrossVector3F(
					ray.direction,
					difference_ca,
					q);

				float det = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					q,
					det);

				// Ray is parallel to or points away from triangle
				if(G_ABS(det) < 0.000001f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				float denom = 1.0f / det;

				GW::MATH::GVECTORF s = {};
				GW::MATH::GVector::SubtractVectorF(
					ray.position,
					triangle.a,
					s);

				GW::MATH::GVECTORF barycentric = {};
				GW::MATH::GVector::DotF(
					s,
					q,
					barycentric.y);
				barycentric.y *= denom;

				if(barycentric.y < 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORF r = {};
				GW::MATH::GVector::CrossVector3F(
					s,
					difference_ba,
					r);

				GW::MATH::GVector::DotF(
					ray.direction,
					r,
					barycentric.z);
				barycentric.z *= denom;

				if(barycentric.z < 0.0f || barycentric.y + barycentric.z > 1.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				barycentric.x = 1.0f - barycentric.y - barycentric.z;

				if(_outBarycentric)
				{
					*_outBarycentric = barycentric;
				}

				_outContactPoint =
				{
					{
						{
							barycentric.x * _triangle.a.x + barycentric.y * _triangle.b.x + barycentric.z * _triangle.c.x,
							barycentric.x * _triangle.a.y + barycentric.y * _triangle.b.y + barycentric.z * _triangle.c.y,
							barycentric.x * _triangle.a.z + barycentric.y * _triangle.b.z + barycentric.z * _triangle.c.z
						}
					}
				};

				GW::MATH::GVECTORF v = {};
				GW::MATH::GVector::SubtractVectorF(
					_outContactPoint,
					ray.position,
					v);
				GW::MATH::GVector::DotF(
					v,
					v,
					_outInterval);

				_outInterval = sqrtf(_outInterval);

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn IntersectRayToPlaneF(const MATH::GRAYF _ray, const MATH::GPLANEF _plane, GCollisionCheck& _outResult,
												MATH::GVECTORF& _outContactPoint,
												float& _outInterval)
			{
				float denom = 0.0f;
				GW::MATH::GVector::DotF(
					_plane.data.xyz(),
					_ray.direction.xyz(),
					denom);

				if(G_ABS(denom) < 0.000001f)
				{
					// Coplanar
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				float num = 0.0f;
				GW::MATH::GVector::DotF(
					_plane.data.xyz(),
					_ray.position.xyz(),
					num);

				float interval = (_plane.distance - num) / denom;

				if(interval >= 0.0f)
				{
					_outResult = GCollisionCheck::COLLISION;

					GW::MATH::GVector::ScaleF(
						_ray.direction.xyz(),
						interval,
						_outContactPoint);

					GW::MATH::GVector::AddVectorF(
						_ray.position.xyz(),
						_outContactPoint,
						_outContactPoint);

					_outInterval = interval;
				}
				else
				{
					_outResult = GCollisionCheck::NO_COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn IntersectRayToSphereF(const MATH::GRAYF _ray, const MATH::GSPHEREF _sphere, GCollisionCheck& _outResult,
												 MATH::GVECTORF& _outContactPoint,
												 float& _outInterval)
			{
				MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					_ray.position.xyz(),
					_sphere.data.xyz(),
					difference_ba);

				float b = 0.0f;
				MATH::GVECTORF direction_n = _ray.direction.xyz();
				GW::MATH::GVector::DotF(
					difference_ba,
					direction_n,
					b);

				float c = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					difference_ba,
					c);
				c = c - _sphere.radius * _sphere.radius;

				if(c > 0.0f && b > 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				float discriminant = b * b - c;

				if(discriminant < 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outInterval = -b - sqrtf(discriminant);

				// If t is negative, ray started inside sphere so clamp t to zero
				if(_outInterval < 0.0f)
				{
					_outInterval = 0.0f;
				}

				GW::MATH::GVector::ScaleF(
					direction_n,
					_outInterval,
					_outContactPoint);

				GW::MATH::GVector::AddVectorF(
					_outContactPoint,
					_ray.position.xyz(),
					_outContactPoint);

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn IntersectRayToCapsuleF(const MATH::GRAYF _ray, const MATH::GCAPSULEF _capsule, GCollisionCheck& _outResult,
												  MATH::GVECTORF& _outContactPoint,
												  float& _outInterval)
			{
				GW::MATH::GVECTORF closest_point1 = {};
				ClosestPointToRayF(
					_ray,
					_capsule.data[0],
					closest_point1);

				GW::MATH::GSPHEREF sphere = {};
				ClosestPointToRayF(
					_ray,
					_capsule.data[1],
					sphere.data);

				ClosestPointsToLineFromLineF(
					{{{closest_point1, sphere.data}}},
					{{{_capsule.data[0], _capsule.data[1]}}},
					closest_point1,
					sphere.data);

				sphere.radius = _capsule.radius;

				return IntersectRayToSphereF(
					_ray,
					sphere,
					_outResult,
					_outContactPoint,
					_outInterval);
			}

			static GReturn IntersectRayToAABBF(const MATH::GRAYF _ray, const MATH::GAABBMMF _aabb, GCollisionCheck& _outResult,
											   MATH::GVECTORF& _outContactPoint,
											   float& _outInterval)
			{
				float interval1 = 0.0f;
				float interval2 = 0.0f;
				float interval3 = 0.0f;
				float interval4 = 0.0f;
				float interval5 = 0.0f;
				float interval6 = 0.0f;

				if(_ray.direction.x)
				{
					interval1 = (_aabb.min.x - _ray.position.x) / _ray.direction.x;
					interval2 = (_aabb.max.x - _ray.position.x) / _ray.direction.x;
				}
				else
				{
					interval1 = (_aabb.min.x - _ray.position.x) > 0.0f ?
						FLT_MAX : FLT_MIN;
					interval2 = (_aabb.max.x - _ray.position.x) > 0.0f ?
						FLT_MAX : FLT_MIN;
				}

				if(_ray.direction.y)
				{
					interval3 = (_aabb.min.y - _ray.position.y) / _ray.direction.y;
					interval4 = (_aabb.max.y - _ray.position.y) / _ray.direction.y;
				}
				else
				{
					interval3 = (_aabb.min.y - _ray.position.y) > 0.0f ?
						FLT_MAX : FLT_MIN;
					interval4 = (_aabb.max.y - _ray.position.y) > 0.0f ?
						FLT_MAX : FLT_MIN;
				}

				if(_ray.direction.z)
				{
					interval5 = (_aabb.min.z - _ray.position.z) / _ray.direction.z;
					interval6 = (_aabb.max.z - _ray.position.z) / _ray.direction.z;
				}
				else
				{
					interval5 = (_aabb.min.z - _ray.position.z) > 0.0f ?
						FLT_MAX : FLT_MIN;
					interval6 = (_aabb.max.z - _ray.position.z) > 0.0f ?
						FLT_MAX : FLT_MIN;
				}

				float interval_min = G_LARGER(G_LARGER(
					G_SMALLER(interval1, interval2),
					G_SMALLER(interval3, interval4)),
					G_SMALLER(interval5, interval6));

				float interval_max = G_SMALLER(G_SMALLER(
					G_LARGER(interval1, interval2),
					G_LARGER(interval3, interval4)),
					G_LARGER(interval5, interval6));

				if(interval_max < 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(interval_max < interval_min)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outInterval = (interval_min < 0.0f) ?
					interval_max : interval_min;

				GW::MATH::GVector::ScaleF(
					_ray.direction.xyz(),
					_outInterval,
					_outContactPoint);

				GW::MATH::GVector::AddVectorF(
					_outContactPoint,
					_ray.position.xyz(),
					_outContactPoint);

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn IntersectRayToOBBF(const MATH::GRAYF _ray, const MATH::GOBBF _obb, GCollisionCheck& _outResult,
											  MATH::GVECTORF& _outContactPoint, float& _outInterval)
			{
				MATH::GMATRIXF obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionF(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXF obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0f}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0f}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0f}}},
							{{{0.0f, 0.0f, 0.0f, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				MATH::GRAYF ray = {};
				ray.position = _ray.position;
				ray.position.w = 1.0f;
				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					ray.position,
					ray.position);
				GW::MATH::GVector::AddVectorF(
					ray.position,
					_obb.center,
					ray.position);

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					_ray.direction,
					ray.direction);
				GW::MATH::GVector::NormalizeF(
					ray.direction,
					ray.direction);

				MATH::GAABBMMF mm = {};
				ConvertAABBCEToAABBMMF(
					{{{_obb.center, _obb.extent}}},
					mm);

				IntersectRayToAABBF(
					ray,
					mm,
					_outResult,
					_outContactPoint,
					_outInterval);

				GMatrixImplementation::InverseF(
					obb_rotation_inverse,
					obb_rotation);

				GW::MATH::GVector::SubtractVectorF(
					_outContactPoint,
					_obb.center,
					_outContactPoint);

				_outContactPoint.w = 1.0F;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation,
					_outContactPoint,
					_outContactPoint);

				_outContactPoint.w = 0.0F;

				return GReturn::SUCCESS;
			}

			static GReturn IntersectSphereToSphereF(const MATH::GSPHEREF _sphere1, const MATH::GSPHEREF _sphere2,
													GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1,
													MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection,
													float& _outDistance)
			{
				TestSphereToSphereF(
					_sphere1,
					_sphere2,
					_outResult);

				if (static_cast<int>(_outResult) < 1)
				{
					return GReturn::SUCCESS;
				}

				GW::MATH::GVector::SubtractVectorF(
					_sphere2.data.xyz(),
					_sphere1.data.xyz(),
					_outDirection);

				GW::MATH::GVector::NormalizeF(
					_outDirection,
					_outDirection);

				GW::MATH::GVector::ScaleF(
					_outDirection,
					_sphere1.radius,
					_outContactClosest1);

				GW::MATH::GVector::AddVectorF(
					_sphere1.data.xyz(),
					_outContactClosest1,
					_outContactClosest1);

				GW::MATH::GVector::ScaleF(
					_outDirection,
					-_sphere2.radius,
					_outContactClosest2);

				GW::MATH::GVector::AddVectorF(
					_sphere2.data.xyz(),
					_outContactClosest2,
					_outContactClosest2);

				GW::MATH::GVECTORF difference = {};

				GW::MATH::GVector::SubtractVectorF(
					_outContactClosest1,
					_outContactClosest2,
					difference);

				GW::MATH::GVector::DotF(
					difference,
					difference,
					_outDistance);

				_outDistance = sqrtf(_outDistance);

				return GReturn::SUCCESS;
			}

			static GReturn IntersectSphereToCapsuleF(const MATH::GSPHEREF _sphere, const MATH::GCAPSULEF _capsule,
													 GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1,
													 MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection,
													 float& _outDistance)
			{
				MATH::GSPHEREF sphere = {};

				ClosestPointToLineF(
					{{{_capsule.data[0], _capsule.data[1]}}},
					_sphere.data,
					sphere.data);

				sphere.radius = _capsule.radius;

				return IntersectSphereToSphereF(
					_sphere,
					sphere,
					_outResult,
					_outContactClosest1,
					_outContactClosest2,
					_outDirection,
					_outDistance);
			}

			static GReturn IntersectSphereToAABBF(const MATH::GSPHEREF _sphere, const MATH::GAABBCEF _aabb, GCollisionCheck& _outResult,
												  MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2,
												  MATH::GVECTORF& _outDirection, float& _outDistance)
			{
				MATH::GAABBMMF mm = {};
				ConvertAABBCEToAABBMMF(
					_aabb,
					mm);

				float sq_distance = 0.0f;
				SqDistancePointToAABBF(
					_sphere.data.xyz(),
					mm,
					sq_distance);

				float sq_radius = _sphere.radius * _sphere.radius;

				_outResult = (sq_distance <= sq_radius) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				if(_outResult < GCollisionCheck::COLLISION)
				{
					return GReturn::SUCCESS;
				}

				GW::MATH::GVector::SubtractVectorF(
					_aabb.center.xyz(),
					_sphere.data.xyz(),
					_outDirection);

				if(GW::MATH::GVector::NormalizeF(_outDirection, _outDirection) == GReturn::FAILURE)
				{
					_outDirection = {};
				}

				GW::MATH::GVector::ScaleF(
					_outDirection,
					_sphere.radius,
					_outContactClosest1);

				GW::MATH::GVector::AddVectorF(
					_sphere.data.xyz(),
					_outContactClosest1,
					_outContactClosest1);

				for(int i = 0; i < 3; i++)
				{
					_outContactClosest2.data[i] = _sphere.data.data[i];

					_outContactClosest2.data[i] = G_LARGER(
						_outContactClosest2.data[i],
						mm.min.data[i]);

					_outContactClosest2.data[i] = G_SMALLER(
						_outContactClosest2.data[i],
						mm.max.data[i]);
				}

				// Point is inside AABB so clamp to closest face
				if(G_ABS(_sphere.x - _outContactClosest2.x) < 0.000001f ||
				   G_ABS(_sphere.y - _outContactClosest2.y) < 0.000001f ||
				   G_ABS(_sphere.z - _outContactClosest2.z) < 0.000001f)
				{
					GW::MATH::GVECTORF translation = {};
					float low = static_cast<float>(0xffffffff);
					float val = 0.0f;

					val = mm.max.x - _sphere.x;
					if(G_ABS(val) < low)
					{
						translation = {{{val, 0.0f, 0.0f}}};
						low = G_ABS(val);
					}

					val = _sphere.x - mm.min.x;
					if(G_ABS(val) < low)
					{
						translation = {{{val, 0.0f, 0.0f}}};
						low = G_ABS(val);
					}

					val = mm.max.y - _sphere.y;
					if(G_ABS(val) < low)
					{
						translation = {{{0.0f, val, 0.0f}}};
						low = G_ABS(val);
					}

					val = _sphere.y - mm.min.y;
					if(G_ABS(val) < low)
					{
						translation = {{{0.0f, val, 0.0f}}};
						low = G_ABS(val);
					}

					val = mm.max.z - _sphere.z;
					if(G_ABS(val) < low)
					{
						translation = {{{0.0f, 0.0f, val}}};
						low = G_ABS(val);
					}

					val = _sphere.z - mm.min.z;
					if(G_ABS(val) < low)
					{
						translation = {{{0.0f, 0.0f, val}}};
						low = G_ABS(val);
					}

					GW::MATH::GVector::AddVectorF(
						_outContactClosest2,
						translation,
						_outContactClosest2);
				}

				GW::MATH::GVector::SubtractVectorF(
					_outContactClosest2,
					_outContactClosest1,
					_outDirection);

				GW::MATH::GVector::DotF(
					_outDirection,
					_outDirection,
					_outDistance);

				_outDistance = sqrtf(_outDistance);

				if(GW::MATH::GVector::NormalizeF(_outDirection, _outDirection) == GReturn::FAILURE)
				{
					_outDirection = {};
				}

				return GReturn::SUCCESS;
			}

			static GReturn IntersectSphereToOBBF(const MATH::GSPHEREF _sphere, const MATH::GOBBF _obb, GCollisionCheck& _outResult,
												 MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2,
												 MATH::GVECTORF& _outDirection, float& _outDistance)
			{
				MATH::GMATRIXF obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionF(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXF obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0f}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0f}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0f}}},
							{{{0.0f, 0.0f, 0.0f, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotF(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				MATH::GSPHEREF sphere = {};
				sphere.data = _sphere.data;
				sphere.radius = 1.0f;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					sphere.data,
					sphere.data);
				GW::MATH::GVector::AddVectorF(
					sphere.data,
					_obb.center,
					sphere.data);
				sphere.radius = _sphere.radius;

				IntersectSphereToAABBF(
					sphere,
					{{{_obb.center, _obb.extent}}},
					_outResult,
					_outContactClosest1,
					_outContactClosest2,
					_outDirection,
					_outDistance);

				GMatrixImplementation::InverseF(
					obb_rotation_inverse,
					obb_rotation);

				GW::MATH::GVector::SubtractVectorF(
					_outContactClosest1,
					_obb.center,
					_outContactClosest1);

				_outContactClosest1.w = 1.0F;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation,
					_outContactClosest1,
					_outContactClosest1);

				_outContactClosest1.w = 0.0F;

				GW::MATH::GVector::SubtractVectorF(
					_outContactClosest2,
					_obb.center,
					_outContactClosest2);

				_outContactClosest2.w = 1.0F;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation,
					_outContactClosest2,
					_outContactClosest2);

				_outContactClosest2.w = 0.0F;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation,
					_outDirection.xyz(),
					_outDirection);

				return GReturn::SUCCESS;
			}

			static GReturn IntersectCapsuleToCapsuleF(const MATH::GCAPSULEF _capsule1, const MATH::GCAPSULEF _capsule2,
													  GCollisionCheck& _outResult, MATH::GVECTORF& _outContactClosest1,
													  MATH::GVECTORF& _outContactClosest2, MATH::GVECTORF& _outDirection,
													  float& _outDistance)
			{
				MATH::GSPHEREF sphere1 = {};
				MATH::GSPHEREF sphere2 = {};

				ClosestPointsToLineFromLineF(
					{{{_capsule1.data[0], _capsule1.data[1]}}},
					{{{_capsule2.data[0], _capsule2.data[1]}}},
					sphere1.data,
					sphere2.data);

				sphere1.radius = _capsule1.radius;
				sphere2.radius = _capsule2.radius;

				return IntersectSphereToSphereF(
					sphere1,
					sphere2,
					_outResult,
					_outContactClosest1,
					_outContactClosest2,
					_outDirection,
					_outDistance);
			}

			static GReturn IntersectCapsuleToAABBF(const MATH::GCAPSULEF _capsule, const MATH::GAABBMMF _aabb, GCollisionCheck& _outResult,
												   MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2,
												   MATH::GVECTORF& _outDirection, float& _outDistance)
			{
				// Extend AABB by capsule radius
				MATH::GAABBMMF aabbMM =
				{
					{
						{
							{{{_aabb.min.x - _capsule.radius, _aabb.min.y - _capsule.radius, _aabb.min.z - _capsule.radius , 0.0f}}},
							{{{_aabb.max.x + _capsule.radius, _aabb.max.y + _capsule.radius, _aabb.max.z + _capsule.radius}}}
						}
					}
				};

				MATH::GRAYF ray = {};
				ray.position = _capsule.data[0].xyz();

				GW::MATH::GVector::SubtractVectorF(
					ray.position,
					_capsule.data[0].xyz(),
					ray.direction);

				GW::MATH::GVector::NormalizeF(
					ray.direction,
					ray.direction);

				IntersectRayToAABBF(
					ray,
					aabbMM,
					_outResult,
					_outContactClosest1,
					_outDistance);

				if (static_cast<int>(_outResult) <= 0 || _outDistance > 1.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Flags to determine the region
				int u = 0;
				int v = 0;

				if(_outContactClosest1.x < _aabb.min.x)
				{
					u |= 1;
				}
				if(_outContactClosest1.x > _aabb.max.x)
				{
					v |= 1;
				}

				if(_outContactClosest1.y < _aabb.min.y)
				{
					u |= 2;
				}
				if(_outContactClosest1.y > _aabb.max.y)
				{
					v |= 2;
				}

				if(_outContactClosest1.z < _aabb.min.z)
				{
					u |= 4;
				}
				if(_outContactClosest1.z > _aabb.max.z)
				{
					v |= 4;
				}

				int m = u + v;

				auto Corner = [](const MATH::GAABBMMF box, const int n)->GW::MATH::GVECTORF
				{
					if(n & 1)
					{
						return GW::MATH::GVECTORF
						{
							{{box.max.x, box.max.y, box.max.z}}
						};
					}
					else
					{
						return GW::MATH::GVECTORF
						{
							{{box.min.x, box.min.y, box.min.z}}
						};
					}
				};

				GW::MATH::GCAPSULEF capsule;
				capsule.data[0] = Corner(aabbMM, v);

				// Vertex Region
				if(m == 7)
				{
					float tmin = static_cast<float>(0xffffffff);

					capsule.data[1] = Corner(aabbMM, v ^ 1);
					IntersectLineToCapsuleF(
						{{{_capsule.data[0].xyz(), _capsule.data[1].xyz()}}},
						capsule,
						_outResult,
						_outContactClosest1,
						_outDirection,
						tmin);

					if (static_cast<int>(_outResult) > 0)
					{
						_outDistance = G_SMALLER(tmin, _outDistance);
					}

					capsule.data[1] = Corner(aabbMM, v ^ 2);
					IntersectLineToCapsuleF(
						{{{_capsule.data[0].xyz(), _capsule.data[1].xyz()}}},
						capsule,
						_outResult,
						_outContactClosest1,
						_outDirection,
						tmin);

					if (static_cast<int>(_outResult) > 0)
					{
						_outDistance = G_SMALLER(tmin, _outDistance);
					}

					capsule.data[1] = Corner(aabbMM, v ^ 4);
					IntersectLineToCapsuleF(
						{{{_capsule.data[0].xyz(), _capsule.data[1].xyz()}}},
						capsule,
						_outResult,
						_outContactClosest1,
						_outDirection,
						tmin);

					if (static_cast<int>(_outResult) > 0)
					{
						_outDistance = G_SMALLER(tmin, _outDistance);
					}

					if(tmin == static_cast<float>(0xffffffff))
					{
						_outResult = GCollisionCheck::NO_COLLISION;
						return GReturn::SUCCESS;
					}

					_outDistance = tmin;

					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				if((m & (m - 1)) == 0)
				{
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				capsule.data[1] = capsule.data[0];
				capsule.data[0] = Corner(aabbMM, u ^ 7);

				return IntersectLineToCapsuleF(
					{{{_capsule.data[0].xyz(), _capsule.data[1].xyz()}}},
					capsule,
					_outResult,
					_outContactClosest1,
					_outDirection,
					_outDistance);
			}

			static GReturn IntersectCapsuleToOBBF(const MATH::GCAPSULEF _capsule, const MATH::GOBBF _obb, GCollisionCheck& _outResult,
												  MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2,
												  MATH::GVECTORF& _outDirection, float& _outDistance)
			{
				MATH::GMATRIXF obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionF(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXF obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0f}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0f}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0f}}},
							{{{0.0f, 0.0f, 0.0f, 1.0f}}}
						}
					}
				};

				MATH::GCAPSULEF capsule = {};
				capsule.data[0] = _capsule.data[0];
				capsule.data[0].w = 1.0f;
				capsule.data[1] = _capsule.data[1];
				capsule.data[1].w = 1.0f;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					capsule.data[0],
					capsule.data[0]);

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation_inverse,
					capsule.data[1],
					capsule.data[1]);

				capsule.radius = _capsule.radius;

				IntersectCapsuleToAABBF(
					capsule,
					{{{_obb.center, _obb.extent}}},
					_outResult,
					_outContactClosest1,
					_outContactClosest2,
					_outDirection,
					_outDistance);

				GMatrixImplementation::InverseF(
					obb_rotation_inverse,
					obb_rotation);

				GW::MATH::GVector::SubtractVectorF(
					_outContactClosest1,
					_obb.center,
					_outContactClosest1);

				_outContactClosest1.w = 1.0F;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation,
					_outContactClosest1,
					_outContactClosest1);

				_outContactClosest1.w = 0.0F;

				GW::MATH::GVector::SubtractVectorF(
					_outContactClosest2,
					_obb.center,
					_outContactClosest2);

				_outContactClosest2.w = 1.0F;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation,
					_outContactClosest2,
					_outContactClosest2);

				_outContactClosest2.w = 0.0F;

				GMatrixImplementation::VectorXMatrixF(
					obb_rotation,
					_outDirection.xyz(),
					_outDirection);

				return GReturn::SUCCESS;
			}

			static GReturn IntersectAABBToAABBF(const MATH::GAABBCEF _aabb1, const MATH::GAABBCEF _aabb2, GCollisionCheck& _outResult,
												MATH::GAABBCEF& _outContactAABB, MATH::GVECTORF& _outDirection,
												float& _outDistance)
			{
				if(G_ABS(_aabb1.center.x - _aabb2.center.x) > (_aabb1.extent.x + _aabb2.extent.x) ||
				   G_ABS(_aabb1.center.y - _aabb2.center.y) > (_aabb1.extent.y + _aabb2.extent.y) ||
				   G_ABS(_aabb1.center.z - _aabb2.center.z) > (_aabb1.extent.z + _aabb2.extent.z))
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				MATH::GAABBMMF aabb = {};
				aabb.min.x = G_LARGER(_aabb1.center.x - _aabb1.extent.x, _aabb2.center.x - _aabb2.extent.x);
				aabb.max.x = G_SMALLER(_aabb1.center.x + _aabb1.extent.x, _aabb2.center.x + _aabb2.extent.x);
				aabb.min.y = G_LARGER(_aabb1.center.y - _aabb1.extent.y, _aabb2.center.y - _aabb2.extent.y);
				aabb.max.y = G_SMALLER(_aabb1.center.y + _aabb1.extent.y, _aabb2.center.y + _aabb2.extent.y);
				aabb.min.z = G_LARGER(_aabb1.center.z - _aabb1.extent.z, _aabb2.center.z - _aabb2.extent.z);
				aabb.max.z = G_SMALLER(_aabb1.center.z + _aabb1.extent.z, _aabb2.center.z + _aabb2.extent.z);

				GW::MATH::GVECTORF difference = {};

				GW::MATH::GVector::SubtractVectorF(
					aabb.max,
					aabb.min,
					difference);

				GW::MATH::GVector::DotF(
					difference,
					difference,
					_outDistance);

				_outDistance = sqrtf(_outDistance);

				GW::MATH::GVector::SubtractVectorF(
					_aabb2.center,
					_aabb1.center,
					_outDirection);

				GW::MATH::GVector::NormalizeF(
					_outDirection,
					_outDirection);

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			//static GReturn IntersectAABBToOBBF(const MATH::GAABBCEF _aabb, const MATH::GOBBF _obb, GCollisionCheck& _outResult,
			//								   MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2,
			//								   MATH::GVECTORF& _outDirection, float& _outDistance)
			//{
			//	return IntersectOBBToOBBF(
			//		{_aabb.center, _aabb.extent},
			//		_obb,
			//		_outResult,
			//		_outContactClosest1,
			//		_outContactClosest2,
			//		_outDirection,
			//		_outDistance);
			//}

			//static GReturn IntersectOBBToOBBF(const MATH::GOBBF _obb1, const MATH::GOBBF _obb2, GCollisionCheck& _outResult,
			//								  MATH::GVECTORF& _outContactClosest1, MATH::GVECTORF& _outContactClosest2,
			//								  MATH::GVECTORF& _outDirection, float& _outDistance)
			//{
			//	// Convert quaternions into 3 axes for both OBB1 and OBB2.
			//	float xx2 = 2.0f * _obb1.rotation.x * _obb1.rotation.x;
			//	float yy2 = 2.0f * _obb1.rotation.y * _obb1.rotation.y;
			//	float zz2 = 2.0f * _obb1.rotation.z * _obb1.rotation.z;

			//	float xy2 = 2.0f * _obb1.rotation.x * _obb1.rotation.y;
			//	float xz2 = 2.0f * _obb1.rotation.x * _obb1.rotation.z;
			//	float yz2 = 2.0f * _obb1.rotation.y * _obb1.rotation.z;

			//	float wx2 = 2.0f * _obb1.rotation.w * _obb1.rotation.x;
			//	float wy2 = 2.0f * _obb1.rotation.w * _obb1.rotation.y;
			//	float wz2 = 2.0f * _obb1.rotation.w * _obb1.rotation.z;

			//	MATH::GVECTORF obb1_rotation[3] =
			//	{
			//		{ 1.0f - yy2 - zz2, xy2 - wz2, xz2 + wy2 },
			//		{ xy2 + wz2, 1.0f - xx2 - zz2, yz2 - wx2 },
			//		{ xz2 - wy2, yz2 + wx2, 1.0f - xx2 - yy2 }
			//	};

			//	xx2 = 2.0f * _obb2.rotation.x * _obb2.rotation.x;
			//	yy2 = 2.0f * _obb2.rotation.y * _obb2.rotation.y;
			//	zz2 = 2.0f * _obb2.rotation.z * _obb2.rotation.z;

			//	xy2 = 2.0f * _obb2.rotation.x * _obb2.rotation.y;
			//	xz2 = 2.0f * _obb2.rotation.x * _obb2.rotation.z;
			//	yz2 = 2.0f * _obb2.rotation.y * _obb2.rotation.z;

			//	wx2 = 2.0f * _obb2.rotation.w * _obb2.rotation.x;
			//	wy2 = 2.0f * _obb2.rotation.w * _obb2.rotation.y;
			//	wz2 = 2.0f * _obb2.rotation.w * _obb2.rotation.z;

			//	MATH::GVECTORF obb2_rotation[3] =
			//	{
			//		{ 1.0f - yy2 - zz2, xy2 - wz2, xz2 + wy2 },
			//		{ xy2 + wz2, 1.0f - xx2 - zz2, yz2 - wx2 },
			//		{ xz2 - wy2, yz2 + wx2, 1.0f - xx2 - yy2 }
			//	};

			//	float projected_radii = 0.0f;
			//	float projected_radii_1 = 0.0f;
			//	float projected_radii_2 = 0.0f;
			//	float test_axis = 0.0f;

			//	float rotation[3][3] = {};
			//	float abs_rotation[3][3] = {};

			//	for(int i = 0; i < 3; i++)
			//	{
			//		for(int j = 0; j < 3; j++)
			//		{
			//			GW::MATH::GVector::DotF(
			//				obb1_rotation[i],
			//				obb2_rotation[j],
			//				rotation[i][j]);
			//		}
			//	}

			//	// Get translation and then bring it into a's coordinate frame.
			//	MATH::GVECTORF difference_ba = {};
			//	GW::MATH::GVector::SubtractVectorF(
			//		_obb2.center,
			//		_obb1.center,
			//		difference_ba);

			//	MATH::GVECTORF translation_vec = {};
			//	GW::MATH::GVector::DotF(
			//		difference_ba,
			//		obb1_rotation[0],
			//		translation_vec.x);

			//	GW::MATH::GVector::DotF(
			//		difference_ba,
			//		obb1_rotation[1],
			//		translation_vec.y);

			//	GW::MATH::GVector::DotF(
			//		difference_ba,
			//		obb1_rotation[2],
			//		translation_vec.z);

			//	// Get common values while maintaining numerical precision.
			//	for(int i = 0; i < 3; i++)
			//	{
			//		for(int j = 0; j < 3; j++)
			//		{
			//			abs_rotation[i][j] =
			//				G_ABS(rotation[i][j]) + 0.000001f;
			//		}
			//	}

			//	_outDistance = static_cast<float>(0x0);

			//	auto GetInfo = [&](
			//		float axis,
			//		float radii_1,
			//		float radii_2,
			//		GW::MATH::GVECTORF vec1,
			//		GW::MATH::GVECTORF* vec2,
			//		GW::MATH::GVECTORF& dir,
			//		float& distance)
			//	{
			//		float x = G_ABS(radii_1 - (axis - radii_2));

			//		if(x < distance)
			//		{
			//			distance = x;

			//			if(vec2)
			//			{
			//				GW::MATH::GVector::CrossVector3F(
			//					vec1,
			//					vec2[0],
			//					dir);

			//				GW::MATH::GVector::NormalizeF(
			//					dir,
			//					dir);
			//			}
			//			else
			//			{
			//				GW::MATH::GVector::NormalizeF(
			//					vec1,
			//					dir);
			//			}
			//		}
			//	};

			//	// Test axes for OBB1 x, y, z.
			//	for(int i = 0; i < 3; i++)
			//	{
			//		projected_radii_1 = _obb1.extent.data[i];

			//		projected_radii_2 =
			//			_obb2.extent.data[0] * abs_rotation[i][0] +
			//			_obb2.extent.data[1] * abs_rotation[i][1] +
			//			_obb2.extent.data[2] * abs_rotation[i][2];

			//		projected_radii = projected_radii_1 + projected_radii_2;

			//		test_axis = G_ABS(translation_vec.data[i]);

			//		if(test_axis > projected_radii)
			//		{
			//			_outResult = GCollisionCheck::NO_COLLISION;
			//			return GReturn::SUCCESS;
			//		}
			//		else
			//		{
			//			GetInfo(
			//				test_axis,
			//				projected_radii_1,
			//				projected_radii_2,
			//				obb1_rotation[i],
			//				nullptr,
			//				_outDirection,
			//				_outDistance);
			//		}
			//	}

			//	// Test axes for OBB2 x, y, z.
			//	for(int i = 0; i < 3; i++)
			//	{
			//		projected_radii_1 =
			//			_obb1.extent.data[0] * abs_rotation[0][i] +
			//			_obb1.extent.data[1] * abs_rotation[1][i] +
			//			_obb1.extent.data[2] * abs_rotation[2][i];

			//		projected_radii_2 = _obb2.extent.data[i];

			//		projected_radii = projected_radii_1 + projected_radii_2;

			//		test_axis = G_ABS(
			//			translation_vec.data[0] * rotation[0][i] +
			//			translation_vec.data[1] * rotation[1][i] +
			//			translation_vec.data[2] * rotation[2][i]);

			//		if(test_axis > projected_radii)
			//		{
			//			_outResult = GCollisionCheck::NO_COLLISION;
			//			return GReturn::SUCCESS;
			//		}
			//		else
			//		{
			//			GetInfo(
			//				test_axis,
			//				projected_radii_1,
			//				projected_radii_2,
			//				obb2_rotation[i],
			//				nullptr,
			//				_outDirection,
			//				_outDistance);
			//		}
			//	}

			//	// Test OBB1 x & OBB2 x
			//	projected_radii_1 =
			//		_obb1.extent.data[1] * abs_rotation[2][0] +
			//		_obb1.extent.data[2] * abs_rotation[1][0];

			//	projected_radii_2 =
			//		_obb2.extent.data[1] * abs_rotation[0][2] +
			//		_obb2.extent.data[2] * abs_rotation[0][1];

			//	projected_radii = projected_radii_1 + projected_radii_2;

			//	test_axis = G_ABS(
			//		translation_vec.data[2] * rotation[1][0] -
			//		translation_vec.data[1] * rotation[2][0]);

			//	if(test_axis > projected_radii)
			//	{
			//		_outResult = GCollisionCheck::NO_COLLISION;
			//		return GReturn::SUCCESS;
			//	}
			//	else
			//	{
			//		GetInfo(
			//			test_axis,
			//			projected_radii_1,
			//			projected_radii_2,
			//			obb1_rotation[0],
			//			&obb2_rotation[0],
			//			_outDirection,
			//			_outDistance);
			//	}

			//	// Test OBB1 x & OBB2 y
			//	projected_radii_1 =
			//		_obb1.extent.data[1] * abs_rotation[2][1] +
			//		_obb1.extent.data[2] * abs_rotation[1][1];

			//	projected_radii_2 =
			//		_obb2.extent.data[0] * abs_rotation[0][2] +
			//		_obb2.extent.data[2] * abs_rotation[0][0];

			//	projected_radii = projected_radii_1 + projected_radii_2;

			//	test_axis = G_ABS(
			//		translation_vec.data[2] * rotation[1][1] -
			//		translation_vec.data[1] * rotation[2][1]);

			//	if(test_axis > projected_radii)
			//	{
			//		_outResult = GCollisionCheck::NO_COLLISION;
			//		return GReturn::SUCCESS;
			//	}
			//	else
			//	{
			//		GetInfo(
			//			test_axis,
			//			projected_radii_1,
			//			projected_radii_2,
			//			obb1_rotation[0],
			//			&obb2_rotation[1],
			//			_outDirection,
			//			_outDistance);
			//	}

			//	// Test OBB1 x & OBB2 z
			//	projected_radii_1 =
			//		_obb1.extent.data[1] * abs_rotation[2][2] +
			//		_obb1.extent.data[2] * abs_rotation[1][2];

			//	projected_radii_2 =
			//		_obb2.extent.data[0] * abs_rotation[0][1] +
			//		_obb2.extent.data[1] * abs_rotation[0][0];

			//	projected_radii = projected_radii_1 + projected_radii_2;

			//	test_axis = G_ABS(
			//		translation_vec.data[2] * rotation[1][2] -
			//		translation_vec.data[1] * rotation[2][2]);

			//	if(test_axis > projected_radii)
			//	{
			//		_outResult = GCollisionCheck::NO_COLLISION;
			//		return GReturn::SUCCESS;
			//	}
			//	else
			//	{
			//		GetInfo(
			//			test_axis,
			//			projected_radii_1,
			//			projected_radii_2,
			//			obb1_rotation[0],
			//			&obb2_rotation[2],
			//			_outDirection,
			//			_outDistance);
			//	}

			//	// Test OBB1 y & OBB2 x
			//	projected_radii_1 =
			//		_obb1.extent.data[0] * abs_rotation[2][0] +
			//		_obb1.extent.data[2] * abs_rotation[0][0];

			//	projected_radii_2 =
			//		_obb2.extent.data[1] * abs_rotation[1][2] +
			//		_obb2.extent.data[2] * abs_rotation[1][1];

			//	projected_radii = projected_radii_1 + projected_radii_2;

			//	test_axis = G_ABS(
			//		translation_vec.data[0] * rotation[2][0] -
			//		translation_vec.data[2] * rotation[0][0]);

			//	if(test_axis > projected_radii)
			//	{
			//		_outResult = GCollisionCheck::NO_COLLISION;
			//		return GReturn::SUCCESS;
			//	}
			//	else
			//	{
			//		GetInfo(
			//			test_axis,
			//			projected_radii_1,
			//			projected_radii_2,
			//			obb1_rotation[1],
			//			&obb2_rotation[0],
			//			_outDirection,
			//			_outDistance);
			//	}

			//	// Test OBB1 y & OBB2 y
			//	projected_radii_1 =
			//		_obb1.extent.data[0] * abs_rotation[2][1] +
			//		_obb1.extent.data[2] * abs_rotation[0][1];

			//	projected_radii_2 =
			//		_obb2.extent.data[0] * abs_rotation[1][2] +
			//		_obb2.extent.data[2] * abs_rotation[1][0];

			//	projected_radii = projected_radii_1 + projected_radii_2;

			//	test_axis = G_ABS(
			//		translation_vec.data[0] * rotation[2][1] -
			//		translation_vec.data[2] * rotation[0][1]);

			//	if(test_axis > projected_radii)
			//	{
			//		_outResult = GCollisionCheck::NO_COLLISION;
			//		return GReturn::SUCCESS;
			//	}
			//	else
			//	{
			//		GetInfo(
			//			test_axis,
			//			projected_radii_1,
			//			projected_radii_2,
			//			obb1_rotation[1],
			//			&obb2_rotation[1],
			//			_outDirection,
			//			_outDistance);
			//	}

			//	// Test OBB1 y & OBB2 z
			//	projected_radii_1 =
			//		_obb1.extent.data[0] * abs_rotation[2][2] +
			//		_obb1.extent.data[2] * abs_rotation[0][2];

			//	projected_radii_2 =
			//		_obb2.extent.data[0] * abs_rotation[1][1] +
			//		_obb2.extent.data[1] * abs_rotation[1][0];

			//	projected_radii = projected_radii_1 + projected_radii_2;

			//	test_axis = G_ABS(
			//		translation_vec.data[0] * rotation[2][2] -
			//		translation_vec.data[2] * rotation[0][2]);

			//	if(test_axis > projected_radii)
			//	{
			//		_outResult = GCollisionCheck::NO_COLLISION;
			//		return GReturn::SUCCESS;
			//	}
			//	else
			//	{
			//		GetInfo(
			//			test_axis,
			//			projected_radii_1,
			//			projected_radii_2,
			//			obb1_rotation[1],
			//			&obb2_rotation[2],
			//			_outDirection,
			//			_outDistance);
			//	}

			//	// Test OBB1 z & OBB2 x
			//	projected_radii_1 =
			//		_obb1.extent.data[0] * abs_rotation[1][0] +
			//		_obb1.extent.data[1] * abs_rotation[0][0];

			//	projected_radii_2 =
			//		_obb2.extent.data[1] * abs_rotation[2][2] +
			//		_obb2.extent.data[2] * abs_rotation[2][1];

			//	projected_radii = projected_radii_1 + projected_radii_2;

			//	test_axis = G_ABS(
			//		translation_vec.data[1] * rotation[0][0] -
			//		translation_vec.data[0] * rotation[1][0]);

			//	if(test_axis > projected_radii)
			//	{
			//		_outResult = GCollisionCheck::NO_COLLISION;
			//		return GReturn::SUCCESS;
			//	}
			//	else
			//	{
			//		GetInfo(
			//			test_axis,
			//			projected_radii_1,
			//			projected_radii_2,
			//			obb1_rotation[2],
			//			&obb2_rotation[0],
			//			_outDirection,
			//			_outDistance);
			//	}

			//	// Test OBB1 z & OBB2 y
			//	projected_radii_1 =
			//		_obb1.extent.data[0] * abs_rotation[1][1] +
			//		_obb1.extent.data[1] * abs_rotation[0][1];

			//	projected_radii_2 =
			//		_obb2.extent.data[0] * abs_rotation[2][2] +
			//		_obb2.extent.data[2] * abs_rotation[2][0];

			//	projected_radii = projected_radii_1 + projected_radii_2;

			//	test_axis = G_ABS(
			//		translation_vec.data[1] * rotation[0][1] -
			//		translation_vec.data[0] * rotation[1][1]);

			//	if(test_axis > projected_radii)
			//	{
			//		_outResult = GCollisionCheck::NO_COLLISION;
			//		return GReturn::SUCCESS;
			//	}
			//	else
			//	{
			//		GetInfo(
			//			test_axis,
			//			projected_radii_1,
			//			projected_radii_2,
			//			obb1_rotation[2],
			//			&obb2_rotation[1],
			//			_outDirection,
			//			_outDistance);
			//	}

			//	// Test OBB1 z & OBB2 z
			//	projected_radii_1 =
			//		_obb1.extent.data[0] * abs_rotation[1][2] +
			//		_obb1.extent.data[1] * abs_rotation[0][2];

			//	projected_radii_2 =
			//		_obb2.extent.data[0] * abs_rotation[2][1] +
			//		_obb2.extent.data[1] * abs_rotation[2][0];

			//	projected_radii = projected_radii_1 + projected_radii_2;

			//	test_axis = G_ABS(
			//		translation_vec.data[1] * rotation[0][2] -
			//		translation_vec.data[0] * rotation[1][2]);

			//	if(test_axis > projected_radii)
			//	{
			//		_outResult = GCollisionCheck::NO_COLLISION;
			//		return GReturn::SUCCESS;
			//	}
			//	else
			//	{
			//		GetInfo(
			//			test_axis,
			//			projected_radii_1,
			//			projected_radii_2,
			//			obb1_rotation[2],
			//			&obb2_rotation[2],
			//			_outDirection,
			//			_outDistance);
			//	}
			//	_outDistance += 0.000001f;

			//	GW::MATH::GVector::ScaleF(
			//		_outDirection,
			//		_outDistance,
			//		_outContactClosest1);

			//	GW::MATH::GVector::AddVectorF(
			//		_outContactClosest1,
			//		_obb2.center,
			//		_outContactClosest1);

			//	GW::MATH::GVector::ScaleF(
			//		_outDirection,
			//		-(_outDistance),
			//		_outContactClosest2);

			//	GW::MATH::GVector::AddVectorF(
			//		_outContactClosest2,
			//		_obb2.center,
			//		_outContactClosest2);

			//	_outResult = GCollisionCheck::COLLISION;
			//	return GReturn::SUCCESS;
			//}

			static GReturn SqDistancePointToLineF(const MATH::GVECTORF _point, const MATH::GLINEF _line, float& _outDistance)
			{
				GW::MATH::GVECTORF p = _point.xyz();

				MATH::GLINEF line =
				{
					{
						{
							_line.start.xyz(),
							_line.end.xyz()
						}
					}
				};

				MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					line.end,
					line.start,
					difference_ba);

				MATH::GVECTORF difference_pa = {};
				GW::MATH::GVector::SubtractVectorF(
					p,
					line.start,
					difference_pa);

				MATH::GVECTORF difference_pb = {};
				GW::MATH::GVector::SubtractVectorF(
					p,
					line.end,
					difference_pb);

				float interval1 = 0.0f;
				GW::MATH::GVector::DotF(
					difference_pa,
					difference_ba,
					interval1);

				if(interval1 <= 0.0f)
				{
					GW::MATH::GVector::DotF(
						difference_pa,
						difference_pa,
						_outDistance);

					return GReturn::SUCCESS;
				}

				float interval2 = 0.0f;
				GW::MATH::GVector::DotF(
					difference_ba,
					difference_ba,
					interval2);

				if(interval1 >= interval2)
				{
					GW::MATH::GVector::DotF(
						difference_pb,
						difference_pb,
						_outDistance);

					return GReturn::SUCCESS;
				}

				GW::MATH::GVector::DotF(
					difference_pa,
					difference_pa,
					_outDistance);

				if(G_ABS(interval2) >= 0.000001f)
				{
					_outDistance -= interval1 * interval1 / interval2;
				}

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToRayF(const MATH::GVECTORF _point, const MATH::GRAYF _ray, float& _outDistance)
			{
				GW::MATH::GVECTORF p = {};

				ClosestPointToRayF(
					_ray,
					_point,
					p);

				GW::MATH::GVector::SubtractVectorF(
					p,
					_point.xyz(),
					p);

				GW::MATH::GVector::DotF(
					p,
					p,
					_outDistance);

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToTriangleF(const MATH::GVECTORF _point, const MATH::GTRIANGLEF _triangle,
													  float& _outDistance)
			{
				GW::MATH::GVECTORF p = {};
				ClosestPointToTriangleF(
					_triangle,
					_point,
					p);

				GW::MATH::GVector::SubtractVectorF(
					p,
					_point.xyz(),
					p);

				GW::MATH::GVector::DotF(
					p,
					p,
					_outDistance);

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToPlaneF(const MATH::GVECTORF _point, const MATH::GPLANEF _plane,
												   float& _outDistance)
			{
				GW::MATH::GVector::DotF(
					_plane.data.xyz(),
					_point.xyz(),
					_outDistance);
				_outDistance -= _plane.distance;
				_outDistance *= _outDistance;

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToSphereF(const MATH::GVECTORF _point, const MATH::GSPHEREF _sphere,
													float& _outDistance)
			{
				GW::MATH::GVECTORF p = {};
				ClosestPointToSphereF(
					_sphere,
					_point,
					p);

				GW::MATH::GVector::SubtractVectorF(
					p,
					_point.xyz(),
					p);

				GW::MATH::GVector::DotF(
					p,
					p,
					_outDistance);

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToCapsuleF(const MATH::GVECTORF _point, const MATH::GCAPSULEF _capsule,
													 float& _outDistance)
			{
				GW::MATH::GVECTORF p = {};
				ClosestPointToCapsuleF(
					_capsule,
					_point,
					p);

				GW::MATH::GVector::SubtractVectorF(
					p,
					_point.xyz(),
					p);

				GW::MATH::GVector::DotF(
					p,
					p,
					_outDistance);

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToAABBF(const MATH::GVECTORF _point, const MATH::GAABBMMF _aabb,
												  float& _outDistance)
			{

				_outDistance = 0.0f;

				for(int i = 0; i < 3; i++)
				{
					float v = _point.data[i];

					if(v < _aabb.min.data[i])
					{
						_outDistance += (_aabb.min.data[i] - v) * (_aabb.min.data[i] - v);
					}

					if(v > _aabb.max.data[i])
					{
						_outDistance += (v - _aabb.max.data[i]) * (v - _aabb.max.data[i]);
					}
				}

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToOBBF(const MATH::GVECTORF _point, const MATH::GOBBF _obb, float& _outDistance)
			{
				MATH::GVECTORF p = {};
				ClosestPointToOBBF(
					_obb,
					_point,
					p);

				GW::MATH::GVector::SubtractVectorF(
					p,
					_point,
					p);

				GW::MATH::GVector::DotF(
					p,
					p,
					_outDistance);

				return GReturn::SUCCESS;
			}

			static GReturn BarycentricF(const MATH::GVECTORF _a, const MATH::GVECTORF _b, const MATH::GVECTORF _c,
										const MATH::GVECTORF _p, MATH::GVECTORF& _outBarycentric)
			{
				MATH::GVECTORF difference_ba = {};
				GW::MATH::GVector::SubtractVectorF(
					_b,
					_a,
					difference_ba);

				MATH::GVECTORF difference_ca = {};
				GW::MATH::GVector::SubtractVectorF(
					_c,
					_a,
					difference_ca);

				MATH::GVECTORF triangle_n = {};
				GW::MATH::GVector::CrossVector3F(
					difference_ba,
					difference_ca,
					triangle_n);

				float x = G_ABS(triangle_n.x);
				float y = G_ABS(triangle_n.y);
				float z = G_ABS(triangle_n.z);

				// Degenerate triangle
				if(x + y + z < 0.000001f)
				{
					return GReturn::FAILURE;
				}

				float nominator_u = 0.0f;
				float nominator_v = 0.0f;
				float w = 0.0f;

				// Project to yz plane
				if(x >= y && x >= z)
				{
					// Area of pbc in yz plane
					GW::MATH::GVector::CrossVector2F(
						GW::MATH::GVECTORF{{{_p.y - _b.y,_b.y - _c.y}}},
						GW::MATH::GVECTORF{{{_p.z - _b.z,_b.z - _c.z}}},
						nominator_u);

					// Area of pca in yz plane
					GW::MATH::GVector::CrossVector2F(
						GW::MATH::GVECTORF{{{_p.y - _c.y,_c.y - _a.y}}},
						GW::MATH::GVECTORF{{{_p.z - _c.z,_c.z - _a.z}}},
						nominator_v);

					w = 1.0f / triangle_n.x;
				}
				// Project to the xz plane
				else if(y >= x && y >= z)
				{
					// Area of pbc in xz plane
					GW::MATH::GVector::CrossVector2F(
						GW::MATH::GVECTORF{{{_p.x - _b.x,_b.x - _c.x}}},
						GW::MATH::GVECTORF{{{_p.z - _b.z,_b.z - _c.z}}},
						nominator_u);

					// Area of pca in xz plane
					GW::MATH::GVector::CrossVector2F(
						GW::MATH::GVECTORF{{{_p.x - _c.x,_c.x - _a.x}}},
						GW::MATH::GVECTORF{{{_p.z - _c.z,_c.z - _a.z}}},
						nominator_v);

					w = 1.0f / (-triangle_n.y);
				}
				// Project to the xy plane
				else
				{
					// Area of pbc in xy plane
					GW::MATH::GVector::CrossVector2F(
						GW::MATH::GVECTORF{{{_p.x - _b.x,_b.x - _c.x}}},
						GW::MATH::GVECTORF{{{_p.y - _b.y,_b.y - _c.y}}},
						nominator_u);

					// Area of pca in xy plane
					GW::MATH::GVector::CrossVector2F(
						GW::MATH::GVECTORF{{{_p.x - _c.x,_c.x - _a.x}}},
						GW::MATH::GVECTORF{{{_p.y - _c.y,_c.y - _a.y}}},
						nominator_v);

					w = 1.0f / triangle_n.z;
				}

				float u = nominator_u * w;
				float v = nominator_v * w;

				_outBarycentric =
				{
					{
						{
							u,
							v,
							1.0f - u - v
						}
					}
				};

				return GReturn::SUCCESS;
			}

			// DOUBLE

			static GReturn ConvertAABBCEToAABBMMD(const MATH::GAABBCED _aabbCE, MATH::GAABBMMD& _outAABBMM)
			{
				_outAABBMM.min =
				{
					{
						{
							_aabbCE.center.x - _aabbCE.extent.x,
							_aabbCE.center.y - _aabbCE.extent.y,
							_aabbCE.center.z - _aabbCE.extent.z
						}
					}
				};

				_outAABBMM.max =
				{
					{
						{
							_aabbCE.center.x + _aabbCE.extent.x,
							_aabbCE.center.y + _aabbCE.extent.y,
							_aabbCE.center.z + _aabbCE.extent.z
						}
					}
				};

				return GReturn::SUCCESS;
			}

			static GReturn ConvertAABBMMToAABBCED(const MATH::GAABBMMD _aabbMM, MATH::GAABBCED& _outAABCE)
			{
				_outAABCE.center =
				{
					{
						{
							(_aabbMM.min.x + _aabbMM.max.x) * 0.5,
							(_aabbMM.min.y + _aabbMM.max.y) * 0.5,
							(_aabbMM.min.z + _aabbMM.max.z) * 0.5
						}
					}
				};

				_outAABCE.extent =
				{
					{
						{
							_aabbMM.max.x - _outAABCE.center.x,
							_aabbMM.max.y - _outAABCE.center.y,
							_aabbMM.max.z - _outAABCE.center.z
						}
					}
				};

				return GReturn::SUCCESS;
			}

			static GReturn ComputePlaneD(const MATH::GVECTORD _planePositionA, const MATH::GVECTORD _planePositionB,
										 const MATH::GVECTORD _planePositionC, MATH::GPLANED& _outPlane)
			{
				GW::MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					_planePositionB,
					_planePositionA,
					difference_ba);

				GW::MATH::GVECTORD difference_ca = {};
				GW::MATH::GVector::SubtractVectorD(
					_planePositionC,
					_planePositionA,
					difference_ca);

				GW::MATH::GVector::CrossVector3D(
					difference_ca,
					difference_ba,
					_outPlane.data);

				if(GW::MATH::GVector::NormalizeD(_outPlane.data, _outPlane.data) == GReturn::FAILURE)
				{
					 // ba and ca are parallel which degenerates to a line.
					return GReturn::FAILURE;
				}

				GW::MATH::GVector::DotD(
					_outPlane.data,
					_planePositionA.xyz(),
					_outPlane.distance);

				return GReturn::SUCCESS;
			}

			static GReturn IsTriangleD(const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult)
			{
				MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle.b,
					_triangle.a,
					difference_ba);

				MATH::GVECTORD difference_ca = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle.c,
					_triangle.a,
					difference_ca);

				MATH::GVECTORD triangle_normal = {};
				GW::MATH::GVector::CrossVector3D(
					difference_ba,
					difference_ca,
					triangle_normal);

				double triangle_area = 0;
				GW::MATH::GVector::DotD(
					triangle_normal,
					triangle_normal,
					triangle_area);

				_outResult = (G_ABS(triangle_area) < 1.192092896e-07) ? GCollisionCheck::NO_COLLISION : GCollisionCheck::COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToConvexPolygonD(const MATH::GVECTORD _queryPoint, const MATH::GVECTORD* _polygonPoints,
													 const unsigned int _pointsCount, GCollisionCheck& _outResult)
			{
				if(!_polygonPoints || _pointsCount < 3)
				{
					return GReturn::FAILURE;
				}

				auto Collinear = [&](const GW::MATH::GVECTORD p, const GW::MATH::GLINED l)
				{
					if(p.x <= G_LARGER(l.start.x, l.end.x) && p.x <= G_SMALLER(l.start.x, l.end.x) &&
					   p.y <= G_LARGER(l.start.y, l.end.y) && p.y <= G_SMALLER(l.start.y, l.end.y))
					{
						return true;
					}

					return false;
				};

				auto Area2D = [&](const MATH::GVECTORD a, const MATH::GVECTORD b, const MATH::GVECTORD p)
				{
					double winding = 0;

					GW::MATH::GVECTORD difference_pa = {};
					GW::MATH::GVector::SubtractVectorD(
						p,
						a,
						difference_pa);

					GW::MATH::GVECTORD difference_ba = {};
					GW::MATH::GVector::SubtractVectorD(
						b,
						a,
						difference_ba);

					GW::MATH::GVector::CrossVector2D(
						difference_pa,
						difference_ba,
						winding);

					if(G_ABS(winding) < 0.000001f)
					{
						return 0;
					}
					else if(winding > 0.0f)
					{
						return 1;
					}
					else
					{
						return -1;
					}
				};

				auto IsCrossing = [&](const GW::MATH::GLINED l1, const GW::MATH::GLINED l2)
				{
					int winding1 = Area2D(l1.start, l1.end, l2.start);
					int winding2 = Area2D(l1.start, l1.end, l2.end);
					int winding3 = Area2D(l2.start, l2.end, l1.start);
					int winding4 = Area2D(l2.start, l2.end, l1.end);

					if(winding1 != winding2 && winding3 != winding4)
					{
						return true;
					}
					if(winding1 == 0 && Collinear(l2.start, l1))
					{
						return true;
					}
					if(winding2 == 0 && Collinear(l2.end, l1))
					{
						return true;
					}
					if(winding3 == 0 && Collinear(l1.start, l2))
					{
						return true;
					}
					if(winding4 == 0 && Collinear(l1.end, l2))
					{
						return true;
					}

					return false;
				};

				GW::MATH::GLINED inf_line =
				{
					{
						{
							{{{_queryPoint.x, _queryPoint.y, 0.0f, 0.0f}}},
							{{{static_cast<double>(0xffffffff), _queryPoint.y}}}
						}
					}
				};

				int count = 0;
				int i = 0;

				do
				{
					GW::MATH::GLINED side = {};
					side.start = _polygonPoints[i];
					side.end = _polygonPoints[(i + 1) % _pointsCount];

					if(IsCrossing(side, inf_line))
					{
						if(Area2D(side.start, _queryPoint, side.end) == 0)
						{
							_outResult = static_cast<GCollisionCheck>(Collinear(_queryPoint, side));
							return GReturn::SUCCESS;
						}
						count++;
					}

					i = (i + 1) % _pointsCount;
				}
				while(i != 0);

				_outResult = static_cast<GCollisionCheck>(count & 1);
				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToLineD(const MATH::GLINED _line, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				MATH::GVECTORD line_a = _line.start.xyz();

				MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					_line.end.xyz(),
					line_a,
					difference_ba);

				MATH::GVECTORD difference_pa = {};
				GW::MATH::GVector::SubtractVectorD(
					_queryPoint.xyz(),
					line_a,
					difference_pa);

				double interval = 0.0;
				GW::MATH::GVector::DotD(
					difference_pa,
					difference_ba,
					interval);

				double sq_length = 0.0;
				GW::MATH::GVector::DotD(
					difference_ba,
					difference_ba,
					sq_length);

				// If line degenerates to point
				if(sq_length <= 1.192092896e-07)
				{
					_outPoint = line_a;
					return GReturn::SUCCESS;
				}

				interval /= sq_length;

				interval = G_CLAMP(
					interval,
					0.0,
					1.0f);

				GW::MATH::GVector::ScaleD(
					difference_ba,
					interval,
					_outPoint);

				GW::MATH::GVector::AddVectorD(
					line_a,
					_outPoint,
					_outPoint);

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointsToLineFromLineD(const MATH::GLINED _line1, const MATH::GLINED _line2, MATH::GVECTORD& _outPoint1, MATH::GVECTORD& _outPoint2)
			{
				MATH::GLINED line1 =
				{
					{
						{
							_line1.start.xyz(),
							_line1.end.xyz()
						}
					}
				};

				MATH::GLINED line2 =
				{
					{
						{
							_line2.start.xyz(),
							_line2.end.xyz()
						}
					}
				};

				MATH::GVECTORD direction1 = {};
				GW::MATH::GVector::SubtractVectorD(
					line1.end,
					line1.start,
					direction1);

				MATH::GVECTORD direction2 = {};
				GW::MATH::GVector::SubtractVectorD(
					line2.end,
					line2.start,
					direction2);

				MATH::GVECTORD distance = {};
				GW::MATH::GVector::SubtractVectorD(
					line1.start,
					line2.start,
					distance);

				double sq_length1 = 0.0;
				GW::MATH::GVector::DotD(
					direction1,
					direction1,
					sq_length1);

				double sq_length2 = 0.0;
				GW::MATH::GVector::DotD(
					direction2,
					direction2,
					sq_length2);

				double f = 0.0;
				GW::MATH::GVector::DotD(
					direction2,
					distance,
					f);

				double interval1 = 0.0;
				double interval2 = 0.0;

				int use_cases = 0x00;

				// First line degenerates to a point.
				if(sq_length1 <= 1.192092896e-07)
				{
					use_cases |= 0x01;
				}

				// Second line degenerates to a point.
				if(sq_length2 <= 1.192092896e-07)
				{
					use_cases |= 0x02;
				}

				switch(use_cases)
				{
					// First line degenerates to a point.
					case 0x01:
					{
						interval2 = f / sq_length2;
						interval2 = G_CLAMP(
							interval2,
							0.0,
							1.0f);
					}
					break;
					// Second line degenerates to a point.
					case 0x02:
					{
						double c = 0.0;
						GW::MATH::GVector::DotD(
							direction1,
							distance,
							c);

						interval1 = G_CLAMP(
							-c / sq_length1,
							0.0,
							1.0f);
					}
					break;
					// Both lines degenerate to a point.
					case 0x03:
					{
						_outPoint1 = line1.start.xyz();
						_outPoint2 = line2.start.xyz();
						return GReturn::SUCCESS;
					}
					break;
					default:
					{
						double c = 0.0;
						GW::MATH::GVector::DotD(
							direction1,
							distance,
							c);

						double b = 0.0;
						GW::MATH::GVector::DotD(
							direction1,
							direction2,
							b);

						double denom = sq_length1 * sq_length2 - b * b;

						// Get interval for the first line from the second line unless lines are parallel.
						if(denom != 0.0)
						{
							interval1 = G_CLAMP(
								(b * f - c * sq_length2) / denom,
								0.0,
								1.0f);
						}
						else
						{
							interval1 = 0.0;
						}

						// Get interval for the second line.
						interval2 = (b * interval1 + f) / sq_length2;

						if(interval2 < 0.0)
						{
							interval2 = 0.0;

							interval1 = G_CLAMP(
								-c / sq_length1,
								0.0,
								1.0f);
						}
						else if(interval2 > 1.0f)
						{
							interval2 = 1.0f;

							interval1 = G_CLAMP(
								(b - c) / sq_length1,
								0.0,
								1.0f);
						}
					}
					break;
				}

				GW::MATH::GVector::ScaleD(
					direction1,
					interval1,
					direction1);

				GW::MATH::GVector::AddVectorD(
					line1.start,
					direction1,
					_outPoint1);

				GW::MATH::GVector::ScaleD(
					direction2,
					interval2,
					direction2);

				GW::MATH::GVector::AddVectorD(
					line2.start,
					direction2,
					_outPoint2);

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToRayD(const MATH::GRAYD _ray, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				MATH::GVECTORD line_a = _ray.position.xyz();
				MATH::GVECTORD line_direction = _ray.direction.xyz();

				MATH::GVECTORD difference_pa = {};
				GW::MATH::GVector::SubtractVectorD(
					_queryPoint.xyz(),
					line_a,
					difference_pa);

				double interval = 0.0;
				GW::MATH::GVector::DotD(
					difference_pa,
					line_direction,
					interval);

				double sq_length = 0.0;
				GW::MATH::GVector::DotD(
					line_direction,
					line_direction,
					sq_length);

				// If line degenerates to point
				if(sq_length <= 1.192092896e-07)
				{
					_outPoint = line_a;
					return GReturn::SUCCESS;
				}

				interval /= sq_length;

				interval = interval < 0.0 ? 0.0 : interval;

				GW::MATH::GVector::ScaleD(
					line_direction,
					interval,
					_outPoint);

				GW::MATH::GVector::AddVectorD(
					line_a,
					_outPoint,
					_outPoint);

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToTriangleD(const MATH::GTRIANGLED _triangle, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				GW::MATH::GVECTORD a = _triangle.a.xyz();
				GW::MATH::GVECTORD b = _triangle.b.xyz();
				GW::MATH::GVECTORD c = _triangle.c.xyz();
				GW::MATH::GVECTORD p = _queryPoint.xyz();

				MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					b,
					a,
					difference_ba);

				MATH::GVECTORD difference_ca = {};
				GW::MATH::GVector::SubtractVectorD(
					c,
					a,
					difference_ca);

				MATH::GVECTORD difference_pa = {};
				GW::MATH::GVector::SubtractVectorD(
					p,
					a,
					difference_pa);

				double dot1 = 0.0;
				GW::MATH::GVector::DotD(
					difference_ba,
					difference_pa,
					dot1);

				double dot2 = 0.0;
				GW::MATH::GVector::DotD(
					difference_ca,
					difference_pa,
					dot2);

				// p is closest to vertex a
				if(dot1 <= 1.192092896e-07 && dot2 <= 1.192092896e-07)
				{
					_outPoint = a;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORD difference_pb = {};
				GW::MATH::GVector::SubtractVectorD(
					p,
					b,
					difference_pb);

				double dot3 = 0.0;
				GW::MATH::GVector::DotD(
					difference_ba,
					difference_pb,
					dot3);

				double dot4 = 0.0;
				GW::MATH::GVector::DotD(
					difference_ca,
					difference_pb,
					dot4);

				// p is closest to vertex b
				if(dot3 >= 1.192092896e-07 && dot4 <= dot3)
				{
					_outPoint = b;
					return GReturn::SUCCESS;
				}

				double vc = dot1 * dot4 - dot3 * dot2;

				// p is closest to edge ab
				if(vc <= 1.192092896e-07 && dot1 >= 1.192092896e-07 && dot3 <= 1.192092896e-07)
				{
					double interval = dot1 / (dot1 - dot3);

					GW::MATH::GVector::ScaleD(
						difference_ba,
						interval,
						_outPoint);

					GW::MATH::GVector::AddVectorD(
						a,
						_outPoint,
						_outPoint);

					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORD difference_pc = {};
				GW::MATH::GVector::SubtractVectorD(
					p,
					c,
					difference_pc);

				double dot5 = 0.0;
				GW::MATH::GVector::DotD(
					difference_ca,
					difference_pc,
					dot5);

				double dot6 = 0.0;
				GW::MATH::GVector::DotD(
					difference_ba,
					difference_pc,
					dot6);

				// p is closest to vertex c
				if(dot5 >= 1.192092896e-07 && dot6 <= dot5)
				{
					_outPoint = c;
					return GReturn::SUCCESS;
				}

				double vb = dot6 * dot2 - dot1 * dot5;
				// p is closest to edge ac
				if(vb <= 1.192092896e-07 && dot2 >= 1.192092896e-07 && dot5 <= 1.192092896e-07)
				{
					double interval = dot2 / (dot2 - dot5);

					GW::MATH::GVector::ScaleD(
						difference_ca,
						interval,
						_outPoint);

					GW::MATH::GVector::AddVectorD(
						a,
						_outPoint,
						_outPoint);

					return GReturn::SUCCESS;
				}

				double va = dot3 * dot5 - dot6 * dot4;
				// p is closest to edge bc
				if(va <= 1.192092896e-07 && (dot4 - dot3) >= 1.192092896e-07 && (dot6 - dot5) >= 1.192092896e-07)
				{
					double h = dot4 - dot3;
					double interval = h / (h + dot6 - dot5);

					GW::MATH::GVector::SubtractVectorD(
						c,
						b,
						_outPoint);

					GW::MATH::GVector::ScaleD(
						_outPoint,
						interval,
						_outPoint);

					GW::MATH::GVector::AddVectorD(
						b,
						_outPoint,
						_outPoint);

					return GReturn::SUCCESS;
				}

				// p is closest to some point on the face
				double denom = 1.0 / (va + vb + vc);
				double v = vb * denom;
				double w = vc * denom;

				GW::MATH::GVector::ScaleD(
					difference_ba,
					v,
					_outPoint);

				GW::MATH::GVECTORD acw = {};
				GW::MATH::GVector::ScaleD(
					difference_ca,
					w,
					acw);

				GW::MATH::GVector::AddVectorD(
					acw,
					_outPoint,
					_outPoint);

				GW::MATH::GVector::AddVectorD(
					a,
					_outPoint,
					_outPoint);

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToPlaneD(const MATH::GPLANED _plane, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				MATH::GVECTORD plane_normal = _plane.data.xyz();
				MATH::GVECTORD query_point = _queryPoint.xyz();

				double interval = 0.0;
				GW::MATH::GVector::DotD(
					plane_normal,
					query_point,
					interval);

				interval -= _plane.distance;

				GW::MATH::GVector::ScaleD(
					plane_normal,
					interval,
					_outPoint);

				GW::MATH::GVector::SubtractVectorD(
					query_point,
					_outPoint,
					_outPoint);

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToSphereD(const MATH::GSPHERED _sphere, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				GW::MATH::GVECTORD direction = {};
				GW::MATH::GVector::SubtractVectorD(
					_queryPoint,
					_sphere.data,
					direction);

				if(GW::MATH::GVector::NormalizeD(direction.xyz(), direction) == GReturn::FAILURE)
				{
					_outPoint = _queryPoint;
					return GReturn::FAILURE;
				}

				GW::MATH::GVector::ScaleD(
					direction,
					_sphere.radius,
					direction);

				GW::MATH::GVector::AddVectorD(
					_sphere.data.xyz(),
					direction,
					_outPoint);

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToCapsuleD(const MATH::GCAPSULED _capsule, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				ClosestPointToLineD(
					{{{_capsule.data[0].xyz(),_capsule.data[1].xyz()}}},
					_queryPoint,
					_outPoint);

				return ClosestPointToSphereD(
					{{{_outPoint.x, _outPoint.y, _outPoint.z, _capsule.radius}}},
					_queryPoint,
					_outPoint);
			}

			static GReturn ClosestPointToAABBD(const MATH::GAABBMMD _aabb, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				for(int i = 0; i < 3; i++)
				{
					_outPoint.data[i] = _queryPoint.data[i];

					_outPoint.data[i] = G_LARGER(
						_outPoint.data[i],
						_aabb.min.data[i]);

					_outPoint.data[i] = G_SMALLER(
						_outPoint.data[i],
						_aabb.max.data[i]);
				}

				if(G_ABS(_queryPoint.x - _outPoint.x) < 1.192092896e-07 &&
				   G_ABS(_queryPoint.y - _outPoint.y) < 1.192092896e-07 &&
				   G_ABS(_queryPoint.z - _outPoint.z) < 1.192092896e-07)
				{
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn ClosestPointToOBBD(const MATH::GOBBD _obb, const MATH::GVECTORD _queryPoint, MATH::GVECTORD& _outPoint)
			{
				double xx2 = 2.0f * _obb.rotation.x * _obb.rotation.x;
				double yy2 = 2.0f * _obb.rotation.y * _obb.rotation.y;
				double zz2 = 2.0f * _obb.rotation.z * _obb.rotation.z;
				double xy2 = 2.0f * _obb.rotation.x * _obb.rotation.y;
				double xz2 = 2.0f * _obb.rotation.x * _obb.rotation.z;
				double yz2 = 2.0f * _obb.rotation.y * _obb.rotation.z;
				double wx2 = 2.0f * _obb.rotation.w * _obb.rotation.x;
				double wy2 = 2.0f * _obb.rotation.w * _obb.rotation.y;
				double wz2 = 2.0f * _obb.rotation.w * _obb.rotation.z;

				MATH::GVECTORD obb_rotation[3] =
				{
					{{{1.0f - yy2 - zz2, xy2 - wz2, xz2 + wy2}}},
					{{{xy2 + wz2, 1.0f - xx2 - zz2, yz2 - wx2}}},
					{{{xz2 - wy2, yz2 + wx2, 1.0f - xx2 - yy2}}}
				};

				MATH::GVECTORD difference = {};
				GW::MATH::GVector::SubtractVectorD(
					_queryPoint.xyz(),
					_obb.data->xyz(),
					difference);

				_outPoint = _obb.center.xyz();

				MATH::GVECTORD world_coord = {};

				double distance = 0.0;

				for(int i = 0; i < 3; i++)
				{
					// Project the difference to this axis
					GW::MATH::GVector::DotD(
						difference,
						obb_rotation[i],
						distance);

					// Clamp to boundary
					distance = G_SMALLER(
						distance,
						_obb.extent.data[i]);

					distance = G_LARGER(
						distance,
						-_obb.extent.data[i]);

					GW::MATH::GVector::ScaleD(
						obb_rotation[i],
						distance,
						world_coord);

					GW::MATH::GVector::AddVectorD(
						_outPoint,
						world_coord,
						_outPoint);
				}

				if(G_ABS(_queryPoint.x - _outPoint.x) < 1.192092896e-07 &&
				   G_ABS(_queryPoint.y - _outPoint.y) < 1.192092896e-07 &&
				   G_ABS(_queryPoint.z - _outPoint.z) < 1.192092896e-07)
				{
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn ComputeSphereFromPointsD(const MATH::GVECTORD* _pointCloud, const unsigned int _pointsCount, MATH::GSPHERED& _outSphere)
			{
				if(!_pointCloud || _pointsCount < 2)
				{
					return GReturn::FAILURE;
				}

				// Find a good almost bounding sphere
				unsigned int min_x = 0;
				unsigned int max_x = 0;
				unsigned int min_y = 0;
				unsigned int max_y = 0;
				unsigned int min_z = 0;
				unsigned int max_z = 0;

				for(unsigned int i = 1; i < _pointsCount; i++)
				{
					if(_pointCloud[i].x < _pointCloud[min_x].x)
					{
						min_x = i;
					}
					if(_pointCloud[i].x > _pointCloud[max_x].x)
					{
						max_x = i;
					}

					if(_pointCloud[i].y < _pointCloud[min_y].y)
					{
						min_y = i;
					}
					if(_pointCloud[i].y > _pointCloud[max_y].y)
					{
						max_y = i;
					}

					if(_pointCloud[i].z < _pointCloud[min_z].z)
					{
						min_z = i;
					}
					if(_pointCloud[i].z > _pointCloud[max_z].z)
					{
						max_z = i;
					}
				}

				GW::MATH::GVECTORD difference = {};
				GW::MATH::GVector::SubtractVectorD(
					_pointCloud[max_x],
					_pointCloud[min_x],
					difference);

				double sq_distance_x = 0.0;
				GW::MATH::GVector::DotD(
					difference,
					difference,
					sq_distance_x);

				GW::MATH::GVector::SubtractVectorD(
					_pointCloud[max_y],
					_pointCloud[min_y],
					difference);

				double sq_distance_y = 0.0;
				GW::MATH::GVector::DotD(
					difference,
					difference,
					sq_distance_y);

				GW::MATH::GVector::SubtractVectorD(
					_pointCloud[max_z],
					_pointCloud[min_z],
					difference);

				double sq_distance_z = 0.0;
				GW::MATH::GVector::DotD(
					difference,
					difference,
					sq_distance_z);

				int min = min_x;
				int max = max_x;

				if((sq_distance_y > sq_distance_x) && (sq_distance_y > sq_distance_z))
				{
					min = min_y;
					max = max_y;
				}

				if((sq_distance_z > sq_distance_x) && (sq_distance_z > sq_distance_y))
				{
					min = min_z;
					max = max_z;
				}

				GW::MATH::GVector::AddVectorD(
					_pointCloud[min].xyz(),
					_pointCloud[max].xyz(),
					_outSphere.data);

				GW::MATH::GVector::ScaleD(
					_outSphere.data,
					0.5f,
					_outSphere.data);

				GW::MATH::GVector::SubtractVectorD(
					_pointCloud[max].xyz(),
					_outSphere.data,
					difference);

				GW::MATH::GVector::DotD(
					difference,
					difference,
					_outSphere.radius);

				_outSphere.radius = sqrt(_outSphere.radius);

				// Improve the bound and include all points
				auto UpdateSphereBounds = [&](const MATH::GVECTORD p, MATH::GSPHERED& outSphere)
				{
					GW::MATH::GVECTORD difference = {};
					GW::MATH::GVector::SubtractVectorD(
						p.xyz(),
						outSphere.data.xyz(),
						difference);

					double sq_distance = 0.0;
					GW::MATH::GVector::DotD(
						difference,
						difference,
						sq_distance);

					if(sq_distance > outSphere.radius* outSphere.radius)
					{
						double distance = sqrt(sq_distance);
						double radius = (outSphere.radius + distance) * 0.5f;
						double increase = (radius - outSphere.radius) / distance;

						GW::MATH::GVector::ScaleD(
							difference,
							increase,
							difference);

						GW::MATH::GVector::AddVectorD(
							outSphere.data,
							difference,
							outSphere.data);

						outSphere.radius = radius;
					}
				};

				for(unsigned int i = 0; i < _pointsCount; i++)
				{
					UpdateSphereBounds(
						_pointCloud[i],
						_outSphere);
				}

				return GReturn::SUCCESS;
			}

			static GReturn ComputeAABBFromPointsD(const MATH::GVECTORD* _pointCloud, const unsigned int _pointsCount, MATH::GAABBMMD& _outAABB)
			{
				if(!_pointCloud || _pointsCount == 0)
				{
					return GReturn::FAILURE;
				}

				_outAABB.min = _pointCloud[0];
				_outAABB.max = _pointCloud[0];

				for(unsigned int i = 1; i < _pointsCount; i++)
				{
					if(_outAABB.min.x > _pointCloud[i].x)
					{
						_outAABB.min.x = _pointCloud[i].x;
					}
					if(_outAABB.max.x < _pointCloud[i].x)
					{
						_outAABB.max.x = _pointCloud[i].x;
					}

					if(_outAABB.min.y > _pointCloud[i].y)
					{
						_outAABB.min.y = _pointCloud[i].y;
					}
					if(_outAABB.max.y < _pointCloud[i].y)
					{
						_outAABB.max.y = _pointCloud[i].y;
					}

					if(_outAABB.min.z > _pointCloud[i].z)
					{
						_outAABB.min.z = _pointCloud[i].z;
					}
					if(_outAABB.max.z < _pointCloud[i].z)
					{
						_outAABB.max.z = _pointCloud[i].z;
					}
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToLineD(const MATH::GVECTORD _point, const MATH::GLINED _line, GCollisionCheck& _outResult)
			{
				MATH::GVECTORD point = _point.xyz();

				MATH::GLINED line =
				{
					{
						{
							_line.start.xyz(),
							_line.end.xyz()
						}
					}
				};

				GW::MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					line.end,
					line.start,
					difference_ba);

				double distance_ba = 0.0;
				GW::MATH::GVector::DotD(
					difference_ba,
					difference_ba,
					distance_ba);
				distance_ba = sqrt(distance_ba);

				GW::MATH::GVECTORD difference_pa = {};
				GW::MATH::GVector::SubtractVectorD(
					point,
					line.start,
					difference_pa);

				double distance_pa = 0.0;
				GW::MATH::GVector::DotD(
					difference_pa,
					difference_pa,
					distance_pa);
				distance_pa = sqrt(distance_pa);

				GW::MATH::GVECTORD difference_bp = {};
				GW::MATH::GVector::SubtractVectorD(
					line.end,
					point,
					difference_bp);

				double distance_bp = 0.0;
				GW::MATH::GVector::DotD(
					difference_bp,
					difference_bp,
					distance_bp);
				distance_bp = sqrt(distance_bp);

				_outResult = (G_COMPARISON_STANDARD_D(distance_ba, distance_pa + distance_bp)) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToRayD(const MATH::GVECTORD _point, const MATH::GRAYD _ray, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD difference_pa = {};
				GW::MATH::GVector::SubtractVectorD(
					_point.xyz(),
					_ray.position.xyz(),
					difference_pa);

				// Point is ray position
				if(GW::MATH::GVector::NormalizeD(difference_pa, difference_pa) == GReturn::FAILURE)
				{
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_ABS(difference_pa.x - _ray.direction.x) < 1.192092896e-07 &&
				   G_ABS(difference_pa.y - _ray.direction.y) < 1.192092896e-07 &&
				   G_ABS(difference_pa.z - _ray.direction.z) < 1.192092896e-07)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck::NO_COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToTriangleD(const MATH::GVECTORD _point, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD* _outBarycentric)
			{
				MATH::GPLANED plane = {};
				if(ComputePlaneD(_triangle.a, _triangle.b, _triangle.c, plane) == GReturn::FAILURE)
				{
					// Degenerate triangle.
					return GReturn::FAILURE;
				}

				TestPointToPlaneD(
					_point,
					plane,
					_outResult);

				if(static_cast<int>(_outResult) > 0)
				{
					MATH::GVECTORD barycentric = {};
					// Compute plane already handles fail case of degenerate triangle.
					BarycentricD(_triangle.a, _triangle.b, _triangle.c, _point, barycentric);

					_outResult = (barycentric.y >= 0.0 && barycentric.z >= 0.0 && (barycentric.y + barycentric.z) <= 1.0) ?
						GCollisionCheck::COLLISION :
						GCollisionCheck::NO_COLLISION;

					if(_outBarycentric)
					{
						*_outBarycentric = barycentric;
					}
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToPlaneD(const MATH::GVECTORD _point, const MATH::GPLANED _plane, GCollisionCheck& _outResult)
			{
				double distance = 0.0;
				GW::MATH::GVector::DotD(
					_point.xyz(),
					_plane.data.xyz(),
					distance);
				distance = distance - _plane.distance;

				if(distance < -1.192092896e-07)
				{
					_outResult = GCollisionCheck::BELOW;
				}
				else if(G_ABS(distance) <= 1.192092896e-07)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck::ABOVE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToSphereD(const MATH::GVECTORD _point, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					_point,
					_sphere.data.xyz(),
					difference_ba);

				double sq_distance = 0.0;
				GW::MATH::GVector::DotD(
					difference_ba,
					difference_ba,
					sq_distance);

				double sq_radius = _sphere.radius * _sphere.radius;

				_outResult = sq_distance <= sq_radius ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToCapsuleD(const MATH::GVECTORD _point, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult)
			{
				GW::MATH::GSPHERED sphere = {};

				if(ClosestPointToCapsuleD(_capsule, _point, sphere.data) == GReturn::FAILURE)
				{
					// Point is center of capsule
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				sphere.radius = _capsule.radius;
				return TestPointToSphereD(
					_point,
					sphere,
					_outResult);
			}

			static GReturn TestPointToAABBD(const MATH::GVECTORD _point, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult)
			{
				if(G_ABS(_aabb.center.x - _point.x) - _aabb.extent.x > 1.192092896e-07 ||
				   G_ABS(_aabb.center.y - _point.y) - _aabb.extent.y > 1.192092896e-07 ||
				   G_ABS(_aabb.center.z - _point.z) - _aabb.extent.z > 1.192092896e-07)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck::COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPointToOBBD(const MATH::GVECTORD _point, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD closest_point = {};

				ClosestPointToOBBD(
					_obb,
					_point,
					closest_point);

				if(G_ABS(closest_point.x - _point.x) > 1.192092896e-07 ||
				   G_ABS(closest_point.y - _point.y) > 1.192092896e-07 ||
				   G_ABS(closest_point.z - _point.z) > 1.192092896e-07)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck::COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToLineD(const MATH::GLINED _line1, const MATH::GLINED _line2, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD closest_point1 = {};
				GW::MATH::GVECTORD closest_point2 = {};

				ClosestPointsToLineFromLineD(
					_line1,
					_line2,
					closest_point1,
					closest_point2);

				if(G_ABS(closest_point1.x - closest_point2.x) > 1.192092896e-07 ||
				   G_ABS(closest_point1.y - closest_point2.y) > 1.192092896e-07 ||
				   G_ABS(closest_point1.z - closest_point2.z) > 1.192092896e-07)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
				}
				else
				{
					_outResult = GCollisionCheck::COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToRayD(const MATH::GLINED _line, const MATH::GRAYD _ray, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD closest_point1 = {};
				ClosestPointToRayD(
					_ray,
					_line.start,
					closest_point1);

				GW::MATH::GVECTORD closest_point2 = {};
				ClosestPointToRayD(
					_ray,
					_line.end,
					closest_point2);

				return TestLineToLineD(
					_line,
					{{{closest_point1, closest_point2}}},
					_outResult);
			}

			static GReturn TestLineToTriangleD(const MATH::GLINED _line, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD* _outBarycentric)
			{
				MATH::GLINED line =
				{
					{
						{
							_line.start.xyz(),
							_line.end.xyz()
						}
					}
				};

				MATH::GTRIANGLED triangle =
				{
					{
						{
							_triangle.a.xyz(),
							_triangle.b.xyz(),
							_triangle.c.xyz()
						}
					}
				};

				GW::MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					triangle.b,
					triangle.a,
					difference_ba);

				GW::MATH::GVECTORD difference_ca = {};
				GW::MATH::GVector::SubtractVectorD(
					triangle.c,
					triangle.a,
					difference_ca);

				GW::MATH::GVECTORD norm = {};
				GW::MATH::GVector::CrossVector3D(
					difference_ca,
					difference_ba,
					norm);

				GW::MATH::GVECTORD difference_line = {};
				GW::MATH::GVector::SubtractVectorD(
					line.start,
					line.end,
					difference_line);

				double dot = 0.0;
				GW::MATH::GVector::DotD(
					difference_line,
					norm,
					dot);

				// Segment is parallel to triangle
				if(dot <= 0.0)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORD difference_pa = {};
				GW::MATH::GVector::SubtractVectorD(
					line.start,
					triangle.a,
					difference_pa);

				double interval = 0.0;
				GW::MATH::GVector::DotD(
					difference_pa,
					norm,
					interval);

				if(interval < 0.0 || interval > dot)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORD cross = {};
				GW::MATH::GVector::CrossVector3D(
					difference_line,
					difference_pa,
					cross);

				// Test to see if within bounds of barycentric coordinates.
				GW::MATH::GVECTORD barycentric = {};
				GW::MATH::GVector::DotD(
					difference_ca,
					cross,
					barycentric.y);
				barycentric.y = -barycentric.y;

				if(barycentric.y < 0.0 || barycentric.y > dot)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVector::DotD(
					difference_ba,
					cross,
					barycentric.z);

				if(barycentric.z < 0.0 || barycentric.y + barycentric.z > dot)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(_outBarycentric)
				{
					double over_denom = 1.0 / dot;

					barycentric.y *= over_denom;
					barycentric.z *= over_denom;

					*_outBarycentric =
					{
						{
							{
								1.0 - barycentric.y - barycentric.z,
						barycentric.y,
						barycentric.z
							}
						}
					};
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestLineToPlaneD(const MATH::GLINED _line, const MATH::GPLANED _plane, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					_line.end.xyz(),
					_line.start.xyz(),
					difference_ba);

				double denom = 0.0;
				GW::MATH::GVector::DotD(
					_plane.data.xyz(),
					difference_ba,
					denom);

				double num = 0.0;
				GW::MATH::GVector::DotD(
					_plane.data.xyz(),
					_line.start.xyz(),
					num);

				if(G_ABS(denom) < 1.192092896e-07)
				{
					// Coplanar
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				double interval = (_plane.distance - num) / denom;

				if(interval >= 0.0 && interval <= 1.0f)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					// Half plane test
					num -= _plane.distance;
					_outResult = (num < 0.0) ?
						_outResult = GCollisionCheck::BELOW :
						_outResult = GCollisionCheck::ABOVE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestLineToSphereD(const MATH::GLINED _line, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD closest_point = {};
				ClosestPointToLineD(
					_line,
					_sphere.data,
					closest_point);

				return TestPointToSphereD(
					closest_point,
					_sphere,
					_outResult);
			}

			static GReturn TestLineToCapsuleD(const MATH::GLINED _line, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD closest_point1 = {};
				GW::MATH::GVECTORD closest_point2 = {};
				ClosestPointsToLineFromLineD(
					_line,
					{{{_capsule.data[0],_capsule.data[1]}}},
					closest_point1,
					closest_point2);

				return TestPointToSphereD(
					closest_point1,
					{{{closest_point2.x,closest_point2.y,closest_point2.z,_capsule.radius}}},
					_outResult);
			}

			static GReturn TestLineToAABBD(const MATH::GLINED _line, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult)
			{
				MATH::GLINED line =
				{
					{
						{
							_line.start.xyz(),
							_line.end.xyz()
						}
					}
				};

				GW::MATH::GVECTORD extent = _aabb.extent.xyz();

				GW::MATH::GVECTORD line_midpoint = {};
				GW::MATH::GVector::AddVectorD(
					line.start,
					line.end,
					line_midpoint);

				GW::MATH::GVector::ScaleD(
					line_midpoint,
					0.5f,
					line_midpoint);

				GW::MATH::GVECTORD line_mid_length = {};
				GW::MATH::GVector::SubtractVectorD(
					line.end,
					line_midpoint,
					line_mid_length);

				// Translate box and line to origin
				GW::MATH::GVECTORD origin = {};
				GW::MATH::GVector::SubtractVectorD(
					line_midpoint,
					_aabb.center.xyz(),
					origin);

				GW::MATH::GVECTORD axis =
				{
					{
						{
							G_ABS(line_mid_length.x),
							G_ABS(line_mid_length.y),
							G_ABS(line_mid_length.z)
						}
					}
				};

				// Separating axes
				for(int i = 0; i < 3; i++)
				{
					if(G_ABS(origin.data[i]) > extent.data[i] + axis.data[i])
					{
						_outResult = GCollisionCheck::NO_COLLISION;
						return GReturn::SUCCESS;
					}
				}

				axis.x += 1.192092896e-07;
				axis.y += 1.192092896e-07;
				axis.z += 1.192092896e-07;

				if(G_ABS(origin.y * line_mid_length.z - origin.z * line_mid_length.y) >
				   extent.y* axis.z + extent.z * axis.y)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_ABS(origin.z * line_mid_length.x - origin.x * line_mid_length.z) >
				   extent.x* axis.z + extent.z * axis.x)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_ABS(origin.x * line_mid_length.z - origin.y * line_mid_length.x) >
				   extent.x* axis.y + extent.z * axis.x)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestLineToOBBD(const MATH::GLINED _line, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				MATH::GLINED line =
				{
					{
						{
							_line.start,
							_line.end
						}
					}
				};
				line.start.w = 1.0f;
				line.end.w = 1.0f;

				MATH::GMATRIXD obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionD(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXD obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0}}},
							{{{0.0, 0.0, 0.0, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					line.start,
					line.start);
				GW::MATH::GVector::AddVectorD(
					line.start,
					_obb.center,
					line.start);

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					line.end,
					line.end);
				GW::MATH::GVector::AddVectorD(
					line.end,
					_obb.center,
					line.end);

				return TestLineToAABBD(
					line,
					{{{_obb.center, _obb.extent}}},
					_outResult);
			}

			static GReturn TestRayToTriangleD(const MATH::GRAYD _ray, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD* _outBarycentric)
			{
				MATH::GRAYD ray =
				{
					{
						{
							_ray.position.xyz(),
							_ray.direction.xyz()
						}
					}
				};

				MATH::GTRIANGLED triangle =
				{
					{
						{
							_triangle.a.xyz(),
							_triangle.b.xyz(),
							_triangle.c.xyz()
						}
					}
				};

				GW::MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					triangle.b,
					triangle.a,
					difference_ba);

				GW::MATH::GVECTORD difference_ca = {};
				GW::MATH::GVector::SubtractVectorD(
					triangle.c,
					triangle.a,
					difference_ca);

				GW::MATH::GVECTORD q = {};
				GW::MATH::GVector::CrossVector3D(
					ray.direction,
					difference_ca,
					q);

				double det = 0.0;
				GW::MATH::GVector::DotD(
					difference_ba,
					q,
					det);

				// Ray is parallel to or points away from triangle
				if(G_ABS(det) < 1.192092896e-07)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				double denom = 1.0f / det;

				GW::MATH::GVECTORD s = {};
				GW::MATH::GVector::SubtractVectorD(
					ray.position,
					triangle.a,
					s);

				GW::MATH::GVECTORD barycentric = {};
				GW::MATH::GVector::DotD(
					s,
					q,
					barycentric.y);
				barycentric.y *= denom;

				if(barycentric.y < 0.0)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORD r = {};
				GW::MATH::GVector::CrossVector3D(
					s,
					difference_ba,
					r);

				GW::MATH::GVector::DotD(
					ray.direction,
					r,
					barycentric.z);
				barycentric.z *= denom;

				if(barycentric.z < 0.0 || barycentric.y + barycentric.z > 1.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(_outBarycentric)
				{
					*_outBarycentric = barycentric;
					_outBarycentric->x = 1.0f - barycentric.y - barycentric.z;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestRayToPlaneD(const MATH::GRAYD _ray, const MATH::GPLANED _plane, GCollisionCheck& _outResult)
			{
				double denom = 0.0;
				GW::MATH::GVector::DotD(
					_plane.data.xyz(),
					_ray.direction.xyz(),
					denom);

				if(G_ABS(denom) < 1.192092896e-07)
				{
					// Ray is parallel
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				double num = 0.0;
				GW::MATH::GVector::DotD(
					_plane.data.xyz(),
					_ray.position.xyz(),
					num);

				double interval = (_plane.distance - num) / denom;
				if(interval >= 0.0)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					// Half plane test
					num -= _plane.distance;
					_outResult = (num < 0.0) ?
						_outResult = GCollisionCheck::BELOW :
						_outResult = GCollisionCheck::ABOVE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestRayToSphereD(const MATH::GRAYD _ray, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult)
			{
				MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					_ray.position.xyz(),
					_sphere.data.xyz(),
					difference_ba);

				double c = 0.0;
				GW::MATH::GVector::DotD(
					difference_ba,
					difference_ba,
					c);
				c -= _sphere.radius * _sphere.radius;

				// At least one real root.
				if(c <= 0.0)
				{
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				double b = 0.0;
				GW::MATH::GVector::DotD(
					difference_ba,
					_ray.direction.xyz(),
					b);

				// Ray is outside sphere and pointing away from it.
				if(b > 0.0)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// The discriminant determines if there were solutions or not.
				double discriminant = b * b - c;
				_outResult = (discriminant < 0.0) ?
					GCollisionCheck::NO_COLLISION :
					GCollisionCheck::COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestRayToCapsuleD(const MATH::GRAYD _ray, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD closest_point1 = {};
				ClosestPointToRayD(
					_ray,
					_capsule.data[0],
					closest_point1);

				GW::MATH::GSPHERED sphere = {};
				ClosestPointToRayD(
					_ray,
					_capsule.data[1],
					sphere.data);

				ClosestPointsToLineFromLineD(
					{{{closest_point1, sphere.data}}},
					{{{_capsule.data[0], _capsule.data[1]}}},
					closest_point1,
					sphere.data);

				sphere.radius = _capsule.radius;

				return TestPointToSphereD(
					closest_point1,
					sphere,
					_outResult);
			}

			static GReturn TestRayToAABBD(const MATH::GRAYD _ray, const MATH::GAABBMMD _aabb, GCollisionCheck& _outResult)
			{
				double interval1 = 0.0;
				double interval2 = 0.0;
				double interval3 = 0.0;
				double interval4 = 0.0;
				double interval5 = 0.0;
				double interval6 = 0.0;

				if(_ray.direction.x)
				{
					interval1 = (_aabb.min.x - _ray.position.x) / _ray.direction.x;
					interval2 = (_aabb.max.x - _ray.position.x) / _ray.direction.x;
				}
				else
				{
					interval1 = (_aabb.min.x - _ray.position.x) > 0.0 ?
						DBL_MAX : DBL_MIN;
					interval2 = (_aabb.max.x - _ray.position.x) > 0.0 ?
						DBL_MAX : DBL_MIN;
				}

				if(_ray.direction.y)
				{
					interval3 = (_aabb.min.y - _ray.position.y) / _ray.direction.y;
					interval4 = (_aabb.max.y - _ray.position.y) / _ray.direction.y;
				}
				else
				{
					interval3 = (_aabb.min.y - _ray.position.y) > 0.0 ?
						DBL_MAX : DBL_MIN;
					interval4 = (_aabb.max.y - _ray.position.y) > 0.0 ?
						DBL_MAX : DBL_MIN;
				}

				if(_ray.direction.z)
				{
					interval5 = (_aabb.min.z - _ray.position.z) / _ray.direction.z;
					interval6 = (_aabb.max.z - _ray.position.z) / _ray.direction.z;
				}
				else
				{
					interval5 = (_aabb.min.z - _ray.position.z) > 0.0 ?
						DBL_MAX : DBL_MIN;
					interval6 = (_aabb.max.z - _ray.position.z) > 0.0 ?
						DBL_MAX : DBL_MIN;
				}

				double interval_min = G_LARGER(G_LARGER(
					G_SMALLER(interval1, interval2),
					G_SMALLER(interval3, interval4)),
					G_SMALLER(interval5, interval6));

				double interval_max = G_SMALLER(G_SMALLER(
					G_LARGER(interval1, interval2),
					G_LARGER(interval3, interval4)),
					G_LARGER(interval5, interval6));

				if(interval_max < 0.0)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(interval_max < interval_min)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestRayToOBBD(const MATH::GRAYD _ray, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				MATH::GMATRIXD obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionD(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXD obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0}}},
							{{{0.0, 0.0, 0.0, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				MATH::GRAYD ray =
				{
					{
						{
							_ray.position,
							_ray.direction.xyz()
						}
					}
				};
				ray.position.w = 1.0f;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					_ray.position,
					ray.position);
				GW::MATH::GVector::AddVectorD(
					ray.position,
					_obb.center,
					ray.position);

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					_ray.direction,
					ray.direction);
				GW::MATH::GVector::NormalizeD(
					ray.direction,
					ray.direction);

				MATH::GAABBMMD mm = {};
				ConvertAABBCEToAABBMMD(
					{{{_obb.center, _obb.extent}}},
					mm);

				return TestRayToAABBD(
					ray,
					mm,
					_outResult);
			}

			static GReturn TestTriangleToTriangleD(const MATH::GTRIANGLED _triangle1, const MATH::GTRIANGLED _triangle2, GCollisionCheck& _outResult)
			{
				// Half plane test if triangle1 lies completely on one side to triangle2 plane
				GW::MATH::GVECTORD difference_b2a2 = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle2.b.xyz(),
					_triangle2.a.xyz(),
					difference_b2a2);

				GW::MATH::GVECTORD difference_c2a2 = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle2.c.xyz(),
					_triangle2.a.xyz(),
					difference_c2a2);

				GW::MATH::GVECTORD plane2 = {};
				GW::MATH::GVector::CrossVector3D(
					difference_c2a2,
					difference_b2a2,
					plane2);

				GW::MATH::GVECTORD difference_a1a2 = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle1.a.xyz(),
					_triangle2.a.xyz(),
					difference_a1a2);

				GW::MATH::GVECTORD det1 = {};
				GW::MATH::GVector::DotD(
					difference_a1a2,
					plane2,
					det1.x);

				GW::MATH::GVECTORD difference_b1a2 = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle1.b.xyz(),
					_triangle2.a.xyz(),
					difference_b1a2);

				GW::MATH::GVector::DotD(
					difference_b1a2,
					plane2,
					det1.y);

				GW::MATH::GVECTORD difference_c1a2 = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle1.c.xyz(),
					_triangle2.a.xyz(),
					difference_c1a2);

				GW::MATH::GVector::DotD(
					difference_c1a2,
					plane2,
					det1.z);

				if(((det1.x * det1.y) > 0.0) && ((det1.x * det1.z) > 0.0))
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Half plane test if triangle2 lies completely on one side to triangle1 plane
				GW::MATH::GVECTORD difference_b1a1 = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle1.b.xyz(),
					_triangle1.a.xyz(),
					difference_b1a1);

				GW::MATH::GVECTORD difference_c1a1 = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle1.c.xyz(),
					_triangle1.a.xyz(),
					difference_c1a1);

				GW::MATH::GVECTORD plane1 = {};
				GW::MATH::GVector::CrossVector3D(
					difference_c1a1,
					difference_b1a1,
					plane1);

				GW::MATH::GVECTORD difference_a2a1 = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle2.a.xyz(),
					_triangle1.a.xyz(),
					difference_a2a1);

				GW::MATH::GVECTORD det2 = {};
				GW::MATH::GVector::DotD(
					difference_a2a1,
					plane1,
					det2.x);

				GW::MATH::GVECTORD difference_b2a1 = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle2.b.xyz(),
					_triangle1.a.xyz(),
					difference_b2a1);

				GW::MATH::GVector::DotD(
					difference_b2a1,
					plane1,
					det2.y);

				GW::MATH::GVECTORD difference_c2a1 = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle2.c.xyz(),
					_triangle1.a.xyz(),
					difference_c2a1);

				GW::MATH::GVector::DotD(
					difference_c2a1,
					plane1,
					det2.z);

				if(((det2.x * det2.y) > 0.0) && ((det2.x * det2.z) > 0.0))
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Bring both triangles into canonical form
				MATH::GTRIANGLED triangle1 = {};
				MATH::GTRIANGLED triangle2 = {};

				if(det1.x > 0.0)
				{
					if(det1.y > 0.0)
					{
						triangle1 =
						{
							{
								{
									_triangle1.c,
									_triangle1.a,
									_triangle1.b
								}
							}
						};

						triangle2 =
						{
							{
								{
									_triangle2.a,
									_triangle2.c,
									_triangle2.b
								}
							}
						};
					}
					else if(det1.z > 0.0)
					{
						triangle1 =
						{
							{
								{
									_triangle1.b,
									_triangle1.c,
									_triangle1.a
								}
							}
						};

						triangle2 =
						{
							{
								{
									_triangle2.a,
									_triangle2.c,
									_triangle2.b
								}
							}
						};
					}
					else
					{
						triangle1 =
						{
							{
								{
									_triangle1.a,
									_triangle1.b,
									_triangle1.c
								}
							}
						};

						triangle2 =
						{
							{
								{
									_triangle2.a,
									_triangle2.b,
									_triangle2.c
								}
							}
						};
					}
				}
				else if(det1.x < 0.0)
				{
					if(det1.y < 0.0)
					{
						triangle1 =
						{
							{
								{
									_triangle1.c,
									_triangle1.a,
									_triangle1.b
								}
							}
						};

						triangle2 =
						{
							{
								{
									_triangle2.a,
									_triangle2.b,
									_triangle2.c
								}
							}
						};
					}
					else if(det1.z < 0.0)
					{
						triangle1 =
						{
							{
								{
									_triangle1.b,
									_triangle1.c,
									_triangle1.a
								}
							}
						};

						triangle2 =
						{
							{
								{
									_triangle2.a,
									_triangle2.b,
									_triangle2.c
								}
							}
						};
					}
					else
					{
						triangle1 =
						{
							{
								{
									_triangle1.a,
									_triangle1.b,
									_triangle1.c
								}
							}
						};

						triangle2 =
						{
							{
								{
									_triangle2.a,
									_triangle2.c,
									_triangle2.b
								}
							}
						};
					}
				}
				else
				{
					if(det1.y < 0.0)
					{
						if(det1.z >= 0.0)
						{
							triangle1 =
							{
								{
									{
										_triangle1.b,
										_triangle1.c,
										_triangle1.a
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.c,
										_triangle2.b
									}
								}
							};
						}
						else
						{
							triangle1 =
							{
								{
									{
										_triangle1.a,
										_triangle1.b,
										_triangle1.c
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.b,
										_triangle2.c
									}
								}
							};
						}
					}
					else if(det1.y > 0.0)
					{
						if(det1.z > 0.0)
						{
							triangle1 =
							{
								{
									{
										_triangle1.a,
										_triangle1.b,
										_triangle1.c
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.c,
										_triangle2.b
									}
								}
							};
						}
						else
						{
							triangle1 =
							{
								{
									{
										_triangle1.b,
										_triangle1.c,
										_triangle1.a
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.b,
										_triangle2.c
									}
								}
							};
						}
					}
					else
					{
						if(det1.z > 0.0)
						{
							triangle1 =
							{
								{
									{
										_triangle1.c,
										_triangle1.a,
										_triangle1.b
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.b,
										_triangle2.c
									}
								}
							};
						}
						else if(det1.z < 0.0)
						{
							triangle1 =
							{
								{
									{
										_triangle1.c,
										_triangle1.a,
										_triangle1.b
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.c,
										_triangle2.b
									}
								}
							};
						}
						else
						{
							triangle1 =
							{
								{
									{
										_triangle1.a,
										_triangle1.b,
										_triangle1.c
									}
								}
							};

							triangle2 =
							{
								{
									{
										_triangle2.a,
										_triangle2.b,
										_triangle2.c
									}
								}
							};

							// return coplanar result
							auto Orient2D = [](const double* a, const double* b, const double* c)
							{
								return ((a[0] - c[0]) * (b[1] - c[1]) - (a[1] - c[1]) * (b[0] - c[0]));
							};

							auto TestVertex2D = [&](
								const double* a1, const double* b1, const double* c1,
								const double* a2, const double* b2, const double* c2)
							{
								if(Orient2D(c2, a2, b1) >= 0.0)
								{
									if(Orient2D(c2, b2, b1) <= 0.0)
									{
										if(Orient2D(a1, a2, b1) > 0.0)
										{
											return (Orient2D(a1, b2, b1) <= 0.0) ? 1 : 0;
										}
										else
										{
											if(Orient2D(a1, a2, c1) >= 0.0)
											{
												return (Orient2D(b1, c1, a2) >= 0.0) ? 1 : 0;
											}
											else return 0;
										}
									}
									else
									{
										if(Orient2D(a1, b2, b1) <= 0.0)
										{
											if(Orient2D(c2, b2, c1) <= 0.0)
											{
												return (Orient2D(b1, c1, b2) >= 0.0) ? 1 : 0;
											}
											else return 0;
										}
										else return 0;
									}
								}
								else
								{
									if(Orient2D(c2, a2, c1) >= 0.0)
									{
										if(Orient2D(b1, c1, c2) >= 0.0)
										{
											return (Orient2D(a1, a2, c1) >= 0.0) ? 1 : 0;
										}
										else
										{
											if(Orient2D(b1, c1, b2) >= 0.0)
											{
												return (Orient2D(c2, c1, b2) >= 0.0) ? 1 : 0;
											}
											else return 0;
										}
									}
									else  return 0;
								}
							};

							auto TestEdge2D = [&](
								const double* a1, const double* b1, const double* c1,
								const double* a2, const double* b2, const double* c2)
							{
								if(Orient2D(c2, a2, b1) >= 0.0)
								{
									if(Orient2D(a1, a2, b1) >= 0.0)
									{
										return (Orient2D(a1, b1, c2) >= 0.0) ? 1 : 0;
									}
									else
									{
										if(Orient2D(b1, c1, a2) >= 0.0)
										{
											return (Orient2D(c1, a1, a2) >= 0.0) ? 1 : 0;
										}
										else return 0;
									}
								}
								else
								{
									if(Orient2D(c2, a2, c1) >= 0.0)
									{
										if(Orient2D(a1, a2, c1) >= 0.0)
										{
											if(Orient2D(a1, c1, c2) >= 0.0) return 1;
											else
											{
												return (Orient2D(b1, c1, c2) >= 0.0) ? 1 : 0;
											}
										}
										else  return 0;
									}
									else return 0;
								}
							};

							auto TestTriangles2D = [&](
								const double* a1, const double* b1, const double* c1,
								const double* a2, const double* b2, const double* c2)
							{
								if(Orient2D(a2, b2, a1) >= 0.0)
								{
									if(Orient2D(b2, c2, a1) >= 0.0)
									{
										if(Orient2D(c2, a2, a1) >= 0.0)
										{
											return 1;
										}
										else
										{
											return TestEdge2D(
												a1, b1, c1,
												a2, b2, c2);
										}
									}
									else
									{
										if(Orient2D(c2, a2, a1) >= 0.0)
										{
											return TestEdge2D(
												a1, b1, c1,
												c2, a2, b2);
										}
										else
										{
											return TestVertex2D(
												a1, b1, c1,
												a2, b2, c2);
										}
									}
								}
								else
								{
									if(Orient2D(b2, c2, a1) >= 0.0)
									{
										if(Orient2D(c2, a2, a1) >= 0.0)
										{
											return TestEdge2D(
												a1, b1, c1,
												b2, c2, a2);
										}
										else
										{
											return TestVertex2D(
												a1, b1, c1,
												b2, c2, a2);
										}
									}
									else
									{
										return TestVertex2D(
											a1, b1, c1,
											c2, a2, b2);
									}
								}
							};

							GW::MATH::GVECTORD normal =
							{
								{
									{
										G_ABS(plane1.x),
										G_ABS(plane1.y),
										G_ABS(plane1.z)
									}
								}
							};

							GW::MATH::GTRIANGLED tri2_1 = {};
							GW::MATH::GTRIANGLED tri2_2 = {};

							if((normal.x > normal.z) && (normal.x >= normal.y))
							{
								// Project onto yz
								tri2_1.a.x = triangle1.b.z;
								tri2_1.a.y = triangle1.b.y;
								tri2_1.b.x = triangle1.a.z;
								tri2_1.b.y = triangle1.a.y;
								tri2_1.c.x = triangle1.c.z;
								tri2_1.c.y = triangle1.c.y;

								tri2_2.a.x = triangle2.b.z;
								tri2_2.a.y = triangle2.b.y;
								tri2_2.b.x = triangle2.a.z;
								tri2_2.b.y = triangle2.a.y;
								tri2_2.c.x = triangle2.c.z;
								tri2_2.c.y = triangle2.c.y;
							}
							else if((normal.y > normal.z) && (normal.y >= normal.x))
							{
								// Project onto xz
								tri2_1.a.x = triangle1.b.x;
								tri2_1.a.y = triangle1.b.z;
								tri2_1.b.x = triangle1.a.x;
								tri2_1.b.y = triangle1.a.z;
								tri2_1.c.x = triangle1.c.x;
								tri2_1.c.y = triangle1.c.z;

								tri2_2.a.x = triangle2.b.x;
								tri2_2.a.y = triangle2.b.z;
								tri2_2.b.x = triangle2.a.x;
								tri2_2.b.y = triangle2.a.z;
								tri2_2.c.x = triangle2.c.x;
								tri2_2.c.y = triangle2.c.z;
							}
							else
							{
								// Project onto xy
								tri2_1.a.x = triangle1.a.x;
								tri2_1.a.y = triangle1.a.y;
								tri2_1.b.x = triangle1.b.x;
								tri2_1.b.y = triangle1.b.y;
								tri2_1.c.x = triangle1.c.x;
								tri2_1.c.y = triangle1.c.y;

								tri2_2.a.x = triangle2.a.x;
								tri2_2.a.y = triangle2.a.y;
								tri2_2.b.x = triangle2.b.x;
								tri2_2.b.y = triangle2.b.y;
								tri2_2.c.x = triangle2.c.x;
								tri2_2.c.y = triangle2.c.y;
							}

							if(Orient2D(tri2_1.a.data, tri2_1.b.data, tri2_1.c.data) < 0.0)
							{
								if(Orient2D(tri2_1.a.data, tri2_1.b.data, tri2_1.c.data) < 0.0)
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data,
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data));
								}
								else
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data,
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data));
								}
							}
							else
							{
								if(Orient2D(tri2_2.a.data, tri2_2.b.data, tri2_2.c.data) < 0.0)
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data,
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data));
								}
								else
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data,
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data));
								}
							}

							return GReturn::SUCCESS;
						}
					}
				}

				if(det2.x > 0.0)
				{
					if(det2.y > 0.0)
					{
						triangle1 =
						{
							{
								{
									triangle1.a,
									triangle1.c,
									triangle1.b
								}
							}
						};

						triangle2 =
						{
							{
								{
									triangle2.c,
									triangle2.a,
									triangle2.b
								}
							}
						};
					}
					else if(det2.z > 0.0)
					{
						triangle1 =
						{
							{
								{
									triangle1.a,
									triangle1.c,
									triangle1.b
								}
							}
						};

						triangle2 =
						{
							{
								{
									triangle2.b,
									triangle2.c,
									triangle2.a
								}
							}
						};
					}
					else
					{
						triangle1 =
						{
							{
								{
									triangle1.a,
									triangle1.b,
									triangle1.c
								}
							}
						};

						triangle2 =
						{
							{
								{
									triangle2.a,
									triangle2.b,
									triangle2.c
								}
							}
						};
					}
				}
				else if(det2.x < 0.0)
				{
					if(det2.y < 0.0)
					{
						triangle1 =
						{
							{
								{
									triangle1.a,
									triangle1.b,
									triangle1.c
								}
							}
						};

						triangle2 =
						{
							{
								{
									triangle2.c,
									triangle2.a,
									triangle2.b
								}
							}
						};
					}
					else if(det2.z < 0.0)
					{
						triangle1 =
						{
							{
								{
									triangle1.a,
									triangle1.b,
									triangle1.c
								}
							}
						};

						triangle2 =
						{
							{
								{
									triangle2.b,
									triangle2.c,
									triangle2.a
								}
							}
						};
					}
					else
					{
						triangle1 =
						{
							{
								{
									triangle1.a,
									triangle1.c,
									triangle1.b
								}
							}
						};

						triangle2 =
						{
							{
								{
									triangle2.a,
									triangle2.b,
									triangle2.c
								}
							}
						};
					}
				}
				else
				{
					if(det2.y < 0.0)
					{
						if(det2.z >= 0.0)
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.c,
										triangle1.b
									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.b,
										triangle2.c,
										triangle2.a
									}
								}
							};
						}
						else
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.b,
										triangle1.c
									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.a,
										triangle2.b,
										triangle2.c
									}
								}
							};
						}
					}
					else if(det2.y > 0.0)
					{
						if(det2.z > 0.0)
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.c,
										triangle1.b
									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.a,
										triangle2.b,
										triangle2.c
									}
								}
							};
						}
						else
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.b,
										triangle1.c
									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.b,
										triangle2.c,
										triangle2.a
									}
								}
							};
						}
					}
					else
					{
						if(det2.z > 0.0)
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.b,
										triangle1.c
									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.c,
										triangle2.a,
										triangle2.b
									}
								}
							};
						}
						else if(det2.z < 0.0)
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.c,
										triangle1.b
									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.c,
										triangle2.a,
										triangle2.b
									}
								}
							};
						}
						else
						{
							triangle1 =
							{
								{
									{
										triangle1.a,
										triangle1.b,
										triangle1.c

									}
								}
							};

							triangle2 =
							{
								{
									{
										triangle2.a,
										triangle2.b,
										triangle2.c
									}
								}
							};

							// return coplanar result
							auto Orient2D = [](const double* a, const double* b, const double* c)
							{
								return ((a[0] - c[0]) * (b[1] - c[1]) - (a[1] - c[1]) * (b[0] - c[0]));
							};

							auto TestVertex2D = [&](
								const double* a1, const double* b1, const double* c1,
								const double* a2, const double* b2, const double* c2)
							{
								if(Orient2D(c2, a2, b1) >= 0.0)
								{
									if(Orient2D(c2, b2, b1) <= 0.0)
									{
										if(Orient2D(a1, a2, b1) > 0.0)
										{
											return (Orient2D(a1, b2, b1) <= 0.0) ? 1 : 0;
										}
										else
										{
											if(Orient2D(a1, a2, c1) >= 0.0)
											{
												return (Orient2D(b1, c1, a2) >= 0.0) ? 1 : 0;
											}
											else return 0;
										}
									}
									else
									{
										if(Orient2D(a1, b2, b1) <= 0.0)
										{
											if(Orient2D(c2, b2, c1) <= 0.0)
											{
												return (Orient2D(b1, c1, b2) >= 0.0) ? 1 : 0;
											}
											else return 0;
										}
										else return 0;
									}
								}
								else
								{
									if(Orient2D(c2, a2, c1) >= 0.0)
									{
										if(Orient2D(b1, c1, c2) >= 0.0)
										{
											return (Orient2D(a1, a2, c1) >= 0.0) ? 1 : 0;
										}
										else
										{
											if(Orient2D(b1, c1, b2) >= 0.0)
											{
												return (Orient2D(c2, c1, b2) >= 0.0) ? 1 : 0;
											}
											else return 0;
										}
									}
									else  return 0;
								}
							};

							auto TestEdge2D = [&](
								const double* a1, const double* b1, const double* c1,
								const double* a2, const double* b2, const double* c2)
							{
								if(Orient2D(c2, a2, b1) >= 0.0)
								{
									if(Orient2D(a1, a2, b1) >= 0.0)
									{
										return (Orient2D(a1, b1, c2) >= 0.0) ? 1 : 0;
									}
									else
									{
										if(Orient2D(b1, c1, a2) >= 0.0)
										{
											return (Orient2D(c1, a1, a2) >= 0.0) ? 1 : 0;
										}
										else return 0;
									}
								}
								else
								{
									if(Orient2D(c2, a2, c1) >= 0.0)
									{
										if(Orient2D(a1, a2, c1) >= 0.0)
										{
											if(Orient2D(a1, c1, c2) >= 0.0) return 1;
											else
											{
												return (Orient2D(b1, c1, c2) >= 0.0) ? 1 : 0;
											}
										}
										else  return 0;
									}
									else return 0;
								}
							};

							auto TestTriangles2D = [&](
								const double* a1, const double* b1, const double* c1,
								const double* a2, const double* b2, const double* c2)
							{
								if(Orient2D(a2, b2, a1) >= 0.0)
								{
									if(Orient2D(b2, c2, a1) >= 0.0)
									{
										if(Orient2D(c2, a2, a1) >= 0.0)
										{
											return 1;
										}
										else
										{
											return TestEdge2D(
												a1, b1, c1,
												a2, b2, c2);
										}
									}
									else
									{
										if(Orient2D(c2, a2, a1) >= 0.0)
										{
											return TestEdge2D(
												a1, b1, c1,
												c2, a2, b2);
										}
										else
										{
											return TestVertex2D(
												a1, b1, c1,
												a2, b2, c2);
										}
									}
								}
								else
								{
									if(Orient2D(b2, c2, a1) >= 0.0)
									{
										if(Orient2D(c2, a2, a1) >= 0.0)
										{
											return TestEdge2D(
												a1, b1, c1,
												b2, c2, a2);
										}
										else
										{
											return TestVertex2D(
												a1, b1, c1,
												b2, c2, a2);
										}
									}
									else
									{
										return TestVertex2D(
											a1, b1, c1,
											c2, a2, b2);
									}
								}
							};

							GW::MATH::GVECTORD normal =
							{
								{
									{
										G_ABS(plane1.x),
										G_ABS(plane1.y),
										G_ABS(plane1.z)
									}
								}
							};

							GW::MATH::GTRIANGLED tri2_1 = {};
							GW::MATH::GTRIANGLED tri2_2 = {};

							if((normal.x > normal.z) && (normal.x >= normal.y))
							{
								// Project onto yz
								tri2_1.a.x = triangle1.b.z;
								tri2_1.a.y = triangle1.b.y;
								tri2_1.b.x = triangle1.a.z;
								tri2_1.b.y = triangle1.a.y;
								tri2_1.c.x = triangle1.c.z;
								tri2_1.c.y = triangle1.c.y;

								tri2_2.a.x = triangle2.b.z;
								tri2_2.a.y = triangle2.b.y;
								tri2_2.b.x = triangle2.a.z;
								tri2_2.b.y = triangle2.a.y;
								tri2_2.c.x = triangle2.c.z;
								tri2_2.c.y = triangle2.c.y;
							}
							else if((normal.y > normal.z) && (normal.y >= normal.x))
							{
								// Project onto xz
								tri2_1.a.x = triangle1.b.x;
								tri2_1.a.y = triangle1.b.z;
								tri2_1.b.x = triangle1.a.x;
								tri2_1.b.y = triangle1.a.z;
								tri2_1.c.x = triangle1.c.x;
								tri2_1.c.y = triangle1.c.z;

								tri2_2.a.x = triangle2.b.x;
								tri2_2.a.y = triangle2.b.z;
								tri2_2.b.x = triangle2.a.x;
								tri2_2.b.y = triangle2.a.z;
								tri2_2.c.x = triangle2.c.x;
								tri2_2.c.y = triangle2.c.z;
							}
							else
							{
								// Project onto xy
								tri2_1.a.x = triangle1.a.x;
								tri2_1.a.y = triangle1.a.y;
								tri2_1.b.x = triangle1.b.x;
								tri2_1.b.y = triangle1.b.y;
								tri2_1.c.x = triangle1.c.x;
								tri2_1.c.y = triangle1.c.y;

								tri2_2.a.x = triangle2.a.x;
								tri2_2.a.y = triangle2.a.y;
								tri2_2.b.x = triangle2.b.x;
								tri2_2.b.y = triangle2.b.y;
								tri2_2.c.x = triangle2.c.x;
								tri2_2.c.y = triangle2.c.y;
							}

							if(Orient2D(tri2_1.a.data, tri2_1.b.data, tri2_1.c.data) < 0.0)
							{
								if(Orient2D(tri2_1.a.data, tri2_1.b.data, tri2_1.c.data) < 0.0)
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data,
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data));
								}
								else
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data,
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data));
								}
							}
							else
							{
								if(Orient2D(tri2_2.a.data, tri2_2.b.data, tri2_2.c.data) < 0.0)
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data,
										tri2_1.a.data, tri2_1.c.data, tri2_1.b.data));
								}
								else
								{
									_outResult = static_cast<GCollisionCheck>(TestTriangles2D(
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data,
										tri2_1.a.data, tri2_1.b.data, tri2_1.c.data));
								}
							}

							return GReturn::SUCCESS;
						}
					}
				}

				// Edges confirmed to form a line where the triangle planes meet. Check if triangles are within an interval.
				GW::MATH::GVECTORD difference_a2b1 = {};
				GW::MATH::GVector::SubtractVectorD(
					triangle2.a,
					triangle1.b,
					difference_a2b1);

				GW::MATH::GVECTORD difference_a1b1 = {};
				GW::MATH::GVector::SubtractVectorD(
					triangle1.a,
					triangle1.b,
					difference_a1b1);

				GW::MATH::GVector::CrossVector3D(
					difference_a1b1,
					difference_a2b1,
					plane1);

				GW::MATH::GVECTORD difference_b2b1 = {};
				GW::MATH::GVector::SubtractVectorD(
					triangle2.b,
					triangle1.b,
					difference_b2b1);

				double dot1 = 0.0;
				GW::MATH::GVector::DotD(
					difference_b2b1,
					plane1,
					dot1);

				if(dot1 > 0.0)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVector::SubtractVectorD(
					triangle2.a,
					triangle1.a,
					difference_a2a1);

				GW::MATH::GVector::SubtractVectorD(
					triangle1.c,
					triangle1.a,
					difference_c1a1);

				GW::MATH::GVector::CrossVector3D(
					difference_c1a1,
					difference_a2a1,
					plane1);

				GW::MATH::GVector::SubtractVectorD(
					triangle2.c,
					triangle1.a,
					difference_c2a1);

				GW::MATH::GVector::DotD(
					difference_c2a1,
					plane1,
					dot1);

				if(dot1 > 0.0)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestTriangleToPlaneD(const MATH::GTRIANGLED _triangle, const MATH::GPLANED _plane, GCollisionCheck& _outResult)
			{
				GCollisionCheck plane_test;

				TestPointToPlaneD(
					_triangle.a,
					_plane,
					plane_test);
				_outResult = plane_test;

				if (static_cast<int>(_outResult) > 0)
				{
					return GReturn::SUCCESS;
				}

				TestPointToPlaneD(
					_triangle.b,
					_plane,
					plane_test);

				if(_outResult != plane_test)
				{
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				TestPointToPlaneD(
					_triangle.c,
					_plane,
					plane_test);

				if(_outResult != plane_test)
				{
					_outResult = GCollisionCheck::COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestTriangleToSphereD(const MATH::GTRIANGLED _triangle, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD closest_point = {};
				ClosestPointToTriangleD(
					_triangle,
					_sphere.data,
					closest_point);

				return TestPointToSphereD(
					closest_point,
					_sphere,
					_outResult);
			}

			static GReturn TestTriangleToCapsuleD(const MATH::GTRIANGLED _triangle, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD closest_point1 = {};
				ClosestPointToTriangleD(
					_triangle,
					_capsule.data[0],
					closest_point1);

				GW::MATH::GVECTORD closest_point2 = {};
				ClosestPointToTriangleD(
					_triangle,
					_capsule.data[1],
					closest_point2);

				return TestLineToCapsuleD(
					{{{closest_point1, closest_point2}}},
					_capsule,
					_outResult);
			}

			static GReturn TestTriangleToAABBD(const MATH::GTRIANGLED _triangle, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD right = {{{1,0,0,0}}};
				GW::MATH::GVECTORD up = {{{0,1,0,0}}};
				GW::MATH::GVECTORD forward = {{{0,0,1,0}}};

				GW::MATH::GVECTORD v0 = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle.a.xyz(),
					_aabb.center.xyz(),
					v0);

				GW::MATH::GVECTORD v1 = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle.b.xyz(),
					_aabb.center.xyz(),
					v1);

				GW::MATH::GVECTORD v2 = {};
				GW::MATH::GVector::SubtractVectorD(
					_triangle.c.xyz(),
					_aabb.center.xyz(),
					v2);

				GW::MATH::GVECTORD f0 = {};
				GW::MATH::GVector::SubtractVectorD(
					v1,
					v0,
					f0);

				GW::MATH::GVECTORD f1 = {};
				GW::MATH::GVector::SubtractVectorD(
					v2,
					v1,
					f1);

				GW::MATH::GVECTORD f2 = {};
				GW::MATH::GVector::SubtractVectorD(
					v0,
					v2,
					f2);

				GW::MATH::GVECTORD axis[9] = {};

				GW::MATH::GVector::CrossVector3D(
					right,
					f0,
					axis[0]);

				GW::MATH::GVector::CrossVector3D(
					up,
					f0,
					axis[1]);

				GW::MATH::GVector::CrossVector3D(
					forward,
					f0,
					axis[2]);

				GW::MATH::GVector::CrossVector3D(
					right,
					f1,
					axis[3]);

				GW::MATH::GVector::CrossVector3D(
					up,
					f1,
					axis[4]);

				GW::MATH::GVector::CrossVector3D(
					forward,
					f1,
					axis[5]);

				GW::MATH::GVector::CrossVector3D(
					right,
					f2,
					axis[6]);

				GW::MATH::GVector::CrossVector3D(
					up,
					f2,
					axis[7]);

				GW::MATH::GVector::CrossVector3D(
					forward,
					f2,
					axis[8]);

				double p0 = 0.0;
				double p1 = 0.0;
				double p2 = 0.0;
				double r = 0.0;
				GW::MATH::GVECTORD dots = {};

				for(int i = 0; i < 9; i++)
				{
					GW::MATH::GVector::DotD(
						v0,
						axis[i],
						p0);
					GW::MATH::GVector::DotD(
						v1,
						axis[i],
						p1);
					GW::MATH::GVector::DotD(
						v2,
						axis[i],
						p2);

					GW::MATH::GVector::DotD(
						right,
						axis[i],
						dots.x);
					GW::MATH::GVector::DotD(
						up,
						axis[i],
						dots.y);
					GW::MATH::GVector::DotD(
						forward,
						axis[i],
						dots.z);

					r =
						_aabb.extent.x * G_ABS(dots.x) +
						_aabb.extent.y * G_ABS(dots.y) +
						_aabb.extent.z * G_ABS(dots.z);

					if(G_LARGER(-G_LARGER(p0, -G_LARGER(p1, p2)),
								G_SMALLER(p0, G_SMALLER(p1, p2))) > r)
					{
						_outResult = GCollisionCheck::NO_COLLISION;
						return GReturn::SUCCESS;
					}
				}

				// Test the 3 axis corresponding to the face normals of the AABB
				if(G_LARGER(v0.x, G_LARGER(v1.x, v2.x)) < -_aabb.extent.x ||
				   G_SMALLER(v0.x, G_SMALLER(v1.x, v2.x)) > _aabb.extent.x)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_LARGER(v0.y, G_LARGER(v1.y, v2.y)) < -_aabb.extent.y ||
				   G_SMALLER(v0.y, G_SMALLER(v1.y, v2.y)) > _aabb.extent.y)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_LARGER(v0.z, G_LARGER(v1.z, v2.z)) < -_aabb.extent.z ||
				   G_SMALLER(v0.z, G_SMALLER(v1.z, v2.z)) > _aabb.extent.z)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test separating axis to triangle face normal
				GW::MATH::GPLANED plane;

				ComputePlaneD(
					_triangle.a,
					_triangle.b,
					_triangle.c,
					plane);

				return TestPlaneToAABBD(
					plane,
					_aabb,
					_outResult);
			}

			static GReturn TestTriangleToOBBD(const MATH::GTRIANGLED _triangle, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				MATH::GMATRIXD obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionD(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXD obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0}}},
							{{{0.0, 0.0, 0.0, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				MATH::GTRIANGLED triangle =
				{
					{
						{
							_triangle.a,
							_triangle.b,
							_triangle.c
						}
					}
				};
				triangle.a.w = 1.0f;
				triangle.b.w = 1.0f;
				triangle.c.w = 1.0f;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					triangle.a,
					triangle.a);
				GW::MATH::GVector::AddVectorD(
					triangle.a,
					_obb.center,
					triangle.a);

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					triangle.b,
					triangle.b);
				GW::MATH::GVector::AddVectorD(
					triangle.b,
					_obb.center,
					triangle.b);

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					triangle.c,
					triangle.c);
				GW::MATH::GVector::AddVectorD(
					triangle.c,
					_obb.center,
					triangle.c);

				return TestTriangleToAABBD(
					triangle,
					{{{_obb.center, _obb.extent}}},
					_outResult);
			}

			static GReturn TestPlaneToPlaneD(const MATH::GPLANED _plane1, const MATH::GPLANED _plane2, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD cross = {};
				GW::MATH::GVector::CrossVector3D(
					_plane1.data.xyz(),
					_plane2.data.xyz(),
					cross);

				double dot = 0.0;
				GW::MATH::GVector::DotD(
					cross,
					cross,
					dot);

				_outResult = (dot < 1.192092896e-07) ?
					GCollisionCheck::NO_COLLISION :
					GCollisionCheck::COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestPlaneToSphereD(const MATH::GPLANED _plane, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult)
			{
				double distance = 0.0;
				GW::MATH::GVector::DotD(
					_sphere.data.xyz(),
					_plane.data.xyz(),
					distance);
				distance -= _plane.distance;

				if(G_ABS(distance) <= _sphere.radius)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					_outResult = (distance > 0.0) ?
						GCollisionCheck::ABOVE :
						GCollisionCheck::BELOW;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPlaneToCapsuleD(const MATH::GPLANED _plane, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult)
			{
				double distance_start = 0.0;
				GW::MATH::GVector::DotD(
					_capsule.data[0].xyz(),
					_plane.data.xyz(),
					distance_start);
				distance_start -= _plane.distance;

				double distance_end = 0.0;
				GW::MATH::GVector::DotD(
					_capsule.data[1].xyz(),
					_plane.data.xyz(),
					distance_end);
				distance_end -= _plane.distance;

				if(distance_start * distance_end < 0.0)
				{
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_ABS(distance_start) <= _capsule.radius || G_ABS(distance_end) <= _capsule.radius)
				{
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = (distance_start > 0.0) ?
					GCollisionCheck::ABOVE :
					GCollisionCheck::BELOW;
				return GReturn::SUCCESS;

			}

			static GReturn TestPlaneToAABBD(const MATH::GPLANED _plane, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD plane_normal = _plane.data.xyz();

				double interval =
					_aabb.extent.x * G_ABS(_plane.x) +
					_aabb.extent.y * G_ABS(_plane.y) +
					_aabb.extent.z * G_ABS(_plane.z);

				double distance = 0.0;
				GW::MATH::GVector::DotD(
					plane_normal,
					_aabb.center.xyz(),
					distance);
				distance -= _plane.distance;

				if(G_ABS(distance) <= interval)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					_outResult = (distance > 0.0) ?
						GCollisionCheck::ABOVE :
						GCollisionCheck::BELOW;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestPlaneToOBBD(const MATH::GPLANED _plane, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD plane_normal = _plane.data.xyz();

				double xx2 = 2.0f * _obb.rotation.x * _obb.rotation.x;
				double yy2 = 2.0f * _obb.rotation.y * _obb.rotation.y;
				double zz2 = 2.0f * _obb.rotation.z * _obb.rotation.z;

				double xy2 = 2.0f * _obb.rotation.x * _obb.rotation.y;
				double xz2 = 2.0f * _obb.rotation.x * _obb.rotation.z;
				double yz2 = 2.0f * _obb.rotation.y * _obb.rotation.z;

				double wx2 = 2.0f * _obb.rotation.w * _obb.rotation.x;
				double wy2 = 2.0f * _obb.rotation.w * _obb.rotation.y;
				double wz2 = 2.0f * _obb.rotation.w * _obb.rotation.z;

				MATH::GVECTORD obb_rotation[3] =
				{
					{{{1.0f - yy2 - zz2, xy2 - wz2, xz2 + wy2}}},
					{{{xy2 + wz2, 1.0f - xx2 - zz2, yz2 - wx2}}},
					{{{xz2 - wy2, yz2 + wx2, 1.0f - xx2 - yy2}}}
				};

				double interval = 0.0;
				double s = 0.0;

				for(int i = 0; i < 3; i++)
				{
					GW::MATH::GVector::DotD(
						plane_normal,
						obb_rotation[i],
						s);

					interval += _obb.extent.data[i] * G_ABS(s);
				}

				GW::MATH::GVector::DotD(
					plane_normal,
					_obb.center.xyz(),
					s);

				s -= _plane.distance;

				if(G_ABS(s) <= interval)
				{
					_outResult = GCollisionCheck::COLLISION;
				}
				else
				{
					_outResult = (s > 0.0) ?
						GCollisionCheck::ABOVE :
						GCollisionCheck::BELOW;
				}

				return GReturn::SUCCESS;
			}

			static GReturn TestSphereToSphereD(const MATH::GSPHERED _sphere1, const MATH::GSPHERED _sphere2, GCollisionCheck& _outResult)
			{
				MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					_sphere1.data.xyz(),
					_sphere2.data.xyz(),
					difference_ba);

				double sq_distance = 0.0;
				GW::MATH::GVector::DotD(
					difference_ba,
					difference_ba,
					sq_distance);

				double sq_radii = _sphere1.radius + _sphere2.radius;
				sq_radii *= sq_radii;

				_outResult = (sq_distance <= sq_radii) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestSphereToCapsuleD(const MATH::GSPHERED _sphere, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult)
			{
				// Compute squared distance between the sphere center and capsule's start and end.
				double sq_distance = 0.0;
				SqDistancePointToLineD(
					_sphere.data,
					{{{_capsule.data[0], _capsule.data[1]}}},
					sq_distance);

				double sq_radii = _sphere.radius + _capsule.radius;
				sq_radii *= sq_radii;

				_outResult = (sq_distance <= sq_radii) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestSphereToAABBD(const MATH::GSPHERED _sphere, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult)
			{
				MATH::GAABBMMD mm = {};
				ConvertAABBCEToAABBMMD(
					_aabb,
					mm);

				double sq_distance = 0.0;
				SqDistancePointToAABBD(
					_sphere.data.xyz(),
					mm,
					sq_distance);

				double sq_radius = _sphere.radius * _sphere.radius;

				_outResult = (sq_distance <= sq_radius) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestSphereToOBBD(const MATH::GSPHERED _sphere, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				GW::MATH::GVECTORD closest_point = {};
				ClosestPointToOBBD(
					_obb,
					_sphere.data.xyz(),
					closest_point);

				GW::MATH::GVECTORD difference = {};
				GW::MATH::GVector::SubtractVectorD(
					closest_point,
					_sphere.data.xyz(),
					difference);

				double sq_radius = _sphere.radius * _sphere.radius;

				double sq_distance = 0.0;
				GW::MATH::GVector::DotD(
					difference,
					difference,
					sq_distance);

				_outResult = (sq_distance <= sq_radius) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestCapsuleToCapsuleD(const MATH::GCAPSULED _capsule1, const MATH::GCAPSULED _capsule2, GCollisionCheck& _outResult)
			{
				MATH::GVECTORD closest1 = {};
				MATH::GVECTORD closest2 = {};

				ClosestPointsToLineFromLineD(
					{{{_capsule1.data[0], _capsule1.data[1]}}},
					{{{_capsule2.data[0], _capsule2.data[1]}}},
					closest1,
					closest2);

				MATH::GVECTORD difference_ab = {};
				GW::MATH::GVector::SubtractVectorD(
					closest1,
					closest2,
					difference_ab);

				double sq_distance = 0.0;
				GW::MATH::GVector::DotD(
					difference_ab,
					difference_ab,
					sq_distance);

				double sq_radii = _capsule1.radius + _capsule2.radius;
				sq_radii *= sq_radii;

				_outResult = (sq_distance <= sq_radii) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn TestCapsuleToAABBD(const MATH::GCAPSULED _capsule, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult)
			{
				// Expand AABB extents by capsule's radius.
				GW::MATH::GVECTORD center = _aabb.center.xyz();
				GW::MATH::GVECTORD extent = _aabb.extent.xyz();
				extent.x += _capsule.radius;
				extent.y += _capsule.radius;
				extent.z += _capsule.radius;

				GW::MATH::GVECTORD line_midpoint = {};
				GW::MATH::GVector::AddVectorD(
					_capsule.data[0].xyz(),
					_capsule.data[1].xyz(),
					line_midpoint);

				GW::MATH::GVector::ScaleD(
					line_midpoint,
					0.5f,
					line_midpoint);

				GW::MATH::GVECTORD line_mid_length = {};
				GW::MATH::GVector::SubtractVectorD(
					_capsule.data[1].xyz(),
					line_midpoint,
					line_mid_length);

				// Translate box and line to origin
				GW::MATH::GVECTORD o = {};
				GW::MATH::GVector::SubtractVectorD(
					line_midpoint,
					center,
					o);

				GW::MATH::GVECTORD axis =
				{
					{
						{
							G_ABS(line_mid_length.x),
							G_ABS(line_mid_length.y),
							G_ABS(line_mid_length.z)
						}
					}
				};

				// Separating axes
				for(int i = 0; i < 3; i++)
				{
					if(G_ABS(o.data[i]) > extent.data[i] + axis.data[i])
					{
						_outResult = GCollisionCheck::NO_COLLISION;
						return GReturn::SUCCESS;
					}
				}

				axis.x += 1.192092896e-07;
				axis.y += 1.192092896e-07;
				axis.z += 1.192092896e-07;

				if(G_ABS(o.y * line_mid_length.z - o.z * line_mid_length.y) >
				   extent.y* axis.z + extent.z * axis.y)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_ABS(o.z * line_mid_length.x - o.x * line_mid_length.z) >
				   extent.x* axis.z + extent.z * axis.x)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(G_ABS(o.x * line_mid_length.z - o.y * line_mid_length.x) >
				   extent.x* axis.y + extent.z * axis.x)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestCapsuleToOBBD(const MATH::GCAPSULED _capsule, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				MATH::GMATRIXD obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionD(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXD obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0}}},
							{{{0.0, 0.0, 0.0, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				MATH::GCAPSULED capsule = {};
				capsule.data[0] = _capsule.data[0];
				capsule.data[0].w = 1.0f;
				capsule.data[1] = _capsule.data[1];
				capsule.data[1].w = 1.0f;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					capsule.data[0],
					capsule.data[0]);
				GW::MATH::GVector::AddVectorD(
					capsule.data[0],
					_obb.center,
					capsule.data[0]);

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					capsule.data[1],
					capsule.data[1]);
				GW::MATH::GVector::AddVectorD(
					capsule.data[1],
					_obb.center,
					capsule.data[1]);

				capsule.radius = _capsule.radius;

				return TestCapsuleToAABBD(
					capsule,
					{{{_obb.center, _obb.extent}}},
					_outResult);
			}

			static GReturn TestAABBToAABBD(const MATH::GAABBCED _aabb1, const MATH::GAABBCED _aabb2, GCollisionCheck& _outResult)
			{
				if(G_ABS(_aabb1.center.x - _aabb2.center.x) > (_aabb1.extent.x + _aabb2.extent.x) ||
				   G_ABS(_aabb1.center.y - _aabb2.center.y) > (_aabb1.extent.y + _aabb2.extent.y) ||
				   G_ABS(_aabb1.center.z - _aabb2.center.z) > (_aabb1.extent.z + _aabb2.extent.z))
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn TestAABBToOBBD(const MATH::GAABBCED _aabb, const MATH::GOBBD _obb, GCollisionCheck& _outResult)
			{
				MATH::GOBBD obb =
				{
					{
						{
							_aabb.center,
							_aabb.extent,
							{{{0.0, 0.0, 0.0, 1.0f}}}
						}
					}
				};

				return TestOBBToOBBD(
					obb,
					_obb,
					_outResult);
			}

			static GReturn TestOBBToOBBD(const MATH::GOBBD _obb1, const MATH::GOBBD _obb2, GCollisionCheck& _outResult)
			{
				// Convert quaternions into 3 axes for both OBB1 and OBB2.
				double xx2 = 2.0f * _obb1.rotation.x * _obb1.rotation.x;
				double yy2 = 2.0f * _obb1.rotation.y * _obb1.rotation.y;
				double zz2 = 2.0f * _obb1.rotation.z * _obb1.rotation.z;

				double xy2 = 2.0f * _obb1.rotation.x * _obb1.rotation.y;
				double xz2 = 2.0f * _obb1.rotation.x * _obb1.rotation.z;
				double yz2 = 2.0f * _obb1.rotation.y * _obb1.rotation.z;

				double wx2 = 2.0f * _obb1.rotation.w * _obb1.rotation.x;
				double wy2 = 2.0f * _obb1.rotation.w * _obb1.rotation.y;
				double wz2 = 2.0f * _obb1.rotation.w * _obb1.rotation.z;

				MATH::GVECTORD obb1_rotation[3] =
				{
					{{{1.0f - yy2 - zz2, xy2 - wz2, xz2 + wy2}}},
					{{{xy2 + wz2, 1.0f - xx2 - zz2, yz2 - wx2}}},
					{{{xz2 - wy2, yz2 + wx2, 1.0f - xx2 - yy2}}}
				};

				xx2 = 2.0f * _obb2.rotation.x * _obb2.rotation.x;
				yy2 = 2.0f * _obb2.rotation.y * _obb2.rotation.y;
				zz2 = 2.0f * _obb2.rotation.z * _obb2.rotation.z;

				xy2 = 2.0f * _obb2.rotation.x * _obb2.rotation.y;
				xz2 = 2.0f * _obb2.rotation.x * _obb2.rotation.z;
				yz2 = 2.0f * _obb2.rotation.y * _obb2.rotation.z;

				wx2 = 2.0f * _obb2.rotation.w * _obb2.rotation.x;
				wy2 = 2.0f * _obb2.rotation.w * _obb2.rotation.y;
				wz2 = 2.0f * _obb2.rotation.w * _obb2.rotation.z;

				MATH::GVECTORD obb2_rotation[3] =
				{
					{{{1.0f - yy2 - zz2, xy2 - wz2, xz2 + wy2}}},
					{{{xy2 + wz2, 1.0f - xx2 - zz2, yz2 - wx2}}},
					{{{xz2 - wy2, yz2 + wx2, 1.0f - xx2 - yy2}}}
				};

				double projected_radii = 0.0;
				double projected_radii_1 = 0.0;
				double projected_radii_2 = 0.0;
				double test_axis = 0.0;

				double rotation[3][3] = {};
				double abs_rotation[3][3] = {};

				for(int i = 0; i < 3; i++)
				{
					for(int j = 0; j < 3; j++)
					{
						GW::MATH::GVector::DotD(
							obb1_rotation[i],
							obb2_rotation[j],
							rotation[i][j]);
					}
				}

				// Get translation and then bring it into a's coordinate frame.
				MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					_obb2.center,
					_obb1.center,
					difference_ba);

				MATH::GVECTORD translation_vec = {};
				GW::MATH::GVector::DotD(
					difference_ba,
					obb1_rotation[0],
					translation_vec.x);

				GW::MATH::GVector::DotD(
					difference_ba,
					obb1_rotation[1],
					translation_vec.y);

				GW::MATH::GVector::DotD(
					difference_ba,
					obb1_rotation[2],
					translation_vec.z);

				// Get common values while maintaining numerical precision.
				for(int i = 0; i < 3; i++)
				{
					for(int j = 0; j < 3; j++)
					{
						abs_rotation[i][j] =
							G_ABS(rotation[i][j]) + 1.192092896e-07;
					}
				}

				// Test axes for OBB1 x, y, z.
				for(int i = 0; i < 3; i++)
				{
					projected_radii_1 = _obb1.extent.data[i];

					projected_radii_2 =
						_obb2.extent.data[0] * abs_rotation[i][0] +
						_obb2.extent.data[1] * abs_rotation[i][1] +
						_obb2.extent.data[2] * abs_rotation[i][2];

					projected_radii = projected_radii_1 + projected_radii_2;

					test_axis = G_ABS(translation_vec.data[i]);

					if(test_axis > projected_radii)
					{
						_outResult = GCollisionCheck::NO_COLLISION;
						return GReturn::SUCCESS;
					}
				}

				// Test axes for OBB2 x, y, z.
				for(int i = 0; i < 3; i++)
				{
					projected_radii_1 =
						_obb1.extent.data[0] * abs_rotation[0][i] +
						_obb1.extent.data[1] * abs_rotation[1][i] +
						_obb1.extent.data[2] * abs_rotation[2][i];

					projected_radii_2 = _obb2.extent.data[i];

					projected_radii = projected_radii_1 + projected_radii_2;

					test_axis = G_ABS(
						translation_vec.data[0] * rotation[0][i] +
						translation_vec.data[1] * rotation[1][i] +
						translation_vec.data[2] * rotation[2][i]);

					if(test_axis > projected_radii)
					{
						_outResult = GCollisionCheck::NO_COLLISION;
						return GReturn::SUCCESS;
					}
				}

				// Test OBB1 x & OBB2 x
				projected_radii_1 =
					_obb1.extent.data[1] * abs_rotation[2][0] +
					_obb1.extent.data[2] * abs_rotation[1][0];

				projected_radii_2 =
					_obb2.extent.data[1] * abs_rotation[0][2] +
					_obb2.extent.data[2] * abs_rotation[0][1];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[2] * rotation[1][0] -
					translation_vec.data[1] * rotation[2][0]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 x & OBB2 y
				projected_radii_1 =
					_obb1.extent.data[1] * abs_rotation[2][1] +
					_obb1.extent.data[2] * abs_rotation[1][1];

				projected_radii_2 =
					_obb2.extent.data[0] * abs_rotation[0][2] +
					_obb2.extent.data[2] * abs_rotation[0][0];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[2] * rotation[1][1] -
					translation_vec.data[1] * rotation[2][1]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 x & OBB2 z
				projected_radii_1 =
					_obb1.extent.data[1] * abs_rotation[2][2] +
					_obb1.extent.data[2] * abs_rotation[1][2];

				projected_radii_2 =
					_obb2.extent.data[0] * abs_rotation[0][1] +
					_obb2.extent.data[1] * abs_rotation[0][0];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[2] * rotation[1][2] -
					translation_vec.data[1] * rotation[2][2]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 y & OBB2 x
				projected_radii_1 =
					_obb1.extent.data[0] * abs_rotation[2][0] +
					_obb1.extent.data[2] * abs_rotation[0][0];

				projected_radii_2 =
					_obb2.extent.data[1] * abs_rotation[1][2] +
					_obb2.extent.data[2] * abs_rotation[1][1];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[0] * rotation[2][0] -
					translation_vec.data[2] * rotation[0][0]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 y & OBB2 y
				projected_radii_1 =
					_obb1.extent.data[0] * abs_rotation[2][1] +
					_obb1.extent.data[2] * abs_rotation[0][1];

				projected_radii_2 =
					_obb2.extent.data[0] * abs_rotation[1][2] +
					_obb2.extent.data[2] * abs_rotation[1][0];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[0] * rotation[2][1] -
					translation_vec.data[2] * rotation[0][1]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 y & OBB2 z
				projected_radii_1 =
					_obb1.extent.data[0] * abs_rotation[2][2] +
					_obb1.extent.data[2] * abs_rotation[0][2];

				projected_radii_2 =
					_obb2.extent.data[0] * abs_rotation[1][1] +
					_obb2.extent.data[1] * abs_rotation[1][0];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[0] * rotation[2][2] -
					translation_vec.data[2] * rotation[0][2]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 z & OBB2 x
				projected_radii_1 =
					_obb1.extent.data[0] * abs_rotation[1][0] +
					_obb1.extent.data[1] * abs_rotation[0][0];

				projected_radii_2 =
					_obb2.extent.data[1] * abs_rotation[2][2] +
					_obb2.extent.data[2] * abs_rotation[2][1];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[1] * rotation[0][0] -
					translation_vec.data[0] * rotation[1][0]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 z & OBB2 y
				projected_radii_1 =
					_obb1.extent.data[0] * abs_rotation[1][1] +
					_obb1.extent.data[1] * abs_rotation[0][1];

				projected_radii_2 =
					_obb2.extent.data[0] * abs_rotation[2][2] +
					_obb2.extent.data[2] * abs_rotation[2][0];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[1] * rotation[0][1] -
					translation_vec.data[0] * rotation[1][1]);

				if(test_axis > projected_radii)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Test OBB1 z & OBB2 z
				projected_radii_1 =
					_obb1.extent.data[0] * abs_rotation[1][2] +
					_obb1.extent.data[1] * abs_rotation[0][2];

				projected_radii_2 =
					_obb2.extent.data[0] * abs_rotation[2][1] +
					_obb2.extent.data[1] * abs_rotation[2][0];

				projected_radii = projected_radii_1 + projected_radii_2;

				test_axis = G_ABS(
					translation_vec.data[1] * rotation[0][2] -
					translation_vec.data[0] * rotation[1][2]);

				_outResult = test_axis > projected_radii ?
					GCollisionCheck::NO_COLLISION :
					GCollisionCheck::COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn IntersectLineToTriangleD(const MATH::GLINED _line, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD* _outBarycentric, MATH::GVECTORD& _outDirection, double& _outInterval)
			{
				MATH::GLINED line =
				{
					{
						{
							_line.start.xyz(),
							_line.end.xyz()
						}
					}
				};

				MATH::GTRIANGLED triangle =
				{
					{
						{
							_triangle.a.xyz(),
							_triangle.b.xyz(),
							_triangle.c.xyz()
						}
					}
				};

				GW::MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					triangle.b,
					triangle.a,
					difference_ba);

				GW::MATH::GVECTORD difference_ca = {};
				GW::MATH::GVector::SubtractVectorD(
					triangle.c,
					triangle.a,
					difference_ca);

				GW::MATH::GVECTORD norm = {};
				GW::MATH::GVector::CrossVector3D(
					difference_ca,
					difference_ba,
					norm);

				GW::MATH::GVECTORD difference_line = {};
				GW::MATH::GVector::SubtractVectorD(
					line.start,
					line.end,
					difference_line);

				double dot = 0.0;
				GW::MATH::GVector::DotD(
					difference_line,
					norm,
					dot);

				// Segment is parallel to triangle
				if(dot <= 0.0)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORD difference_pa = {};
				GW::MATH::GVector::SubtractVectorD(
					line.start,
					triangle.a,
					difference_pa);

				double interval = 0.0;
				GW::MATH::GVector::DotD(
					difference_pa,
					norm,
					interval);

				if(interval < 0.0 || interval > dot)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORD cross = {};
				GW::MATH::GVector::CrossVector3D(
					difference_line,
					difference_pa,
					cross);

				// Test to see if within bounds of barycentric coordinates.
				GW::MATH::GVECTORD barycentric = {};
				GW::MATH::GVector::DotD(
					difference_ca,
					cross,
					barycentric.y);
				barycentric.y = -barycentric.y;

				if(barycentric.y < 0.0 || barycentric.y > dot)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVector::DotD(
					difference_ba,
					cross,
					barycentric.z);

				if(barycentric.z < 0.0 || barycentric.y + barycentric.z > dot)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				double over_denom = 1.0f / dot;
				barycentric.y *= over_denom;
				barycentric.z *= over_denom;
				barycentric.x = 1.0f - barycentric.y - barycentric.z;
				_outInterval = interval * over_denom;

				_outContactPoint =
				{
					{
						{
							barycentric.x * _triangle.a.x + barycentric.y * _triangle.b.x + barycentric.z * _triangle.c.x,
							barycentric.x * _triangle.a.y + barycentric.y * _triangle.b.y + barycentric.z * _triangle.c.y,
							barycentric.x * _triangle.a.z + barycentric.y * _triangle.b.z + barycentric.z * _triangle.c.z
						}
					}
				};

				if(_outBarycentric)
				{
					*_outBarycentric = barycentric;
				}

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn IntersectLineToPlaneD(const MATH::GLINED _line, const MATH::GPLANED _plane, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval)
			{
				GW::MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					_line.end.xyz(),
					_line.start.xyz(),
					difference_ba);

				double denom = 0.0;
				GW::MATH::GVector::DotD(
					_plane.data.xyz(),
					difference_ba,
					denom);

				if(G_ABS(denom) < 1.192092896e-07)
				{
					// Coplanar
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				double num = 0.0;
				GW::MATH::GVector::DotD(
					_plane.data.xyz(),
					_line.start.xyz(),
					num);

				double interval = (_plane.distance - num) / denom;

				if(interval >= 0.0 && interval <= 1.0f)
				{
					_outResult = GCollisionCheck::COLLISION;

					_outDirection = difference_ba;
					GW::MATH::GVector::NormalizeD(
						_outDirection,
						_outDirection);

					GW::MATH::GVector::ScaleD(
						difference_ba,
						interval,
						_outContactPoint);

					GW::MATH::GVector::AddVectorD(
						_line.start.xyz(),
						_outContactPoint,
						_outContactPoint);

					_outInterval = interval;
				}
				else
				{
					num -= _plane.distance;

					_outResult = (num < 0.0) ?
						_outResult = GCollisionCheck::BELOW :
						_outResult = GCollisionCheck::ABOVE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn IntersectLineToSphereD(const MATH::GLINED _line, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval)
			{
				MATH::GLINED line =
				{
					{
						{
							_line.start.xyz(),
							_line.end.xyz()
						}
					}
				};

				GW::MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					line.start,
					_sphere.data.xyz(),
					difference_ba);

				GW::MATH::GVECTORD dir = {};
				GW::MATH::GVector::SubtractVectorD(
					line.end,
					line.start,
					dir);

				double sq_length = 0.0f;
				GW::MATH::GVector::DotD(
					dir,
					dir,
					sq_length);

				if(GW::MATH::GVector::NormalizeD(dir, dir) == GReturn::FAILURE)
				{
					return GReturn::FAILURE;
				}

				double b = 0.0f;
				GW::MATH::GVector::DotD(
					difference_ba,
					dir,
					b);

				double c = 0.0f;
				GW::MATH::GVector::DotD(
					difference_ba,
					difference_ba,
					c);
				c -= _sphere.radius * _sphere.radius;

				if(c > 0.0f && b > 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				double discriminant = b * b - c;

				if(discriminant < 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outDirection = dir;
				_outInterval = -b - sqrt(discriminant);

				if(_outInterval <= 0.0f)
				{
					// Line is contained in sphere.
					// Clamp to line start.
					_outInterval = 0.0f;
					_outContactPoint = line.start;
				}
				else if(_outInterval * _outInterval >= sq_length)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}
				else
				{
					GW::MATH::GVector::ScaleD(
						_outDirection,
						_outInterval,
						_outContactPoint);

					GW::MATH::GVector::AddVectorD(
						_outContactPoint,
						line.start,
						_outContactPoint);
				}

				_outResult = GCollisionCheck::COLLISION;

				return GReturn::SUCCESS;
			}

			static GReturn IntersectLineToCapsuleD(const MATH::GLINED _line, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval)
			{
				GW::MATH::GVECTORD closest_point1 = {};
				GW::MATH::GVECTORD closest_point2 = {};
				ClosestPointsToLineFromLineD(
					_line,
					{{{_capsule.data[0], _capsule.data[1]}}},
					closest_point1,
					closest_point2);

				MATH::GSPHERED sphere = {};
				sphere.data = closest_point2;
				sphere.radius = _capsule.radius;

				return IntersectLineToSphereD(
					_line,
					sphere,
					_outResult,
					_outContactPoint,
					_outDirection,
					_outInterval);
			}

			static GReturn IntersectLineToAABBD(const MATH::GLINED _line, const MATH::GAABBMMD _aabb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval)
			{
				GW::MATH::GVector::SubtractVectorD(
					_line.end.xyz(),
					_line.start.xyz(),
					_outDirection);

				if(GW::MATH::GVector::NormalizeD(_outDirection, _outDirection) == GReturn::FAILURE)
				{
					return GReturn::FAILURE;
				}

								// TODO div by 0
				double interval1 = (_aabb.min.x - _line.start.x) / _outDirection.x;
				double interval2 = (_aabb.max.x - _line.start.x) / _outDirection.x;

				double interval3 = (_aabb.min.y - _line.start.y) / _outDirection.y;
				double interval4 = (_aabb.max.y - _line.start.y) / _outDirection.y;

				double interval5 = (_aabb.min.z - _line.start.z) / _outDirection.z;
				double interval6 = (_aabb.max.z - _line.start.z) / _outDirection.z;

				double interval_min = G_LARGER(G_LARGER(
					G_SMALLER(interval1, interval2),
					G_SMALLER(interval3, interval4)),
					G_SMALLER(interval5, interval6));

				double interval_max = G_SMALLER(G_SMALLER(
					G_LARGER(interval1, interval2),
					G_LARGER(interval3, interval4)),
					G_LARGER(interval5, interval6));

				if(interval_max < 0.0 || interval_min > 1.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(interval_max < interval_min)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outInterval = (interval_min < 0.0) ?
					interval_max : interval_min;

				GW::MATH::GVector::ScaleD(
					_outDirection,
					_outInterval,
					_outContactPoint);

				GW::MATH::GVector::AddVectorD(
					_outContactPoint,
					_line.start.xyz(),
					_outContactPoint);

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn IntersectLineToOBBD(const MATH::GLINED _line, const MATH::GOBBD _obb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD& _outDirection, double& _outInterval)
			{
				MATH::GLINED line = {};
				line.start = _line.start;
				line.start.w = 1.0f;
				line.end = _line.end;
				line.end.w = 1.0f;

				MATH::GMATRIXD obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionD(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXD obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0}}},
							{{{0.0, 0.0, 0.0, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					line.start,
					line.start);
				GW::MATH::GVector::AddVectorD(
					line.start,
					_obb.center,
					line.start);

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					line.end,
					line.end);
				GW::MATH::GVector::AddVectorD(
					line.end,
					_obb.center,
					line.end);

				MATH::GAABBMMD mm = {};
				ConvertAABBCEToAABBMMD(
					{{{_obb.center, _obb.extent}}},
					mm);

				if(IntersectLineToAABBD(
					line,
					mm,
					_outResult,
					_outContactPoint,
					_outDirection,
					_outInterval) == GReturn::FAILURE)
				{
					return GReturn::FAILURE;
				}

				GMatrixImplementation::InverseD(
					obb_rotation_inverse,
					obb_rotation);

				GW::MATH::GVector::SubtractVectorD(
					_outContactPoint,
					_obb.center,
					_outContactPoint);

				_outContactPoint.w = 1.0F;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation,
					_outContactPoint,
					_outContactPoint);

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation,
					_outDirection.xyz(),
					_outDirection);

				_outContactPoint.w = 0.0F;

				return GReturn::SUCCESS;
			}

			static GReturn IntersectRayToTriangleD(const MATH::GRAYD _ray, const MATH::GTRIANGLED _triangle, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, MATH::GVECTORD* _outBarycentric, double& _outInterval)
			{
				MATH::GRAYD ray =
				{
					{
						{
							_ray.position.xyz(),
							_ray.direction.xyz()
						}
					}
				};

				MATH::GTRIANGLED triangle =
				{
					{
						{
							_triangle.a.xyz(),
							_triangle.b.xyz(),
							_triangle.c.xyz()
						}
					}
				};

				GW::MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					triangle.b,
					triangle.a,
					difference_ba);

				GW::MATH::GVECTORD difference_ca = {};
				GW::MATH::GVector::SubtractVectorD(
					triangle.c,
					triangle.a,
					difference_ca);

				GW::MATH::GVECTORD q = {};
				GW::MATH::GVector::CrossVector3D(
					ray.direction,
					difference_ca,
					q);

				double det = 0.0f;
				GW::MATH::GVector::DotD(
					difference_ba,
					q,
					det);

				// Ray is parallel to or points away from triangle
				if(G_ABS(det) < 1.192092896e-07)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				double denom = 1.0f / det;

				GW::MATH::GVECTORD s = {};
				GW::MATH::GVector::SubtractVectorD(
					ray.position,
					triangle.a,
					s);

				GW::MATH::GVECTORD barycentric = {};
				GW::MATH::GVector::DotD(
					s,
					q,
					barycentric.y);
				barycentric.y *= denom;

				if(barycentric.y < 0.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				GW::MATH::GVECTORD r = {};
				GW::MATH::GVector::CrossVector3D(
					s,
					difference_ba,
					r);

				GW::MATH::GVector::DotD(
					ray.direction,
					r,
					barycentric.z);
				barycentric.z *= denom;

				if(barycentric.z < 0.0f || barycentric.y + barycentric.z > 1.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				barycentric.x = 1.0f - barycentric.y - barycentric.z;

				if(_outBarycentric)
				{
					*_outBarycentric = barycentric;
				}

				_outContactPoint =
				{
					{
						{
							barycentric.x * _triangle.a.x + barycentric.y * _triangle.b.x + barycentric.z * _triangle.c.x,
							barycentric.x * _triangle.a.y + barycentric.y * _triangle.b.y + barycentric.z * _triangle.c.y,
							barycentric.x * _triangle.a.z + barycentric.y * _triangle.b.z + barycentric.z * _triangle.c.z
						}
					}
				};

				GW::MATH::GVECTORD v = {};
				GW::MATH::GVector::SubtractVectorD(
					_outContactPoint,
					ray.position,
					v);
				GW::MATH::GVector::DotD(
					v,
					v,
					_outInterval);

				_outInterval = sqrt(_outInterval);

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn IntersectRayToPlaneD(const MATH::GRAYD _ray, const MATH::GPLANED _plane, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval)
			{
				double denom = 0.0f;
				GW::MATH::GVector::DotD(
					_plane.data.xyz(),
					_ray.direction.xyz(),
					denom);

				if(G_ABS(denom) < 1.192092896e-07)
				{
					// Coplanar
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				double num = 0.0f;
				GW::MATH::GVector::DotD(
					_plane.data.xyz(),
					_ray.position.xyz(),
					num);

				double interval = (_plane.distance - num) / denom;

				if(interval >= 0.0f)
				{
					_outResult = GCollisionCheck::COLLISION;

					GW::MATH::GVector::ScaleD(
						_ray.direction.xyz(),
						interval,
						_outContactPoint);

					GW::MATH::GVector::AddVectorD(
						_ray.position.xyz(),
						_outContactPoint,
						_outContactPoint);

					_outInterval = interval;
				}
				else
				{
					_outResult = GCollisionCheck::NO_COLLISION;
				}

				return GReturn::SUCCESS;
			}

			static GReturn IntersectRayToSphereD(const MATH::GRAYD _ray, const MATH::GSPHERED _sphere, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval)
			{
				MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					_ray.position.xyz(),
					_sphere.data.xyz(),
					difference_ba);

				double b = 0.0;
				MATH::GVECTORD direction_n = _ray.direction.xyz();
				GW::MATH::GVector::DotD(
					difference_ba,
					direction_n,
					b);

				double c = 0.0;
				GW::MATH::GVector::DotD(
					difference_ba,
					difference_ba,
					c);
				c = c - _sphere.radius * _sphere.radius;

				if(c > 0.0 && b > 0.0)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				double discriminant = b * b - c;

				if(discriminant < 0.0)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outInterval = -b - sqrt(discriminant);

				// If t is negative, ray started inside sphere so clamp t to zero
				if(_outInterval < 0.0)
				{
					_outInterval = 0.0;
				}

				GW::MATH::GVector::ScaleD(
					direction_n,
					_outInterval,
					_outContactPoint);

				GW::MATH::GVector::AddVectorD(
					_outContactPoint,
					_ray.position.xyz(),
					_outContactPoint);

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn IntersectRayToCapsuleD(const MATH::GRAYD _ray, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval)
			{
				GW::MATH::GVECTORD closest_point1 = {};
				ClosestPointToRayD(
					_ray,
					_capsule.data[0],
					closest_point1);

				GW::MATH::GSPHERED sphere = {};
				ClosestPointToRayD(
					_ray,
					_capsule.data[1],
					sphere.data);

				ClosestPointsToLineFromLineD(
					{{{closest_point1, sphere.data}}},
					{{{_capsule.data[0], _capsule.data[1]}}},
					closest_point1,
					sphere.data);

				sphere.radius = _capsule.radius;

				return IntersectRayToSphereD(
					_ray,
					sphere,
					_outResult,
					_outContactPoint,
					_outInterval);
			}

			static GReturn IntersectRayToAABBD(const MATH::GRAYD _ray, const MATH::GAABBMMD _aabb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval)
			{
				double interval1 = 0.0;
				double interval2 = 0.0;
				double interval3 = 0.0;
				double interval4 = 0.0;
				double interval5 = 0.0;
				double interval6 = 0.0;

				if(_ray.direction.x)
				{
					interval1 = (_aabb.min.x - _ray.position.x) / _ray.direction.x;
					interval2 = (_aabb.max.x - _ray.position.x) / _ray.direction.x;
				}
				else
				{
					interval1 = (_aabb.min.x - _ray.position.x) > 0.0 ?
						DBL_MAX : DBL_MIN;
					interval2 = (_aabb.max.x - _ray.position.x) > 0.0 ?
						DBL_MAX : DBL_MIN;
				}

				if(_ray.direction.y)
				{
					interval3 = (_aabb.min.y - _ray.position.y) / _ray.direction.y;
					interval4 = (_aabb.max.y - _ray.position.y) / _ray.direction.y;
				}
				else
				{
					interval3 = (_aabb.min.y - _ray.position.y) > 0.0 ?
						DBL_MAX : DBL_MIN;
					interval4 = (_aabb.max.y - _ray.position.y) > 0.0 ?
						DBL_MAX : DBL_MIN;
				}

				if(_ray.direction.z)
				{
					interval5 = (_aabb.min.z - _ray.position.z) / _ray.direction.z;
					interval6 = (_aabb.max.z - _ray.position.z) / _ray.direction.z;
				}
				else
				{
					interval5 = (_aabb.min.z - _ray.position.z) > 0.0 ?
						DBL_MAX : DBL_MIN;
					interval6 = (_aabb.max.z - _ray.position.z) > 0.0 ?
						DBL_MAX : DBL_MIN;
				}

				double interval_min = G_LARGER(G_LARGER(
					G_SMALLER(interval1, interval2),
					G_SMALLER(interval3, interval4)),
					G_SMALLER(interval5, interval6));

				double interval_max = G_SMALLER(G_SMALLER(
					G_LARGER(interval1, interval2),
					G_LARGER(interval3, interval4)),
					G_LARGER(interval5, interval6));

				if(interval_max < 0.0)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				if(interval_max < interval_min)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				_outInterval = (interval_min < 0.0) ?
					interval_max : interval_min;

				GW::MATH::GVector::ScaleD(
					_ray.direction.xyz(),
					_outInterval,
					_outContactPoint);

				GW::MATH::GVector::AddVectorD(
					_outContactPoint,
					_ray.position.xyz(),
					_outContactPoint);

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			static GReturn IntersectRayToOBBD(const MATH::GRAYD _ray, const MATH::GOBBD _obb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactPoint, double& _outInterval)
			{
				MATH::GMATRIXD obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionD(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXD obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0}}},
							{{{0.0, 0.0, 0.0, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				MATH::GRAYD ray = {};
				ray.position = _ray.position;
				ray.position.w = 1.0f;
				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					ray.position,
					ray.position);
				GW::MATH::GVector::AddVectorD(
					ray.position,
					_obb.center,
					ray.position);

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					_ray.direction,
					ray.direction);
				GW::MATH::GVector::NormalizeD(
					ray.direction,
					ray.direction);

				MATH::GAABBMMD mm = {};
				ConvertAABBCEToAABBMMD(
					{{{_obb.center, _obb.extent}}},
					mm);

				IntersectRayToAABBD(
					ray,
					mm,
					_outResult,
					_outContactPoint,
					_outInterval);

				GMatrixImplementation::InverseD(
					obb_rotation_inverse,
					obb_rotation);

				GW::MATH::GVector::SubtractVectorD(
					_outContactPoint,
					_obb.center,
					_outContactPoint);

				_outContactPoint.w = 1.0F;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation,
					_outContactPoint,
					_outContactPoint);

				_outContactPoint.w = 0.0F;

				return GReturn::SUCCESS;
			}

			static GReturn IntersectSphereToSphereD(const MATH::GSPHERED _sphere1, const MATH::GSPHERED _sphere2, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				TestSphereToSphereD(
					_sphere1,
					_sphere2,
					_outResult);

				if (static_cast<int>(_outResult) < 1)
				{
					return GReturn::SUCCESS;
				}

				GW::MATH::GVector::SubtractVectorD(
					_sphere2.data.xyz(),
					_sphere1.data.xyz(),
					_outDirection);

				GW::MATH::GVector::NormalizeD(
					_outDirection,
					_outDirection);

				GW::MATH::GVector::ScaleD(
					_outDirection,
					_sphere1.radius,
					_outContactClosest1);

				GW::MATH::GVector::AddVectorD(
					_sphere1.data.xyz(),
					_outContactClosest1,
					_outContactClosest1);

				GW::MATH::GVector::ScaleD(
					_outDirection,
					-_sphere2.radius,
					_outContactClosest2);

				GW::MATH::GVector::AddVectorD(
					_sphere2.data.xyz(),
					_outContactClosest2,
					_outContactClosest2);

				GW::MATH::GVECTORD difference = {};

				GW::MATH::GVector::SubtractVectorD(
					_outContactClosest1,
					_outContactClosest2,
					difference);

				GW::MATH::GVector::DotD(
					difference,
					difference,
					_outDistance);

				_outDistance = sqrt(_outDistance);

				return GReturn::SUCCESS;
			}

			static GReturn IntersectSphereToCapsuleD(const MATH::GSPHERED _sphere, const MATH::GCAPSULED _capsule, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				MATH::GSPHERED sphere = {};

				ClosestPointToLineD(
					{{{_capsule.data[0], _capsule.data[1]}}},
					_sphere.data,
					sphere.data);

				sphere.radius = _capsule.radius;

				return IntersectSphereToSphereD(
					_sphere,
					sphere,
					_outResult,
					_outContactClosest1,
					_outContactClosest2,
					_outDirection,
					_outDistance);
			}

			static GReturn IntersectSphereToAABBD(const MATH::GSPHERED _sphere, const MATH::GAABBCED _aabb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				MATH::GAABBMMD mm = {};
				ConvertAABBCEToAABBMMD(
					_aabb,
					mm);

				double sq_distance = 0.0;
				SqDistancePointToAABBD(
					_sphere.data.xyz(),
					mm,
					sq_distance);

				double sq_radius = _sphere.radius * _sphere.radius;

				_outResult = (sq_distance <= sq_radius) ?
					GCollisionCheck::COLLISION :
					GCollisionCheck::NO_COLLISION;

				if(_outResult < GCollisionCheck::COLLISION)
				{
					return GReturn::SUCCESS;
				}

				GW::MATH::GVector::SubtractVectorD(
					_aabb.center.xyz(),
					_sphere.data.xyz(),
					_outDirection);

				if(GW::MATH::GVector::NormalizeD(_outDirection, _outDirection) == GReturn::FAILURE)
				{
					_outDirection = {};
				}

				GW::MATH::GVector::ScaleD(
					_outDirection,
					_sphere.radius,
					_outContactClosest1);

				GW::MATH::GVector::AddVectorD(
					_sphere.data.xyz(),
					_outContactClosest1,
					_outContactClosest1);

				for(int i = 0; i < 3; i++)
				{
					_outContactClosest2.data[i] = _sphere.data.data[i];

					_outContactClosest2.data[i] = G_LARGER(
						_outContactClosest2.data[i],
						mm.min.data[i]);

					_outContactClosest2.data[i] = G_SMALLER(
						_outContactClosest2.data[i],
						mm.max.data[i]);
				}

				// Point is inside AABB so clamp to closest face
				if(G_ABS(_sphere.x - _outContactClosest2.x) < 1.192092896e-07 ||
				   G_ABS(_sphere.y - _outContactClosest2.y) < 1.192092896e-07 ||
				   G_ABS(_sphere.z - _outContactClosest2.z) < 1.192092896e-07)
				{
					GW::MATH::GVECTORD translation = {};
					double low = static_cast<double>(0xffffffff);
					double val = 0.0;

					val = mm.max.x - _sphere.x;
					if(G_ABS(val) < low)
					{
						translation = {{{val, 0.0, 0.0}}};
						low = G_ABS(val);
					}

					val = _sphere.x - mm.min.x;
					if(G_ABS(val) < low)
					{
						translation = {{{val, 0.0, 0.0}}};
						low = G_ABS(val);
					}

					val = mm.max.y - _sphere.y;
					if(G_ABS(val) < low)
					{
						translation = {{{0.0, val, 0.0}}};
						low = G_ABS(val);
					}

					val = _sphere.y - mm.min.y;
					if(G_ABS(val) < low)
					{
						translation = {{{0.0, val, 0.0}}};
						low = G_ABS(val);
					}

					val = mm.max.z - _sphere.z;
					if(G_ABS(val) < low)
					{
						translation = {{{0.0, 0.0, val}}};
						low = G_ABS(val);
					}

					val = _sphere.z - mm.min.z;
					if(G_ABS(val) < low)
					{
						translation = {{{0.0, 0.0, val}}};
						low = G_ABS(val);
					}

					GW::MATH::GVector::AddVectorD(
						_outContactClosest2,
						translation,
						_outContactClosest2);
				}

				GW::MATH::GVector::SubtractVectorD(
					_outContactClosest2,
					_outContactClosest1,
					_outDirection);

				GW::MATH::GVector::DotD(
					_outDirection,
					_outDirection,
					_outDistance);

				_outDistance = sqrt(_outDistance);

				if(GW::MATH::GVector::NormalizeD(_outDirection, _outDirection) == GReturn::FAILURE)
				{
					_outDirection = {};
				}

				return GReturn::SUCCESS;
			}

			static GReturn IntersectSphereToOBBD(const MATH::GSPHERED _sphere, const MATH::GOBBD _obb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				MATH::GMATRIXD obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionD(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXD obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0}}},
							{{{0.0, 0.0, 0.0, 1.0f}}}
						}
					}
				};

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row1,
					obb_rotation_inverse.row4.x);
				obb_rotation_inverse.row4.x = -obb_rotation_inverse.row4.x;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row2,
					obb_rotation_inverse.row4.y);
				obb_rotation_inverse.row4.y = -obb_rotation_inverse.row4.y;

				GW::MATH::GVector::DotD(
					_obb.center,
					obb_rotation.row3,
					obb_rotation_inverse.row4.z);
				obb_rotation_inverse.row4.z = -obb_rotation_inverse.row4.z;

				MATH::GSPHERED sphere = {};
				sphere.data = _sphere.data;
				sphere.radius = 1.0f;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					sphere.data,
					sphere.data);
				GW::MATH::GVector::AddVectorD(
					sphere.data,
					_obb.center,
					sphere.data);
				sphere.radius = _sphere.radius;

				IntersectSphereToAABBD(
					sphere,
					{{{_obb.center, _obb.extent}}},
					_outResult,
					_outContactClosest1,
					_outContactClosest2,
					_outDirection,
					_outDistance);

				GMatrixImplementation::InverseD(
					obb_rotation_inverse,
					obb_rotation);

				GW::MATH::GVector::SubtractVectorD(
					_outContactClosest1,
					_obb.center,
					_outContactClosest1);

				_outContactClosest1.w = 1.0F;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation,
					_outContactClosest1,
					_outContactClosest1);

				_outContactClosest1.w = 0.0F;

				GW::MATH::GVector::SubtractVectorD(
					_outContactClosest2,
					_obb.center,
					_outContactClosest2);

				_outContactClosest2.w = 1.0F;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation,
					_outContactClosest2,
					_outContactClosest2);

				_outContactClosest2.w = 0.0F;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation,
					_outDirection.xyz(),
					_outDirection);

				return GReturn::SUCCESS;
			}

			static GReturn IntersectCapsuleToCapsuleD(const MATH::GCAPSULED _capsule1, const MATH::GCAPSULED _capsule2, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				MATH::GSPHERED sphere1 = {};
				MATH::GSPHERED sphere2 = {};

				ClosestPointsToLineFromLineD(
					{{{_capsule1.data[0], _capsule1.data[1]}}},
					{{{_capsule2.data[0], _capsule2.data[1]}}},
					sphere1.data,
					sphere2.data);

				sphere1.radius = _capsule1.radius;
				sphere2.radius = _capsule2.radius;

				return IntersectSphereToSphereD(
					sphere1,
					sphere2,
					_outResult,
					_outContactClosest1,
					_outContactClosest2,
					_outDirection,
					_outDistance);
			}

			static GReturn IntersectCapsuleToAABBD(const MATH::GCAPSULED _capsule, const MATH::GAABBMMD _aabb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				// Extend AABB by capsule radius
				MATH::GAABBMMD aabbMM =
				{
					{
						{
							{{{_aabb.min.x - _capsule.radius, _aabb.min.y - _capsule.radius, _aabb.min.z - _capsule.radius , 0.0}}},
							{{{_aabb.max.x + _capsule.radius, _aabb.max.y + _capsule.radius, _aabb.max.z + _capsule.radius}}}
						}
					}
				};

				MATH::GRAYD ray = {};
				ray.position = _capsule.data[0].xyz();

				GW::MATH::GVector::SubtractVectorD(
					ray.position,
					_capsule.data[0].xyz(),
					ray.direction);

				GW::MATH::GVector::NormalizeD(
					ray.direction,
					ray.direction);

				IntersectRayToAABBD(
					ray,
					aabbMM,
					_outResult,
					_outContactClosest1,
					_outDistance);

				if(static_cast<int>(_outResult) <= 0 || _outDistance > 1.0f)
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				// Flags to determine the region
				int u = 0;
				int v = 0;

				if(_outContactClosest1.x < _aabb.min.x)
				{
					u |= 1;
				}
				if(_outContactClosest1.x > _aabb.max.x)
				{
					v |= 1;
				}

				if(_outContactClosest1.y < _aabb.min.y)
				{
					u |= 2;
				}
				if(_outContactClosest1.y > _aabb.max.y)
				{
					v |= 2;
				}

				if(_outContactClosest1.z < _aabb.min.z)
				{
					u |= 4;
				}
				if(_outContactClosest1.z > _aabb.max.z)
				{
					v |= 4;
				}

				int m = u + v;

				auto Corner = [](const MATH::GAABBMMD box, const int n)->GW::MATH::GVECTORD
				{
					if(n & 1)
					{
						return GW::MATH::GVECTORD{{{box.max.x, box.max.y, box.max.z}}};
					}
					else
					{
						return GW::MATH::GVECTORD{{{box.min.x, box.min.y, box.min.z}}};
					}
				};

				GW::MATH::GCAPSULED capsule;
				capsule.data[0] = Corner(aabbMM, v);

				// Vertex Region
				if(m == 7)
				{
					double tmin = static_cast<double>(0xffffffff);

					capsule.data[1] = Corner(aabbMM, v ^ 1);
					IntersectLineToCapsuleD(
						{{{_capsule.data[0].xyz(), _capsule.data[1].xyz()}}},
						capsule,
						_outResult,
						_outContactClosest1,
						_outDirection,
						tmin);

					if (static_cast<int>(_outResult) > 0)
					{
						_outDistance = G_SMALLER(tmin, _outDistance);
					}

					capsule.data[1] = Corner(aabbMM, v ^ 2);
					IntersectLineToCapsuleD(
						{{{_capsule.data[0].xyz(), _capsule.data[1].xyz()}}},
						capsule,
						_outResult,
						_outContactClosest1,
						_outDirection,
						tmin);

					if(static_cast<int>(_outResult) > 0)
					{
						_outDistance = G_SMALLER(tmin, _outDistance);
					}

					capsule.data[1] = Corner(aabbMM, v ^ 4);
					IntersectLineToCapsuleD(
						{{{_capsule.data[0].xyz(), _capsule.data[1].xyz()}}},
						capsule,
						_outResult,
						_outContactClosest1,
						_outDirection,
						tmin);

					if (static_cast<int>(_outResult) > 0)
					{
						_outDistance = G_SMALLER(tmin, _outDistance);
					}

					if(tmin == static_cast<double>(0xffffffff))
					{
						_outResult = GCollisionCheck::NO_COLLISION;
						return GReturn::SUCCESS;
					}

					_outDistance = tmin;

					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				if((m & (m - 1)) == 0)
				{
					_outResult = GCollisionCheck::COLLISION;
					return GReturn::SUCCESS;
				}

				capsule.data[1] = capsule.data[0];
				capsule.data[0] = Corner(aabbMM, u ^ 7);

				return IntersectLineToCapsuleD(
					{{{_capsule.data[0].xyz(), _capsule.data[1].xyz()}}},
					capsule,
					_outResult,
					_outContactClosest1,
					_outDirection,
					_outDistance);
			}

			static GReturn IntersectCapsuleToOBBD(const MATH::GCAPSULED _capsule, const MATH::GOBBD _obb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				MATH::GMATRIXD obb_rotation = {};
				GMatrixImplementation::ConvertQuaternionD(
					{{{_obb.rotation.x,_obb.rotation.y,_obb.rotation.z,_obb.rotation.w}}},
					obb_rotation);

				MATH::GMATRIXD obb_rotation_inverse =
				{
					{
						{
							{{{obb_rotation.data[0], obb_rotation.data[4], obb_rotation.data[8], 0.0}}},
							{{{obb_rotation.data[1], obb_rotation.data[5], obb_rotation.data[9], 0.0}}},
							{{{obb_rotation.data[2], obb_rotation.data[6], obb_rotation.data[10], 0.0}}},
							{{{0.0, 0.0, 0.0, 1.0f}}}
						}
					}
				};

				MATH::GCAPSULED capsule = {};
				capsule.data[0] = _capsule.data[0];
				capsule.data[0].w = 1.0f;
				capsule.data[1] = _capsule.data[1];
				capsule.data[1].w = 1.0f;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					capsule.data[0],
					capsule.data[0]);

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation_inverse,
					capsule.data[1],
					capsule.data[1]);

				capsule.radius = _capsule.radius;

				IntersectCapsuleToAABBD(
					capsule,
					{{{_obb.center, _obb.extent}}},
					_outResult,
					_outContactClosest1,
					_outContactClosest2,
					_outDirection,
					_outDistance);

				GMatrixImplementation::InverseD(
					obb_rotation_inverse,
					obb_rotation);

				GW::MATH::GVector::SubtractVectorD(
					_outContactClosest1,
					_obb.center,
					_outContactClosest1);

				_outContactClosest1.w = 1.0F;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation,
					_outContactClosest1,
					_outContactClosest1);

				_outContactClosest1.w = 0.0F;

				GW::MATH::GVector::SubtractVectorD(
					_outContactClosest2,
					_obb.center,
					_outContactClosest2);

				_outContactClosest2.w = 1.0F;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation,
					_outContactClosest2,
					_outContactClosest2);

				_outContactClosest2.w = 0.0F;

				GMatrixImplementation::VectorXMatrixD(
					obb_rotation,
					_outDirection.xyz(),
					_outDirection);

				return GReturn::SUCCESS;
			}

			static GReturn IntersectAABBToAABBD(const MATH::GAABBCED _aabb1, const MATH::GAABBCED _aabb2, GCollisionCheck& _outResult, MATH::GAABBCED& _outContactAABB, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				if(G_ABS(_aabb1.center.x - _aabb2.center.x) > (_aabb1.extent.x + _aabb2.extent.x) ||
				   G_ABS(_aabb1.center.y - _aabb2.center.y) > (_aabb1.extent.y + _aabb2.extent.y) ||
				   G_ABS(_aabb1.center.z - _aabb2.center.z) > (_aabb1.extent.z + _aabb2.extent.z))
				{
					_outResult = GCollisionCheck::NO_COLLISION;
					return GReturn::SUCCESS;
				}

				MATH::GAABBMMD aabb = {};
				aabb.min.x = G_LARGER(_aabb1.center.x - _aabb1.extent.x, _aabb2.center.x - _aabb2.extent.x);
				aabb.max.x = G_SMALLER(_aabb1.center.x + _aabb1.extent.x, _aabb2.center.x + _aabb2.extent.x);
				aabb.min.y = G_LARGER(_aabb1.center.y - _aabb1.extent.y, _aabb2.center.y - _aabb2.extent.y);
				aabb.max.y = G_SMALLER(_aabb1.center.y + _aabb1.extent.y, _aabb2.center.y + _aabb2.extent.y);
				aabb.min.z = G_LARGER(_aabb1.center.z - _aabb1.extent.z, _aabb2.center.z - _aabb2.extent.z);
				aabb.max.z = G_SMALLER(_aabb1.center.z + _aabb1.extent.z, _aabb2.center.z + _aabb2.extent.z);

				GW::MATH::GVECTORD difference = {};

				GW::MATH::GVector::SubtractVectorD(
					aabb.max,
					aabb.min,
					difference);

				GW::MATH::GVector::DotD(
					difference,
					difference,
					_outDistance);

				_outDistance = sqrt(_outDistance);

				GW::MATH::GVector::SubtractVectorD(
					_aabb2.center,
					_aabb1.center,
					_outDirection);

				GW::MATH::GVector::NormalizeD(
					_outDirection,
					_outDirection);

				_outResult = GCollisionCheck::COLLISION;
				return GReturn::SUCCESS;
			}

			/*static GReturn IntersectAABBToOBBD(const MATH::GAABBCED _aabb, const MATH::GOBBD _obb, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				return IntersectOBBToOBBD(
					{_aabb.center, _aabb.extent},
					_obb,
					_outResult,
					_outContactClosest1,
					_outContactClosest2,
					_outDirection,
					_outDistance);
			}

			static GReturn IntersectOBBToOBBD(const MATH::GOBBD _obb1, const MATH::GOBBD _obb2, GCollisionCheck& _outResult, MATH::GVECTORD& _outContactClosest1, MATH::GVECTORD& _outContactClosest2, MATH::GVECTORD& _outDirection, double& _outDistance)
			{
				return GReturn::FAILURE;
			}*/

			static GReturn SqDistancePointToLineD(const MATH::GVECTORD _point, const MATH::GLINED _line, double& _outDistance)
			{
				GW::MATH::GVECTORD p = _point.xyz();

				MATH::GLINED line =
				{
					{
						{
							_line.start.xyz(),
							_line.end.xyz()
						}
					}
				};

				MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					line.end,
					line.start,
					difference_ba);

				MATH::GVECTORD difference_pa = {};
				GW::MATH::GVector::SubtractVectorD(
					p,
					line.start,
					difference_pa);

				MATH::GVECTORD difference_pb = {};
				GW::MATH::GVector::SubtractVectorD(
					p,
					line.end,
					difference_pb);

				double interval1 = 0.0;
				GW::MATH::GVector::DotD(
					difference_pa,
					difference_ba,
					interval1);

				if(interval1 <= 0.0)
				{
					GW::MATH::GVector::DotD(
						difference_pa,
						difference_pa,
						_outDistance);

					return GReturn::SUCCESS;
				}

				double interval2 = 0.0;
				GW::MATH::GVector::DotD(
					difference_ba,
					difference_ba,
					interval2);

				if(interval1 >= interval2)
				{
					GW::MATH::GVector::DotD(
						difference_pb,
						difference_pb,
						_outDistance);

					return GReturn::SUCCESS;
				}

				GW::MATH::GVector::DotD(
					difference_pa,
					difference_pa,
					_outDistance);

				if(G_ABS(interval2) >= 1.192092896e-07)
				{
					_outDistance -= interval1 * interval1 / interval2;
				}

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToRayD(const MATH::GVECTORD _point, const MATH::GRAYD _ray, double& _outDistance)
			{
				GW::MATH::GVECTORD p = {};

				ClosestPointToRayD(
					_ray,
					_point,
					p);

				GW::MATH::GVector::SubtractVectorD(
					p,
					_point.xyz(),
					p);

				GW::MATH::GVector::DotD(
					p,
					p,
					_outDistance);

				_outDistance = sqrt(_outDistance);

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToTriangleD(const MATH::GVECTORD _point, const MATH::GTRIANGLED _triangle, double& _outDistance)
			{
				GW::MATH::GVECTORD p = {};
				ClosestPointToTriangleD(
					_triangle,
					_point,
					p);

				GW::MATH::GVector::SubtractVectorD(
					p,
					_point.xyz(),
					p);

				GW::MATH::GVector::DotD(
					p,
					p,
					_outDistance);

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToPlaneD(const MATH::GVECTORD _point, const MATH::GPLANED _plane, double& _outDistance)
			{
				GW::MATH::GVector::DotD(
					_plane.data.xyz(),
					_point.xyz(),
					_outDistance);
				_outDistance -= _plane.distance;
				_outDistance *= _outDistance;

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToSphereD(const MATH::GVECTORD _point, const MATH::GSPHERED _sphere, double& _outDistance)
			{
				GW::MATH::GVECTORD p = {};
				ClosestPointToSphereD(
					_sphere,
					_point,
					p);

				GW::MATH::GVector::SubtractVectorD(
					p,
					_point.xyz(),
					p);

				GW::MATH::GVector::DotD(
					p,
					p,
					_outDistance);

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToCapsuleD(const MATH::GVECTORD _point, const MATH::GCAPSULED _capsule, double& _outDistance)
			{
				GW::MATH::GVECTORD p = {};
				ClosestPointToCapsuleD(
					_capsule,
					_point,
					p);

				GW::MATH::GVector::SubtractVectorD(
					p,
					_point.xyz(),
					p);

				GW::MATH::GVector::DotD(
					p,
					p,
					_outDistance);

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToAABBD(const MATH::GVECTORD _point, const MATH::GAABBMMD _aabb, double& _outDistance)
			{

				_outDistance = 0.0;

				for(int i = 0; i < 3; i++)
				{
					double v = _point.data[i];

					if(v < _aabb.min.data[i])
					{
						_outDistance += (_aabb.min.data[i] - v) * (_aabb.min.data[i] - v);
					}

					if(v > _aabb.max.data[i])
					{
						_outDistance += (v - _aabb.max.data[i]) * (v - _aabb.max.data[i]);
					}
				}

				return GReturn::SUCCESS;
			}

			static GReturn SqDistancePointToOBBD(const MATH::GVECTORD _point, const MATH::GOBBD _obb, double& _outDistance)
			{
				MATH::GVECTORD p = {};
				ClosestPointToOBBD(
					_obb,
					_point,
					p);

				GW::MATH::GVector::SubtractVectorD(
					p,
					_point,
					p);

				GW::MATH::GVector::DotD(
					p,
					p,
					_outDistance);

				return GReturn::SUCCESS;
			}

			static GReturn BarycentricD(const MATH::GVECTORD _a, const MATH::GVECTORD _b, const MATH::GVECTORD _c, const MATH::GVECTORD _p, MATH::GVECTORD& _outBarycentric)
			{
				MATH::GVECTORD difference_ba = {};
				GW::MATH::GVector::SubtractVectorD(
					_b,
					_a,
					difference_ba);

				MATH::GVECTORD difference_ca = {};
				GW::MATH::GVector::SubtractVectorD(
					_c,
					_a,
					difference_ca);

				MATH::GVECTORD triangle_n = {};
				GW::MATH::GVector::CrossVector3D(
					difference_ba,
					difference_ca,
					triangle_n);

				double x = G_ABS(triangle_n.x);
				double y = G_ABS(triangle_n.y);
				double z = G_ABS(triangle_n.z);

				// Degenerate triangle
				if(x + y + z < 1.192092896e-07)
				{
					return GReturn::FAILURE;
				}

				double nominator_u = 0.0;
				double nominator_v = 0.0;
				double w = 0.0;

				// Project to yz plane
				if(x >= y && x >= z)
				{
					// Area of pbc in yz plane
					GW::MATH::GVector::CrossVector2D(
						GW::MATH::GVECTORD{{{_p.y - _b.y,_b.y - _c.y}}},
						GW::MATH::GVECTORD{{{_p.z - _b.z,_b.z - _c.z}}},
						nominator_u);

					// Area of pca in yz plane
					GW::MATH::GVector::CrossVector2D(
						GW::MATH::GVECTORD{{{_p.y - _c.y,_c.y - _a.y}}},
						GW::MATH::GVECTORD{{{_p.z - _c.z,_c.z - _a.z}}},
						nominator_v);

					w = 1.0 / triangle_n.x;
				}
				// Project to the xz plane
				else if(y >= x && y >= z)
				{
					// Area of pbc in xz plane
					GW::MATH::GVector::CrossVector2D(
						GW::MATH::GVECTORD{{{_p.x - _b.x,_b.x - _c.x}}},
						GW::MATH::GVECTORD{{{_p.z - _b.z,_b.z - _c.z}}},
						nominator_u);

					// Area of pca in xz plane
					GW::MATH::GVector::CrossVector2D(
						GW::MATH::GVECTORD{{{_p.x - _c.x,_c.x - _a.x}}},
						GW::MATH::GVECTORD{{{_p.z - _c.z,_c.z - _a.z}}},
						nominator_v);

					w = 1.0 / (-triangle_n.y);
				}
				// Project to the xy plane
				else
				{
					// Area of pbc in xy plane
					GW::MATH::GVector::CrossVector2D(
						GW::MATH::GVECTORD{{{_p.x - _b.x,_b.x - _c.x}}},
						GW::MATH::GVECTORD{{{_p.y - _b.y,_b.y - _c.y}}},
						nominator_u);

					// Area of pca in xy plane
					GW::MATH::GVector::CrossVector2D(
						GW::MATH::GVECTORD{{{_p.x - _c.x,_c.x - _a.x}}},
						GW::MATH::GVECTORD{{{_p.y - _c.y,_c.y - _a.y}}},
						nominator_v);

					w = 1.0 / triangle_n.z;
				}

				double u = nominator_u * w;
				double v = nominator_v * w;

				_outBarycentric =
				{
					{
						{
							u,
							v,
							1.0 - u - v
						}
					}
				};

				return GReturn::SUCCESS;
			}
		};
	}
}


#endif


namespace GW
{
	namespace MATH
	{
		class GCollision final
			: public I::GProxy<I::GCollisionInterface, I::GCollisionImplementation>
		{
		public:
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GCollision)
			GATEWARE_TYPEDEF(GCollisionCheck)
			GATEWARE_STATIC_FUNCTION(ConvertAABBCEToAABBMMF)
			GATEWARE_STATIC_FUNCTION(ConvertAABBMMToAABBCEF)
			GATEWARE_STATIC_FUNCTION(ComputePlaneF)
			GATEWARE_STATIC_FUNCTION(IsTriangleF)
			GATEWARE_STATIC_FUNCTION(TestPointToConvexPolygonF)
			GATEWARE_STATIC_FUNCTION(ClosestPointToLineF)
			GATEWARE_STATIC_FUNCTION(ClosestPointsToLineFromLineF)
			GATEWARE_STATIC_FUNCTION(ClosestPointToRayF)
			GATEWARE_STATIC_FUNCTION(ClosestPointToTriangleF)
			GATEWARE_STATIC_FUNCTION(ClosestPointToPlaneF)
			GATEWARE_STATIC_FUNCTION(ClosestPointToSphereF)
			GATEWARE_STATIC_FUNCTION(ClosestPointToCapsuleF)
			GATEWARE_STATIC_FUNCTION(ClosestPointToAABBF)
			GATEWARE_STATIC_FUNCTION(ClosestPointToOBBF)
			GATEWARE_STATIC_FUNCTION(ComputeSphereFromPointsF)
			GATEWARE_STATIC_FUNCTION(ComputeAABBFromPointsF)
			GATEWARE_STATIC_FUNCTION(TestPointToLineF)
			GATEWARE_STATIC_FUNCTION(TestPointToRayF)
			GATEWARE_STATIC_FUNCTION(TestPointToTriangleF)
			GATEWARE_STATIC_FUNCTION(TestPointToPlaneF)
			GATEWARE_STATIC_FUNCTION(TestPointToSphereF)
			GATEWARE_STATIC_FUNCTION(TestPointToCapsuleF)
			GATEWARE_STATIC_FUNCTION(TestPointToAABBF)
			GATEWARE_STATIC_FUNCTION(TestPointToOBBF)
			GATEWARE_STATIC_FUNCTION(TestLineToLineF)
			GATEWARE_STATIC_FUNCTION(TestLineToRayF)
			GATEWARE_STATIC_FUNCTION(TestLineToTriangleF)
			GATEWARE_STATIC_FUNCTION(TestLineToPlaneF)
			GATEWARE_STATIC_FUNCTION(TestLineToSphereF)
			GATEWARE_STATIC_FUNCTION(TestLineToCapsuleF)
			GATEWARE_STATIC_FUNCTION(TestLineToAABBF)
			GATEWARE_STATIC_FUNCTION(TestLineToOBBF)
			GATEWARE_STATIC_FUNCTION(TestRayToTriangleF)
			GATEWARE_STATIC_FUNCTION(TestRayToPlaneF)
			GATEWARE_STATIC_FUNCTION(TestRayToSphereF)
			GATEWARE_STATIC_FUNCTION(TestRayToCapsuleF)
			GATEWARE_STATIC_FUNCTION(TestRayToAABBF)
			GATEWARE_STATIC_FUNCTION(TestRayToOBBF)
			GATEWARE_STATIC_FUNCTION(TestTriangleToTriangleF)
			GATEWARE_STATIC_FUNCTION(TestTriangleToPlaneF)
			GATEWARE_STATIC_FUNCTION(TestTriangleToSphereF)
			GATEWARE_STATIC_FUNCTION(TestTriangleToCapsuleF)
			GATEWARE_STATIC_FUNCTION(TestTriangleToAABBF)
			GATEWARE_STATIC_FUNCTION(TestTriangleToOBBF)
			GATEWARE_STATIC_FUNCTION(TestPlaneToPlaneF)
			GATEWARE_STATIC_FUNCTION(TestPlaneToSphereF)
			GATEWARE_STATIC_FUNCTION(TestPlaneToCapsuleF)
			GATEWARE_STATIC_FUNCTION(TestPlaneToAABBF)
			GATEWARE_STATIC_FUNCTION(TestPlaneToOBBF)
			GATEWARE_STATIC_FUNCTION(TestSphereToSphereF)
			GATEWARE_STATIC_FUNCTION(TestSphereToCapsuleF)
			GATEWARE_STATIC_FUNCTION(TestSphereToAABBF)
			GATEWARE_STATIC_FUNCTION(TestSphereToOBBF)
			GATEWARE_STATIC_FUNCTION(TestCapsuleToCapsuleF)
			GATEWARE_STATIC_FUNCTION(TestCapsuleToAABBF)
			GATEWARE_STATIC_FUNCTION(TestCapsuleToOBBF)
			GATEWARE_STATIC_FUNCTION(TestAABBToAABBF)
			GATEWARE_STATIC_FUNCTION(TestAABBToOBBF)
			GATEWARE_STATIC_FUNCTION(TestOBBToOBBF)
			GATEWARE_STATIC_FUNCTION(IntersectLineToTriangleF)
			GATEWARE_STATIC_FUNCTION(IntersectLineToPlaneF)
			GATEWARE_STATIC_FUNCTION(IntersectLineToSphereF)
			GATEWARE_STATIC_FUNCTION(IntersectLineToCapsuleF)
			GATEWARE_STATIC_FUNCTION(IntersectLineToAABBF)
			GATEWARE_STATIC_FUNCTION(IntersectLineToOBBF)
			GATEWARE_STATIC_FUNCTION(IntersectRayToTriangleF)
			GATEWARE_STATIC_FUNCTION(IntersectRayToPlaneF)
			GATEWARE_STATIC_FUNCTION(IntersectRayToSphereF)
			GATEWARE_STATIC_FUNCTION(IntersectRayToCapsuleF)
			GATEWARE_STATIC_FUNCTION(IntersectRayToAABBF)
			GATEWARE_STATIC_FUNCTION(IntersectRayToOBBF)
			GATEWARE_STATIC_FUNCTION(IntersectSphereToSphereF)
			GATEWARE_STATIC_FUNCTION(IntersectSphereToCapsuleF)
			GATEWARE_STATIC_FUNCTION(IntersectSphereToAABBF)
			GATEWARE_STATIC_FUNCTION(IntersectSphereToOBBF)
			GATEWARE_STATIC_FUNCTION(IntersectCapsuleToCapsuleF)
			GATEWARE_STATIC_FUNCTION(IntersectCapsuleToAABBF)
			GATEWARE_STATIC_FUNCTION(IntersectCapsuleToOBBF)
			GATEWARE_STATIC_FUNCTION(IntersectAABBToAABBF)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToLineF)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToRayF)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToTriangleF)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToPlaneF)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToSphereF)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToCapsuleF)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToAABBF)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToOBBF)
			GATEWARE_STATIC_FUNCTION(BarycentricF)

			// Double
			GATEWARE_STATIC_FUNCTION(ConvertAABBCEToAABBMMD)
			GATEWARE_STATIC_FUNCTION(ConvertAABBMMToAABBCED)
			GATEWARE_STATIC_FUNCTION(ComputePlaneD)
			GATEWARE_STATIC_FUNCTION(IsTriangleD)
			GATEWARE_STATIC_FUNCTION(TestPointToConvexPolygonD)
			GATEWARE_STATIC_FUNCTION(ClosestPointToLineD)
			GATEWARE_STATIC_FUNCTION(ClosestPointsToLineFromLineD)
			GATEWARE_STATIC_FUNCTION(ClosestPointToRayD)
			GATEWARE_STATIC_FUNCTION(ClosestPointToTriangleD)
			GATEWARE_STATIC_FUNCTION(ClosestPointToPlaneD)
			GATEWARE_STATIC_FUNCTION(ClosestPointToSphereD)
			GATEWARE_STATIC_FUNCTION(ClosestPointToCapsuleD)
			GATEWARE_STATIC_FUNCTION(ClosestPointToAABBD)
			GATEWARE_STATIC_FUNCTION(ClosestPointToOBBD)
			GATEWARE_STATIC_FUNCTION(ComputeSphereFromPointsD)
			GATEWARE_STATIC_FUNCTION(ComputeAABBFromPointsD)
			GATEWARE_STATIC_FUNCTION(TestPointToLineD)
			GATEWARE_STATIC_FUNCTION(TestPointToRayD)
			GATEWARE_STATIC_FUNCTION(TestPointToTriangleD)
			GATEWARE_STATIC_FUNCTION(TestPointToPlaneD)
			GATEWARE_STATIC_FUNCTION(TestPointToSphereD)
			GATEWARE_STATIC_FUNCTION(TestPointToCapsuleD)
			GATEWARE_STATIC_FUNCTION(TestPointToAABBD)
			GATEWARE_STATIC_FUNCTION(TestPointToOBBD)
			GATEWARE_STATIC_FUNCTION(TestLineToLineD)
			GATEWARE_STATIC_FUNCTION(TestLineToRayD)
			GATEWARE_STATIC_FUNCTION(TestLineToTriangleD)
			GATEWARE_STATIC_FUNCTION(TestLineToPlaneD)
			GATEWARE_STATIC_FUNCTION(TestLineToSphereD)
			GATEWARE_STATIC_FUNCTION(TestLineToCapsuleD)
			GATEWARE_STATIC_FUNCTION(TestLineToAABBD)
			GATEWARE_STATIC_FUNCTION(TestLineToOBBD)
			GATEWARE_STATIC_FUNCTION(TestRayToTriangleD)
			GATEWARE_STATIC_FUNCTION(TestRayToPlaneD)
			GATEWARE_STATIC_FUNCTION(TestRayToSphereD)
			GATEWARE_STATIC_FUNCTION(TestRayToCapsuleD)
			GATEWARE_STATIC_FUNCTION(TestRayToAABBD)
			GATEWARE_STATIC_FUNCTION(TestRayToOBBD)
			GATEWARE_STATIC_FUNCTION(TestTriangleToTriangleD)
			GATEWARE_STATIC_FUNCTION(TestTriangleToPlaneD)
			GATEWARE_STATIC_FUNCTION(TestTriangleToSphereD)
			GATEWARE_STATIC_FUNCTION(TestTriangleToCapsuleD)
			GATEWARE_STATIC_FUNCTION(TestTriangleToAABBD)
			GATEWARE_STATIC_FUNCTION(TestTriangleToOBBD)
			GATEWARE_STATIC_FUNCTION(TestPlaneToPlaneD)
			GATEWARE_STATIC_FUNCTION(TestPlaneToSphereD)
			GATEWARE_STATIC_FUNCTION(TestPlaneToCapsuleD)
			GATEWARE_STATIC_FUNCTION(TestPlaneToAABBD)
			GATEWARE_STATIC_FUNCTION(TestPlaneToOBBD)
			GATEWARE_STATIC_FUNCTION(TestSphereToSphereD)
			GATEWARE_STATIC_FUNCTION(TestSphereToCapsuleD)
			GATEWARE_STATIC_FUNCTION(TestSphereToAABBD)
			GATEWARE_STATIC_FUNCTION(TestSphereToOBBD)
			GATEWARE_STATIC_FUNCTION(TestCapsuleToCapsuleD)
			GATEWARE_STATIC_FUNCTION(TestCapsuleToAABBD)
			GATEWARE_STATIC_FUNCTION(TestCapsuleToOBBD)
			GATEWARE_STATIC_FUNCTION(TestAABBToAABBD)
			GATEWARE_STATIC_FUNCTION(TestAABBToOBBD)
			GATEWARE_STATIC_FUNCTION(TestOBBToOBBD)
			GATEWARE_STATIC_FUNCTION(IntersectLineToTriangleD)
			GATEWARE_STATIC_FUNCTION(IntersectLineToPlaneD)
			GATEWARE_STATIC_FUNCTION(IntersectLineToSphereD)
			GATEWARE_STATIC_FUNCTION(IntersectLineToCapsuleD)
			GATEWARE_STATIC_FUNCTION(IntersectLineToAABBD)
			GATEWARE_STATIC_FUNCTION(IntersectLineToOBBD)
			GATEWARE_STATIC_FUNCTION(IntersectRayToTriangleD)
			GATEWARE_STATIC_FUNCTION(IntersectRayToPlaneD)
			GATEWARE_STATIC_FUNCTION(IntersectRayToSphereD)
			GATEWARE_STATIC_FUNCTION(IntersectRayToCapsuleD)
			GATEWARE_STATIC_FUNCTION(IntersectRayToAABBD)
			GATEWARE_STATIC_FUNCTION(IntersectRayToOBBD)
			GATEWARE_STATIC_FUNCTION(IntersectSphereToSphereD)
			GATEWARE_STATIC_FUNCTION(IntersectSphereToCapsuleD)
			GATEWARE_STATIC_FUNCTION(IntersectSphereToAABBD)
			GATEWARE_STATIC_FUNCTION(IntersectSphereToOBBD)
			GATEWARE_STATIC_FUNCTION(IntersectCapsuleToCapsuleD)
			GATEWARE_STATIC_FUNCTION(IntersectCapsuleToAABBD)
			GATEWARE_STATIC_FUNCTION(IntersectCapsuleToOBBD)
			GATEWARE_STATIC_FUNCTION(IntersectAABBToAABBD)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToLineD)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToRayD)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToTriangleD)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToPlaneD)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToSphereD)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToCapsuleD)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToAABBD)
			GATEWARE_STATIC_FUNCTION(SqDistancePointToOBBD)
			GATEWARE_STATIC_FUNCTION(BarycentricD)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}

#endif // GCOLLISION_H

/*---------------------------------
|	End of GCollision.h
----------------------------------*/


/*---------------------------------
|	Begin of GQuaternion.h
----------------------------------*/
#ifndef GQUATERNION_H
#define GQUATERNION_H





namespace GW
{
	namespace I
	{
		class GQuaternionInterface : public virtual GInterfaceInterface
		{
		public:
			// Floats
			static GReturn AddQuaternionF( MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, MATH::GQUATERNIONF& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SubtractQuaternionF( MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, MATH::GQUATERNIONF& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MultiplyQuaternionF( MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, MATH::GQUATERNIONF& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ScaleF( MATH::GQUATERNIONF _quaternion, float _scalar, MATH::GQUATERNIONF& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SetByVectorAngleF( MATH::GVECTORF _vector, float _radian, MATH::GQUATERNIONF& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SetByMatrixF( MATH::GMATRIXF _matrix, MATH::GQUATERNIONF& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn DotF( MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, float& _outValue ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn CrossF( MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, MATH::GVECTORF& _outVector ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ConjugateF( MATH::GQUATERNIONF _quaternion, MATH::GQUATERNIONF& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn InverseF( MATH::GQUATERNIONF _quaternion, MATH::GQUATERNIONF& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MagnitudeF( MATH::GQUATERNIONF _quaternion, float& _outMagnitude ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn NormalizeF( MATH::GQUATERNIONF _quaternion, MATH::GQUATERNIONF& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IdentityF( MATH::GQUATERNIONF& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn LerpF( MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, float _ratio, MATH::GQUATERNIONF& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SlerpF( MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, float _ratio, MATH::GQUATERNIONF& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Upgrade(MATH::GQUATERNIONF _quaternionF, MATH::GQUATERNIOND& _outQuaternionD) { return GReturn::NO_IMPLEMENTATION; }
			// Doubles
			static GReturn AddQuaternionD( MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, MATH::GQUATERNIOND& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SubtractQuaternionD( MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, MATH::GQUATERNIOND& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MultiplyQuaternionD( MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, MATH::GQUATERNIOND& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ScaleD( MATH::GQUATERNIOND _quaternion, double _scalar, MATH::GQUATERNIOND& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SetByVectorAngleD( MATH::GVECTORD _vector, double _radian, MATH::GQUATERNIOND& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SetByMatrixD( MATH::GMATRIXD _matrix, MATH::GQUATERNIOND& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn DotD( MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, double& _outValue ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn CrossD( MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, MATH::GVECTORD& _outVector ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ConjugateD( MATH::GQUATERNIOND _quaternion, MATH::GQUATERNIOND& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn InverseD( MATH::GQUATERNIOND _quaternion, MATH::GQUATERNIOND& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MagnitudeD( MATH::GQUATERNIOND _quaternion, double& _outMagnitude ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn NormalizeD( MATH::GQUATERNIOND _quaternion, MATH::GQUATERNIOND& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn IdentityD( MATH::GQUATERNIOND& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn LerpD( MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, double _ratio, MATH::GQUATERNIOND& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn SlerpD( MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, double _ratio, MATH::GQUATERNIOND& _outQuaternion ) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Downgrade(MATH::GQUATERNIOND _quaternionD, MATH::GQUATERNIONF& _outQuaternionF) { return GReturn::NO_IMPLEMENTATION; }
		};
	}
}

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GQuaternion.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_MATH) || defined(GATEWARE_DISABLE_GQUATERNION) || \
    (defined(GATEWARE_ENABLE_MATH) && !defined(GATEWARE_DISABLE_GQUATERNION) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
	namespace I
	{
		class GQuaternionImplementation : public virtual GQuaternionInterface,
			private GInterfaceImplementation
		{
		public:
			GReturn Create()
			{
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			// Floats
			static GReturn AddQuaternionF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, MATH::GQUATERNIONF& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn SubtractQuaternionF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, MATH::GQUATERNIONF& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn MultiplyQuaternionF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, MATH::GQUATERNIONF& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn ScaleF(MATH::GQUATERNIONF _quaternion, float _scalar, MATH::GQUATERNIONF& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn SetByVectorAngleF(MATH::GVECTORF _vector, float _radian, MATH::GQUATERNIONF& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn SetByMatrixF(MATH::GMATRIXF _matrix, MATH::GQUATERNIONF& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn DotF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, float& _outValue)
			{
				return GReturn::FAILURE;
			}
			static GReturn CrossF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, MATH::GVECTORF& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn ConjugateF(MATH::GQUATERNIONF _quaternion, MATH::GQUATERNIONF& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn InverseF(MATH::GQUATERNIONF _quaternion, MATH::GQUATERNIONF& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn MagnitudeF(MATH::GQUATERNIONF _quaternion, float& _outMagnitude)
			{
				return GReturn::FAILURE;
			}
			static GReturn NormalizeF(MATH::GQUATERNIONF _quaternion, MATH::GQUATERNIONF& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn IdentityF(MATH::GQUATERNIONF& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn LerpF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, float _ratio, MATH::GQUATERNIONF& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn SlerpF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, float _ratio, MATH::GQUATERNIONF& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn Upgrade(MATH::GQUATERNIONF _quaternionF, MATH::GQUATERNIOND& _outQuaternionD) 
			{
				return GReturn::FAILURE; 
			}
			// Doubles
			static GReturn AddQuaternionD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, MATH::GQUATERNIOND& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn SubtractQuaternionD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, MATH::GQUATERNIOND& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn MultiplyQuaternionD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, MATH::GQUATERNIOND& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn ScaleD(MATH::GQUATERNIOND _quaternion, double _scalar, MATH::GQUATERNIOND& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn SetByVectorAngleD(MATH::GVECTORD _vector, double _radain, MATH::GQUATERNIOND& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn SetByMatrixD(MATH::GMATRIXD _matrix, MATH::GQUATERNIOND& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn DotD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, double& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn CrossD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, MATH::GVECTORD& _outVector)
			{
				return GReturn::FAILURE;
			}
			static GReturn ConjugateD(MATH::GQUATERNIOND _quaternion, MATH::GQUATERNIOND& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn InverseD(MATH::GQUATERNIOND _quaternion, MATH::GQUATERNIOND& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn MagnitudeD(MATH::GQUATERNIOND _quaternion, double& _outMagnitude)
			{
				return GReturn::FAILURE;
			}
			static GReturn NormalizeD(MATH::GQUATERNIOND _quaternion, MATH::GQUATERNIOND& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn IdentityD(MATH::GQUATERNIOND& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn LerpD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, float _ratio, MATH::GQUATERNIOND& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn SlerpD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, double _ratio, MATH::GQUATERNIOND& _outQuaternion)
			{
				return GReturn::FAILURE;
			}
			static GReturn Downgrade(MATH::GQUATERNIOND _quaternionD, MATH::GQUATERNIONF& _outQuaternionF)
			{
				return GReturn::FAILURE; 
			}
		};
	}
}

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
    #include <cmath>

namespace GW
{
	namespace I
	{
		class GQuaternionImplementation : public virtual GQuaternionInterface,
			private GInterfaceImplementation
		{
		public:
			GReturn Create()
			{
				return GReturn::SUCCESS;
			}
			static GReturn AddQuaternionF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, MATH::GQUATERNIONF& _outQuaternion)
			{
				_outQuaternion.x = _quaternion1.x + _quaternion2.x;
				_outQuaternion.y = _quaternion1.y + _quaternion2.y;
				_outQuaternion.z = _quaternion1.z + _quaternion2.z;
				_outQuaternion.w = _quaternion1.w + _quaternion2.w;
				return GReturn::SUCCESS;
			}
			static GReturn SubtractQuaternionF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, MATH::GQUATERNIONF& _outQuaternion)
			{
				_outQuaternion.x = _quaternion1.x - _quaternion2.x;
				_outQuaternion.y = _quaternion1.y - _quaternion2.y;
				_outQuaternion.z = _quaternion1.z - _quaternion2.z;
				_outQuaternion.w = _quaternion1.w - _quaternion2.w;
				return GReturn::SUCCESS;
			}
			static GReturn MultiplyQuaternionF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, MATH::GQUATERNIONF& _outQuaternion)
			{
				MATH::GQUATERNIONF _q1 = _quaternion1;
				MATH::GQUATERNIONF _q2 = _quaternion2;

				_outQuaternion.x = _q1.w * _q2.x + _q1.x * _q2.w + _q1.y * _q2.z - _q1.z * _q2.y;
				_outQuaternion.y = _q1.w * _q2.y - _q1.x * _q2.z + _q1.y * _q2.w + _q1.z * _q2.x;
				_outQuaternion.z = _q1.w * _q2.z + _q1.x * _q2.y - _q1.y * _q2.x + _q1.z * _q2.w;
				_outQuaternion.w = _q1.w * _q2.w - _q1.x * _q2.x - _q1.y * _q2.y - _q1.z * _q2.z;

				return GReturn::SUCCESS;
			}
			static GReturn ScaleF(MATH::GQUATERNIONF _quaternion, float _scalar, MATH::GQUATERNIONF& _outQuaternion)
			{
				_outQuaternion.x = _quaternion.x * _scalar;
				_outQuaternion.y = _quaternion.y * _scalar;
				_outQuaternion.z = _quaternion.z * _scalar;
				_outQuaternion.w = _quaternion.w * _scalar;
				return GReturn::SUCCESS;
			}
			static GReturn SetByVectorAngleF(MATH::GVECTORF _vector, float _radian, MATH::GQUATERNIONF& _outQuaternion)
			{
				float s = sinf(_radian / 2.0f);
				_outQuaternion.x = s * _vector.x;
				_outQuaternion.y = s * _vector.y;
				_outQuaternion.z = s * _vector.z;
				_outQuaternion.w = cosf(_radian / 2.0f);
				return GReturn::SUCCESS;
			}
			static GReturn SetByMatrixF(MATH::GMATRIXF _matrix, MATH::GQUATERNIONF& _outQuaternion)
			{
				float det;
				float sx = sqrtf(_matrix.data[0] * _matrix.data[0] + _matrix.data[4] * _matrix.data[4] + _matrix.data[8] * _matrix.data[8]);
				float sy = sqrtf(_matrix.data[1] * _matrix.data[1] + _matrix.data[5] * _matrix.data[5] + _matrix.data[9] * _matrix.data[9]);
				float sz = sqrtf(_matrix.data[2] * _matrix.data[2] + _matrix.data[6] * _matrix.data[6] + _matrix.data[10] * _matrix.data[10]);
				if (G_COMPARISON_STANDARD_F(sx, 0.0f) || G_COMPARISON_STANDARD_F(sy, 0.0f) || G_COMPARISON_STANDARD_F(sz, 0.0f))
				{
					//scale too close to zero, can not decompose rotation
					return GReturn::FAILURE;
				}

				float a0 = _matrix.data[0] * _matrix.data[5] - _matrix.data[1] * _matrix.data[4];
				float a1 = _matrix.data[0] * _matrix.data[6] - _matrix.data[2] * _matrix.data[4];
				float a2 = _matrix.data[0] * _matrix.data[7] - _matrix.data[3] * _matrix.data[4];
				float a3 = _matrix.data[1] * _matrix.data[6] - _matrix.data[2] * _matrix.data[5];
				float a4 = _matrix.data[1] * _matrix.data[7] - _matrix.data[3] * _matrix.data[5];
				float a5 = _matrix.data[2] * _matrix.data[7] - _matrix.data[3] * _matrix.data[6];
				float b0 = _matrix.data[8] * _matrix.data[13] - _matrix.data[9] * _matrix.data[12];
				float b1 = _matrix.data[8] * _matrix.data[14] - _matrix.data[10] * _matrix.data[12];
				float b2 = _matrix.data[8] * _matrix.data[15] - _matrix.data[11] * _matrix.data[12];
				float b3 = _matrix.data[9] * _matrix.data[14] - _matrix.data[10] * _matrix.data[13];
				float b4 = _matrix.data[9] * _matrix.data[15] - _matrix.data[11] * _matrix.data[13];
				float b5 = _matrix.data[10] * _matrix.data[15] - _matrix.data[11] * _matrix.data[14];

				det = a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0;

				if (det < 0)
				{
					sz = -sz;
				}
				MATH::GMATRIXF Rotation = _matrix;
				Rotation.data[0] /= sx;
				Rotation.data[1] /= sy;
				Rotation.data[2] /= sz;
				Rotation.data[4] /= sx;
				Rotation.data[5] /= sy;
				Rotation.data[6] /= sz;
				Rotation.data[8] /= sx;
				Rotation.data[9] /= sy;
				Rotation.data[10] /= sz;

				float trace = _matrix.data[0] + _matrix.data[5] + _matrix.data[10] + 1;

				if (trace > G_EPSILON_F)
				{
					float s = 0.5f / sqrtf(trace);
					_outQuaternion.x = (Rotation.row3.y - Rotation.row2.z) * s;
					_outQuaternion.y = (Rotation.row1.z - Rotation.row3.x) * s;
					_outQuaternion.z = (Rotation.row2.x - Rotation.row1.y) * s;
					_outQuaternion.w = 0.25f / s;
				}
				else
				{
					if (Rotation.row1.x > Rotation.row2.y&& Rotation.row1.x > Rotation.row3.z)
					{
						float s = 0.5f / sqrtf(1.0f + Rotation.row1.x - Rotation.row2.y - Rotation.row3.z);
						_outQuaternion.x = 0.25f / s;
						_outQuaternion.y = (Rotation.row1.y + Rotation.row2.x) * s;
						_outQuaternion.z = (Rotation.row1.z + Rotation.row3.x) * s;
						_outQuaternion.w = (Rotation.row3.y - Rotation.row2.z) * s;
					}
					else if (Rotation.row2.y > Rotation.row3.z)
					{
						float s = 0.5f / sqrtf(1.0f + Rotation.row2.y - Rotation.row1.x - Rotation.row3.z);
						_outQuaternion.x = (Rotation.row1.y + Rotation.row2.x) * s;
						_outQuaternion.y = 0.25f / s;
						_outQuaternion.z = (Rotation.row2.z + Rotation.row3.y) * s;
						_outQuaternion.w = (Rotation.row1.z - Rotation.row3.x) * s;
					}
					else
					{
						float s = 0.5f / sqrtf(1.0f + Rotation.row3.z - Rotation.row1.x - Rotation.row2.y);
						_outQuaternion.x = (Rotation.row1.z + Rotation.row3.x) * s;
						_outQuaternion.y = (Rotation.row2.z + Rotation.row3.y) * s;
						_outQuaternion.z = 0.25f / s;
						_outQuaternion.w = (Rotation.row2.x - Rotation.row1.y) * s;
					}
				}
				return GReturn::SUCCESS;
			}
			static GReturn DotF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, float& _outValue)
			{
				_outValue = _quaternion1.w * _quaternion2.w + _quaternion1.x * _quaternion2.x + _quaternion1.y * _quaternion2.y + _quaternion1.z * _quaternion2.z;
				return GReturn::SUCCESS;
			}
			static GReturn CrossF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, MATH::GVECTORF& _outVector)
			{
				_outVector.x = (_quaternion1.y * _quaternion2.z) - (_quaternion1.z * _quaternion2.y);
				_outVector.y = (_quaternion1.z * _quaternion2.x) - (_quaternion1.x * _quaternion2.z);
				_outVector.z = (_quaternion1.x * _quaternion2.y) - (_quaternion1.y * _quaternion2.x);
				_outVector.w = 0.0f;

				return GReturn::SUCCESS;
			}
			static GReturn ConjugateF(MATH::GQUATERNIONF _quaternion, MATH::GQUATERNIONF& _outQuaternion)
			{
				_outQuaternion.x = -_quaternion.x;
				_outQuaternion.y = -_quaternion.y;
				_outQuaternion.z = -_quaternion.z;
				_outQuaternion.w = _quaternion.w;
				return GReturn::SUCCESS;
			}
			static GReturn InverseF(MATH::GQUATERNIONF _quaternion, MATH::GQUATERNIONF& _outQuaternion)
			{
				MATH::GQUATERNIONF temp;
				float magnitude;
				ConjugateF(_quaternion, temp);
				if (MagnitudeF(_quaternion, magnitude) != GReturn::SUCCESS)
				{
					return GReturn::FAILURE;
				}
				_outQuaternion.x = temp.x / (magnitude * magnitude);
				_outQuaternion.y = temp.y / (magnitude * magnitude);
				_outQuaternion.z = temp.z / (magnitude * magnitude);
				_outQuaternion.w = temp.w / (magnitude * magnitude);
				return GReturn::SUCCESS;
			}
			static GReturn MagnitudeF(MATH::GQUATERNIONF _quaternion, float& _outMagnitude)
			{
				_outMagnitude = sqrtf(_quaternion.x * _quaternion.x + _quaternion.y * _quaternion.y + _quaternion.z * _quaternion.z + _quaternion.w * _quaternion.w);
				if (G_COMPARISON_STANDARD_F(_outMagnitude, G_EPSILON_F))
					return GReturn::FAILURE;

				return GReturn::SUCCESS;
			}
			static GReturn NormalizeF(MATH::GQUATERNIONF _quaternion, MATH::GQUATERNIONF& _outQuaternion)
			{
				float magnitude;
				MagnitudeF(_quaternion, magnitude);
				if (G_COMPARISON_STANDARD_F(magnitude, 1.0f))
				{
					_outQuaternion = _quaternion;
					return GReturn::SUCCESS;
				}
				if (G_COMPARISON_STANDARD_F(magnitude, G_EPSILON_F))
				{
					return GReturn::FAILURE;
				}
				magnitude = 1 / magnitude;
				_outQuaternion.x = _quaternion.x * magnitude;
				_outQuaternion.y = _quaternion.y * magnitude;
				_outQuaternion.z = _quaternion.z * magnitude;
				_outQuaternion.w = _quaternion.w * magnitude;
				return GReturn::SUCCESS;
			}
			static GReturn IdentityF(MATH::GQUATERNIONF& _outQuaternion)
			{
				_outQuaternion = MATH::GIdentityQuaternionF;
				return GReturn::SUCCESS;
			}
			static GReturn LerpF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, float _ratio, MATH::GQUATERNIONF& _outQuaternion)
			{
				_outQuaternion.x = G_LERP(_quaternion1.x, _quaternion2.x, _ratio);
				_outQuaternion.y = G_LERP(_quaternion1.y, _quaternion2.y, _ratio);
				_outQuaternion.z = G_LERP(_quaternion1.z, _quaternion2.z, _ratio);
				_outQuaternion.w = G_LERP(_quaternion1.w, _quaternion2.w, _ratio);
				return GReturn::SUCCESS;
			}
			static GReturn SlerpF(MATH::GQUATERNIONF _quaternion1, MATH::GQUATERNIONF _quaternion2, float _ratio, MATH::GQUATERNIONF& _outQuaternion)
			{
				MATH::GQUATERNIONF q1;
				MATH::GQUATERNIONF q2;
				if (NormalizeF(_quaternion1, q1) != GReturn::SUCCESS || NormalizeF(_quaternion2, q2) != GReturn::SUCCESS)
				{
					return GReturn::FAILURE;
				}
				float dot;
				DotF(q1, q2, dot);
				float theta = acosf(dot);

				ScaleF(q1, sinf(theta * (1 - _ratio)) / sinf(theta), q1);
				ScaleF(q2, sinf(theta * _ratio) / sinf(theta), q2);

				AddQuaternionF(q1, q2, _outQuaternion);

				return GReturn::SUCCESS;
			}
			static GReturn Upgrade(MATH::GQUATERNIONF _quaternionF, MATH::GQUATERNIOND& _outQuaternionD) 
			{
				_outQuaternionD.x = static_cast<double>(_quaternionF.x);
				_outQuaternionD.y = static_cast<double>(_quaternionF.y);
				_outQuaternionD.z = static_cast<double>(_quaternionF.z);
				_outQuaternionD.w = static_cast<double>(_quaternionF.w);

				return GReturn::SUCCESS; 
			}






			static GReturn AddQuaternionD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, MATH::GQUATERNIOND& _outQuaternion)
			{
				_outQuaternion.x = _quaternion1.x + _quaternion2.x;
				_outQuaternion.y = _quaternion1.y + _quaternion2.y;
				_outQuaternion.z = _quaternion1.z + _quaternion2.z;
				_outQuaternion.w = _quaternion1.w + _quaternion2.w;
				return GReturn::SUCCESS;
			}
			static GReturn SubtractQuaternionD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, MATH::GQUATERNIOND& _outQuaternion)
			{
				_outQuaternion.x = _quaternion1.x - _quaternion2.x;
				_outQuaternion.y = _quaternion1.y - _quaternion2.y;
				_outQuaternion.z = _quaternion1.z - _quaternion2.z;
				_outQuaternion.w = _quaternion1.w - _quaternion2.w;
				return GReturn::SUCCESS;
			}
			static GReturn MultiplyQuaternionD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, MATH::GQUATERNIOND& _outQuaternion)
			{
				MATH::GQUATERNIOND _q1 = _quaternion1;
				MATH::GQUATERNIOND _q2 = _quaternion2;
				_outQuaternion.x = _q1.w * _q2.x + _q1.x * _q2.w + _q1.y * _q2.z - _q1.z * _q2.y;
				_outQuaternion.y = _q1.w * _q2.y - _q1.x * _q2.z + _q1.y * _q2.w + _q1.z * _q2.x;
				_outQuaternion.z = _q1.w * _q2.z + _q1.x * _q2.y - _q1.y * _q2.x + _q1.z * _q2.w;
				_outQuaternion.w = _q1.w * _q2.w - _q1.x * _q2.x - _q1.y * _q2.y - _q1.z * _q2.z;


				return GReturn::SUCCESS;
			}
			static GReturn ScaleD(MATH::GQUATERNIOND _quaternion, double _scalar, MATH::GQUATERNIOND& _outQuaternion)
			{
				_outQuaternion.x = _quaternion.x * _scalar;
				_outQuaternion.y = _quaternion.y * _scalar;
				_outQuaternion.z = _quaternion.z * _scalar;
				_outQuaternion.w = _quaternion.w * _scalar;
				return GReturn::SUCCESS;
			}
			static GReturn SetByVectorAngleD(MATH::GVECTORD _vector, double _radian, MATH::GQUATERNIOND& _outQuaternion)
			{
				double s = sin(_radian / 2.0);
				_outQuaternion.x = s * _vector.x;
				_outQuaternion.y = s * _vector.y;
				_outQuaternion.z = s * _vector.z;
				_outQuaternion.w = cos(_radian / 2.0);
				return GReturn::SUCCESS;
			}
			static GReturn SetByMatrixD(MATH::GMATRIXD _matrix, MATH::GQUATERNIOND& _outQuaternion)
			{
				double det;
				double sx = sqrt(_matrix.data[0] * _matrix.data[0] + _matrix.data[4] * _matrix.data[4] + _matrix.data[8] * _matrix.data[8]);
				double sy = sqrt(_matrix.data[1] * _matrix.data[1] + _matrix.data[5] * _matrix.data[5] + _matrix.data[9] * _matrix.data[9]);
				double sz = sqrt(_matrix.data[2] * _matrix.data[2] + _matrix.data[6] * _matrix.data[6] + _matrix.data[10] * _matrix.data[10]);
				if (G_COMPARISON_STANDARD_D(sx, 0) || G_COMPARISON_STANDARD_D(sy, 0) || G_COMPARISON_STANDARD_D(sz, 0))
				{
					//scale too close to zero, can not decompose rotation
					return GReturn::FAILURE;
				}
				double a0 = _matrix.data[0] * _matrix.data[5] - _matrix.data[1] * _matrix.data[4];
				double a1 = _matrix.data[0] * _matrix.data[6] - _matrix.data[2] * _matrix.data[4];
				double a2 = _matrix.data[0] * _matrix.data[7] - _matrix.data[3] * _matrix.data[4];
				double a3 = _matrix.data[1] * _matrix.data[6] - _matrix.data[2] * _matrix.data[5];
				double a4 = _matrix.data[1] * _matrix.data[7] - _matrix.data[3] * _matrix.data[5];
				double a5 = _matrix.data[2] * _matrix.data[7] - _matrix.data[3] * _matrix.data[6];
				double b0 = _matrix.data[8] * _matrix.data[13] - _matrix.data[9] * _matrix.data[12];
				double b1 = _matrix.data[8] * _matrix.data[14] - _matrix.data[10] * _matrix.data[12];
				double b2 = _matrix.data[8] * _matrix.data[15] - _matrix.data[11] * _matrix.data[12];
				double b3 = _matrix.data[9] * _matrix.data[14] - _matrix.data[10] * _matrix.data[13];
				double b4 = _matrix.data[9] * _matrix.data[15] - _matrix.data[11] * _matrix.data[13];
				double b5 = _matrix.data[10] * _matrix.data[15] - _matrix.data[11] * _matrix.data[14];

				det = a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0;

				if (det < 0)
				{
					sz = -sz;
				}
				MATH::GMATRIXD Rotation = _matrix;
				Rotation.data[0] /= sx;
				Rotation.data[1] /= sy;
				Rotation.data[2] /= sz;
				Rotation.data[4] /= sx;
				Rotation.data[5] /= sy;
				Rotation.data[6] /= sz;
				Rotation.data[8] /= sx;
				Rotation.data[9] /= sy;
				Rotation.data[10] /= sz;

				double trace = _matrix.data[0] + _matrix.data[5] + _matrix.data[10] + 1;

				if (trace > G_EPSILON_D)
				{
					double s = 0.5 / sqrt(trace);
					_outQuaternion.x = (Rotation.row3.y - Rotation.row2.z) * s;
					_outQuaternion.y = (Rotation.row1.z - Rotation.row3.x) * s;
					_outQuaternion.z = (Rotation.row2.x - Rotation.row1.y) * s;
					_outQuaternion.w = 0.25 / s;
				}
				else
				{
					if (Rotation.row1.x > Rotation.row2.y&& Rotation.row1.x > Rotation.row3.z)
					{
						double s = 0.5 / sqrt(1.0 + Rotation.row1.x - Rotation.row2.y - Rotation.row3.z);
						_outQuaternion.x = 0.25 / s;
						_outQuaternion.y = (Rotation.row1.y + Rotation.row2.x) * s;
						_outQuaternion.z = (Rotation.row1.z + Rotation.row3.x) * s;
						_outQuaternion.w = (Rotation.row3.y - Rotation.row2.z) * s;
					}
					else if (Rotation.row2.y > Rotation.row3.z)
					{
						double s = 0.5 / sqrt(1.0 + Rotation.row2.y - Rotation.row1.x - Rotation.row3.z);
						_outQuaternion.x = (Rotation.row1.y + Rotation.row2.x) * s;
						_outQuaternion.y = 0.25 / s;
						_outQuaternion.z = (Rotation.row2.z + Rotation.row3.y) * s;
						_outQuaternion.w = (Rotation.row1.z - Rotation.row3.x) * s;
					}
					else
					{
						double s = 0.5 / sqrt(1.0 + Rotation.row3.z - Rotation.row1.x - Rotation.row2.y);
						_outQuaternion.x = (Rotation.row1.z + Rotation.row3.x) * s;
						_outQuaternion.y = (Rotation.row2.z + Rotation.row3.y) * s;
						_outQuaternion.z = 0.25 / s;
						_outQuaternion.w = (Rotation.row2.x - Rotation.row1.y) * s;
					}
				}
				return GReturn::SUCCESS;
			}
			static GReturn DotD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, double& _outValue)
			{
				_outValue = _quaternion1.w * _quaternion2.w + _quaternion1.x * _quaternion2.x + _quaternion1.y * _quaternion2.y + _quaternion1.z * _quaternion2.z;
				return GReturn::SUCCESS;
			}
			static GReturn CrossD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, MATH::GVECTORD& _outVector)
			{
				_outVector.x = (_quaternion1.y * _quaternion2.z) - (_quaternion1.z * _quaternion2.y);
				_outVector.y = (_quaternion1.z * _quaternion2.x) - (_quaternion1.x * _quaternion2.z);
				_outVector.z = (_quaternion1.x * _quaternion2.y) - (_quaternion1.y * _quaternion2.x);
				_outVector.w = 0.0;

				return GReturn::SUCCESS;
			}
			static GReturn ConjugateD(MATH::GQUATERNIOND _quaternion, MATH::GQUATERNIOND& _outQuaternion)
			{
				_outQuaternion.x = -_quaternion.x;
				_outQuaternion.y = -_quaternion.y;
				_outQuaternion.z = -_quaternion.z;
				_outQuaternion.w = _quaternion.w;

				return GReturn::SUCCESS;
			}
			static GReturn InverseD(MATH::GQUATERNIOND _quaternion, MATH::GQUATERNIOND& _outQuaternion)
			{
				MATH::GQUATERNIOND temp;
				double magnitude;
				ConjugateD(_quaternion, temp);
				if (MagnitudeD(_quaternion, magnitude) != GReturn::SUCCESS)
				{
					return GReturn::FAILURE;
				};

				_outQuaternion.x = temp.x / (magnitude * magnitude);
				_outQuaternion.y = temp.y / (magnitude * magnitude);
				_outQuaternion.z = temp.z / (magnitude * magnitude);
				_outQuaternion.w = temp.w / (magnitude * magnitude);
				return GReturn::SUCCESS;
			}
			static GReturn MagnitudeD(MATH::GQUATERNIOND _quaternion, double& _outMagnitude)
			{
				_outMagnitude = sqrt(_quaternion.x * _quaternion.x + _quaternion.y * _quaternion.y + _quaternion.z * _quaternion.z + _quaternion.w * _quaternion.w);
				if (G_COMPARISON_STANDARD_D(_outMagnitude, 0))
					return GReturn::FAILURE;
				return GReturn::SUCCESS;
			}
			static GReturn NormalizeD(MATH::GQUATERNIOND _quaternion, MATH::GQUATERNIOND& _outQuaternion)
			{
				double magnitude;
				MagnitudeD(_quaternion, magnitude);
				if (G_COMPARISON_STANDARD_D(magnitude, 1))
				{
					_outQuaternion = _quaternion;
					return GReturn::SUCCESS;
				}
				if (G_COMPARISON_STANDARD_D(magnitude, G_EPSILON_D))
				{
					return GReturn::FAILURE;
				}
				magnitude = 1 / magnitude;
				_outQuaternion.x = _quaternion.x * magnitude;
				_outQuaternion.y = _quaternion.y * magnitude;
				_outQuaternion.z = _quaternion.z * magnitude;
				_outQuaternion.w = _quaternion.w * magnitude;
				return GReturn::SUCCESS;
			}
			static GReturn IdentityD(MATH::GQUATERNIOND& _outQuaternion)
			{
				_outQuaternion = MATH::GIdentityQuaternionD;
				return GReturn::SUCCESS;
			}
			static GReturn LerpD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, double _ratio, MATH::GQUATERNIOND& _outQuaternion)
			{
				if (_ratio > 1)
					_ratio = 1;
				if (_ratio < 0)
					_ratio = 0;

				if (G_COMPARISON_STANDARD_D(_ratio, 0))
				{
					_outQuaternion = _quaternion1;
					return GReturn::SUCCESS;
				}
				else if (G_COMPARISON_STANDARD_D(_ratio, 1))
				{
					_outQuaternion = _quaternion2;
					return GReturn::SUCCESS;
				}

				_outQuaternion.x = G_LERP(_quaternion1.x, _quaternion2.x, _ratio);
				_outQuaternion.y = G_LERP(_quaternion1.y, _quaternion2.y, _ratio);
				_outQuaternion.z = G_LERP(_quaternion1.z, _quaternion2.z, _ratio);
				_outQuaternion.w = G_LERP(_quaternion1.w, _quaternion2.w, _ratio);
				return GReturn::SUCCESS;
			}
			static GReturn SlerpD(MATH::GQUATERNIOND _quaternion1, MATH::GQUATERNIOND _quaternion2, double _ratio, MATH::GQUATERNIOND& _outQuaternion)
			{
				if (_ratio > 1)
					_ratio = 1;
				if (_ratio < 0)
					_ratio = 0;

				MATH::GQUATERNIOND q1;
				MATH::GQUATERNIOND q2;
				if (NormalizeD(_quaternion1, q1) != GReturn::SUCCESS || NormalizeD(_quaternion2, q2) != GReturn::SUCCESS)
				{
					return GReturn::FAILURE;
				}

				if (G_COMPARISON_STANDARD_D(_ratio, 0))
				{
					_outQuaternion = _quaternion1;
					return GReturn::SUCCESS;
				}
				else if (G_COMPARISON_STANDARD_D(_ratio, 1))
				{
					_outQuaternion = _quaternion2;
					return GReturn::SUCCESS;
				}


				double dot;
				DotD(q1, q2, dot);
				double theta = acos(dot);

				ScaleD(q1, sin(theta * (1 - _ratio)) / sin(theta), q1);
				ScaleD(q2, sin(theta * _ratio) / sin(theta), q2);

				AddQuaternionD(q1, q2, _outQuaternion);

				return GReturn::SUCCESS;
			}
			static GReturn Downgrade(MATH::GQUATERNIOND _quaternionD, MATH::GQUATERNIONF& _outQuaternionF) {
				_outQuaternionF.x = static_cast<float>(_quaternionD.x);
				_outQuaternionF.y = static_cast<float>(_quaternionD.y);
				_outQuaternionF.z = static_cast<float>(_quaternionD.z);
				_outQuaternionF.w = static_cast<float>(_quaternionD.w);

				return GReturn::SUCCESS;
			}
		};
	}
}

#endif


namespace GW
{
	namespace MATH
	{
		class GQuaternion final
			: public I::GProxy<I::GQuaternionInterface, I::GQuaternionImplementation >
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS( GQuaternion )
			GATEWARE_STATIC_FUNCTION(AddQuaternionF)
			GATEWARE_STATIC_FUNCTION(SubtractQuaternionF)
			GATEWARE_STATIC_FUNCTION(MultiplyQuaternionF)
			GATEWARE_STATIC_FUNCTION(ScaleF)
			GATEWARE_STATIC_FUNCTION(SetByVectorAngleF)
			GATEWARE_STATIC_FUNCTION(SetByMatrixF)
			GATEWARE_STATIC_FUNCTION(DotF)
			GATEWARE_STATIC_FUNCTION(CrossF)
			GATEWARE_STATIC_FUNCTION(ConjugateF)
			GATEWARE_STATIC_FUNCTION(InverseF)
			GATEWARE_STATIC_FUNCTION(MagnitudeF)
			GATEWARE_STATIC_FUNCTION(NormalizeF)
			GATEWARE_STATIC_FUNCTION(IdentityF)
			GATEWARE_STATIC_FUNCTION(LerpF)
			GATEWARE_STATIC_FUNCTION(SlerpF)
			GATEWARE_STATIC_FUNCTION(Upgrade)


			// Double Quaternion Methods
			GATEWARE_STATIC_FUNCTION(AddQuaternionD)
			GATEWARE_STATIC_FUNCTION(SubtractQuaternionD)
			GATEWARE_STATIC_FUNCTION(MultiplyQuaternionD)
			GATEWARE_STATIC_FUNCTION(ScaleD)
			GATEWARE_STATIC_FUNCTION(SetByVectorAngleD)
			GATEWARE_STATIC_FUNCTION(SetByMatrixD)
			GATEWARE_STATIC_FUNCTION(DotD)
			GATEWARE_STATIC_FUNCTION(CrossD)
			GATEWARE_STATIC_FUNCTION(ConjugateD)
			GATEWARE_STATIC_FUNCTION(InverseD)
			GATEWARE_STATIC_FUNCTION(MagnitudeD)
			GATEWARE_STATIC_FUNCTION(NormalizeD)
			GATEWARE_STATIC_FUNCTION(IdentityD)
			GATEWARE_STATIC_FUNCTION(LerpD)
			GATEWARE_STATIC_FUNCTION(SlerpD)
			GATEWARE_STATIC_FUNCTION(Downgrade)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GQUATERNION_H

/*---------------------------------
|	End of GQuaternion.h
----------------------------------*/


/*---------------------------------
|	Begin of GMatrix2D.h
----------------------------------*/
#ifndef GMATRIX2D_H
#define GMATRIX2D_H





namespace GW
{
	namespace I
	{
		class GMatrix2DInterface : public virtual GInterfaceInterface
		{
		public:
			// Floats
			static GReturn Add2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Add3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Subtract2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Subtract3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Multiply2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Multiply3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MatrixXVector2F(MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GVECTOR2F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MatrixXVector3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR3F _vector, MATH2D::GVECTOR3F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MultiplyNum2F(MATH2D::GMATRIX2F _matrix, float _scalar, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MultiplyNum3F(MATH2D::GMATRIX3F _matrix, float _scalar, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Determinant2F(MATH2D::GMATRIX2F _matrix, float& _outDeterminant) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Determinant3F(MATH2D::GMATRIX3F _matrix, float& _outDeterminant) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Transpose2F(MATH2D::GMATRIX2F _matrix, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Transpose3F(MATH2D::GMATRIX3F _matrix, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Inverse2F(MATH2D::GMATRIX2F _matrix, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Inverse3F(MATH2D::GMATRIX3F _matrix, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetRotation2F(MATH2D::GMATRIX2F _matrix, float& _outRadians) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetRotation3F(MATH2D::GMATRIX3F _matrix, float& _outRadians) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetTranslation3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetScale2F(MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F& _outScale) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetScale3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F& _outScale) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetSkew2F(MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F& _outSkew) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetSkew3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F& _outSkew) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Rotate2F(MATH2D::GMATRIX2F _matrix, float _radians, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateGlobal3F(MATH2D::GMATRIX3F _matrix, float _radians, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateLocal3F(MATH2D::GMATRIX3F _matrix, float _radians, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TranslateGlobal3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TranslateLocal3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Scale2F(MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ScaleGlobal3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ScaleLocal3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Lerp2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, float _ratio, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Lerp3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, float _ratio, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MakeRelative2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MakeRelative3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MakeSeparate2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MakeSeparate3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Upgrade2(MATH2D::GMATRIX2F _matrix, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Upgrade3(MATH2D::GMATRIX3F _matrix, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			// Doubles
			static GReturn Add2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Add3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Subtract2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Subtract3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Multiply2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Multiply3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MatrixXVector2D(MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MatrixXVector3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR3D _vector, MATH2D::GVECTOR3D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MultiplyNum2D(MATH2D::GMATRIX2D _matrix, double _scalar, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MultiplyNum3D(MATH2D::GMATRIX3D _matrix, double _scalar, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Determinant2D(MATH2D::GMATRIX2D _matrix, double& _outDeterminant) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Determinant3D(MATH2D::GMATRIX3D _matrix, double& _outDeterminant) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Transpose2D(MATH2D::GMATRIX2D _matrix, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Transpose3D(MATH2D::GMATRIX3D _matrix, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Inverse2D(MATH2D::GMATRIX2D _matrix, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Inverse3D(MATH2D::GMATRIX3D _matrix, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetRotation2D(MATH2D::GMATRIX2D _matrix, double& _outRadians) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetRotation3D(MATH2D::GMATRIX3D _matrix, double& _outRadians) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetTranslation3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetScale2D(MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D& _outScale) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetScale3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D& _outScale) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetSkew2D(MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D& _outSkew) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GetSkew3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D& _outSkew) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Rotate2D(MATH2D::GMATRIX2D _matrix, double _radians, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateGlobal3D(MATH2D::GMATRIX3D _matrix, double _radians, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn RotateLocal3D(MATH2D::GMATRIX3D _matrix, double _radians, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TranslateGlobal3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn TranslateLocal3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Scale2D(MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ScaleGlobal3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn ScaleLocal3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Lerp2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, double _ratio, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Lerp3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, double _ratio, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MakeRelative2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MakeRelative3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MakeSeparate2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn MakeSeparate3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Downgrade2(MATH2D::GMATRIX2D _matrix, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Downgrade3(MATH2D::GMATRIX3D _matrix, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::NO_IMPLEMENTATION; }
		};
	}
}

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GMatrix2D.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_MATH2D) || defined(GATEWARE_DISABLE_GMATRIX2D) || \
    (defined(GATEWARE_ENABLE_MATH2D) && !defined(GATEWARE_DISABLE_GMATRIX2D) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
	namespace I
	{
		class GMatrix2DImplementation : public virtual GMatrix2DInterface, private GInterfaceImplementation
		{
		public:
			GReturn Create()
			{
				return GReturn::FEATURE_UNSUPPORTED;
			}
			// Floats
			static GReturn Add2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Add3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Subtract2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Subtract3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Multiply2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Multiply3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MatrixXVector2F(MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GVECTOR2F& _outVector) { return GReturn::FAILURE; }
			static GReturn MatrixXVector3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR3F _vector, MATH2D::GVECTOR3F& _outVector) { return GReturn::FAILURE; }
			static GReturn MultiplyNum2F(MATH2D::GMATRIX2F _matrix, float _scalar, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MultiplyNum3F(MATH2D::GMATRIX3F _matrix, float _scalar, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Determinant2F(MATH2D::GMATRIX2F _matrix, float& _outDeterminant) { return GReturn::FAILURE; }
			static GReturn Determinant3F(MATH2D::GMATRIX3F _matrix, float& _outDeterminant) { return GReturn::FAILURE; }
			static GReturn Transpose2F(MATH2D::GMATRIX2F _matrix, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Transpose3F(MATH2D::GMATRIX3F _matrix, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Inverse2F(MATH2D::GMATRIX2F _matrix, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Inverse3F(MATH2D::GMATRIX3F _matrix, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn GetRotation2F(MATH2D::GMATRIX2F _matrix, float& _outRadians) { return GReturn::FAILURE; }
			static GReturn GetRotation3F(MATH2D::GMATRIX3F _matrix, float& _outRadians) { return GReturn::FAILURE; }
			static GReturn GetTranslation3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F& _outVector) { return GReturn::FAILURE; }
			static GReturn GetScale2F(MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F& _outScale) { return GReturn::FAILURE; }
			static GReturn GetScale3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F& _outScale) { return GReturn::FAILURE; }
			static GReturn GetSkew2F(MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F& _outSkew) { return GReturn::FAILURE; }
			static GReturn GetSkew3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F& _outSkew) { return GReturn::FAILURE; }
			static GReturn Rotate2F(MATH2D::GMATRIX2F _matrix, float _radians, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateGlobal3F(MATH2D::GMATRIX3F _matrix, float _radians, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateLocal3F(MATH2D::GMATRIX3F _matrix, float _radians, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn TranslateGlobal3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn TranslateLocal3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Scale2F(MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ScaleGlobal3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ScaleLocal3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Lerp2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, float _ratio, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Lerp3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, float _ratio, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MakeRelative2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MakeRelative3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MakeSeparate2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MakeSeparate3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Upgrade2(MATH2D::GMATRIX2F _matrix, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Upgrade3(MATH2D::GMATRIX3F _matrix, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			// Doubles
			static GReturn Add2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Add3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Subtract2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Subtract3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Multiply2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Multiply3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MatrixXVector2D(MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn MatrixXVector3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR3D _vector, MATH2D::GVECTOR3D& _outVector) { return GReturn::FAILURE; }
			static GReturn MultiplyNum2D(MATH2D::GMATRIX2D _matrix, double _scalar, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MultiplyNum3D(MATH2D::GMATRIX3D _matrix, double _scalar, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Determinant2D(MATH2D::GMATRIX2D _matrix, double& _outDeterminant) { return GReturn::FAILURE; }
			static GReturn Determinant3D(MATH2D::GMATRIX3D _matrix, double& _outDeterminant) { return GReturn::FAILURE; }
			static GReturn Transpose2D(MATH2D::GMATRIX2D _matrix, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Transpose3D(MATH2D::GMATRIX3D _matrix, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Inverse2D(MATH2D::GMATRIX2D _matrix, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Inverse3D(MATH2D::GMATRIX3D _matrix, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn GetRotation2D(MATH2D::GMATRIX2D _matrix, double& _outRadians) { return GReturn::FAILURE; }
			static GReturn GetRotation3D(MATH2D::GMATRIX3D _matrix, double& _outRadians) { return GReturn::FAILURE; }
			static GReturn GetTranslation3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn GetScale2D(MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D& _outScale) { return GReturn::FAILURE; }
			static GReturn GetScale3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D& _outScale) { return GReturn::FAILURE; }
			static GReturn GetSkew2D(MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D& _outSkew) { return GReturn::FAILURE; }
			static GReturn GetSkew3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D& _outSkew) { return GReturn::FAILURE; }
			static GReturn Rotate2D(MATH2D::GMATRIX2D _matrix, double _radians, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateGlobal3D(MATH2D::GMATRIX3D _matrix, double _radians, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn RotateLocal3D(MATH2D::GMATRIX3D _matrix, double _radians, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn TranslateGlobal3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn TranslateLocal3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Scale2D(MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ScaleGlobal3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn ScaleLocal3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Lerp2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, double _ratio, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Lerp3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, double _ratio, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MakeRelative2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MakeRelative3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MakeSeparate2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn MakeSeparate3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Downgrade2(MATH2D::GMATRIX2D _matrix, MATH2D::GMATRIX2D& _outMatrix) { return GReturn::FAILURE; }
			static GReturn Downgrade3(MATH2D::GMATRIX3D _matrix, MATH2D::GMATRIX3D& _outMatrix) { return GReturn::FAILURE; }
		};
	}
}

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
    #include <cmath>

namespace GW
{
	namespace I
	{
		class GMatrix2DImplementation : public virtual GMatrix2DInterface, private GInterfaceImplementation
		{
		public:
			GReturn Create()
			{
				return GReturn::SUCCESS;
			}

			// Floats
			static GReturn Add2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix)
			{
				for (int i = 0; i < 4; i++)
				{
					_outMatrix.data[i] = _matrix1.data[i] + _matrix2.data[i];
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn Add3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix)
			{
				for (int i = 0; i < 9; i++)
				{
					_outMatrix.data[i] = _matrix1.data[i] + _matrix2.data[i];
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn Subtract2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix)
			{
				for (int i = 0; i < 4; i++)
				{
					_outMatrix.data[i] = _matrix1.data[i] - _matrix2.data[i];
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn Subtract3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix)
			{
				for (int i = 0; i < 9; i++)
				{
					_outMatrix.data[i] = _matrix1.data[i] - _matrix2.data[i];
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn Multiply2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix)
			{
				_outMatrix.data[0] = _matrix1.data[0] * _matrix2.data[0] + _matrix1.data[1] * _matrix2.data[2];
				_outMatrix.data[1] = _matrix1.data[0] * _matrix2.data[1] + _matrix1.data[1] * _matrix2.data[3];

				_outMatrix.data[2] = _matrix1.data[2] * _matrix2.data[0] + _matrix1.data[3] * _matrix2.data[2];
				_outMatrix.data[3] = _matrix1.data[2] * _matrix2.data[1] + _matrix1.data[3] * _matrix2.data[3];

				return GW::GReturn::SUCCESS;
			}

			static GReturn Multiply3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix)
			{
				_outMatrix.data[0] = _matrix1.data[0] * _matrix2.data[0] + _matrix1.data[1] * _matrix2.data[3] + _matrix1.data[2] * _matrix2.data[6];
				_outMatrix.data[1] = _matrix1.data[0] * _matrix2.data[1] + _matrix1.data[1] * _matrix2.data[4] + _matrix1.data[2] * _matrix2.data[7];
				_outMatrix.data[2] = _matrix1.data[0] * _matrix2.data[2] + _matrix1.data[1] * _matrix2.data[5] + _matrix1.data[2] * _matrix2.data[8];

				_outMatrix.data[3] = _matrix1.data[3] * _matrix2.data[0] + _matrix1.data[4] * _matrix2.data[3] + _matrix1.data[5] * _matrix2.data[6];
				_outMatrix.data[4] = _matrix1.data[3] * _matrix2.data[1] + _matrix1.data[4] * _matrix2.data[4] + _matrix1.data[5] * _matrix2.data[7];
				_outMatrix.data[5] = _matrix1.data[3] * _matrix2.data[2] + _matrix1.data[4] * _matrix2.data[5] + _matrix1.data[5] * _matrix2.data[8];

				_outMatrix.data[6] = _matrix1.data[6] * _matrix2.data[0] + _matrix1.data[7] * _matrix2.data[3] + _matrix1.data[8] * _matrix2.data[6];
				_outMatrix.data[7] = _matrix1.data[6] * _matrix2.data[1] + _matrix1.data[7] * _matrix2.data[4] + _matrix1.data[8] * _matrix2.data[7];
				_outMatrix.data[8] = _matrix1.data[6] * _matrix2.data[2] + _matrix1.data[7] * _matrix2.data[5] + _matrix1.data[8] * _matrix2.data[8];

				return GW::GReturn::SUCCESS;
			}

			static GReturn MatrixXVector2F(MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GVECTOR2F& _outVector)
			{
				_outVector.x = _vector.data[0] * _matrix.data[0] + _vector.data[1] * _matrix.data[2];
				_outVector.y = _vector.data[0] * _matrix.data[1] + _vector.data[1] * _matrix.data[3];

				return GReturn::SUCCESS;
			}

			static GReturn MatrixXVector3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR3F _vector, MATH2D::GVECTOR3F& _outVector)
			{
				_outVector.x = _vector.data[0] * _matrix.data[0] + _vector.data[1] * _matrix.data[3] + _vector.data[2] * _matrix.data[6];
				_outVector.y = _vector.data[0] * _matrix.data[1] + _vector.data[1] * _matrix.data[4] + _vector.data[2] * _matrix.data[7];
				_outVector.z = _vector.data[0] * _matrix.data[2] + _vector.data[1] * _matrix.data[5] + _vector.data[2] * _matrix.data[8];

				return GReturn::SUCCESS;
			}

			static GReturn MultiplyNum2F(MATH2D::GMATRIX2F _matrix, float _scalar, MATH2D::GMATRIX2F& _outMatrix)
			{
				for (int i = 0; i < 4; i++)
				{
					_outMatrix.data[i] = _matrix.data[i] * _scalar;
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn MultiplyNum3F(MATH2D::GMATRIX3F _matrix, float _scalar, MATH2D::GMATRIX3F& _outMatrix)
			{
				for (int i = 0; i < 9; i++)
				{
					_outMatrix.data[i] = _matrix.data[i] * _scalar;
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn Determinant2F(MATH2D::GMATRIX2F _matrix, float& _outDeterminant)
			{
				_outDeterminant = _matrix.data[0] * _matrix.data[3] - _matrix.data[1] * _matrix.data[2];

				return GW::GReturn::SUCCESS;
			}

			static GReturn Determinant3F(MATH2D::GMATRIX3F _matrix, float& _outDeterminant)
			{
				float a = (_matrix.data[0] * _matrix.data[4] * _matrix.data[8]) + (_matrix.data[1] * _matrix.data[5] * _matrix.data[6]) + (_matrix.data[2] * _matrix.data[3] * _matrix.data[7]);
				float b = (_matrix.data[6] * _matrix.data[4] * _matrix.data[2]) + (_matrix.data[7] * _matrix.data[5] * _matrix.data[0]) + (_matrix.data[8] * _matrix.data[3] * _matrix.data[1]);

				_outDeterminant = a - b;

				return GReturn::SUCCESS;
			}

			static GReturn Transpose2F(MATH2D::GMATRIX2F _matrix, MATH2D::GMATRIX2F& _outMatrix)
			{
				_outMatrix.data[0] = _matrix.data[0];
				_outMatrix.data[1] = _matrix.data[2];
				_outMatrix.data[2] = _matrix.data[1];
				_outMatrix.data[3] = _matrix.data[3];

				return GReturn::SUCCESS;
			}

			static GReturn Transpose3F(MATH2D::GMATRIX3F _matrix, MATH2D::GMATRIX3F& _outMatrix)
			{
				_outMatrix.data[0] = _matrix.data[0];
				_outMatrix.data[1] = _matrix.data[3];
				_outMatrix.data[2] = _matrix.data[6];
				_outMatrix.data[3] = _matrix.data[1];
				_outMatrix.data[4] = _matrix.data[4];
				_outMatrix.data[5] = _matrix.data[7];
				_outMatrix.data[6] = _matrix.data[2];
				_outMatrix.data[7] = _matrix.data[5];
				_outMatrix.data[8] = _matrix.data[8];

				return GReturn::SUCCESS;
			}

			static GReturn Inverse2F(MATH2D::GMATRIX2F _matrix, MATH2D::GMATRIX2F& _outMatrix)
			{
				float determinant;

				Determinant2F(_matrix, determinant);

				if (G2D_COMPARISON_STANDARD_F(determinant, 0.0f))
				{
					return GReturn::FAILURE;
				}

				_outMatrix.data[0] = _matrix.data[3];
				_outMatrix.data[1] = -_matrix.data[1];
				_outMatrix.data[2] = -_matrix.data[2];
				_outMatrix.data[3] = _matrix.data[0];

				MultiplyNum2F(_outMatrix, 1.0f / determinant, _outMatrix);

				return GReturn::SUCCESS;
			}

			static GReturn Inverse3F(MATH2D::GMATRIX3F _matrix, MATH2D::GMATRIX3F& _outMatrix)
			{
				float determinant;

				Determinant3F(_matrix, determinant);

				if (G2D_COMPARISON_STANDARD_F(determinant, 0.0f))
				{
					return GReturn::FAILURE;
				}

				// simultaneously calculate the matrix of minors, convert it to the matrix of cofactors, and then transpose it
				_outMatrix.data[0] = (_matrix.data[4] * _matrix.data[8] - _matrix.data[5] * _matrix.data[7]); // 0
				_outMatrix.data[1] = -(_matrix.data[1] * _matrix.data[8] - _matrix.data[2] * _matrix.data[7]); // 3
				_outMatrix.data[2] = (_matrix.data[1] * _matrix.data[5] - _matrix.data[2] * _matrix.data[4]); // 6

				_outMatrix.data[3] = -(_matrix.data[3] * _matrix.data[8] - _matrix.data[5] * _matrix.data[6]); // 1
				_outMatrix.data[4] = (_matrix.data[0] * _matrix.data[8] - _matrix.data[2] * _matrix.data[6]); // 4
				_outMatrix.data[5] = -(_matrix.data[0] * _matrix.data[5] - _matrix.data[2] * _matrix.data[3]); // 7

				_outMatrix.data[6] = (_matrix.data[3] * _matrix.data[7] - _matrix.data[4] * _matrix.data[6]); // 2
				_outMatrix.data[7] = -(_matrix.data[0] * _matrix.data[7] - _matrix.data[1] * _matrix.data[6]); // 5
				_outMatrix.data[8] = (_matrix.data[0] * _matrix.data[4] - _matrix.data[1] * _matrix.data[3]); // 8

				MultiplyNum3F(_outMatrix, 1.0f / determinant, _outMatrix);

				return GReturn::SUCCESS;
			}

			static GReturn GetRotation2F(MATH2D::GMATRIX2F _matrix, float& _outRadians)
			{
				// Apply the QR-like decomposition.
				if (!G2D_COMPARISON_STANDARD_F(_matrix.data[0], 0.0f) || !G2D_COMPARISON_STANDARD_F(_matrix.data[1], 0.0f))
				{
					float r = sqrt(_matrix.data[0] * _matrix.data[0] + _matrix.data[1] * _matrix.data[1]);
					_outRadians = _matrix.data[1] > 0.0f ? acos(_matrix.data[0] / r) : -acos(_matrix.data[0] / r);
				}
				else if (!G2D_COMPARISON_STANDARD_F(_matrix.data[2], 0.0f) || !G2D_COMPARISON_STANDARD_F(_matrix.data[3], 0.0f))
				{
					float s = sqrt(_matrix.data[2] * _matrix.data[2] + _matrix.data[3] * _matrix.data[3]);
					_outRadians = G2D_PI_F / 2.0f - (_matrix.data[3] > 0.0f ? acos(-_matrix.data[3] / s) : -acos(_matrix.data[3] / s));
				}
				else
				{
					// x1 = x2 = y1 = y2 = 0
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn GetRotation3F(MATH2D::GMATRIX3F _matrix, float& _outRadians)
			{
				// Apply the QR-like decomposition.
				if (!G2D_COMPARISON_STANDARD_F(_matrix.data[0], 0.0f) || !G2D_COMPARISON_STANDARD_F(_matrix.data[1], 0.0f))
				{
					float r = sqrt(_matrix.data[0] * _matrix.data[0] + _matrix.data[1] * _matrix.data[1]);
					_outRadians = _matrix.data[1] > 0.0f ? acos(_matrix.data[0] / r) : -acos(_matrix.data[0] / r);
				}
				else if (!G2D_COMPARISON_STANDARD_F(_matrix.data[3], 0.0f) || !G2D_COMPARISON_STANDARD_F(_matrix.data[4], 0.0f))
				{
					float s = sqrt(_matrix.data[3] * _matrix.data[3] + _matrix.data[4] * _matrix.data[4]);
					_outRadians = G2D_PI_F / 2.0f - (_matrix.data[4] > 0.0f ? acos(-_matrix.data[4] / s) : -acos(_matrix.data[4] / s));
				}
				else
				{
					// x1 = x2 = y1 = y2 = 0
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn GetTranslation3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F& _outVector)
			{
				_outVector.x = _matrix.row3.x;
				_outVector.y = _matrix.row3.y;

				return GReturn::SUCCESS;
			}

			static GReturn GetScale2F(MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F& _outScale)
			{
				float delta = _matrix.data[0] * _matrix.data[3] - _matrix.data[1] * _matrix.data[2];

				// Apply the QR-like decomposition.
				if (!G2D_COMPARISON_STANDARD_F(_matrix.data[0], 0.0f) || !G2D_COMPARISON_STANDARD_F(_matrix.data[1], 0.0f))
				{
					float r = sqrt(_matrix.data[0] * _matrix.data[0] + _matrix.data[1] * _matrix.data[1]);
					_outScale = { r, delta / r };
				}
				else if (!G2D_COMPARISON_STANDARD_F(_matrix.data[2], 0.0f) || !G2D_COMPARISON_STANDARD_F(_matrix.data[3], 0.0f))
				{
					float s = sqrt(_matrix.data[2] * _matrix.data[2] + _matrix.data[3] * _matrix.data[3]);
					_outScale = { delta / s, s };
				}
				else
				{
					// x1 = x2 = y1 = y2 = 0
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn GetScale3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F& _outScale)
			{
				float delta = _matrix.data[0] * _matrix.data[4] - _matrix.data[1] * _matrix.data[3];

				// Apply the QR-like decomposition.
				if (!G2D_COMPARISON_STANDARD_F(_matrix.data[0], 0.0f) || !G2D_COMPARISON_STANDARD_F(_matrix.data[1], 0.0f))
				{
					float r = sqrt(_matrix.data[0] * _matrix.data[0] + _matrix.data[1] * _matrix.data[1]);
					_outScale = { r, delta / r };
				}
				else if (!G2D_COMPARISON_STANDARD_F(_matrix.data[3], 0.0f) || !G2D_COMPARISON_STANDARD_F(_matrix.data[4], 0.0f))
				{
					float s = sqrt(_matrix.data[3] * _matrix.data[3] + _matrix.data[4] * _matrix.data[4]);
					_outScale = { delta / s, s };
				}
				else
				{
					// x1 = x2 = y1 = y2 = 0
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn GetSkew2F(MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F& _outSkew)
			{
				// Apply the QR-like decomposition.
				if (!G2D_COMPARISON_STANDARD_F(_matrix.data[0], 0.0f) || !G2D_COMPARISON_STANDARD_F(_matrix.data[1], 0.0f))
				{
					float r = _matrix.data[0] * _matrix.data[0] + _matrix.data[1] * _matrix.data[1];
					_outSkew = { atanf((_matrix.data[0] * _matrix.data[1] + _matrix.data[2] * _matrix.data[3]) / r), 0.0f };
				}
				else if (!G2D_COMPARISON_STANDARD_F(_matrix.data[2], 0.0f) || !G2D_COMPARISON_STANDARD_F(_matrix.data[3], 0.0f))
				{
					float s = _matrix.data[2] * _matrix.data[2] + _matrix.data[3] * _matrix.data[3];
					_outSkew = { 0.0f, atanf((_matrix.data[0] * _matrix.data[2] + _matrix.data[1] * _matrix.data[3]) / s) };
				}
				else
				{
					// x1 = x2 = y1 = y2 = 0
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn GetSkew3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F& _outSkew)
			{
				// Apply the QR-like decomposition.
				if (!G2D_COMPARISON_STANDARD_F(_matrix.data[0], 0.0f) || !G2D_COMPARISON_STANDARD_F(_matrix.data[1], 0.0f))
				{
					float r = _matrix.data[0] * _matrix.data[0] + _matrix.data[1] * _matrix.data[1];
					_outSkew = { atanf((_matrix.data[0] * _matrix.data[1] + _matrix.data[3] * _matrix.data[4]) / r), 0.0f };
				}
				else if (!G2D_COMPARISON_STANDARD_F(_matrix.data[3], 0.0f) || !G2D_COMPARISON_STANDARD_F(_matrix.data[4], 0.0f))
				{
					float s = _matrix.data[3] * _matrix.data[3] + _matrix.data[4] * _matrix.data[4];
					_outSkew = { 0.0f, atanf((_matrix.data[0] * _matrix.data[3] + _matrix.data[1] * _matrix.data[4]) / s) };
				}
				else
				{
					// x1 = x2 = y1 = y2 = 0
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn Rotate2F(MATH2D::GMATRIX2F _matrix, float _radians, MATH2D::GMATRIX2F& _outMatrix)
			{
				float c = cos(_radians);
				float s = sin(_radians);
				MATH2D::GMATRIX2F rotationMatrix = MATH2D::GIdentityMatrix2F;
				rotationMatrix.data[0] = c;
				rotationMatrix.data[1] = s;
				rotationMatrix.data[2] = -s;
				rotationMatrix.data[3] = c;

				Multiply2F(_matrix, rotationMatrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn RotateGlobal3F(MATH2D::GMATRIX3F _matrix, float _radians, MATH2D::GMATRIX3F& _outMatrix)
			{
				float c = cos(_radians);
				float s = sin(_radians);
				MATH2D::GMATRIX3F rotationMatrix = MATH2D::GIdentityMatrix3F;
				rotationMatrix.data[0] = c;
				rotationMatrix.data[1] = s;
				rotationMatrix.data[3] = -s;
				rotationMatrix.data[4] = c;

				// store translation
				MATH2D::GVECTOR3F translation = _matrix.row3;

				Multiply3F(_matrix, rotationMatrix, _outMatrix);

				// restore translation
				_outMatrix.row3 = translation;

				return GW::GReturn::SUCCESS;
			}

			static GReturn RotateLocal3F(MATH2D::GMATRIX3F _matrix, float _radians, MATH2D::GMATRIX3F& _outMatrix)
			{
				float c = cos(_radians);
				float s = sin(_radians);
				MATH2D::GMATRIX3F rotationMatrix = MATH2D::GIdentityMatrix3F;
				rotationMatrix.data[0] = c;
				rotationMatrix.data[1] = s;
				rotationMatrix.data[3] = -s;
				rotationMatrix.data[4] = c;

				Multiply3F(rotationMatrix, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn TranslateGlobal3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX3F& _outMatrix)
			{
				MATH2D::GMATRIX3F translationMatrix = MATH2D::GIdentityMatrix3F;
				translationMatrix.data[6] = _vector.x;
				translationMatrix.data[7] = _vector.y;

				Multiply3F(_matrix, translationMatrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn TranslateLocal3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX3F& _outMatrix)
			{
				MATH2D::GMATRIX3F translationMatrix = MATH2D::GIdentityMatrix3F;
				translationMatrix.data[6] = _vector.x;
				translationMatrix.data[7] = _vector.y;

				Multiply3F(translationMatrix, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn Scale2F(MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX2F& _outMatrix)
			{
				MATH2D::GMATRIX2F scaleMatrix = MATH2D::GIdentityMatrix2F;
				scaleMatrix.data[0] = _vector.x;
				scaleMatrix.data[3] = _vector.y;

				Multiply2F(_matrix, scaleMatrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn ScaleGlobal3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX3F& _outMatrix)
			{
				MATH2D::GMATRIX3F scaleMatrix = MATH2D::GIdentityMatrix3F;
				scaleMatrix.data[0] = _vector.x;
				scaleMatrix.data[4] = _vector.y;

				// store translation
				MATH2D::GVECTOR3F translation = _matrix.row3;

				Multiply3F(_matrix, scaleMatrix, _outMatrix);

				// restore translation
				_outMatrix.row3 = translation;

				return GW::GReturn::SUCCESS;
			}

			static GReturn ScaleLocal3F(MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX3F& _outMatrix)
			{
				MATH2D::GMATRIX3F scaleMatrix = MATH2D::GIdentityMatrix3F;
				scaleMatrix.data[0] = _vector.x;
				scaleMatrix.data[4] = _vector.y;

				Multiply3F(scaleMatrix, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn Lerp2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, float _ratio, MATH2D::GMATRIX2F& _outMatrix)
			{
				for (int i = 0; i < 4; i++)
				{
					_outMatrix.data[i] = G2D_LERP(_matrix1.data[i], _matrix2.data[i], _ratio);
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn Lerp3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, float _ratio, MATH2D::GMATRIX3F& _outMatrix)
			{
				for (int i = 0; i < 9; i++)
				{
					_outMatrix.data[i] = G2D_LERP(_matrix1.data[i], _matrix2.data[i], _ratio);
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn MakeRelative2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix)
			{
				MATH2D::GMATRIX2F inverseMatrix2;
				Inverse2F(_matrix2, inverseMatrix2);

				Multiply2F(_matrix1, inverseMatrix2, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn MakeRelative3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix)
			{
				MATH2D::GMATRIX3F inverseMatrix2;
				Inverse3F(_matrix2, inverseMatrix2);

				Multiply3F(_matrix1, inverseMatrix2, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn MakeSeparate2F(MATH2D::GMATRIX2F _matrix1, MATH2D::GMATRIX2F _matrix2, MATH2D::GMATRIX2F& _outMatrix)
			{
				Multiply2F(_matrix1, _matrix2, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn MakeSeparate3F(MATH2D::GMATRIX3F _matrix1, MATH2D::GMATRIX3F _matrix2, MATH2D::GMATRIX3F& _outMatrix)
			{
				Multiply3F(_matrix1, _matrix2, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn Upgrade2(MATH2D::GMATRIX2F _matrix, MATH2D::GMATRIX2D& _outMatrix)
			{
				for (int i = 0; i < 4; i++)
				{
					_outMatrix.data[i] = static_cast<double>(_matrix.data[i]);
				}

				return GReturn::SUCCESS;
			}

			static GReturn Upgrade3(MATH2D::GMATRIX3F _matrix, MATH2D::GMATRIX3D& _outMatrix)
			{
				for (int i = 0; i < 9; i++)
				{
					_outMatrix.data[i] = static_cast<double>(_matrix.data[i]);
				}

				return GReturn::SUCCESS;
			}











			// Doubles
			static GReturn Add2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix)
			{
				for (int i = 0; i < 4; i++)
				{
					_outMatrix.data[i] = _matrix1.data[i] + _matrix2.data[i];
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn Add3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix)
			{
				for (int i = 0; i < 9; i++)
				{
					_outMatrix.data[i] = _matrix1.data[i] + _matrix2.data[i];
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn Subtract2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix)
			{
				for (int i = 0; i < 4; i++)
				{
					_outMatrix.data[i] = _matrix1.data[i] - _matrix2.data[i];
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn Subtract3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix)
			{
				for (int i = 0; i < 9; i++)
				{
					_outMatrix.data[i] = _matrix1.data[i] - _matrix2.data[i];
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn Multiply2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix)
			{
				_outMatrix.data[0] = _matrix1.data[0] * _matrix2.data[0] + _matrix1.data[1] * _matrix2.data[2];
				_outMatrix.data[1] = _matrix1.data[0] * _matrix2.data[1] + _matrix1.data[1] * _matrix2.data[3];

				_outMatrix.data[2] = _matrix1.data[2] * _matrix2.data[0] + _matrix1.data[3] * _matrix2.data[2];
				_outMatrix.data[3] = _matrix1.data[2] * _matrix2.data[1] + _matrix1.data[3] * _matrix2.data[3];

				return GW::GReturn::SUCCESS;
			}

			static GReturn Multiply3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix)
			{
				_outMatrix.data[0] = _matrix1.data[0] * _matrix2.data[0] + _matrix1.data[1] * _matrix2.data[3] + _matrix1.data[2] * _matrix2.data[6];
				_outMatrix.data[1] = _matrix1.data[0] * _matrix2.data[1] + _matrix1.data[1] * _matrix2.data[4] + _matrix1.data[2] * _matrix2.data[7];
				_outMatrix.data[2] = _matrix1.data[0] * _matrix2.data[2] + _matrix1.data[1] * _matrix2.data[5] + _matrix1.data[2] * _matrix2.data[8];

				_outMatrix.data[3] = _matrix1.data[3] * _matrix2.data[0] + _matrix1.data[4] * _matrix2.data[3] + _matrix1.data[5] * _matrix2.data[6];
				_outMatrix.data[4] = _matrix1.data[3] * _matrix2.data[1] + _matrix1.data[4] * _matrix2.data[4] + _matrix1.data[5] * _matrix2.data[7];
				_outMatrix.data[5] = _matrix1.data[3] * _matrix2.data[2] + _matrix1.data[4] * _matrix2.data[5] + _matrix1.data[5] * _matrix2.data[8];

				_outMatrix.data[6] = _matrix1.data[6] * _matrix2.data[0] + _matrix1.data[7] * _matrix2.data[3] + _matrix1.data[8] * _matrix2.data[6];
				_outMatrix.data[7] = _matrix1.data[6] * _matrix2.data[1] + _matrix1.data[7] * _matrix2.data[4] + _matrix1.data[8] * _matrix2.data[7];
				_outMatrix.data[8] = _matrix1.data[6] * _matrix2.data[2] + _matrix1.data[7] * _matrix2.data[5] + _matrix1.data[8] * _matrix2.data[8];

				return GW::GReturn::SUCCESS;
			}

			static GReturn MatrixXVector2D(MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GVECTOR2D& _outVector)
			{
				_outVector.x = _vector.data[0] * _matrix.data[0] + _vector.data[1] * _matrix.data[2];
				_outVector.y = _vector.data[0] * _matrix.data[1] + _vector.data[1] * _matrix.data[3];

				return GReturn::SUCCESS;
			}

			static GReturn MatrixXVector3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR3D _vector, MATH2D::GVECTOR3D& _outVector)
			{
				_outVector.x = _vector.data[0] * _matrix.data[0] + _vector.data[1] * _matrix.data[3] + _vector.data[2] * _matrix.data[6];
				_outVector.y = _vector.data[0] * _matrix.data[1] + _vector.data[1] * _matrix.data[4] + _vector.data[2] * _matrix.data[7];
				_outVector.z = _vector.data[0] * _matrix.data[2] + _vector.data[1] * _matrix.data[5] + _vector.data[2] * _matrix.data[8];

				return GReturn::SUCCESS;
			}

			static GReturn MultiplyNum2D(MATH2D::GMATRIX2D _matrix, double _scalar, MATH2D::GMATRIX2D& _outMatrix)
			{
				for (int i = 0; i < 4; i++)
				{
					_outMatrix.data[i] = _matrix.data[i] * _scalar;
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn MultiplyNum3D(MATH2D::GMATRIX3D _matrix, double _scalar, MATH2D::GMATRIX3D& _outMatrix)
			{
				for (int i = 0; i < 9; i++)
				{
					_outMatrix.data[i] = _matrix.data[i] * _scalar;
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn Determinant2D(MATH2D::GMATRIX2D _matrix, double& _outDeterminant)
			{
				_outDeterminant = _matrix.data[0] * _matrix.data[3] - _matrix.data[1] * _matrix.data[2];

				return GW::GReturn::SUCCESS;
			}

			static GReturn Determinant3D(MATH2D::GMATRIX3D _matrix, double& _outDeterminant)
			{
				double a = (_matrix.data[0] * _matrix.data[4] * _matrix.data[8]) + (_matrix.data[1] * _matrix.data[5] * _matrix.data[6]) + (_matrix.data[2] * _matrix.data[3] * _matrix.data[7]);
				double b = (_matrix.data[6] * _matrix.data[4] * _matrix.data[2]) + (_matrix.data[7] * _matrix.data[5] * _matrix.data[0]) + (_matrix.data[8] * _matrix.data[3] * _matrix.data[1]);

				_outDeterminant = a - b;

				return GReturn::SUCCESS;
			}

			static GReturn Transpose2D(MATH2D::GMATRIX2D _matrix, MATH2D::GMATRIX2D& _outMatrix)
			{
				_outMatrix.data[0] = _matrix.data[0];
				_outMatrix.data[1] = _matrix.data[2];
				_outMatrix.data[2] = _matrix.data[1];
				_outMatrix.data[3] = _matrix.data[3];

				return GReturn::SUCCESS;
			}

			static GReturn Transpose3D(MATH2D::GMATRIX3D _matrix, MATH2D::GMATRIX3D& _outMatrix)
			{
				_outMatrix.data[0] = _matrix.data[0];
				_outMatrix.data[1] = _matrix.data[3];
				_outMatrix.data[2] = _matrix.data[6];
				_outMatrix.data[3] = _matrix.data[1];
				_outMatrix.data[4] = _matrix.data[4];
				_outMatrix.data[5] = _matrix.data[7];
				_outMatrix.data[6] = _matrix.data[2];
				_outMatrix.data[7] = _matrix.data[5];
				_outMatrix.data[8] = _matrix.data[8];

				return GReturn::SUCCESS;
			}

			static GReturn Inverse2D(MATH2D::GMATRIX2D _matrix, MATH2D::GMATRIX2D& _outMatrix)
			{
				double determinant;

				Determinant2D(_matrix, determinant);

				if (G2D_COMPARISON_STANDARD_D(determinant, 0.0))
				{
					return GReturn::FAILURE;
				}

				_outMatrix.data[0] = _matrix.data[3];
				_outMatrix.data[1] = -_matrix.data[1];
				_outMatrix.data[2] = -_matrix.data[2];
				_outMatrix.data[3] = _matrix.data[0];

				MultiplyNum2D(_outMatrix, 1.0 / determinant, _outMatrix);

				return GReturn::SUCCESS;
			}

			static GReturn Inverse3D(MATH2D::GMATRIX3D _matrix, MATH2D::GMATRIX3D& _outMatrix)
			{
				double determinant;

				Determinant3D(_matrix, determinant);

				if (G2D_COMPARISON_STANDARD_D(determinant, 0.0))
				{
					return GReturn::FAILURE;
				}

				// simultaneously calculate the matrix of minors, convert it to the matrix of cofactors, and then transpose it
				_outMatrix.data[0] = (_matrix.data[4] * _matrix.data[8] - _matrix.data[5] * _matrix.data[7]); // 0
				_outMatrix.data[1] = -(_matrix.data[1] * _matrix.data[8] - _matrix.data[2] * _matrix.data[7]); // 3
				_outMatrix.data[2] = (_matrix.data[1] * _matrix.data[5] - _matrix.data[2] * _matrix.data[4]); // 6

				_outMatrix.data[3] = -(_matrix.data[3] * _matrix.data[8] - _matrix.data[5] * _matrix.data[6]); // 1
				_outMatrix.data[4] = (_matrix.data[0] * _matrix.data[8] - _matrix.data[2] * _matrix.data[6]); // 4
				_outMatrix.data[5] = -(_matrix.data[0] * _matrix.data[5] - _matrix.data[2] * _matrix.data[3]); // 7

				_outMatrix.data[6] = (_matrix.data[3] * _matrix.data[7] - _matrix.data[4] * _matrix.data[6]); // 2
				_outMatrix.data[7] = -(_matrix.data[0] * _matrix.data[7] - _matrix.data[1] * _matrix.data[6]); // 5
				_outMatrix.data[8] = (_matrix.data[0] * _matrix.data[4] - _matrix.data[1] * _matrix.data[3]); // 8

				MultiplyNum3D(_outMatrix, 1.0 / determinant, _outMatrix);

				return GReturn::SUCCESS;
			}

			static GReturn GetRotation2D(MATH2D::GMATRIX2D _matrix, double& _outRadians)
			{
				// Apply the QR-like decomposition.
				if (!G2D_COMPARISON_STANDARD_D(_matrix.data[0], 0.0) || !G2D_COMPARISON_STANDARD_D(_matrix.data[1], 0.0))
				{
					double r = sqrt(_matrix.data[0] * _matrix.data[0] + _matrix.data[1] * _matrix.data[1]);
					_outRadians = _matrix.data[1] > 0.0 ? acos(_matrix.data[0] / r) : -acos(_matrix.data[0] / r);
				}
				else if (!G2D_COMPARISON_STANDARD_D(_matrix.data[2], 0.0) || !G2D_COMPARISON_STANDARD_D(_matrix.data[3], 0.0))
				{
					double s = sqrt(_matrix.data[2] * _matrix.data[2] + _matrix.data[3] * _matrix.data[3]);
					_outRadians = G2D_PI / 2.0 - (_matrix.data[3] > 0.0 ? acos(-_matrix.data[3] / s) : -acos(_matrix.data[3] / s));
				}
				else
				{
					// x1 = x2 = y1 = y2 = 0
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn GetRotation3D(MATH2D::GMATRIX3D _matrix, double& _outRadians)
			{
				// Apply the QR-like decomposition.
				if (!G2D_COMPARISON_STANDARD_D(_matrix.data[0], 0.0) || !G2D_COMPARISON_STANDARD_D(_matrix.data[1], 0.0))
				{
					double r = sqrt(_matrix.data[0] * _matrix.data[0] + _matrix.data[1] * _matrix.data[1]);
					_outRadians = _matrix.data[1] > 0.0 ? acos(_matrix.data[0] / r) : -acos(_matrix.data[0] / r);
				}
				else if (!G2D_COMPARISON_STANDARD_D(_matrix.data[3], 0.0) || !G2D_COMPARISON_STANDARD_D(_matrix.data[4], 0.0))
				{
					double s = sqrt(_matrix.data[3] * _matrix.data[3] + _matrix.data[4] * _matrix.data[4]);
					_outRadians = G2D_PI / 2.0 - (_matrix.data[4] > 0.0 ? acos(-_matrix.data[4] / s) : -acos(_matrix.data[4] / s));
				}
				else
				{
					// x1 = x2 = y1 = y2 = 0
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn GetTranslation3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D& _outVector)
			{
				_outVector.x = _matrix.row3.x;
				_outVector.y = _matrix.row3.y;

				return GReturn::SUCCESS;
			}

			static GReturn GetScale2D(MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D& _outScale)
			{
				double delta = _matrix.data[0] * _matrix.data[3] - _matrix.data[1] * _matrix.data[2];

				// Apply the QR-like decomposition.
				if (!G2D_COMPARISON_STANDARD_D(_matrix.data[0], 0.0) || !G2D_COMPARISON_STANDARD_D(_matrix.data[1], 0.0))
				{
					double r = sqrt(_matrix.data[0] * _matrix.data[0] + _matrix.data[1] * _matrix.data[1]);
					_outScale = { r, delta / r };
				}
				else if (!G2D_COMPARISON_STANDARD_D(_matrix.data[2], 0.0) || !G2D_COMPARISON_STANDARD_D(_matrix.data[3], 0.0))
				{
					double s = sqrt(_matrix.data[2] * _matrix.data[2] + _matrix.data[3] * _matrix.data[3]);
					_outScale = { delta / s, s };
				}
				else
				{
					// x1 = x2 = y1 = y2 = 0
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn GetScale3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D& _outScale)
			{
				double delta = _matrix.data[0] * _matrix.data[4] - _matrix.data[1] * _matrix.data[3];

				// Apply the QR-like decomposition.
				if (!G2D_COMPARISON_STANDARD_D(_matrix.data[0], 0.0) || !G2D_COMPARISON_STANDARD_D(_matrix.data[1], 0.0))
				{
					double r = sqrt(_matrix.data[0] * _matrix.data[0] + _matrix.data[1] * _matrix.data[1]);
					_outScale = { r, delta / r };
				}
				else if (!G2D_COMPARISON_STANDARD_D(_matrix.data[3], 0.0) || !G2D_COMPARISON_STANDARD_D(_matrix.data[4], 0.0))
				{
					double s = sqrt(_matrix.data[3] * _matrix.data[3] + _matrix.data[4] * _matrix.data[4]);
					_outScale = { delta / s, s };
				}
				else
				{
					// x1 = x2 = y1 = y2 = 0
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn GetSkew2D(MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D& _outSkew)
			{
				// Apply the QR-like decomposition.
				if (!G2D_COMPARISON_STANDARD_D(_matrix.data[0], 0.0) || !G2D_COMPARISON_STANDARD_D(_matrix.data[1], 0.0))
				{
					double r = _matrix.data[0] * _matrix.data[0] + _matrix.data[1] * _matrix.data[1];
					_outSkew = { atan((_matrix.data[0] * _matrix.data[1] + _matrix.data[2] * _matrix.data[3]) / r), 0.0 };
				}
				else if (!G2D_COMPARISON_STANDARD_D(_matrix.data[2], 0.0) || !G2D_COMPARISON_STANDARD_D(_matrix.data[3], 0.0))
				{
					double s = _matrix.data[2] * _matrix.data[2] + _matrix.data[3] * _matrix.data[3];
					_outSkew = { 0.0, atan((_matrix.data[0] * _matrix.data[2] + _matrix.data[1] * _matrix.data[3]) / s) };
				}
				else
				{
					// x1 = x2 = y1 = y2 = 0
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn GetSkew3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D& _outSkew)
			{
				// Apply the QR-like decomposition.
				if (!G2D_COMPARISON_STANDARD_D(_matrix.data[0], 0.0) || !G2D_COMPARISON_STANDARD_D(_matrix.data[1], 0.0))
				{
					double r = _matrix.data[0] * _matrix.data[0] + _matrix.data[1] * _matrix.data[1];
					_outSkew = { atan((_matrix.data[0] * _matrix.data[1] + _matrix.data[3] * _matrix.data[4]) / r), 0.0 };
				}
				else if (!G2D_COMPARISON_STANDARD_D(_matrix.data[3], 0.0) || !G2D_COMPARISON_STANDARD_D(_matrix.data[4], 0.0))
				{
					double s = _matrix.data[3] * _matrix.data[3] + _matrix.data[4] * _matrix.data[4];
					_outSkew = { 0.0, atan((_matrix.data[0] * _matrix.data[3] + _matrix.data[1] * _matrix.data[4]) / s) };
				}
				else
				{
					// x1 = x2 = y1 = y2 = 0
					return GReturn::FAILURE;
				}

				return GReturn::SUCCESS;
			}

			static GReturn Rotate2D(MATH2D::GMATRIX2D _matrix, double _radians, MATH2D::GMATRIX2D& _outMatrix)
			{
				double c = cos(_radians);
				double s = sin(_radians);
				MATH2D::GMATRIX2D rotationMatrix = MATH2D::GIdentityMatrix2D;
				rotationMatrix.data[0] = c;
				rotationMatrix.data[1] = s;
				rotationMatrix.data[2] = -s;
				rotationMatrix.data[3] = c;

				Multiply2D(_matrix, rotationMatrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn RotateGlobal3D(MATH2D::GMATRIX3D _matrix, double _radians, MATH2D::GMATRIX3D& _outMatrix)
			{
				double c = cos(_radians);
				double s = sin(_radians);
				MATH2D::GMATRIX3D rotationMatrix = MATH2D::GIdentityMatrix3D;
				rotationMatrix.data[0] = c;
				rotationMatrix.data[1] = s;
				rotationMatrix.data[3] = -s;
				rotationMatrix.data[4] = c;

				// store translation
				MATH2D::GVECTOR3D translation = _matrix.row3;

				Multiply3D(_matrix, rotationMatrix, _outMatrix);

				// restore translation
				_outMatrix.row3 = translation;

				return GW::GReturn::SUCCESS;
			}

			static GReturn RotateLocal3D(MATH2D::GMATRIX3D _matrix, double _radians, MATH2D::GMATRIX3D& _outMatrix)
			{
				double c = cos(_radians);
				double s = sin(_radians);
				MATH2D::GMATRIX3D rotationMatrix = MATH2D::GIdentityMatrix3D;
				rotationMatrix.data[0] = c;
				rotationMatrix.data[1] = s;
				rotationMatrix.data[3] = -s;
				rotationMatrix.data[4] = c;

				Multiply3D(rotationMatrix, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn TranslateGlobal3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX3D& _outMatrix)
			{
				MATH2D::GMATRIX3D translationMatrix = MATH2D::GIdentityMatrix3D;
				translationMatrix.data[6] = _vector.x;
				translationMatrix.data[7] = _vector.y;

				Multiply3D(_matrix, translationMatrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn TranslateLocal3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX3D& _outMatrix)
			{
				MATH2D::GMATRIX3D translationMatrix = MATH2D::GIdentityMatrix3D;
				translationMatrix.data[6] = _vector.x;
				translationMatrix.data[7] = _vector.y;

				Multiply3D(translationMatrix, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn Scale2D(MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX2D& _outMatrix)
			{
				MATH2D::GMATRIX2D scaleMatrix = MATH2D::GIdentityMatrix2D;
				scaleMatrix.data[0] = _vector.x;
				scaleMatrix.data[3] = _vector.y;

				Multiply2D(_matrix, scaleMatrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn ScaleGlobal3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX3D& _outMatrix)
			{
				MATH2D::GMATRIX3D scaleMatrix = MATH2D::GIdentityMatrix3D;
				scaleMatrix.data[0] = _vector.x;
				scaleMatrix.data[4] = _vector.y;

				// store translation
				MATH2D::GVECTOR3D translation = _matrix.row3;

				Multiply3D(_matrix, scaleMatrix, _outMatrix);

				// restore translation
				_outMatrix.row3 = translation;

				return GW::GReturn::SUCCESS;
			}

			static GReturn ScaleLocal3D(MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX3D& _outMatrix)
			{
				MATH2D::GMATRIX3D scaleMatrix = MATH2D::GIdentityMatrix3D;
				scaleMatrix.data[0] = _vector.x;
				scaleMatrix.data[4] = _vector.y;

				Multiply3D(scaleMatrix, _matrix, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn Lerp2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, double _ratio, MATH2D::GMATRIX2D& _outMatrix)
			{
				for (int i = 0; i < 4; i++)
				{
					_outMatrix.data[i] = G2D_LERP(_matrix1.data[i], _matrix2.data[i], _ratio);
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn Lerp3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, double _ratio, MATH2D::GMATRIX3D& _outMatrix)
			{
				for (int i = 0; i < 9; i++)
				{
					_outMatrix.data[i] = G2D_LERP(_matrix1.data[i], _matrix2.data[i], _ratio);
				}

				return GW::GReturn::SUCCESS;
			}

			static GReturn MakeRelative2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix)
			{
				MATH2D::GMATRIX2D inverseMatrix2;
				Inverse2D(_matrix2, inverseMatrix2);

				Multiply2D(_matrix1, inverseMatrix2, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn MakeRelative3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix)
			{
				MATH2D::GMATRIX3D inverseMatrix2;
				Inverse3D(_matrix2, inverseMatrix2);

				Multiply3D(_matrix1, inverseMatrix2, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn MakeSeparate2D(MATH2D::GMATRIX2D _matrix1, MATH2D::GMATRIX2D _matrix2, MATH2D::GMATRIX2D& _outMatrix)
			{
				Multiply2D(_matrix1, _matrix2, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn MakeSeparate3D(MATH2D::GMATRIX3D _matrix1, MATH2D::GMATRIX3D _matrix2, MATH2D::GMATRIX3D& _outMatrix)
			{
				Multiply3D(_matrix1, _matrix2, _outMatrix);

				return GW::GReturn::SUCCESS;
			}

			static GReturn Downgrade2(MATH2D::GMATRIX2D _matrix, MATH2D::GMATRIX2F& _outMatrix)
			{
				for (int i = 0; i < 4; i++)
				{
					_outMatrix.data[i] = static_cast<float>(_matrix.data[i]);
				}

				return GReturn::SUCCESS;
			}

			static GReturn Downgrade3(MATH2D::GMATRIX3D _matrix, MATH2D::GMATRIX3F& _outMatrix)
			{
				for (int i = 0; i < 9; i++)
				{
					_outMatrix.data[i] = static_cast<float>(_matrix.data[i]);
				}

				return GReturn::SUCCESS;
			}
		};
	}
}


#endif


namespace GW
{
	namespace MATH2D
	{
		class GMatrix2D final : public I::GProxy<I::GMatrix2DInterface, I::GMatrix2DImplementation>
		{
		public:
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GMatrix2D)
			// floats
			GATEWARE_STATIC_FUNCTION(Add2F)
			GATEWARE_STATIC_FUNCTION(Add3F)
			GATEWARE_STATIC_FUNCTION(Subtract2F)
			GATEWARE_STATIC_FUNCTION(Subtract3F)
			GATEWARE_STATIC_FUNCTION(Multiply2F)
			GATEWARE_STATIC_FUNCTION(Multiply3F)
			GATEWARE_STATIC_FUNCTION(MatrixXVector2F)
			GATEWARE_STATIC_FUNCTION(MatrixXVector3F)
			GATEWARE_STATIC_FUNCTION(MultiplyNum2F)
			GATEWARE_STATIC_FUNCTION(MultiplyNum3F)
			GATEWARE_STATIC_FUNCTION(Determinant2F)
			GATEWARE_STATIC_FUNCTION(Determinant3F)
			GATEWARE_STATIC_FUNCTION(Transpose2F)
			GATEWARE_STATIC_FUNCTION(Transpose3F)
			GATEWARE_STATIC_FUNCTION(Inverse2F)
			GATEWARE_STATIC_FUNCTION(Inverse3F)
			GATEWARE_STATIC_FUNCTION(GetRotation2F)
			GATEWARE_STATIC_FUNCTION(GetRotation3F)
			GATEWARE_STATIC_FUNCTION(GetTranslation3F)
			GATEWARE_STATIC_FUNCTION(GetScale2F)
			GATEWARE_STATIC_FUNCTION(GetScale3F)
			GATEWARE_STATIC_FUNCTION(GetSkew2F)
			GATEWARE_STATIC_FUNCTION(GetSkew3F)
			GATEWARE_STATIC_FUNCTION(Rotate2F)
			GATEWARE_STATIC_FUNCTION(RotateGlobal3F)
			GATEWARE_STATIC_FUNCTION(RotateLocal3F)
			GATEWARE_STATIC_FUNCTION(TranslateGlobal3F)
			GATEWARE_STATIC_FUNCTION(TranslateLocal3F)
			GATEWARE_STATIC_FUNCTION(Scale2F)
			GATEWARE_STATIC_FUNCTION(ScaleGlobal3F)
			GATEWARE_STATIC_FUNCTION(ScaleLocal3F)
			GATEWARE_STATIC_FUNCTION(Lerp2F)
			GATEWARE_STATIC_FUNCTION(Lerp3F)
			GATEWARE_STATIC_FUNCTION(MakeRelative2F)
			GATEWARE_STATIC_FUNCTION(MakeRelative3F)
			GATEWARE_STATIC_FUNCTION(MakeSeparate2F)
			GATEWARE_STATIC_FUNCTION(MakeSeparate3F)
			GATEWARE_STATIC_FUNCTION(Upgrade2)
			GATEWARE_STATIC_FUNCTION(Upgrade3)


			// doubles
			GATEWARE_STATIC_FUNCTION(Add2D)
			GATEWARE_STATIC_FUNCTION(Add3D)
			GATEWARE_STATIC_FUNCTION(Subtract2D)
			GATEWARE_STATIC_FUNCTION(Subtract3D)
			GATEWARE_STATIC_FUNCTION(Multiply2D)
			GATEWARE_STATIC_FUNCTION(Multiply3D)
			GATEWARE_STATIC_FUNCTION(MatrixXVector2D)
			GATEWARE_STATIC_FUNCTION(MatrixXVector3D)
			GATEWARE_STATIC_FUNCTION(MultiplyNum2D)
			GATEWARE_STATIC_FUNCTION(MultiplyNum3D)
			GATEWARE_STATIC_FUNCTION(Determinant2D)
			GATEWARE_STATIC_FUNCTION(Determinant3D)
			GATEWARE_STATIC_FUNCTION(Transpose2D)
			GATEWARE_STATIC_FUNCTION(Transpose3D)
			GATEWARE_STATIC_FUNCTION(Inverse2D)
			GATEWARE_STATIC_FUNCTION(Inverse3D)
			GATEWARE_STATIC_FUNCTION(GetRotation2D)
			GATEWARE_STATIC_FUNCTION(GetRotation3D)
			GATEWARE_STATIC_FUNCTION(GetTranslation3D)
			GATEWARE_STATIC_FUNCTION(GetScale2D)
			GATEWARE_STATIC_FUNCTION(GetScale3D)
			GATEWARE_STATIC_FUNCTION(GetSkew2D)
			GATEWARE_STATIC_FUNCTION(GetSkew3D)
			GATEWARE_STATIC_FUNCTION(Rotate2D)
			GATEWARE_STATIC_FUNCTION(RotateGlobal3D)
			GATEWARE_STATIC_FUNCTION(RotateLocal3D)
			GATEWARE_STATIC_FUNCTION(TranslateGlobal3D)
			GATEWARE_STATIC_FUNCTION(TranslateLocal3D)
			GATEWARE_STATIC_FUNCTION(Scale2D)
			GATEWARE_STATIC_FUNCTION(ScaleGlobal3D)
			GATEWARE_STATIC_FUNCTION(ScaleLocal3D)
			GATEWARE_STATIC_FUNCTION(Lerp2D)
			GATEWARE_STATIC_FUNCTION(Lerp3D)
			GATEWARE_STATIC_FUNCTION(MakeRelative2D)
			GATEWARE_STATIC_FUNCTION(MakeRelative3D)
			GATEWARE_STATIC_FUNCTION(MakeSeparate2D)
			GATEWARE_STATIC_FUNCTION(MakeSeparate3D)
			GATEWARE_STATIC_FUNCTION(Downgrade2)
			GATEWARE_STATIC_FUNCTION(Downgrade3)


			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // #endif GMATRIX_H

/*---------------------------------
|	End of GMatrix2D.h
----------------------------------*/


/*---------------------------------
|	Begin of GVector2D.h
----------------------------------*/
#ifndef GVECTOR2D_H
#define GVECTOR2D_H





namespace GW
{
	namespace I
	{
		class GVector2DInterface : public virtual GInterfaceInterface
		{
		public:
			// floats
			static GReturn Add2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, MATH2D::GVECTOR2F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Add3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, MATH2D::GVECTOR3F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Subtract2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, MATH2D::GVECTOR2F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Subtract3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, MATH2D::GVECTOR3F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Scale2F(MATH2D::GVECTOR2F _vector, float _scalar, MATH2D::GVECTOR2F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Scale3F(MATH2D::GVECTOR3F _vector, float _scalar, MATH2D::GVECTOR3F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Dot2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, float& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Dot3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, float& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Cross2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, float& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Cross3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, MATH2D::GVECTOR3F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn VectorXMatrix2F(MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn VectorXMatrix3F(MATH2D::GVECTOR3F _vector, MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR3F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Transform2F(MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Transform3F(MATH2D::GVECTOR3F _vector, MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR3F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Magnitude2F(MATH2D::GVECTOR2F _vector, float& _outMagnitude) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Magnitude3F(MATH2D::GVECTOR3F _vector, float& _outMagnitude) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Normalize2F(MATH2D::GVECTOR2F _vector, MATH2D::GVECTOR2F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Normalize3F(MATH2D::GVECTOR3F _vector, MATH2D::GVECTOR3F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn LerpF(float _value1, float _value2, float _ratio, float& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Lerp2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, float _ratio, MATH2D::GVECTOR2F& _outVector){ return GReturn::NO_IMPLEMENTATION; }
			static GReturn Lerp3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, float _ratio, MATH2D::GVECTOR3F& _outVector){ return GReturn::NO_IMPLEMENTATION; }
			static GReturn BerpF(float _value1, float _value2, float _value3, MATH2D::GBARYCENTRICF _barycentric, float& _outValue){ return GReturn::NO_IMPLEMENTATION; }
			static GReturn Berp2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, MATH2D::GVECTOR2F _vector3, MATH2D::GBARYCENTRICF _barycentric, MATH2D::GVECTOR2F& _outVector){ return GReturn::NO_IMPLEMENTATION; }
			static GReturn Berp3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, MATH2D::GVECTOR3F _vector3, MATH2D::GBARYCENTRICF _barycentric, MATH2D::GVECTOR3F& _outVector){ return GReturn::NO_IMPLEMENTATION; }
			static GReturn Spline2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, MATH2D::GVECTOR2F _vector3, MATH2D::GVECTOR2F _vector4, float _ratio, MATH2D::GVECTOR2F& _outVector){ return GReturn::NO_IMPLEMENTATION; }
			static GReturn GradientF(MATH2D::GLINE2F _line, MATH2D::GVECTOR2F& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn AngleBetweenVectorsF(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, float& _outRadians) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn AngleBetweenLinesF(MATH2D::GLINE2F _vector1, MATH2D::GLINE2F _vector2, float& _outRadians){ return GReturn::NO_IMPLEMENTATION; }
			static GReturn Upgrade2(MATH2D::GVECTOR2F _vector, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Upgrade3(MATH2D::GVECTOR3F _vector, MATH2D::GVECTOR3D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			// doubles
			static GReturn Add2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Add3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, MATH2D::GVECTOR3D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Subtract2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Subtract3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, MATH2D::GVECTOR3D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Scale2D(MATH2D::GVECTOR2D _vector, double _scalar, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Scale3D(MATH2D::GVECTOR3D _vector, double _scalar, MATH2D::GVECTOR3D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Dot2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, double& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Dot3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, double& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Cross2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, double& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Cross3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, MATH2D::GVECTOR3D& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn VectorXMatrix2D(MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn VectorXMatrix3D(MATH2D::GVECTOR3D _vector, MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR3D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Transform2D(MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Transform3D(MATH2D::GVECTOR3D _vector, MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR3D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Magnitude2D(MATH2D::GVECTOR2D _vector, double& _outMagnitude) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Magnitude3D(MATH2D::GVECTOR3D _vector, double& _outMagnitude) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Normalize2D(MATH2D::GVECTOR2D _vector, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Normalize3D(MATH2D::GVECTOR3D _vector, MATH2D::GVECTOR3D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn LerpD(double _value1, double _value2, double _ratio, double& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Lerp2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, double _ratio, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Lerp3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, double _ratio, MATH2D::GVECTOR3D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn BerpD(double _value1, double _value2, double _value3, MATH2D::GBARYCENTRICD _barycentric, double& _outValue) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Berp2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, MATH2D::GVECTOR2D _vector3, MATH2D::GBARYCENTRICD _barycentric, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Berp3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, MATH2D::GVECTOR3D _vector3, MATH2D::GBARYCENTRICD _barycentric, MATH2D::GVECTOR3D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Spline2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, MATH2D::GVECTOR2D _vector3, MATH2D::GVECTOR2D _vector4, double _ratio, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn GradientD(MATH2D::GLINE2D _line, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn AngleBetweenVectorsD(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, double& _outRadians) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn AngleBetweenLinesD(MATH2D::GLINE2D _vector1, MATH2D::GLINE2D _vector2, double& _outRadians) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Downgrade2(MATH2D::GVECTOR2D _vector, MATH2D::GVECTOR2D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
			static GReturn Downgrade3(MATH2D::GVECTOR3D _vector, MATH2D::GVECTOR3D& _outVector) { return GReturn::NO_IMPLEMENTATION; }
		};
	}
}

// Implementation Source link, will be search-replaced in single header version.
// Implemention for GVector2D.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_MATH2D) || defined(GATEWARE_DISABLE_GVECTOR2D) || \
    (defined(GATEWARE_ENABLE_MATH2D) && !defined(GATEWARE_DISABLE_GVECTOR2D) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
	namespace I
	{
		class GVector2DImplementation : public virtual GVector2DInterface, private GInterfaceImplementation
		{
		public:
			GReturn Create() { return GReturn::INTERFACE_UNSUPPORTED; }
			// Floats
			static GReturn Add2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, MATH2D::GVECTOR2F& _outVector) { return GReturn::FAILURE; }
			static GReturn Add3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, MATH2D::GVECTOR3F& _outVector) { return GReturn::FAILURE; }
			static GReturn Subtract2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, MATH2D::GVECTOR2F& _outVector) { return GReturn::FAILURE; }
			static GReturn Subtract3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, MATH2D::GVECTOR3F& _outVector) { return GReturn::FAILURE; }
			static GReturn Scale2F(MATH2D::GVECTOR2F _vector, float _scalar, MATH2D::GVECTOR2F& _outVector) { return GReturn::FAILURE; }
			static GReturn Scale3F(MATH2D::GVECTOR3F _vector, float _scalar, MATH2D::GVECTOR3F& _outVector) { return GReturn::FAILURE; }
			static GReturn Dot2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, float& _outValue) { return GReturn::FAILURE; }
			static GReturn Dot3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, float& _outValue) { return GReturn::FAILURE; }
			static GReturn Cross2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, float& _outValue) { return GReturn::FAILURE; }
			static GReturn Cross3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, MATH2D::GVECTOR3F& _outVector) { return GReturn::FAILURE; }
			static GReturn VectorXMatrix2F(MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F& _outVector) { return GReturn::FAILURE; }
			static GReturn VectorXMatrix3F(MATH2D::GVECTOR3F _vector, MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR3F& _outVector) { return GReturn::FAILURE; }
			static GReturn Transform2F(MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F& _outVector) { return GReturn::FAILURE; }
			static GReturn Transform3F(MATH2D::GVECTOR3F _vector, MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR3F& _outVector) { return GReturn::FAILURE; }
			static GReturn Magnitude2F(MATH2D::GVECTOR2F _vector, float& _outMagnitude) { return GReturn::FAILURE; }
			static GReturn Magnitude3F(MATH2D::GVECTOR3F _vector, float& _outMagnitude) { return GReturn::FAILURE; }
			static GReturn Normalize2F(MATH2D::GVECTOR2F _vector, MATH2D::GVECTOR2F& _outVector) { return GReturn::FAILURE; }
			static GReturn Normalize3F(MATH2D::GVECTOR3F _vector, MATH2D::GVECTOR3F& _outVector) { return GReturn::FAILURE; }
			static GReturn LerpF(float _value1, float _value2, float _ratio, float& _outValue) { return GReturn::FAILURE; }
			static GReturn Lerp2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, float _ratio, MATH2D::GVECTOR2F& _outVector) { return GReturn::FAILURE; }
			static GReturn Lerp3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, float _ratio, MATH2D::GVECTOR3F& _outVector) { return GReturn::FAILURE; }
			static GReturn BerpF(float _value1, float _value2, float _value3, MATH2D::GBARYCENTRICF _barycentric, float& _outValue) { return GReturn::FAILURE; }
			static GReturn Berp2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, MATH2D::GVECTOR2F _vector3, MATH2D::GBARYCENTRICF _barycentric, MATH2D::GVECTOR2F& _outVector) { return GReturn::FAILURE; }
			static GReturn Berp3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, MATH2D::GVECTOR3F _vector3, MATH2D::GBARYCENTRICF _barycentric, MATH2D::GVECTOR3F& _outVector) { return GReturn::FAILURE; }
			static GReturn Spline2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, MATH2D::GVECTOR2F _vector3, MATH2D::GVECTOR2F _vector4, float _ratio, MATH2D::GVECTOR2F& _outVector) { return GReturn::FAILURE; }
			static GReturn GradientF(MATH2D::GLINE2F _line, MATH2D::GVECTOR2F& _outVector) { return GReturn::FAILURE; }
			static GReturn AngleBetweenVectorsF(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, float& _outRadians) { return GReturn::FAILURE; }
			static GReturn AngleBetweenLinesF(MATH2D::GLINE2F _line1, MATH2D::GLINE2F _line2, float& _outRadians) { return GReturn::FAILURE; }
			static GReturn Upgrade2(MATH2D::GVECTOR2F _vector, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn Upgrade3(MATH2D::GVECTOR3F _vector, MATH2D::GVECTOR3D& _outVector) { return GReturn::FAILURE; }
			// Doubles
			static GReturn Add2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn Add3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, MATH2D::GVECTOR3D& _outVector) { return GReturn::FAILURE; }
			static GReturn Subtract2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn Subtract3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, MATH2D::GVECTOR3D& _outVector) { return GReturn::FAILURE; }
			static GReturn Scale2D(MATH2D::GVECTOR2D _vector, double _scalar, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn Scale3D(MATH2D::GVECTOR3D _vector, double _scalar, MATH2D::GVECTOR3D& _outVector) { return GReturn::FAILURE; }
			static GReturn Dot2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, double& _outValue) { return GReturn::FAILURE; }
			static GReturn Dot3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, double& _outValue) { return GReturn::FAILURE; }
			static GReturn Cross2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, double& _outValue) { return GReturn::FAILURE; }
			static GReturn Cross3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, double& _outValue) { return GReturn::FAILURE; }
			static GReturn VectorXMatrix2D(MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn VectorXMatrix3D(MATH2D::GVECTOR3D _vector, MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR3D& _outVector) { return GReturn::FAILURE; }
			static GReturn Transform2D(MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn Transform3D(MATH2D::GVECTOR3D _vector, MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR3D& _outVector) { return GReturn::FAILURE; }
			static GReturn Magnitude2D(MATH2D::GVECTOR2D _vector, double& _outMagnitude) { return GReturn::FAILURE; }
			static GReturn Magnitude3D(MATH2D::GVECTOR3D _vector, double& _outMagnitude) { return GReturn::FAILURE; }
			static GReturn Normalize2D(MATH2D::GVECTOR2D _vector, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn Normalize3D(MATH2D::GVECTOR3D _vector, MATH2D::GVECTOR3D& _outVector) { return GReturn::FAILURE; }
			static GReturn LerpD(double _value1, double _value2, double _ratio, double& _outValue) { return GReturn::FAILURE; }
			static GReturn Lerp2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, double _ratio, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn Lerp3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, double _ratio, MATH2D::GVECTOR3D& _outVector) { return GReturn::FAILURE; }
			static GReturn BerpD(double _value1, double _value2, double _value3, MATH2D::GBARYCENTRICD _barycentric, double& _outValue) { return GReturn::FAILURE; }
			static GReturn Berp2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, MATH2D::GVECTOR2D _vector3, MATH2D::GBARYCENTRICD _barycentric, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn Berp3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, MATH2D::GVECTOR3D _vector3, MATH2D::GBARYCENTRICD _barycentric, MATH2D::GVECTOR3D& _outVector) { return GReturn::FAILURE; }
			static GReturn Spline2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, MATH2D::GVECTOR2D _vector3, MATH2D::GVECTOR2D _vector4, double _ratio, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn GradientD(MATH2D::GLINE2D _line, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn AngleBetweenVectorsD(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, double& _outRadians) { return GReturn::FAILURE; }
			static GReturn AngleBetweenLinesD(MATH2D::GLINE2D _line1, MATH2D::GLINE2D _line2, double& _outRadians) { return GReturn::FAILURE; }
			static GReturn Downgrade2(MATH2D::GVECTOR2D _vector, MATH2D::GVECTOR2D& _outVector) { return GReturn::FAILURE; }
			static GReturn Downgrade3(MATH2D::GVECTOR3D _vector, MATH2D::GVECTOR3D& _outVector) { return GReturn::FAILURE; }
		};
	}
}

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
    #include <cmath>

namespace GW
{
	namespace I
	{
		class GVector2DImplementation : public virtual GVector2DInterface, private GInterfaceImplementation
		{
		public:

			GReturn Create()
			{
				return GReturn::SUCCESS;
			}

			// Floats
			static GReturn Add2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, MATH2D::GVECTOR2F& _outVector)
			{
				_outVector.x = _vector1.x + _vector2.x;
				_outVector.y = _vector1.y + _vector2.y;

				return GReturn::SUCCESS;
			}

			static GReturn Add3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, MATH2D::GVECTOR3F& _outVector)
			{
				_outVector.x = _vector1.x + _vector2.x;
				_outVector.y = _vector1.y + _vector2.y;
				_outVector.z = _vector1.z + _vector2.z;

				return GReturn::SUCCESS;
			}

			static GReturn Subtract2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, MATH2D::GVECTOR2F& _outVector)
			{
				_outVector.x = _vector1.x - _vector2.x;
				_outVector.y = _vector1.y - _vector2.y;

				return GReturn::SUCCESS;
			}

			static GReturn Subtract3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, MATH2D::GVECTOR3F& _outVector)
			{
				_outVector.x = _vector1.x - _vector2.x;
				_outVector.y = _vector1.y - _vector2.y;
				_outVector.z = _vector1.z - _vector2.z;

				return GReturn::SUCCESS;
			}

			static GReturn Scale2F(MATH2D::GVECTOR2F _vector, float _scalar, MATH2D::GVECTOR2F& _outVector)
			{
				_outVector.x = _scalar * _vector.x;
				_outVector.y = _scalar * _vector.y;

				return GReturn::SUCCESS;
			}

			static GReturn Scale3F(MATH2D::GVECTOR3F _vector, float _scalar, MATH2D::GVECTOR3F& _outVector)
			{
				_outVector.x = _scalar * _vector.x;
				_outVector.y = _scalar * _vector.y;
				_outVector.z = _scalar * _vector.z;

				return GReturn::SUCCESS;
			}

			static GReturn Dot2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, float& _outValue)
			{
				_outValue = (_vector1.x * _vector2.x) + (_vector1.y * _vector2.y);

				return GReturn::SUCCESS;
			}

			static GReturn Dot3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, float& _outValue)
			{
				_outValue = (_vector1.x * _vector2.x) + (_vector1.y * _vector2.y) + (_vector1.z * _vector2.z);

				return GReturn::SUCCESS;
			}

			static GReturn Cross2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, float& _outValue)
			{
				_outValue = (_vector1.x * _vector2.y) - (_vector1.y * _vector2.x);

				return GReturn::SUCCESS;
			}

			static GReturn Cross3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, MATH2D::GVECTOR3F& _outVector)
			{
				_outVector.x = (_vector1.y * _vector2.z) - (_vector1.z * _vector2.y);
				_outVector.y = (_vector1.z * _vector2.x) - (_vector1.x * _vector2.z);
				_outVector.z = (_vector1.x * _vector2.y) - (_vector1.y * _vector2.x);

				return GReturn::SUCCESS;
			}

			static GReturn VectorXMatrix2F(MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F& _outVector)
			{
				_outVector.x = (_vector.x * _matrix.row1.x) + (_vector.y * _matrix.row2.x);
				_outVector.y = (_vector.x * _matrix.row1.y) + (_vector.y * _matrix.row2.y);

				return GReturn::SUCCESS;
			}

			static GReturn VectorXMatrix3F(MATH2D::GVECTOR3F _vector, MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR3F& _outVector)
			{
				_outVector.x = (_vector.x * _matrix.row1.x) + (_vector.y * _matrix.row2.x) + (_vector.z * _matrix.row3.x);
				_outVector.y = (_vector.x * _matrix.row1.y) + (_vector.y * _matrix.row2.y) + (_vector.z * _matrix.row3.y);
				_outVector.z = (_vector.x * _matrix.row1.z) + (_vector.y * _matrix.row2.z) + (_vector.z * _matrix.row3.z);

				return GReturn::SUCCESS;
			}

			static GReturn Transform2F(MATH2D::GVECTOR2F _vector, MATH2D::GMATRIX2F _matrix, MATH2D::GVECTOR2F& _outVector)
			{
				VectorXMatrix2F(_vector, _matrix, _outVector);

				return GReturn::SUCCESS;
			}

			static GReturn Transform3F(MATH2D::GVECTOR3F _vector, MATH2D::GMATRIX3F _matrix, MATH2D::GVECTOR3F& _outVector)
			{
				VectorXMatrix3F(_vector, _matrix, _outVector);

				return GReturn::SUCCESS;
			}

			static GReturn Magnitude2F(MATH2D::GVECTOR2F _vector, float& _outMagnitude)
			{
				_outMagnitude = sqrt((_vector.x * _vector.x) + (_vector.y * _vector.y));
				if (G2D_COMPARISON_STANDARD_F(_outMagnitude, 0.0f))
					return GReturn::FAILURE;
				return GReturn::SUCCESS;
			}

			static GReturn Magnitude3F(MATH2D::GVECTOR3F _vector, float& _outMagnitude)
			{
				_outMagnitude = sqrt((_vector.x * _vector.x) + (_vector.y * _vector.y) + (_vector.z * _vector.z));
				if (G2D_COMPARISON_STANDARD_F(_outMagnitude, 0.0f))
					return GReturn::FAILURE;
				return GReturn::SUCCESS;
			}

			static GReturn Normalize2F(MATH2D::GVECTOR2F _vector, MATH2D::GVECTOR2F& _outVector)
			{
				float magnitude;
				if (-Magnitude2F(_vector, magnitude))
					return GReturn::FAILURE;

				_outVector.x = _vector.x / magnitude;
				_outVector.y = _vector.y / magnitude;

				return GReturn::SUCCESS;
			}

			static GReturn Normalize3F(MATH2D::GVECTOR3F _vector, MATH2D::GVECTOR3F& _outVector)
			{
				float magnitude;
				if (-Magnitude3F(_vector, magnitude))
					return GReturn::FAILURE;

				_outVector.x = _vector.x / magnitude;
				_outVector.y = _vector.y / magnitude;
				_outVector.z = _vector.z / magnitude;

				return GReturn::SUCCESS;
			}

			static GReturn LerpF(float _value1, float _value2, float _ratio, float& _outValue)
			{
				_outValue = G2D_LERP(_value1, _value2, _ratio);

				return GReturn::SUCCESS;
			}

			static GReturn Lerp2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, float _ratio, MATH2D::GVECTOR2F& _outVector)
			{
				_outVector.x = G2D_LERP(_vector1.x, _vector2.x, _ratio);
				_outVector.y = G2D_LERP(_vector1.y, _vector2.y, _ratio);

				return GReturn::SUCCESS;
			}

			static GReturn Lerp3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, float _ratio, MATH2D::GVECTOR3F& _outVector)
			{
				_outVector.x = G2D_LERP(_vector1.x, _vector2.x, _ratio);
				_outVector.y = G2D_LERP(_vector1.y, _vector2.y, _ratio);
				_outVector.z = G2D_LERP(_vector1.z, _vector2.z, _ratio);

				return GReturn::SUCCESS;
			}

			static GReturn BerpF(float _value1, float _value2, float _value3, MATH2D::GBARYCENTRICF _barycentric, float& _outValue)
			{
				_outValue = (_value1 * _barycentric.alpha) + (_value2 * _barycentric.beta) + (_value3 * _barycentric.gamma);

				return GReturn::SUCCESS;
			}

			static GReturn Berp2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, MATH2D::GVECTOR2F _vector3, MATH2D::GBARYCENTRICF _barycentric, MATH2D::GVECTOR2F& _outVector)
			{
				_outVector.x = (_vector1.x * _barycentric.alpha) + (_vector2.x * _barycentric.beta) + (_vector3.x * _barycentric.gamma);
				_outVector.y = (_vector1.y * _barycentric.alpha) + (_vector2.y * _barycentric.beta) + (_vector3.y * _barycentric.gamma);

				return GReturn::SUCCESS;
			}

			static GReturn Berp3F(MATH2D::GVECTOR3F _vector1, MATH2D::GVECTOR3F _vector2, MATH2D::GVECTOR3F _vector3, MATH2D::GBARYCENTRICF _barycentric, MATH2D::GVECTOR3F& _outVector)
			{
				_outVector.x = (_vector1.x * _barycentric.alpha) + (_vector2.x * _barycentric.beta) + (_vector3.x * _barycentric.gamma);
				_outVector.y = (_vector1.y * _barycentric.alpha) + (_vector2.y * _barycentric.beta) + (_vector3.y * _barycentric.gamma);
				_outVector.z = (_vector1.z * _barycentric.alpha) + (_vector2.z * _barycentric.beta) + (_vector3.z * _barycentric.gamma);

				return GReturn::SUCCESS;
			}

			static GReturn Spline2F(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, MATH2D::GVECTOR2F _vector3, MATH2D::GVECTOR2F _vector4, float _ratio, MATH2D::GVECTOR2F& _outVector)
			{
				MATH2D::GVECTOR2F p0 = _vector1;
				MATH2D::GVECTOR2F p1 = _vector2;
				MATH2D::GVECTOR2F p2 = _vector3;
				MATH2D::GVECTOR2F p3 = _vector4;

				float t0 = 0.0f;
				float t1 = pow(sqrt(pow((p1.x - p0.x), 2.0f) + pow((p1.y - p0.y), 2.0f)), 0.5f) + t0;
				float t2 = pow(sqrt(pow((p2.x - p1.x), 2.0f) + pow((p2.y - p1.y), 2.0f)), 0.5f) + t1;
				float t3 = pow(sqrt(pow((p3.x - p2.x), 2.0f) + pow((p3.y - p2.y), 2.0f)), 0.5f) + t2;

				MATH2D::GVECTOR2F A1;
				MATH2D::GVECTOR2F A2;
				MATH2D::GVECTOR2F A3;
				MATH2D::GVECTOR2F B1;
				MATH2D::GVECTOR2F B2;

				float t = t1 + (t2 - t1) * _ratio;

				for (int i = 0; i < 2; i++)
				{
					A1.data[i] = (t1 - t) / (t1 - t0) * p0.data[i] + (t - t0) / (t1 - t0) * p1.data[i];
					A2.data[i] = (t2 - t) / (t2 - t1) * p1.data[i] + (t - t1) / (t2 - t1) * p2.data[i];
					A3.data[i] = (t3 - t) / (t3 - t2) * p2.data[i] + (t - t2) / (t3 - t2) * p3.data[i];

					B1.data[i] = (t2 - t) / (t2 - t0) * A1.data[i] + (t - t0) / (t2 - t0) * A2.data[i];
					B2.data[i] = (t3 - t) / (t3 - t1) * A2.data[i] + (t - t1) / (t3 - t1) * A3.data[i];

					_outVector.data[i] = (t2 - t) / (t2 - t1) * B1.data[i] + (t - t1) / (t2 - t1) * B2.data[i];
				}

				return GReturn::SUCCESS;
			}

			static GReturn GradientF(MATH2D::GLINE2F _line, MATH2D::GVECTOR2F& _outVector)
			{
				_outVector.x = _line.start.y - _line.end.y;
				_outVector.y = _line.end.x - _line.start.x;

				return GReturn::SUCCESS;
			}

			static GReturn AngleBetweenVectorsF(MATH2D::GVECTOR2F _vector1, MATH2D::GVECTOR2F _vector2, float& _outRadians)
			{
				float dot;
				Dot2F(_vector1, _vector2, dot);

				float magnitude1;
				float magnitude2;
				if (-(Magnitude2F(_vector1, magnitude1)) || -(Magnitude2F(_vector2, magnitude2)))
					return GReturn::FAILURE;

				_outRadians = acos(G2D_ABS(dot) / (magnitude1 * magnitude2));

				return GReturn::SUCCESS;
			}

			static GReturn AngleBetweenLinesF(MATH2D::GLINE2F _line1, MATH2D::GLINE2F _line2, float& _outRadians)
			{
				// get vectors parallel to the lines. represented as single points because we assume the vector starts at the origin
				GW::MATH2D::GVECTOR2F u;
				GW::MATH2D::GVECTOR2F v;

				u.x = _line1.end.x - _line1.start.x;
				u.y = _line1.end.y - _line1.start.y;

				v.x = _line2.end.x - _line2.start.x;
				v.y = _line2.end.y - _line2.start.y;

				// now that we have the 2 vectors parallel to the 2 lines, we can perform the actual calculation
				if (-AngleBetweenVectorsF(u, v, _outRadians))
					return GReturn::FAILURE;

				return GReturn::SUCCESS;
			}

			static GReturn Upgrade2(MATH2D::GVECTOR2F _vector, MATH2D::GVECTOR2D& _outVector)
			{
				_outVector.x = static_cast<double>(_vector.x);
				_outVector.y = static_cast<double>(_vector.y);

				return GReturn::SUCCESS;
			}

			static GReturn Upgrade3(MATH2D::GVECTOR3F _vector, MATH2D::GVECTOR3D& _outVector)
			{
				_outVector.x = static_cast<double>(_vector.x);
				_outVector.y = static_cast<double>(_vector.y);
				_outVector.z = static_cast<double>(_vector.z);

				return GReturn::SUCCESS;
			}



			// Doubles
			static GReturn Add2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, MATH2D::GVECTOR2D& _outVector)
			{
				_outVector.x = _vector1.x + _vector2.x;
				_outVector.y = _vector1.y + _vector2.y;

				return GReturn::SUCCESS;
			}

			static GReturn Add3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, MATH2D::GVECTOR3D& _outVector)
			{
				_outVector.x = _vector1.x + _vector2.x;
				_outVector.y = _vector1.y + _vector2.y;
				_outVector.z = _vector1.z + _vector2.z;

				return GReturn::SUCCESS;
			}

			static GReturn Subtract2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, MATH2D::GVECTOR2D& _outVector)
			{
				_outVector.x = _vector1.x - _vector2.x;
				_outVector.y = _vector1.y - _vector2.y;

				return GReturn::SUCCESS;
			}

			static GReturn Subtract3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, MATH2D::GVECTOR3D& _outVector)
			{
				_outVector.x = _vector1.x - _vector2.x;
				_outVector.y = _vector1.y - _vector2.y;
				_outVector.z = _vector1.z - _vector2.z;

				return GReturn::SUCCESS;
			};

			static GReturn Scale2D(MATH2D::GVECTOR2D _vector, double _scalar, MATH2D::GVECTOR2D& _outVector)
			{
				_outVector.x = _scalar * _vector.x;
				_outVector.y = _scalar * _vector.y;

				return GReturn::SUCCESS;
			};

			static GReturn Scale3D(MATH2D::GVECTOR3D _vector, double _scalar, MATH2D::GVECTOR3D& _outVector)
			{
				_outVector.x = _scalar * _vector.x;
				_outVector.y = _scalar * _vector.y;
				_outVector.z = _scalar * _vector.z;

				return GReturn::SUCCESS;
			};

			static GReturn Dot2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, double& _outValue)
			{
				_outValue = (_vector1.x * _vector2.x) + (_vector1.y * _vector2.y);

				return GReturn::SUCCESS;
			};

			static GReturn Dot3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, double& _outValue)
			{
				_outValue = (_vector1.x * _vector2.x) + (_vector1.y * _vector2.y) + (_vector1.z * _vector2.z);

				return GReturn::SUCCESS;
			};

			static GReturn Cross2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, double& _outValue)
			{
				_outValue = (_vector1.x * _vector2.y) - (_vector1.y * _vector2.x);

				return GReturn::SUCCESS;
			};

			static GReturn Cross3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, MATH2D::GVECTOR3D& _outVector)
			{
				_outVector.x = (_vector1.y * _vector2.z) - (_vector1.z * _vector2.y);
				_outVector.y = (_vector1.z * _vector2.x) - (_vector1.x * _vector2.z);
				_outVector.z = (_vector1.x * _vector2.y) - (_vector1.y * _vector2.x);

				return GReturn::SUCCESS;
			};

			static GReturn VectorXMatrix2D(MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D& _outVector)
			{
				_outVector.x = (_vector.x * _matrix.row1.x) + (_vector.y * _matrix.row2.x);
				_outVector.y = (_vector.x * _matrix.row1.y) + (_vector.y * _matrix.row2.y);

				return GReturn::SUCCESS;
			};

			static GReturn VectorXMatrix3D(MATH2D::GVECTOR3D _vector, MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR3D& _outVector)
			{
				_outVector.x = (_vector.x * _matrix.row1.x) + (_vector.y * _matrix.row2.x) + (_vector.z * _matrix.row3.x);
				_outVector.y = (_vector.x * _matrix.row1.y) + (_vector.y * _matrix.row2.y) + (_vector.z * _matrix.row3.y);
				_outVector.z = (_vector.x * _matrix.row1.z) + (_vector.y * _matrix.row2.z) + (_vector.z * _matrix.row3.z);

				return GReturn::SUCCESS;
			};

			static GReturn Transform2D(MATH2D::GVECTOR2D _vector, MATH2D::GMATRIX2D _matrix, MATH2D::GVECTOR2D& _outVector)
			{
				VectorXMatrix2D(_vector, _matrix, _outVector);

				return GReturn::SUCCESS;
			}

			static GReturn Transform3D(MATH2D::GVECTOR3D _vector, MATH2D::GMATRIX3D _matrix, MATH2D::GVECTOR3D& _outVector)
			{
				VectorXMatrix3D(_vector, _matrix, _outVector);

				return GReturn::SUCCESS;
			};

			static GReturn Magnitude2D(MATH2D::GVECTOR2D _vector, double& _outMagnitude)
			{
				_outMagnitude = sqrt((_vector.x * _vector.x) + (_vector.y * _vector.y));
				if (G2D_COMPARISON_STANDARD_D(_outMagnitude, 0.0))
					return GReturn::FAILURE;
				return GReturn::SUCCESS;
			}

			static GReturn Magnitude3D(MATH2D::GVECTOR3D _vector, double& _outMagnitude)
			{
				_outMagnitude = sqrt((_vector.x * _vector.x) + (_vector.y * _vector.y) + (_vector.z * _vector.z));
				if (G2D_COMPARISON_STANDARD_D(_outMagnitude, 0.0))
					return GReturn::FAILURE;
				return GReturn::SUCCESS;
			}

			static GReturn Normalize2D(MATH2D::GVECTOR2D _vector, MATH2D::GVECTOR2D& _outVector)
			{
				double magnitude;
				if (-Magnitude2D(_vector, magnitude))
					return GReturn::FAILURE;

				_outVector.x = _vector.x / magnitude;
				_outVector.y = _vector.y / magnitude;

				return GReturn::SUCCESS;
			}

			static GReturn Normalize3D(MATH2D::GVECTOR3D _vector, MATH2D::GVECTOR3D& _outVector)
			{
				double magnitude;
				if (-Magnitude3D(_vector, magnitude))
					return GReturn::FAILURE;

				_outVector.x = _vector.x / magnitude;
				_outVector.y = _vector.y / magnitude;
				_outVector.z = _vector.z / magnitude;

				return GReturn::SUCCESS;
			}

			static GReturn LerpD(double _value1, double _value2, double _ratio, double& _outValue)
			{
				_outValue = G2D_LERP(_value1, _value2, _ratio);

				return GReturn::SUCCESS;
			};

			static GReturn Lerp2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, double _ratio, MATH2D::GVECTOR2D& _outVector)
			{
				_outVector.x = G2D_LERP(_vector1.x, _vector2.x, _ratio);
				_outVector.y = G2D_LERP(_vector1.y, _vector2.y, _ratio);

				return GReturn::SUCCESS;
			}

			static GReturn Lerp3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, double _ratio, MATH2D::GVECTOR3D& _outVector)
			{
				_outVector.x = G2D_LERP(_vector1.x, _vector2.x, _ratio);
				_outVector.y = G2D_LERP(_vector1.y, _vector2.y, _ratio);
				_outVector.z = G2D_LERP(_vector1.z, _vector2.z, _ratio);

				return GReturn::SUCCESS;
			}

			static GReturn BerpD(double _value1, double _value2, double _value3, MATH2D::GBARYCENTRICD _barycentric, double& _outValue)
			{
				_outValue = (_value1 * _barycentric.alpha) + (_value2 * _barycentric.beta) + (_value3 * _barycentric.gamma);

				return GReturn::SUCCESS;
			}

			static GReturn Berp2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, MATH2D::GVECTOR2D _vector3, MATH2D::GBARYCENTRICD _barycentric, MATH2D::GVECTOR2D& _outVector)
			{
				_outVector.x = (_vector1.x * _barycentric.alpha) + (_vector2.x * _barycentric.beta) + (_vector3.x * _barycentric.gamma);
				_outVector.y = (_vector1.y * _barycentric.alpha) + (_vector2.y * _barycentric.beta) + (_vector3.y * _barycentric.gamma);

				return GReturn::SUCCESS;
			}

			static GReturn Berp3D(MATH2D::GVECTOR3D _vector1, MATH2D::GVECTOR3D _vector2, MATH2D::GVECTOR3D _vector3, MATH2D::GBARYCENTRICD _barycentric, MATH2D::GVECTOR3D& _outVector)
			{
				_outVector.x = (_vector1.x * _barycentric.alpha) + (_vector2.x * _barycentric.beta) + (_vector3.x * _barycentric.gamma);
				_outVector.y = (_vector1.y * _barycentric.alpha) + (_vector2.y * _barycentric.beta) + (_vector3.y * _barycentric.gamma);
				_outVector.z = (_vector1.z * _barycentric.alpha) + (_vector2.z * _barycentric.beta) + (_vector3.z * _barycentric.gamma);

				return GReturn::SUCCESS;
			}

			static GReturn Spline2D(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, MATH2D::GVECTOR2D _vector3, MATH2D::GVECTOR2D _vector4, double _ratio, MATH2D::GVECTOR2D& _outVector)
			{
				MATH2D::GVECTOR2D p0 = _vector1;
				MATH2D::GVECTOR2D p1 = _vector2;
				MATH2D::GVECTOR2D p2 = _vector3;
				MATH2D::GVECTOR2D p3 = _vector4;

				double t0 = 0.0;
				double t1 = pow(sqrt(pow((p1.x - p0.x), 2) + pow((p1.y - p0.y), 2)), 0.5) + t0;
				double t2 = pow(sqrt(pow((p2.x - p1.x), 2) + pow((p2.y - p1.y), 2)), 0.5) + t1;
				double t3 = pow(sqrt(pow((p3.x - p2.x), 2) + pow((p3.y - p2.y), 2)), 0.5) + t2;

				MATH2D::GVECTOR2D A1;
				MATH2D::GVECTOR2D A2;
				MATH2D::GVECTOR2D A3;
				MATH2D::GVECTOR2D B1;
				MATH2D::GVECTOR2D B2;

				double t = t1 + (t2 - t1) * _ratio;

				for (int i = 0; i < 2; i++)
				{
					A1.data[i] = (t1 - t) / (t1 - t0) * p0.data[i] + (t - t0) / (t1 - t0) * p1.data[i];
					A2.data[i] = (t2 - t) / (t2 - t1) * p1.data[i] + (t - t1) / (t2 - t1) * p2.data[i];
					A3.data[i] = (t3 - t) / (t3 - t2) * p2.data[i] + (t - t2) / (t3 - t2) * p3.data[i];

					B1.data[i] = (t2 - t) / (t2 - t0) * A1.data[i] + (t - t0) / (t2 - t0) * A2.data[i];
					B2.data[i] = (t3 - t) / (t3 - t1) * A2.data[i] + (t - t1) / (t3 - t1) * A3.data[i];

					_outVector.data[i] = (t2 - t) / (t2 - t1) * B1.data[i] + (t - t1) / (t2 - t1) * B2.data[i];
				}

				return GReturn::SUCCESS;
			}

			static GReturn GradientD(MATH2D::GLINE2D _line, MATH2D::GVECTOR2D& _outVector)
			{
				_outVector.x = _line.start.y - _line.end.y;
				_outVector.y = _line.end.x - _line.start.x;

				return GReturn::SUCCESS;
			}

			static GReturn AngleBetweenVectorsD(MATH2D::GVECTOR2D _vector1, MATH2D::GVECTOR2D _vector2, double& _outRadians)
			{
				double dot;
				Dot2D(_vector1, _vector2, dot);

				double magnitude1;
				double magnitude2;
				if (-(Magnitude2D(_vector1, magnitude1)) || -(Magnitude2D(_vector2, magnitude2)))
					return GReturn::FAILURE;

				_outRadians = acos(G2D_ABS(dot) / (magnitude1 * magnitude2));

				return GReturn::SUCCESS;
			}

			static GReturn AngleBetweenLinesD(MATH2D::GLINE2D _line1, MATH2D::GLINE2D _line2, double& _outRadians)
			{
				// get vectors parallel to the lines. represented as single points because we assume the vector starts at the origin
				GW::MATH2D::GVECTOR2D u;
				GW::MATH2D::GVECTOR2D v;

				u.x = _line1.end.x - _line1.start.x;
				u.y = _line1.end.y - _line1.start.y;

				v.x = _line2.end.x - _line2.start.x;
				v.y = _line2.end.y - _line2.start.y;

				// now that we have the 2 vectors parallel to the 2 lines, we can perform the actual calculation
				if (-AngleBetweenVectorsD(u, v, _outRadians))
					return GReturn::FAILURE;

				return GReturn::SUCCESS;
			}

			static GReturn Downgrade2(MATH2D::GVECTOR2D _vector, MATH2D::GVECTOR2F& _outVector)
			{
				_outVector.x = static_cast<float>(_vector.x);
				_outVector.y = static_cast<float>(_vector.y);

				return GReturn::SUCCESS;
			}

			static GReturn Downgrade3(MATH2D::GVECTOR3D _vector, MATH2D::GVECTOR3F& _outVector)
			{
				_outVector.x = static_cast<float>(_vector.x);
				_outVector.y = static_cast<float>(_vector.y);
				_outVector.z = static_cast<float>(_vector.z);

				return GReturn::SUCCESS;
			}
		};
	}
}

#endif


namespace GW
{
	namespace MATH2D
	{
		class GVector2D final : public I::GProxy<I::GVector2DInterface, I::GVector2DImplementation>
		{
		public:
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GVector2D)
			// Floats
			GATEWARE_STATIC_FUNCTION(Add2F)
			GATEWARE_STATIC_FUNCTION(Add3F)
			GATEWARE_STATIC_FUNCTION(Subtract2F)
			GATEWARE_STATIC_FUNCTION(Subtract3F)
			GATEWARE_STATIC_FUNCTION(Scale2F)
			GATEWARE_STATIC_FUNCTION(Scale3F)
			GATEWARE_STATIC_FUNCTION(Dot2F)
			GATEWARE_STATIC_FUNCTION(Dot3F)
			GATEWARE_STATIC_FUNCTION(Cross2F)
			GATEWARE_STATIC_FUNCTION(Cross3F)
			GATEWARE_STATIC_FUNCTION(VectorXMatrix2F)
			GATEWARE_STATIC_FUNCTION(VectorXMatrix3F)
			GATEWARE_STATIC_FUNCTION(Transform2F)
			GATEWARE_STATIC_FUNCTION(Transform3F)
			GATEWARE_STATIC_FUNCTION(Magnitude2F)
			GATEWARE_STATIC_FUNCTION(Magnitude3F)
			GATEWARE_STATIC_FUNCTION(Normalize2F)
			GATEWARE_STATIC_FUNCTION(Normalize3F)
			GATEWARE_STATIC_FUNCTION(LerpF)
			GATEWARE_STATIC_FUNCTION(Lerp2F)
			GATEWARE_STATIC_FUNCTION(Lerp3F)
			GATEWARE_STATIC_FUNCTION(BerpF)
			GATEWARE_STATIC_FUNCTION(Berp2F)
			GATEWARE_STATIC_FUNCTION(Berp3F)
			GATEWARE_STATIC_FUNCTION(Spline2F)
			GATEWARE_STATIC_FUNCTION(GradientF)
			GATEWARE_STATIC_FUNCTION(AngleBetweenVectorsF)
			GATEWARE_STATIC_FUNCTION(AngleBetweenLinesF)
			GATEWARE_STATIC_FUNCTION(Upgrade2)
			GATEWARE_STATIC_FUNCTION(Upgrade3)




			// Doubles
			GATEWARE_STATIC_FUNCTION(Add2D)
			GATEWARE_STATIC_FUNCTION(Add3D)
			GATEWARE_STATIC_FUNCTION(Subtract2D)
			GATEWARE_STATIC_FUNCTION(Subtract3D)
			GATEWARE_STATIC_FUNCTION(Scale2D)
			GATEWARE_STATIC_FUNCTION(Scale3D)
			GATEWARE_STATIC_FUNCTION(Dot2D)
			GATEWARE_STATIC_FUNCTION(Dot3D)
			GATEWARE_STATIC_FUNCTION(Cross2D)
			GATEWARE_STATIC_FUNCTION(Cross3D)
			GATEWARE_STATIC_FUNCTION(VectorXMatrix2D)
			GATEWARE_STATIC_FUNCTION(VectorXMatrix3D)
			GATEWARE_STATIC_FUNCTION(Transform2D)
			GATEWARE_STATIC_FUNCTION(Transform3D)
			GATEWARE_STATIC_FUNCTION(Magnitude2D)
			GATEWARE_STATIC_FUNCTION(Magnitude3D)
			GATEWARE_STATIC_FUNCTION(Normalize2D)
			GATEWARE_STATIC_FUNCTION(Normalize3D)
			GATEWARE_STATIC_FUNCTION(LerpD)
			GATEWARE_STATIC_FUNCTION(Lerp2D)
			GATEWARE_STATIC_FUNCTION(Lerp3D)
			GATEWARE_STATIC_FUNCTION(BerpD)
			GATEWARE_STATIC_FUNCTION(Berp2D)
			GATEWARE_STATIC_FUNCTION(Berp3D)
			GATEWARE_STATIC_FUNCTION(Spline2D)
			GATEWARE_STATIC_FUNCTION(GradientD)
			GATEWARE_STATIC_FUNCTION(AngleBetweenVectorsD)
			GATEWARE_STATIC_FUNCTION(AngleBetweenLinesD)
			GATEWARE_STATIC_FUNCTION(Downgrade2)
			GATEWARE_STATIC_FUNCTION(Downgrade3)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GVECTOR2D_H

/*---------------------------------
|	End of GVector2D.h
----------------------------------*/


/*---------------------------------
|	Begin of GBlitter.h
----------------------------------*/
#ifndef GBLITTER_H
#define GBLITTER_H





namespace GW
{
	namespace I
	{
		class GBlitterInterface : public virtual GInterfaceInterface
		{
		public:
			// 16 flags available
			enum DrawOptions
			{
				ROTATE					= 0x1,
				MIRROR_VERTICAL			= 0x2,
				MIRROR_HORIZONTAL		= 0x4,
				IGNORE_SOURCE_COLORS	= 0x8,
				USE_SOURCE_LAYERS		= 0x10,
				USE_SOURCE_STENCILS		= 0x20,
				USE_MASKING				= 0x40,
				USE_TRANSFORMATIONS		= 0x80,
				USE_TRANSPARENCY		= 0x100,
			};
			
			// 16 B
			struct TileDefinition
			{
				unsigned short			source_id;
				unsigned short			x;
				unsigned short			y;
				unsigned short			w;
				unsigned short			h;
				unsigned int			mask_color;
				unsigned char			mask_layer;
				unsigned char			mask_stencil;
			};
			const TileDefinition GBlitterDefaultTileDefinition =
			{
				0xFFFF,
				0,
				0,
				0,
				0,
				0x00000000,
				0,
				0
			};

			// 48 B (44 B + padding)
			struct DrawInstruction
			{
				unsigned int			tile_id;
				unsigned short			flags;
				unsigned char			layer;
				unsigned char			stencil;
				float					t[3];
				float					m[2][2];
				float					p[2];
				unsigned char			pad[4];
			};
			const DrawInstruction GBlitterDefaultDrawInstruction =
			{
				0xFFFFFFFF,
				0,
				0,
				0,
				{ 0, 0, 0 },
				{ { 1, 0 }, { 0, 1 } },
				{ 0, 0 }
			};

			virtual GReturn LoadSource(
				const char* _colorsFilepath, const char* _layersFilepath, const char* _stencilsFilepath,
				unsigned short &_outIndex) = 0;
			virtual GReturn ImportSource(
				const unsigned int* _colors, const unsigned char* _layers, const unsigned char* _stencils,
				unsigned short _width, unsigned short _height, unsigned short _pixelOffset, unsigned short _rowPixelStride,
				unsigned short& _outIndex) = 0;
			virtual GReturn ImportSourceComplex(
				const unsigned int* _colors, unsigned short _colorByteStride, unsigned short _colorRowByteStride,
				const unsigned char* _layers, unsigned short _layerByteStride, unsigned short _layerRowByteStride,
				const unsigned char* _stencils, unsigned short _stencilByteStride, unsigned short _stencilRowByteStride,
				unsigned short _width, unsigned short _height, unsigned short& _outIndex) = 0;
			virtual GReturn DefineTiles(const TileDefinition* _tileDefinitions, const unsigned int _numTiles, unsigned int* _outIndices) = 0;
			virtual GReturn SetTileMaskValues(
				unsigned int* _tileIndices, unsigned int _numTiles,
				unsigned int _maskColor, unsigned char _maskLayer, unsigned char _maskStencil) = 0;
			virtual GReturn DiscardSources(unsigned short* _sourceIndices, unsigned short _numSources) = 0;
			virtual GReturn DiscardTiles(unsigned int* _tileIndices, unsigned int _numTiles) = 0;
			virtual GReturn Clear(unsigned int _color, unsigned char _layer, unsigned char _stencil) = 0;
			virtual GReturn ClearColor(unsigned int _color) = 0;
			virtual GReturn ClearLayer(unsigned char _layer) = 0;
			virtual GReturn ClearStencil(unsigned char _stencil) = 0;
			virtual GReturn DrawDeferred(const DrawInstruction* _drawInstructions, const unsigned short _numDraws) = 0;
			virtual GReturn DrawImmediate(const DrawInstruction* _drawInstructions, const unsigned short _numDraws) = 0;
			virtual GReturn Flush() = 0;
			virtual GReturn ExportResult(
				bool _flush,
				unsigned short _width, unsigned short _height, unsigned short _pixelOffset, unsigned short _rowPixelStride,
				unsigned int* _outColors, unsigned char* _outLayers, unsigned char* _outStencils) = 0;
			virtual GReturn ExportResultComplex(
				bool _flush,
				unsigned short _colorByteStride, unsigned short _colorRowByteStride,
				unsigned short _layerByteStride, unsigned short _layerRowByteStride,
				unsigned short _stencilByteStride, unsigned short _stencilRowByteStride,
				unsigned short _width, unsigned short _height,
				unsigned int* _outColors, unsigned char* _outLayers, unsigned char* _outStencils) = 0;
		};
	};
};

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GBlitter.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible 
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file 
// When adding implementations please try to condense redundant file includes where possible. 
// This will reduce size/redundancy when the library is tool compressed into single header form. 
#if !defined(GATEWARE_ENABLE_GRAPHICS) || defined(GATEWARE_DISABLE_GBLITTER) || \
    (defined(GATEWARE_ENABLE_GRAPHICS) && !defined(GATEWARE_DISABLE_GBLITTER) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW {
	namespace I {

		class GBlitterImplementation : public virtual GBlitterInterface
		{
		public:
			GReturn Create(unsigned short _width, unsigned short _height) { return GReturn::INTERFACE_UNSUPPORTED; }
			GReturn LoadSource(const char* _colorFilepath, const char* _layersFilepath, const char* _stencilsFilepath, unsigned short& _outIndex) override { return GReturn::FAILURE; }
			GReturn ImportSource(
				const unsigned int* _colors, const unsigned char* _layers, const unsigned char* _stencils,
				unsigned short _width, unsigned short _height, unsigned short _pixelOffset, unsigned short _rowPixelStride,
				unsigned short& _outIndex) override
			{
				return GReturn::FAILURE;
			}
			GReturn ImportSourceComplex(
				const unsigned int* _colors, unsigned short _colorByteStride, unsigned short _colorRowByteStride,
				const unsigned char* _layers, unsigned short _layerByteStride, unsigned short _layerRowByteStride,
				const unsigned char* _stencils, unsigned short _stencilByteStride, unsigned short _stencilRowByteStride,
				unsigned short _width, unsigned short _height, unsigned short& _outIndex) override
			{
				return GReturn::FAILURE;
			}
			GReturn DefineTiles(const TileDefinition* _tileDefinitions, const unsigned int _numTiles, unsigned int* _outIndices) override { return GReturn::FAILURE; }
			GReturn SetTileMaskValues(unsigned int* _tileIndices, unsigned int _numTiles, unsigned int _maskColor, unsigned char _maskLayer, unsigned char _maskStencil) { return GReturn::FAILURE; }
			GReturn DiscardSources(unsigned short* _sourceIndices, unsigned short _numSources) override { return GReturn::FAILURE; }
			GReturn DiscardTiles(unsigned int* _tileIndices, unsigned int _numTiles) override { return GReturn::FAILURE; }
			GReturn Clear(unsigned int _color, unsigned char _layer, unsigned char _stencil) override { return GReturn::FAILURE; }
			GReturn ClearColor(unsigned int _color) override { return GReturn::FAILURE; }
			GReturn ClearLayer(unsigned char _layer) override { return GReturn::FAILURE; }
			GReturn ClearStencil(unsigned char _stencil) override { return GReturn::FAILURE; }
			GReturn DrawDeferred(const DrawInstruction* _drawInstructions, const unsigned short _numDraws) override { return GReturn::FAILURE; }
			GReturn DrawImmediate(const DrawInstruction* _drawInstructions, const unsigned short _numDraws) override { return GReturn::FAILURE; }
			GReturn Flush() { return GReturn::FAILURE; }
			GReturn ExportResult(
				bool _flush,
				unsigned short _width, unsigned short _height, unsigned short _pixelOffset, unsigned short _rowPixelStride,
				unsigned int* _outColors, unsigned char* _outLayers, unsigned char* _outStencils) override
			{
				return GReturn::FAILURE;
			}
			GReturn ExportResultComplex(
				bool _flush,
				unsigned short _colorByteStride, unsigned short _colorRowByteStride,
				unsigned short _layerByteStride, unsigned short _layerRowByteStride,
				unsigned short _stencilByteStride, unsigned short _stencilRowByteStride,
				unsigned short _width, unsigned short _height,
				unsigned int* _outColors, unsigned char* _outLayers, unsigned char* _outStencils) override
			{
				return GReturn::FAILURE;
			}
		};

	} // end I namespace
} // end GW namespace

#else //defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
    





#include <cctype> // included for tolower function
#include <vector>
#include <limits>
#include <cmath>


//#define GBLITTER_DEBUG_VERBOSE_NEW							// uncomment this line to override the "new" keyword with a macro that stores additional data to track down memory leaks more easily (WIN32 Debug only)
//#define GBLITTER_DEBUG_SERIAL_FLUSH							// uncomment this line to turn off multithreaded flushing to make debugging easier
//#define GBLITTER_DEBUG_OUTLINE_TRANFORMED_BOUNDS				// uncomment this line to make transformed instructions outline their bounds with a solid color wherever a pixel is not drawn
//#define GBLITTER_DEBUG_FILL_TRANFORMED_BOUNDS					// uncomment this line to make transformed instructions fill their bounds with a solid color wherever a pixel is not drawn (overrides outlining bounds)
//#define GBLITTER_DEBUG_FILL_TRANSFORMED_TRIANGLES				// uncomment this line to make transformed instructions fill the triangles they are divided into with a solid color (color lookup drawing will be done over top of solid color)
//#define GBLITTER_DEBUG_DISABLE_TRANSFORMED_COLOR_LOOKUP		// uncomment this line to make transformed instructions replace color lookup with filling the triangles they are divided into with a solid color (overrides filling triangles)
//#define GBLITTER_DEBUG_DRAW_TRANSFORMED_TRIANGLE_CORNERS		// uncomment this line to make transformed instructions draw the corners of the triangles they are divided into with a solid color

#if defined(_WIN32) && !defined(NDEBUG) && defined(GBLITTER_DEBUG_VERBOSE_NEW)
#define new new(_NORMAL_BLOCK, __FILE__, __LINE__)
#endif


namespace GW
{
	namespace I
	{
		class GBlitterImplementation : public virtual GBlitterInterface
		{

#pragma region DEFINES

			typedef unsigned char				Byte;
			typedef unsigned int				Color; // RGBA quadruple
			typedef unsigned char				ColorChannel; // single value from a Color (R, G, B, or A)
			typedef unsigned char				Layer;
			typedef unsigned char				Stencil;

			// Masks for bits within a byte (MSB to LSB from left to right)
			static constexpr Byte				BIT_0									= 0b00000001u;
			static constexpr Byte				BIT_1									= 0b00000010u;
			static constexpr Byte				BIT_2									= 0b00000100u;
			static constexpr Byte				BIT_3									= 0b00001000u;
			static constexpr Byte				BIT_4									= 0b00010000u;
			static constexpr Byte				BIT_5									= 0b00100000u;
			static constexpr Byte				BIT_6									= 0b01000000u;
			static constexpr Byte				BIT_7									= 0b10000000u;

			// Masks for bytes within a multi-byte value (MSB to LSB from left to right)
			static constexpr unsigned short		BYTE_0									= 0x00ffu;
			static constexpr unsigned short		BYTE_1									= 0xff00u;
			static constexpr unsigned int		BYTE_2									= 0x00ff0000u;
			static constexpr unsigned int		BYTE_3									= 0xff000000u;
			static constexpr unsigned long long	BYTE_4									= 0x000000ff00000000ul;
			static constexpr unsigned long long	BYTE_5									= 0x0000ff0000000000ul;
			static constexpr unsigned long long	BYTE_6									= 0x00ff000000000000ul;
			static constexpr unsigned long long	BYTE_7									= 0xff00000000000000ul;

			// Minimum and maximum possible values in a color channel
			static constexpr ColorChannel		COLOR_CHANNEL_MIN						= (std::numeric_limits<ColorChannel>::min)();
			static constexpr ColorChannel		COLOR_CHANNEL_MAX						= (std::numeric_limits<ColorChannel>::max)();

			// Shorthands for relevant color channels in various formats (first channel to last channel from left to right)
			static constexpr Color				CHANNEL_0_MASK							= BYTE_3;
			static constexpr Color				CHANNEL_1_MASK							= BYTE_2;
			static constexpr Color				CHANNEL_2_MASK							= BYTE_1;
			static constexpr Color				CHANNEL_3_MASK							= BYTE_0;

			static constexpr Color				CHANNEL_MASK_LUMINANCE_L				= CHANNEL_0_MASK;

			static constexpr Color				CHANNEL_MASK_LUMINANCE_LA				= CHANNEL_0_MASK;
			static constexpr Color				CHANNEL_MASK_ALPHA_LA					= CHANNEL_1_MASK;

			static constexpr Color				CHANNEL_MASK_LUMINANCE_AL				= CHANNEL_1_MASK;
			static constexpr Color				CHANNEL_MASK_ALPHA_AL					= CHANNEL_0_MASK;

			static constexpr Color				CHANNEL_MASK_RED_RGBA					= CHANNEL_0_MASK;
			static constexpr Color				CHANNEL_MASK_GREEN_RGBA					= CHANNEL_1_MASK;
			static constexpr Color				CHANNEL_MASK_BLUE_RGBA					= CHANNEL_2_MASK;
			static constexpr Color				CHANNEL_MASK_ALPHA_RGBA					= CHANNEL_3_MASK;

			static constexpr Color				CHANNEL_MASK_RED_ARGB					= CHANNEL_1_MASK;
			static constexpr Color				CHANNEL_MASK_GREEN_ARGB					= CHANNEL_2_MASK;
			static constexpr Color				CHANNEL_MASK_BLUE_ARGB					= CHANNEL_3_MASK;
			static constexpr Color				CHANNEL_MASK_ALPHA_ARGB					= CHANNEL_0_MASK;

			// Byte offsets of color channels within a pixel in memory (values are stored in little endian order)
			static constexpr unsigned short		LITTLE_ENDIAN_BYTE_OFFSET_LUMINANCE_L	= 0;

			static constexpr unsigned short		LITTLE_ENDIAN_BYTE_OFFSET_LUMINANCE_LA	= 1;
			static constexpr unsigned short		LITTLE_ENDIAN_BYTE_OFFSET_ALPHA_LA		= 0;

			static constexpr unsigned short		LITTLE_ENDIAN_BYTE_OFFSET_LUMINANCE_AL	= 0;
			static constexpr unsigned short		LITTLE_ENDIAN_BYTE_OFFSET_ALPHA_AL		= 1;

			static constexpr unsigned short		LITTLE_ENDIAN_BYTE_OFFSET_RED_RGB		= 2;
			static constexpr unsigned short		LITTLE_ENDIAN_BYTE_OFFSET_GREEN_RGB		= 1;
			static constexpr unsigned short		LITTLE_ENDIAN_BYTE_OFFSET_BLUE_RGB		= 0;

			static constexpr unsigned short		LITTLE_ENDIAN_BYTE_OFFSET_RED_RGBA		= 3;
			static constexpr unsigned short		LITTLE_ENDIAN_BYTE_OFFSET_GREEN_RGBA	= 2;
			static constexpr unsigned short		LITTLE_ENDIAN_BYTE_OFFSET_BLUE_RGBA		= 1;
			static constexpr unsigned short		LITTLE_ENDIAN_BYTE_OFFSET_ALPHA_RGBA	= 0;

			static constexpr unsigned short		LITTLE_ENDIAN_BYTE_OFFSET_RED_ARGB		= 2;
			static constexpr unsigned short		LITTLE_ENDIAN_BYTE_OFFSET_GREEN_ARGB	= 1;
			static constexpr unsigned short		LITTLE_ENDIAN_BYTE_OFFSET_BLUE_ARGB		= 0;
			static constexpr unsigned short		LITTLE_ENDIAN_BYTE_OFFSET_ALPHA_ARGB	= 3;

			// Relevant values for TGA files
			static constexpr Byte				TGA_VERTICAL_ORIGIN_TOP					= BIT_5;
			static constexpr Byte				TGA_HORIZONTAL_ORIGIN_RIGHT				= BIT_4;

			// Size of a pixel from a source file in bytes, by format
			static constexpr unsigned short		SOURCE_FILE_PIXEL_SIZE_BYTES_L_8		= 1u;
			static constexpr unsigned short		SOURCE_FILE_PIXEL_SIZE_BYTES_AL_16		= 2u;
			static constexpr unsigned short		SOURCE_FILE_PIXEL_SIZE_BYTES_RGB_24		= 3u;
			static constexpr unsigned short		SOURCE_FILE_PIXEL_SIZE_BYTES_ARGB_32	= 4u;
			static constexpr unsigned short		SOURCE_FILE_PIXEL_SIZE_BYTES_LUT_8		= 1u;

			// Size of a blitter internal pixel in bytes, by format
			static constexpr unsigned short		INTERNAL_PIXEL_SIZE_BYTES_C			= sizeof(Color);
			static constexpr unsigned short		INTERNAL_PIXEL_SIZE_BYTES_L			= sizeof(Layer);
			static constexpr unsigned short		INTERNAL_PIXEL_SIZE_BYTES_S			= sizeof(Stencil);
			static constexpr unsigned short		INTERNAL_PIXEL_SIZE_BYTES_CL		= INTERNAL_PIXEL_SIZE_BYTES_C + INTERNAL_PIXEL_SIZE_BYTES_L;
			static constexpr unsigned short		INTERNAL_PIXEL_SIZE_BYTES_CS		= INTERNAL_PIXEL_SIZE_BYTES_C + INTERNAL_PIXEL_SIZE_BYTES_S;
			static constexpr unsigned short		INTERNAL_PIXEL_SIZE_BYTES_LS		= INTERNAL_PIXEL_SIZE_BYTES_L + INTERNAL_PIXEL_SIZE_BYTES_S;
			static constexpr unsigned short		INTERNAL_PIXEL_SIZE_BYTES_CLS		= INTERNAL_PIXEL_SIZE_BYTES_C + INTERNAL_PIXEL_SIZE_BYTES_L + INTERNAL_PIXEL_SIZE_BYTES_S;

			// Maximum number of sources that can be imported
			static constexpr unsigned short		MAX_SOURCES							= (std::numeric_limits<unsigned short>::max)();

			// Maximum number of tiles that can be defined
			static constexpr unsigned int		MAX_TILES							= (std::numeric_limits<unsigned int>::max)();

			// Maximum dimensions of a source, in pixels
			static constexpr unsigned short		MAX_SOURCE_WIDTH					= (std::numeric_limits<unsigned short>::max)();
			static constexpr unsigned short		MAX_SOURCE_HEIGHT					= (std::numeric_limits<unsigned short>::max)();

			// Size of a pixel in the result canvas, in bytes
			static constexpr unsigned short		RESULT_PIXEL_SIZE_BYTES				= INTERNAL_PIXEL_SIZE_BYTES_CLS;

			// Size of a source or result block, in bytes (256 KB, 1024 B per KB)
			static constexpr unsigned int		DATA_BLOCK_SIZE_BYTES				= 256 * 1024;

			// Dimensions of source blocks
			static constexpr unsigned short		SOURCE_BLOCK_WIDTH					= 256;
			static constexpr unsigned short		SOURCE_BLOCK_HEIGHT_C				= 256;
			static constexpr unsigned short		SOURCE_BLOCK_HEIGHT_L				= 1024;
			static constexpr unsigned short		SOURCE_BLOCK_HEIGHT_S				= 1024;
			static constexpr unsigned short		SOURCE_BLOCK_HEIGHT_CL				= 204;
			static constexpr unsigned short		SOURCE_BLOCK_HEIGHT_CS				= 204;
			static constexpr unsigned short		SOURCE_BLOCK_HEIGHT_LS				= 512;
			static constexpr unsigned short		SOURCE_BLOCK_HEIGHT_CLS				= 170;

			// Dimensions of result blocks
			static constexpr unsigned short		RESULT_BLOCK_WIDTH					= 128;
			static constexpr unsigned short		RESULT_BLOCK_HEIGHT					= RESULT_BLOCK_WIDTH;

			// Size of a result block's canvas, in pixels
			static constexpr unsigned short		RESULT_BLOCK_CANVAS_SIZE_PIXELS		= RESULT_BLOCK_WIDTH * RESULT_BLOCK_HEIGHT;

			// Size of result block's canvas, in bytes
			static constexpr unsigned int		RESULT_BLOCK_CANVAS_SIZE_BYTES		= RESULT_BLOCK_CANVAS_SIZE_PIXELS * RESULT_PIXEL_SIZE_BYTES;

			// Space in a result block not occupied by the canvas, in bytes
			static constexpr unsigned int		RESULT_BLOCK_NON_CANVAS_SIZE_BYTES	= DATA_BLOCK_SIZE_BYTES - RESULT_BLOCK_CANVAS_SIZE_BYTES;

			// Maximum number of instructions in a result block
			//   Defined in STRUCTS region right after the result instruction to allow it to be calculated with the size of the result instruction

			// Space not taken up by canvas or instruction bin in a result block
			//   Defined in STRUCTS region because it depends on the above value, which is also defined there

			// Minimum amount of space that can be left in a result block's bin before it is considered full and the result must flush instructions
			static constexpr unsigned short		RESULT_FLUSH_THRESHOLD				= 4;

#pragma endregion DEFINES
#pragma region ENUMS

			// Detected file type of a source data file
			enum class SOURCE_FILE_TYPE : int
			{
				UNSUPPORTED				= -1,	// Filetype is not natively supported by GBlitter
				UNUSED					=  0,	// File is not used in source data (This value is used during data normalization while importing sources)
				TGA						= +1,	// TGA (Targa)
			};

			// Color formats for TGA files
			/*
				Officially supported image types in TGA file format guidelines
				Values are discrete formats and have no relation to each other
			*/
			struct TGA_IMAGE_TYPE
			{
				enum
				{
					NONE							= 0,	//						no image data is included in the file
					UNCOMPRESSED_COLORMAPPED		= 1,	// [RGB_LUT]			image data is not compressed and is in either pseudo-color or direct-color
					UNCOMPRESSED_TRUECOLOR			= 2,	// [RGB / ARGB]			image data is not compressed and is in true-color
					UNCOMPRESSED_GREYSCALE			= 3,	// [L / AL]				image data is not compressed and is in greyscale true-color
					COMPRESSED_COLORMAPPED			= 9,	// [RLE_RGB_LUT]		image data is run-length encoded and is in either pseudo-color or direct-color
					COMPRESSED_TRUECOLOR			= 10,	// [RLE_RGB / RLE_ARGB]	image data is run-length encoded and is in true-color
					COMPRESSED_GREYSCALE			= 11,	// [RLE_L / RLE_AL]		image data is run-length encoded and is in greyscale true-color
				};
			};

			// Supported pixel attributes for source file data
			struct SOURCE_FILE_PIXEL_ATTRIBUTES
			{
				// Data types/attributes supported for loaded source data pixels (only some combinations of elements are supported)
				enum ELEMENT
				{
					LUMINANCE		= 0x1,
					COLOR			= 0x2,
					ALPHA			= 0x4,
					LUT				= 0x8, // Look-Up Table
					RLE				= 0x10, // Run-Length Encoding
				};
				// Supported combinations of data types for loaded source data
				enum class FORMAT : int
				{
					INVALID				= 0,

					// Greyscale | Luminance | 8bpp | 1 channel, 8b per channel
					L_8					= ELEMENT::LUMINANCE,

					// Greyscale | Alpha-Luminance | 16bpp | 2 channels, 8b per channel
					AL_16				= ELEMENT::ALPHA | ELEMENT::LUMINANCE,

					// Color | Red-Green-Blue | 24bpp | 3 channels, 8b per channel
					RGB_24				= ELEMENT::COLOR,

					// Color | Alpha-Red-Green-Blue | 32bpp | 4 channels, 8b per channel
					ARGB_32				= ELEMENT::ALPHA | ELEMENT::COLOR,

					// Color | Red-Green-Blue Look-Up Table | 8bpp | 3 channels, 8b per channel; pixels contain an 8-bit index into a table of color values
					RGB_LUT_8			= ELEMENT::COLOR | ELEMENT::LUT,

					// Greyscale | Luminance, Run-Length Encoded | 8bpp | 1 channel, 8b per channel
					L_8_RLE				= ELEMENT::LUMINANCE | ELEMENT::RLE,

					// Greyscale | Alpha-Luminance, Run-Length Encoded | 16bpp | 2 channels, 8b per channel
					AL_16_RLE			= ELEMENT::ALPHA | ELEMENT::LUMINANCE | ELEMENT::RLE,

					// Color | Red-Green-Blue, Run-Length Encoded | 24bpp | 3 channels, 8b per channel
					RGB_24_RLE			= ELEMENT::COLOR | ELEMENT::RLE,

					// Color | Alpha-Red-Green-Blue, Run-Length Encoded | 32bpp | 4 channels, 8b per channel
					ARGB_32_RLE			= ELEMENT::ALPHA | ELEMENT::COLOR | ELEMENT::RLE,

					// Color | Red-Green-Blue Look-Up Table, Run-Length Encoded | 8bpp | 3 channels, 8b per channel; pixels contain an 8-bit index into a table of color values
					RGB_LUT_8_RLE		= ELEMENT::COLOR | ELEMENT::LUT | ELEMENT::RLE,
				};
			};

			// Pixel attributes for blitter internal pixels
			struct INTERNAL_PIXEL_ATTRIBUTES
			{
				// Data types that blitter internal pixels can contain
				enum ELEMENT
				{
					COLOR				= 0x1,
					LAYER				= 0x2,
					STENCIL				= 0x4,
				};
				// Possible combinations of data types in a blitter internal pixel (sources can have any valid format; the result uses only CLS format)
				enum class FORMAT : int
				{
					INVALID					= 0,
					C						= 1,
					L						= 2,
					S						= 3,
					CL						= 4,
					CS						= 5,
					LS						= 6,
					CLS						= 7,
				};
			};
			
			// Shorthands for DrawOptions bitflag combinations indicating basic transformations
			/*
			*	Labels also indicate the angle produced by the flag combination and whether it is inverted (read: mirrored about its local y-axis)
			*
			*	R		ROTATE flag is on
			*	V		MIRROR_VERTICAL flag is on
			*	H		MIRROR_HORIZONTAL is on
			*	X		Flag is off
			*/
			struct BASIC_ORIENTATION
			{
				enum
				{
					XXX_0				= 0,
					RXX_90				= DrawOptions::ROTATE,
					XVX_180_INV			= DrawOptions::MIRROR_VERTICAL,
					RVX_90_INV			= DrawOptions::MIRROR_VERTICAL			| DrawOptions::ROTATE,
					XXH_0_INV			= DrawOptions::MIRROR_HORIZONTAL,
					RXH_270_INV			= DrawOptions::MIRROR_HORIZONTAL		| DrawOptions::ROTATE,
					XVH_180				= DrawOptions::MIRROR_HORIZONTAL		| DrawOptions::MIRROR_VERTICAL,
					RVH_270				= DrawOptions::MIRROR_HORIZONTAL		| DrawOptions::MIRROR_VERTICAL			| DrawOptions::ROTATE,
				};
			};
			
			// Shorthands for various DrawOptions bitflag combinations indicating different methods of drawing tiles
			/*
			*	MSK		USE_MASKING
			*	TSF		USE_TRANSFORMATIONS
			*	TSP		USE_TRANSPARENCY
			*	ITP		USE_BILINEAR_INTERP
			*/
			struct RESULT_INSTRUCTION_FORMAT
			{
				enum
				{
					DEFAULT				= 0,
					MSK					= DrawOptions::USE_MASKING,
					TSF					= DrawOptions::USE_TRANSFORMATIONS,
					TSF_MSK				= DrawOptions::USE_TRANSFORMATIONS		| DrawOptions::USE_MASKING,
					TSP					= DrawOptions::USE_TRANSPARENCY,
					TSP_MSK				= DrawOptions::USE_TRANSPARENCY			| DrawOptions::USE_MASKING,
					TSP_TSF				= DrawOptions::USE_TRANSPARENCY			| DrawOptions::USE_TRANSFORMATIONS,
					TSP_TSF_MSK			= DrawOptions::USE_TRANSPARENCY			| DrawOptions::USE_TRANSFORMATIONS		| DrawOptions::USE_MASKING,
				};
			};

#pragma endregion ENUMS
#pragma region STRUCTS

#pragma pack(push,1) // single-byte alignment for loading
			// TGA file header
			struct TgaHeader
			{
				Byte				id_length;
				Byte				color_map_type;
				Byte				data_type_code;
				unsigned short		color_map_origin;
				unsigned short		color_map_length;
				Byte				color_map_depth;
				unsigned short		x_origin;
				unsigned short		y_origin;
				unsigned short		width;
				unsigned short		height;
				Byte				bits_per_pixel;
				Byte				image_descriptor;
				char				image_id[255];
				Byte				color_map[3 * 256];
			};
			// TGA run-length encoding pixel data packet
			struct TgaRLEpacket
			{
				enum class RLE_PACKET_TYPE : int
				{
					RAW = 0,
					RUN_LENGTH = 1,
				};

				RLE_PACKET_TYPE		packet_type = RLE_PACKET_TYPE::RAW; // bit 7 indicates whether this packet is a run-length packet (1) or a raw packet (0)
				Byte				pixel_count = 0; // bits 6-0 indicate the pixel count of the packet (number is one less than pixel count since pixel count cannot be zero, ie 0 = 1 pixel, 127 = 128 pixels)
				Byte				pixel_data[128 * 4]; // holds up to 128 pixels (maximum possible in a TGA RLE packet) with up to 4 bytes per pixel
			};
#pragma pack(pop)


			struct Vector2
			{
				union
				{
					struct
					{
						float x;
						float y;
					};
					float data[2];
				};
			};
			struct Vector3
			{
				union
				{
					struct
					{
						float x;
						float y;
						float z;
					};
					float data[3];
				};
			};

			struct Matrix2x2
			{
				union
				{
					struct
					{
						float a;
						float b;

						float c;
						float d;
					};
					float matrix[2][2];
					Vector2 vectors[2];
					float data[4];
				};
			};
			struct Matrix3x3
			{
				union
				{
					struct
					{
						float a;
						float b;
						float c;

						float d;
						float e;
						float f;

						float g;
						float h;
						float i;
					};
					float matrix[3][3];
					Vector3 vectors[3];
					float data[9];
				};
			};

			struct Point
			{
				int x;
				int y;

				Point() { x = 0; y = 0; }
				Point(int _x, int _y) { x = _x; y = _y; }
				Point(const Point& _lhs) { if (&_lhs != this) { x = _lhs.x; y = _lhs.y; } }
				Point(Vector2 _lhs) { x = static_cast<int>(_lhs.x); y = static_cast<int>(_lhs.y); }
			};
			struct Triangle
			{
				Point a;
				Point b;
				Point c;

				Triangle() {}
				Triangle(Point _a, Point _b, Point _c) { a = _a; b = _b; c = _c; }
				Triangle(Vector2 _a, Vector2 _b, Vector2 _c) { a = _a; b = _b; c = _c; }
			};
			struct Quad
			{
				Point a;
				Point b;
				Point c;
				Point d;

				Quad() {}
				Quad(Point _a, Point _b, Point _c, Point _d) { a = _a; b = _b; c = _c; d = _d; }
				Quad(Vector2 _a, Vector2 _b, Vector2 _c, Vector2 _d) { a = _a; b = _b; c = _c; d = _d; }
			};

			// struct containing data in a normalized format to be stored in a source
			// 10 B + data
			struct SourceDataBuffer
			{
				unsigned short			dataTypes = 0;		// bitflags indicating the types of data present
				unsigned short			w = 0;				// width of source, in pixels
				unsigned short			h = 0;				// height of source, in pixels
				unsigned int			size = 0;			// size of source, in pixels
				Color*					colors = nullptr;	// pixel color data, if present
				Layer*					layers = nullptr;	// pixel layer data, if present
				Stencil*				stencils = nullptr;	// pixel stencil data, if present
			};

			// struct containing one block of data from a source
			// 256 KB (262,144 B)
			struct SourceBlock
			{
				// could contain color, layer, and/or stencil data
				struct COLOR_DATA
				{
					Color				colors[65536];
					// color = 4 B; 4 B per pixel; 256 x 256 pixels
					// 256 * 256 * 4 = 262,144 B (256 KB); 0 B (0 KB) unused
				};
				struct LAYER_DATA
				{
					Layer				layers[262144];
					// layer = 1 B; 1 B per pixel; 256 x 1024 pixels
					// 256 * 1024 * 1 = 262,144 B (256 KB); 0 B (0 KB) unused
				};
				struct STENCIL_DATA
				{
					Stencil				stencils[262144];
					// stencil = 1 B; 1 B per pixel; 256 x 1024 pixels
					// 256 * 1024 * 1 = 262,144 B (256 KB); 0 B (0 KB) unused
				};
				struct COLOR_LAYER_DATA
				{
					Color				colors[52224];
					Layer				layers[52224];
					Byte				pad[1024];
					// color = 4 B, layer = 1 B; 5 B per pixel; 256 x 204 pixels
					// 256 * 204 * 5 = 261,120 B (255 KB); 1024 B (1 KB) unused
				};
				struct COLOR_STENCIL_DATA
				{
					Color				colors[52224];
					Stencil				stencils[52224];
					Byte				pad[1024];
					// color = 4 B, stencil = 1 B; 5 B per pixel; 256 x 204 pixels
					// 256 * 204 * 5 = 261,120 B (255 KB); 1024 B (1 KB) unused
				};
				struct LAYER_STENCIL_DATA
				{
					Layer				layers[131072];
					Stencil				stencils[131072];
					// layer = 1 B, stencil = 1 B; 2 B per pixel; 256 x 512 pixels
					// 256 * 512 * 2 = 262,144 B (256 KB); 0 B (0 KB) unused
				};
				struct COLOR_LAYER_STENCIL_DATA
				{
					Color				colors[43520];
					Layer				layers[43520];
					Stencil				stencils[43520];
					// color = 4 B, layer = 1 B, stencil = 1 B; 6 B per pixel; 256 x 170 pixels
					// 256 * 170 * 6 = 261,120 B (255 KB); 1024 B (1 KB) unused
				};
				
				// all possibilities in the same memory space
				union
				{
					COLOR_DATA					c;
					LAYER_DATA					l;
					STENCIL_DATA				s;
					COLOR_LAYER_DATA			cl;
					COLOR_STENCIL_DATA			cs;
					LAYER_STENCIL_DATA			ls;
					COLOR_LAYER_STENCIL_DATA	cls;
					Byte						raw[262144];
				};
			};

			// struct containing source blocks and metadata about them
			// 18 B + data
			struct Source
			{
				INTERNAL_PIXEL_ATTRIBUTES::FORMAT	format;				// indicates the types of data contained in the source
				unsigned short						w_image;			// width of image, in pixels
				unsigned short						h_image;			// height of image, in pixels
				unsigned short						w_data;				// width of data, in source blocks
				unsigned short						h_data;				// height of data, in source blocks (dependent on pixel format)
				std::vector<SourceBlock>			data;				// source blocks containing source's pixel data
			};

			// struct containing either:
			//   (basic draw) a partial draw instruction that fits entirely within one source block and one result block
			//   (transformed draw) a tile and the inverse of the transformation applied to it
			// 88 B (86 B + padding)
			struct ResultInstruction
			{
				unsigned short			flags;				//  2 B - bitflags indicating data to use and operations to perform
				unsigned short			source_id;			//  2 B - index of source that instruction refers to
				unsigned short			source_block_id;	//  2 B - index of source block that instruction refers to
				unsigned short			x_source;			//  2 B - x coordinate of data origin in source block, in pixels
				unsigned short			y_source;			//  2 B - y coordinate of data origin in source block, in pixels
				unsigned short			w_source;			//  2 B - width of data in source, in pixels
				unsigned short			h_source;			//  2 B - height of data in source, in pixels
				unsigned short			x_result;			//  2 B - x coordinate in result block to draw to, in pixels
				unsigned short			y_result;			//  2 B - y coordinate in result block to draw to, in pixels
				unsigned short			w_result;			//  2 B - width of drawn image in result, in pixels
				unsigned short			h_result;			//  2 B - height of drawn image in result, in pixels
				Layer					layer_override;		//  1 B - layer to draw to, if not using source layer values (still used for sorting even if using source layer values[, unless SORT_PER_PIXEL flag is on (planned feature)])
				Stencil					stencil_override;	//  1 B - stencil value to apply, if not using source stencil values
				Color					mask_color;			//  4 B - color value to remove with bitmasking
				Layer					mask_layer;			//  1 B - layer value to remove with bitmasking
				Stencil					mask_stencil;		//  1 B - stencil value to remove with bitmasking
				// 30 B

				Byte					pad[2];				//  2 B - needed for 8-byte alignment

				// only used by transformed instructions
				Matrix2x2				m_inverse;			// 16 B - inverse of transform matrix
				Vector2					t_inverse;			//  8 B - inverse of translation vector
				Quad					footprint;			// 32 B - quadrilateral formed by tile after transformation
				//56 B
			};

			// Maximum number of instructions in a result block
			//   Defined here instead of in DEFINES region to allow the size of the result instruction struct to be used to automatically determine how many can fit into 256 KB
			static constexpr unsigned short INSTRUCTIONS_PER_RESULT_BLOCK = RESULT_BLOCK_NON_CANVAS_SIZE_BYTES / sizeof(ResultInstruction);

			// Space not taken up by canvas or instruction bin in a result block
			//   Defined here instead of in DEFINES region because it depends on INSTRUCTIONS_PER_RESULT_BLOCK, which is also defined here
			static constexpr unsigned short RESULT_BLOCK_REMAINING_SIZE_BYTES = RESULT_BLOCK_NON_CANVAS_SIZE_BYTES - (INSTRUCTIONS_PER_RESULT_BLOCK * sizeof(ResultInstruction));

			// struct containing one block of data from the result
			// 256 KB (262,144 B)
			struct ResultBlock
			{
				// canvas; 128 x 128 pixels
				Color							color[RESULT_BLOCK_CANVAS_SIZE_PIXELS];
				Layer							layer[RESULT_BLOCK_CANVAS_SIZE_PIXELS];
				Stencil							stencil[RESULT_BLOCK_CANVAS_SIZE_PIXELS];
				// container for result instructions
				ResultInstruction				instruction_bin[INSTRUCTIONS_PER_RESULT_BLOCK];
				// other needed variables
				unsigned short					instruction_count = 0;
				unsigned short					x_result; // x coordinate of origin in result canvas
				unsigned short					y_result; // y coordinate of origin in result canvas

				ResultBlock() {};
				ResultBlock(const ResultBlock& _lhs)
				{
					memcpy(color, _lhs.color, RESULT_BLOCK_CANVAS_SIZE_PIXELS * sizeof(Color));
					memcpy(layer, _lhs.layer, RESULT_BLOCK_CANVAS_SIZE_PIXELS * sizeof(Layer));
					memcpy(stencil, _lhs.stencil, RESULT_BLOCK_CANVAS_SIZE_PIXELS * sizeof(Stencil));
					memcpy(instruction_bin, _lhs.instruction_bin, INSTRUCTIONS_PER_RESULT_BLOCK * sizeof(ResultInstruction));
					instruction_count = _lhs.instruction_count;
					x_result = _lhs.x_result;
					y_result = _lhs.y_result;
				}
			};

			// struct containing result blocks and metadata about them
			// 14 B + data
			struct Result
			{
				unsigned short					w_image;			// width of image, in pixels
				unsigned short					h_image;			// height of image, in pixels
				unsigned int					size_image;			// size of image, in pixels
				unsigned short					w_data;				// width of data, in result blocks
				unsigned short					h_data;				// height of data, in result blocks
				unsigned short					size_data;			// size of data, in result blocks
				std::vector<ResultBlock>		data;				// result blocks containing result's data
				std::vector<GReturn>			flush_results;		// results of individual block flush operations
			};

#pragma endregion STRUCTS
#pragma region VARIABLES

			// Gateware types are named as:	gVariableName

			GW::SYSTEM::GConcurrent				m_gFlushThread;
			gtl::ld_vector<Source>				m_sources;
			gtl::ld_vector<TileDefinition>		m_tiles;
			Result								m_result;

#pragma endregion VARIABLES
#pragma region PRIVATE_GENERAL_FUNCTIONS

			// Converts pixel data type flags into a pixel format
			static inline INTERNAL_PIXEL_ATTRIBUTES::FORMAT pixelFlagsToFormat(unsigned short _dataTypes)
			{
				switch (_dataTypes)
				{
					case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR:
						return INTERNAL_PIXEL_ATTRIBUTES::FORMAT::C;
						break;
					case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER:
						return INTERNAL_PIXEL_ATTRIBUTES::FORMAT::L;
						break;
					case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL:
						return INTERNAL_PIXEL_ATTRIBUTES::FORMAT::S;
						break;
					case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR | INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER:
						return INTERNAL_PIXEL_ATTRIBUTES::FORMAT::CL;
						break;
					case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR | INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL:
						return INTERNAL_PIXEL_ATTRIBUTES::FORMAT::CS;
						break;
					case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER | INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL:
						return INTERNAL_PIXEL_ATTRIBUTES::FORMAT::LS;
						break;
					case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR | INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER | INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL:
						return INTERNAL_PIXEL_ATTRIBUTES::FORMAT::CLS;
						break;
					default:
						return INTERNAL_PIXEL_ATTRIBUTES::FORMAT::INVALID;
						break;
				}
			}
			// Converts a pixel format into pixel data type flags
			static inline unsigned short pixelFormatToFlags(INTERNAL_PIXEL_ATTRIBUTES::FORMAT _format)
			{
				unsigned short dataTypeFlags = 0;
				if (   _format == INTERNAL_PIXEL_ATTRIBUTES::FORMAT::C
					|| _format == INTERNAL_PIXEL_ATTRIBUTES::FORMAT::CL
					|| _format == INTERNAL_PIXEL_ATTRIBUTES::FORMAT::CS
					|| _format == INTERNAL_PIXEL_ATTRIBUTES::FORMAT::CLS)
					dataTypeFlags |= INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR;
				if (   _format == INTERNAL_PIXEL_ATTRIBUTES::FORMAT::L
					|| _format == INTERNAL_PIXEL_ATTRIBUTES::FORMAT::CL
					|| _format == INTERNAL_PIXEL_ATTRIBUTES::FORMAT::LS
					|| _format == INTERNAL_PIXEL_ATTRIBUTES::FORMAT::CLS)
					dataTypeFlags |= INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER;
				if (   _format == INTERNAL_PIXEL_ATTRIBUTES::FORMAT::S
					|| _format == INTERNAL_PIXEL_ATTRIBUTES::FORMAT::CS
					|| _format == INTERNAL_PIXEL_ATTRIBUTES::FORMAT::LS
					|| _format == INTERNAL_PIXEL_ATTRIBUTES::FORMAT::CLS)
					dataTypeFlags |= INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL;
				return dataTypeFlags;
			}

			// Returns the height of a source block containing the specified data types
			static inline unsigned short getSourceBlockHeight(unsigned short _dataTypes)
			{
				switch (_dataTypes)
				{
					case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR:
						return SOURCE_BLOCK_HEIGHT_C;
						break;
					case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER:
						return SOURCE_BLOCK_HEIGHT_L;
						break;
					case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL:
						return SOURCE_BLOCK_HEIGHT_S;
						break;
					case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR | INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER:
						return SOURCE_BLOCK_HEIGHT_CL;
						break;
					case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR | INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL:
						return SOURCE_BLOCK_HEIGHT_CS;
						break;
					case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER | INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL:
						return SOURCE_BLOCK_HEIGHT_LS;
						break;
					case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR | INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER | INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL:
						return SOURCE_BLOCK_HEIGHT_CLS;
						break;
					default:
						return 0;
						break;
				}
			}
			static inline unsigned short getSourceBlockHeight(INTERNAL_PIXEL_ATTRIBUTES::FORMAT _format)
			{
				switch (_format)
				{
					case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::C:
						return SOURCE_BLOCK_HEIGHT_C;
						break;
					case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::L:
						return SOURCE_BLOCK_HEIGHT_L;
						break;
					case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::S:
						return SOURCE_BLOCK_HEIGHT_S;
						break;
					case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::CL:
						return SOURCE_BLOCK_HEIGHT_CL;
						break;
					case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::CS:
						return SOURCE_BLOCK_HEIGHT_CS;
						break;
					case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::LS:
						return SOURCE_BLOCK_HEIGHT_LS;
						break;
					case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::CLS:
						return SOURCE_BLOCK_HEIGHT_CLS;
						break;
					default:
						return 0;
						break;
				}
			}

			// Returns the pixel format of a source file
			static inline SOURCE_FILE_PIXEL_ATTRIBUTES::FORMAT getSourceFilePixelFormat(SOURCE_FILE_TYPE _fileType, unsigned int _formatCode, unsigned int _bitsPerPixel)
			{
				SOURCE_FILE_PIXEL_ATTRIBUTES::FORMAT format = SOURCE_FILE_PIXEL_ATTRIBUTES::FORMAT::INVALID;
				switch (_fileType)
				{
					case (SOURCE_FILE_TYPE::TGA):
					{
						switch (_formatCode)
						{
							case TGA_IMAGE_TYPE::UNCOMPRESSED_COLORMAPPED:
							{
								switch (_bitsPerPixel)
								{
									case 8:
										format = SOURCE_FILE_PIXEL_ATTRIBUTES::FORMAT::RGB_LUT_8;
										break;
									default: break;
								} // end switch (_bitsPerPixel)
							} break; // end case TGA_IMAGE_TYPE::UNCOMPRESSED_COLORMAPPED

							case TGA_IMAGE_TYPE::UNCOMPRESSED_TRUECOLOR:
							{
								switch (_bitsPerPixel)
								{
									case 24:
										format = SOURCE_FILE_PIXEL_ATTRIBUTES::FORMAT::RGB_24;
										break;
									case 32:
										format = SOURCE_FILE_PIXEL_ATTRIBUTES::FORMAT::ARGB_32;
										break;
									default: break;
								} // end switch (_bitsPerPixel)
							} break; // end case TGA_IMAGE_TYPE::UNCOMPRESSED_TRUECOLOR

							case TGA_IMAGE_TYPE::UNCOMPRESSED_GREYSCALE:
							{
								switch (_bitsPerPixel)
								{
									case 8:
										format = SOURCE_FILE_PIXEL_ATTRIBUTES::FORMAT::L_8;
										break;
									case 16:
										format = SOURCE_FILE_PIXEL_ATTRIBUTES::FORMAT::AL_16;
										break;
									default: break;
								} // end switch (_bitsPerPixel)
							} break; // end case TGA_IMAGE_TYPE::UNCOMPRESSED_GREYSCALE

							case TGA_IMAGE_TYPE::COMPRESSED_COLORMAPPED:
							{
								switch (_bitsPerPixel)
								{
									case 8:
										format = SOURCE_FILE_PIXEL_ATTRIBUTES::FORMAT::RGB_LUT_8_RLE;
										break;
									default: break;
								} // end switch (_bitsPerPixel)
							} break; // end case TGA_IMAGE_TYPE::COMPRESSED_COLORMAPPED

							case TGA_IMAGE_TYPE::COMPRESSED_TRUECOLOR:
							{
								switch (_bitsPerPixel)
								{
									case 24:
										format = SOURCE_FILE_PIXEL_ATTRIBUTES::FORMAT::RGB_24_RLE;
										break;
									case 32:
										format = SOURCE_FILE_PIXEL_ATTRIBUTES::FORMAT::ARGB_32_RLE;
										break;
									default: break;
								} // end switch (_bitsPerPixel)
							} break; // end case TGA_IMAGE_TYPE::COMPRESSED_TRUECOLOR

							case TGA_IMAGE_TYPE::COMPRESSED_GREYSCALE:
							{
								switch (_bitsPerPixel)
								{
									case 8:
										format = SOURCE_FILE_PIXEL_ATTRIBUTES::FORMAT::L_8_RLE;
										break;
									case 16:
										format = SOURCE_FILE_PIXEL_ATTRIBUTES::FORMAT::AL_16_RLE;
										break;
									default: break;
								} // end switch (_bitsPerPixel)
							} break; // end case TGA_IMAGE_TYPE::COMPRESSED_GREYSCALE

							default: break;
						} // end switch (_formatCode)
						break;
					} break; // end case TGA

					default: break;
				} // end switch (_fileType)
				return format;
			}

#pragma endregion PRIVATE_GENERAL_FUNCTIONS
#pragma region PRIVATE_INIT_FUNCTIONS

			// Initalizes a result buffer and allocates result blocks for pixel data
			inline void initResult(unsigned short _w, unsigned short _h)
			{
				// store image dimensions
				m_result.w_image = _w;
				m_result.h_image = _h;
				m_result.size_image = _w * _h;
				// calculate data dimensions
				m_result.w_data = (m_result.w_image / RESULT_BLOCK_WIDTH) + ((m_result.w_image % RESULT_BLOCK_WIDTH) ? 1 : 0);
				m_result.h_data = (m_result.h_image / RESULT_BLOCK_HEIGHT) + ((m_result.h_image % RESULT_BLOCK_HEIGHT) ? 1 : 0);
				m_result.size_data = m_result.w_data * m_result.h_data;
				// allocate result blocks and flush results
				for (unsigned int i = 0; i < static_cast<unsigned int>(m_result.size_data); ++i)
				{
					ResultBlock block = {};
					block.x_result = (i % m_result.w_data) * RESULT_BLOCK_WIDTH;
					block.y_result = (i / m_result.w_data) * RESULT_BLOCK_HEIGHT;
					m_result.data.push_back(block);
					m_result.flush_results.push_back(GReturn::REDUNDANT);
				}
			}

			// Initializes a passed in source data buffer and allocates memory for data
			static inline void initSourceDataBuffer(SourceDataBuffer& _outSourceDataBuffer, unsigned short _w, unsigned short _h)
			{
				_outSourceDataBuffer.w = _w;
				_outSourceDataBuffer.h = _h;
				_outSourceDataBuffer.size = _w * _h;
				// initialize arrays to nullptr in case they aren't needed
				_outSourceDataBuffer.colors = nullptr;
				_outSourceDataBuffer.layers = nullptr;
				_outSourceDataBuffer.stencils = nullptr;
				// allocate arrays to store data in as needed
				if (_outSourceDataBuffer.dataTypes & INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR)
					_outSourceDataBuffer.colors = new Color[_outSourceDataBuffer.size];
				if (_outSourceDataBuffer.dataTypes & INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER)
					_outSourceDataBuffer.layers = new Layer[_outSourceDataBuffer.size];
				if (_outSourceDataBuffer.dataTypes & INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL)
					_outSourceDataBuffer.stencils = new Stencil[_outSourceDataBuffer.size];
			}
			// Resets a source data buffer's values and deallocates memory
			static inline void discardSourceDataBuffer(SourceDataBuffer& _sourceDataBuffer)
			{
				_sourceDataBuffer.dataTypes = 0;
				_sourceDataBuffer.w = 0;
				_sourceDataBuffer.h = 0;
				_sourceDataBuffer.size = 0;
				if (_sourceDataBuffer.colors)
				{
					delete[] _sourceDataBuffer.colors;
					_sourceDataBuffer.colors = nullptr;
				}
				if (_sourceDataBuffer.layers)
				{
					delete[] _sourceDataBuffer.layers;
					_sourceDataBuffer.layers = nullptr;
				}
				if (_sourceDataBuffer.stencils)
				{
					delete[] _sourceDataBuffer.stencils;
					_sourceDataBuffer.stencils = nullptr;
				}
			}

			// Extracts the extension from a filepath and returns the detected filetype
			/*
			*	retval GReturn::SUCCESS				Filetype was determined.
			*	retval GReturn::FAILURE				_filepath did not have an extension.
			*/
			static GReturn filterFileExtension(const char* _filepath, SOURCE_FILE_TYPE& _outFiletype)
			{
				// find last '.' in filepath that comes after the last slash to locate extension
				short lastPeriodIndex = -1;
				for (int c = static_cast<int>(strlen(_filepath)) - 1; c >= 0; --c)
				{
					if (_filepath[c] == '\\' || _filepath[c] == '/')
						break;
					if (_filepath[c] == '.')
					{
						lastPeriodIndex = c;
						break;
					}
				}
				// if no '.' is found or a '.' is the first character, filepath is invalid
				if (lastPeriodIndex <= 0)
					return GReturn::FAILURE;
				// otherwise, extract extension from filepath
				size_t extensionStartIndex = _filepath + lastPeriodIndex - _filepath + 1; // get index of first character in extension
				size_t extensionLength = strlen(_filepath) - extensionStartIndex + 1; // get length of extension
				char extension[260]; // allocate and clear array to store extension
				memset(extension, 0, extensionLength);
				for (size_t i = 0; i < extensionLength; ++i) // copy extension into array and convert to lowercase
					extension[i] = tolower(_filepath[i + extensionStartIndex]);
				// filter extension and store detected type (0 = contents of both strings are equal)
				if (strcmp(extension, "tga") == 0)
					_outFiletype = SOURCE_FILE_TYPE::TGA;
				else
					_outFiletype = SOURCE_FILE_TYPE::UNSUPPORTED;
				// return success
				return GReturn::SUCCESS;
			}

			// Reads pixel data out of a TGA file and stores it in a source data buffer
			/*
			*	retval GReturn::SUCCESS				Data was loaded and converted.
			*	retval GReturn::FAILURE				GFile could not be created, or file data could not be read.
			*	retval GReturn::FILE_NOT_FOUND		File could not be opened.
			*	retval GReturn::FORMAT_UNSUPPORTED	File was not in a supported TGA format.
			*	retval GReturn::INVALID_ARGUMENT	File dimensions did not match previously loaded data type(s) file dimensions.
			*/
			GReturn readSourceDataFromTGA(const char* _filepath, unsigned int _dataType, SourceDataBuffer& _outSourceDataBuffer)
			{
				GW::SYSTEM::GFile gFile;
				if (-gFile.Create())
					return GReturn::FAILURE;

				TgaHeader header = {};
				if (-gFile.OpenBinaryRead(_filepath))
					return GReturn::FILE_NOT_FOUND;
				// read data into header
				gFile.Read(reinterpret_cast<char*>(&header), 18);

				// ensure width and height are nonzero
				if (header.width < 1 || header.height < 1)
					return GReturn::FORMAT_UNSUPPORTED;
				// ensure width and height are not greater than maximum
				if (header.width > MAX_SOURCE_WIDTH || header.height > MAX_SOURCE_HEIGHT)
					return GReturn::FORMAT_UNSUPPORTED;
				// ensure pixel format is supported
				SOURCE_FILE_PIXEL_ATTRIBUTES::FORMAT pixelFormat = getSourceFilePixelFormat(SOURCE_FILE_TYPE::TGA, header.data_type_code, header.bits_per_pixel);
				if (pixelFormat == SOURCE_FILE_PIXEL_ATTRIBUTES::FORMAT::INVALID)
					return GReturn::FORMAT_UNSUPPORTED;
				// if multiple data types are used, ensure dimensions of all images are the same
				if (   (_dataType == INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER && (_outSourceDataBuffer.dataTypes & INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR)) // if reading layer data and color data was already read
					|| (_dataType == INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL && (_outSourceDataBuffer.dataTypes & (INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR | INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER)))) // or if reading stencil data and color and/or layer data was already read
					if (header.width != _outSourceDataBuffer.w || header.height != _outSourceDataBuffer.h) // if width and/or height does not match already stored dimensions, images cannot be combined into one source
						return GReturn::INVALID_ARGUMENT;

				// read trailing ID if there is one
				if (header.id_length)
					gFile.Read(reinterpret_cast<char*>(&header.image_id), header.id_length);
				// read colormap if there is one
				if (header.color_map_length)
					gFile.Read(reinterpret_cast<char*>(&header.color_map), header.color_map_length * 3); // number of colors * 1 byte per channel per color * 3 channels
				// initialize source data buffer if it hasn't been already
				if (_outSourceDataBuffer.w == 0 && _outSourceDataBuffer.h == 0)
					initSourceDataBuffer(_outSourceDataBuffer, header.width, header.height);

				// read data into intermediate data buffer (data can have different bpp values and can represent differently sized pixel data types, so it has to be processed before storage)
				unsigned int bytesPerPixel = header.bits_per_pixel / 8;
				Byte* readBuffer = new Byte[_outSourceDataBuffer.size * bytesPerPixel];
				if (-gFile.Read(reinterpret_cast<char*>(readBuffer), _outSourceDataBuffer.size * bytesPerPixel))
				{
					delete[] readBuffer;
					gFile.CloseFile();
					return GReturn::FAILURE;
				}
				// file is no longer needed
				gFile.CloseFile();

				// copy and normalize data from read buffer into source data buffer
				// necessary because processing can change the data size:
				//   greyscale color data must be expanded to ARGB, RGB layer/stencil data must be compacted to only the red channel, indexed color data must be filled in, compressed data must be decompressed, etc
				Byte* normalizeBuffer = nullptr;
				switch (_dataType)
				{
					case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR:
						normalizeBuffer = reinterpret_cast<Byte*>(_outSourceDataBuffer.colors);
						break;
					case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER:
						normalizeBuffer = reinterpret_cast<Byte*>(_outSourceDataBuffer.layers);
						break;
					case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL:
						normalizeBuffer = reinterpret_cast<Byte*>(_outSourceDataBuffer.stencils);
						break;
					default: break;
				}
				normalizeSourceData(readBuffer, normalizeBuffer, header, pixelFormat, _dataType);
				// read buffer is no longer needed
				delete[] readBuffer;

				return GReturn::SUCCESS;
			}

			// Creates a source from a source data buffer
			void createAndStoreSource(const SourceDataBuffer& _sourceDataBuffer, unsigned short& _outIndex)
			{
				Source source;
				// store pixel format
				source.format = pixelFlagsToFormat(_sourceDataBuffer.dataTypes);
				// store image dimensions
				source.w_image = _sourceDataBuffer.w;
				source.h_image = _sourceDataBuffer.h;
				// get height of blocks for source
				unsigned short src_blockheight = getSourceBlockHeight(source.format);
				// calculate data dimensions
				source.w_data = source.w_image / SOURCE_BLOCK_WIDTH + ((source.w_image % SOURCE_BLOCK_WIDTH) ? 1 : 0);
				source.h_data = source.h_image / src_blockheight + ((source.h_image % src_blockheight) ? 1 : 0);
				// allocate source blocks for source's data
				for (unsigned int b = 0; b < static_cast<unsigned int>(source.w_data * source.h_data); ++b)
				{
					SourceBlock block;
					// calculate block's coordinates on block grid
					unsigned int y_sourceBlock = b / source.w_data;
					unsigned int x_sourceBlock = b - y_sourceBlock * source.w_data;
					// calculate starting index of block's data in source buffer
					unsigned int blockStartIndex =
						(y_sourceBlock * (source.w_image * src_blockheight)) // vertical offset of block from origin
						+ ((b - (y_sourceBlock * source.w_data)) * SOURCE_BLOCK_WIDTH); // horizontal offset of block from origin
					// calculate number of rows in block
					unsigned int rows = ((y_sourceBlock + 1) * src_blockheight) > source.h_image ? source.h_image % src_blockheight : src_blockheight;
					// calculate width of rows in block
					unsigned int rowwidth = ((x_sourceBlock + 1) * SOURCE_BLOCK_WIDTH) > source.w_image ? source.w_image % SOURCE_BLOCK_WIDTH : SOURCE_BLOCK_WIDTH;
					// iterate through block's rows
					for (unsigned int y = 0; y < rows; ++y)
					{
						// calculate starting index of row's data in source buffer
						unsigned int bufferIndex = blockStartIndex + (y * source.w_image);
						// store index that row's data starts at in block
						unsigned int sourceIndex = y * SOURCE_BLOCK_WIDTH;
						// copy data into source block
						switch (source.format)
						{
							case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::C:
								memcpy(&block.c.colors[sourceIndex], &_sourceDataBuffer.colors[bufferIndex], rowwidth << 2);
								break;
							case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::L:
								memcpy(&block.l.layers[sourceIndex], &_sourceDataBuffer.layers[bufferIndex], rowwidth);
								break;
							case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::S:
								memcpy(&block.s.stencils[sourceIndex], &_sourceDataBuffer.stencils[bufferIndex], rowwidth);
								break;
							case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::CL:
								memcpy(&block.cl.colors[sourceIndex], &_sourceDataBuffer.colors[bufferIndex], rowwidth << 2);
								memcpy(&block.cl.layers[sourceIndex], &_sourceDataBuffer.layers[bufferIndex], rowwidth);
								break;
							case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::CS:
								memcpy(&block.cs.colors[sourceIndex], &_sourceDataBuffer.colors[bufferIndex], rowwidth << 2);
								memcpy(&block.cs.stencils[sourceIndex], &_sourceDataBuffer.stencils[bufferIndex], rowwidth);
								break;
							case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::LS:
								memcpy(&block.ls.layers[sourceIndex], &_sourceDataBuffer.layers[bufferIndex], rowwidth);
								memcpy(&block.ls.stencils[sourceIndex], &_sourceDataBuffer.stencils[bufferIndex], rowwidth);
								break;
							case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::CLS:
								memcpy(&block.cls.colors[sourceIndex], &_sourceDataBuffer.colors[bufferIndex], rowwidth << 2);
								memcpy(&block.cls.layers[sourceIndex], &_sourceDataBuffer.layers[bufferIndex], rowwidth);
								memcpy(&block.cls.stencils[sourceIndex], &_sourceDataBuffer.stencils[bufferIndex], rowwidth);
							default: break;
						}
					}
					source.data.push_back(block);
				}
				// store source in pool and return index to caller
				_outIndex = m_sources.push_back(source);
			}

#pragma endregion PRIVATE_INIT_FUNCTIONS
#pragma region PRIVATE_DATA_MANIPULATION_FUNCTIONS

			// Inverts the order of bytes in a value (e.g. 3210 -> 0123)
			static inline void invertByteOrder(unsigned short& _outValue)
			{
				_outValue =
					  ((_outValue & BYTE_1) >> 8)
					| ((_outValue & BYTE_0) << 8);
			}
			static inline void invertByteOrder(unsigned int& _outValue)
			{
				_outValue =
					  ((_outValue & BYTE_3) >> 24)
					| ((_outValue & BYTE_2) >> 8)
					| ((_outValue & BYTE_1) << 8)
					| ((_outValue & BYTE_0) << 24);
			}
			static inline void invertByteOrder(unsigned long long& _outValue)
			{
				_outValue =
					  ((_outValue & BYTE_7) >> 56)
					| ((_outValue & BYTE_6) >> 40)
					| ((_outValue & BYTE_5) >> 24)
					| ((_outValue & BYTE_4) >> 8)
					| ((_outValue & BYTE_3) << 8)
					| ((_outValue & BYTE_2) << 24)
					| ((_outValue & BYTE_1) << 40)
					| ((_outValue & BYTE_0) << 56);
			}
			// Changes the order of bytes in a value to the specified order (e.g. 3210 -> 2031)
			static inline void changeByteOrder(unsigned int& _outValue, unsigned short _byte3Order, unsigned short _byte2Order, unsigned short _byte1Order, unsigned short _byte0Order)
			{
				// validate args
				// ensure all orders are <= 3
				if (   _byte3Order > 3
					|| _byte2Order > 3
					|| _byte1Order > 3
					|| _byte0Order > 3)
					return;
				// ensure all orders are unique
				if (   _byte3Order == _byte0Order || _byte3Order == _byte1Order || _byte3Order == _byte2Order
					|| _byte2Order == _byte0Order || _byte2Order == _byte1Order
					|| _byte1Order == _byte0Order)
					return;
				// if args are valid, proceed
				// isolate each channel, shift them all the way to the right, then shift them left by (8 * channel order) bits
				_outValue =
					  (((_outValue & BYTE_3) >> 24)	<< (_byte3Order << 3))
					| (((_outValue & BYTE_2) >> 16)	<< (_byte2Order << 3))
					| (((_outValue & BYTE_1) >> 8)	<< (_byte1Order << 3))
					| (((_outValue & BYTE_0))		<< (_byte0Order << 3));
			}
			static inline void changeByteOrder(
				unsigned long long& _outValue,
				unsigned short _byte7Order, unsigned short _byte6Order, unsigned short _byte5Order, unsigned short _byte4Order,
				unsigned short _byte3Order, unsigned short _byte2Order, unsigned short _byte1Order, unsigned short _byte0Order)
			{
				// validate args
				// ensure all orders are <= 7
				if (   _byte7Order > 7
					|| _byte6Order > 7
					|| _byte5Order > 7
					|| _byte4Order > 7
					|| _byte3Order > 7
					|| _byte2Order > 7
					|| _byte1Order > 7
					|| _byte0Order > 7)
					return;
				// ensure all orders are unique
				if (   _byte7Order == _byte0Order || _byte7Order == _byte1Order || _byte7Order == _byte2Order || _byte7Order == _byte3Order || _byte7Order == _byte4Order || _byte7Order == _byte5Order || _byte7Order == _byte6Order
					|| _byte6Order == _byte0Order || _byte6Order == _byte1Order || _byte6Order == _byte2Order || _byte6Order == _byte3Order || _byte6Order == _byte4Order || _byte6Order == _byte5Order
					|| _byte5Order == _byte0Order || _byte5Order == _byte1Order || _byte5Order == _byte2Order || _byte5Order == _byte3Order || _byte5Order == _byte4Order
					|| _byte4Order == _byte0Order || _byte4Order == _byte1Order || _byte4Order == _byte2Order || _byte4Order == _byte3Order
					|| _byte3Order == _byte0Order || _byte3Order == _byte1Order || _byte3Order == _byte2Order
					|| _byte2Order == _byte0Order || _byte2Order == _byte1Order
					|| _byte1Order == _byte0Order)
					return;
				// if args are valid, proceed
				// isolate each channel, shift them all the way to the right, then shift them left by (8 * channel order) bits
				_outValue =
					  (((_outValue & BYTE_7) >> 56)	<< (_byte7Order << 3))
					| (((_outValue & BYTE_6) >> 48)	<< (_byte6Order << 3))
					| (((_outValue & BYTE_5) >> 40)	<< (_byte5Order << 3))
					| (((_outValue & BYTE_4) >> 32)	<< (_byte4Order << 3))
					| (((_outValue & BYTE_3) >> 24)	<< (_byte3Order << 3))
					| (((_outValue & BYTE_2) >> 16)	<< (_byte2Order << 3))
					| (((_outValue & BYTE_1) >> 8)	<< (_byte1Order << 3))
					| (((_outValue & BYTE_0))		<< (_byte0Order << 3));
			}
			// only use this version of the function if byte orders are pre-validated
			static inline void changeByteOrder_NoValidation(unsigned int& _outValue, unsigned short _byte3Order, unsigned short _byte2Order, unsigned short _byte1Order, unsigned short _byte0Order)
			{
				// isolate each channel, shift them all the way to the right, then shift them left by (8 * channel order) bits
				_outValue =
					  (((_outValue & BYTE_3) >> 24)	<< (_byte3Order << 3))
					| (((_outValue & BYTE_2) >> 16)	<< (_byte2Order << 3))
					| (((_outValue & BYTE_1) >> 8)	<< (_byte1Order << 3))
					| (((_outValue & BYTE_0))		<< (_byte0Order << 3));
			}
			static inline void changeByteOrder_NoValidation(
				unsigned long long& _outValue,
				unsigned short _byte7Order, unsigned short _byte6Order, unsigned short _byte5Order, unsigned short _byte4Order,
				unsigned short _byte3Order, unsigned short _byte2Order, unsigned short _byte1Order, unsigned short _byte0Order)
			{
				// isolate each channel, shift them all the way to the right, then shift them left by (8 * channel order) bits
				_outValue =
					  (((_outValue & BYTE_7) >> 56)	<< (_byte7Order << 3))
					| (((_outValue & BYTE_6) >> 48)	<< (_byte6Order << 3))
					| (((_outValue & BYTE_5) >> 40)	<< (_byte5Order << 3))
					| (((_outValue & BYTE_4) >> 32)	<< (_byte4Order << 3))
					| (((_outValue & BYTE_3) >> 24)	<< (_byte3Order << 3))
					| (((_outValue & BYTE_2) >> 16)	<< (_byte2Order << 3))
					| (((_outValue & BYTE_1) >> 8)	<< (_byte1Order << 3))
					| (((_outValue & BYTE_0))		<< (_byte0Order << 3));
			}

			// Inverts the order of bytes in every value in an array
			static inline void invertArrayByteOrder(unsigned short* _values, unsigned int _numValues)
			{
				for (unsigned int i = 0; i < _numValues; ++i)
					invertByteOrder(_values[i]);
			}
			static inline void invertArrayByteOrder(unsigned int* _values, unsigned int _numValues)
			{
				for (unsigned int i = 0; i < _numValues; ++i)
					invertByteOrder(_values[i]);
			}
			static inline void invertArrayByteOrder(unsigned long long* _values, unsigned int _numValues)
			{
				for (unsigned int i = 0; i < _numValues; ++i)
					invertByteOrder(_values[i]);
			}
			// Changes the order of bytes in every value in an array to the specified order
			static inline void changeArrayByteOrder(unsigned int* _values, unsigned int _numValues, unsigned short _byte3Order, unsigned short _byte2Order, unsigned short _byte1Order, unsigned short _byte0Order)
			{
				// validate args
				// ensure all orders are <= 3
				if (   _byte3Order > 3
					|| _byte2Order > 3
					|| _byte1Order > 3
					|| _byte0Order > 3)
					return;
				// ensure all orders are unique
				if (   _byte3Order == _byte0Order || _byte3Order == _byte1Order || _byte3Order == _byte2Order
					|| _byte2Order == _byte0Order || _byte2Order == _byte1Order
					|| _byte1Order == _byte0Order)
					return;
				// if args are valid, proceed
				// in the edge case that the order is 0123, the basic invert order function is faster
				if (_byte3Order == 0 && _byte2Order == 1 && _byte1Order == 2 && _byte0Order == 3)
					for (unsigned int i = 0; i < _numValues; ++i)
						invertByteOrder(_values[i]);
				// otherwise, default to brute-force change order function
				else
					for (unsigned int i = 0; i < _numValues; ++i)
						changeByteOrder_NoValidation(_values[i], _byte3Order, _byte2Order, _byte1Order, _byte0Order);
			}
			static inline void changeArrayByteOrder(
				unsigned long long* _values, unsigned int _numValues,
				unsigned short _byte7Order, unsigned short _byte6Order, unsigned short _byte5Order, unsigned short _byte4Order,
				unsigned short _byte3Order, unsigned short _byte2Order, unsigned short _byte1Order, unsigned short _byte0Order)
			{
				// validate args
				// ensure all orders are <= 7
				if (   _byte7Order > 7
					|| _byte6Order > 7
					|| _byte5Order > 7
					|| _byte4Order > 7
					|| _byte3Order > 7
					|| _byte2Order > 7
					|| _byte1Order > 7
					|| _byte0Order > 7)
					return;
				// ensure all orders are unique
				if (   _byte7Order == _byte0Order || _byte7Order == _byte1Order || _byte7Order == _byte2Order || _byte7Order == _byte3Order || _byte7Order == _byte4Order || _byte7Order == _byte5Order || _byte7Order == _byte6Order
					|| _byte6Order == _byte0Order || _byte6Order == _byte1Order || _byte6Order == _byte2Order || _byte6Order == _byte3Order || _byte6Order == _byte4Order || _byte6Order == _byte5Order
					|| _byte5Order == _byte0Order || _byte5Order == _byte1Order || _byte5Order == _byte2Order || _byte5Order == _byte3Order || _byte5Order == _byte4Order
					|| _byte4Order == _byte0Order || _byte4Order == _byte1Order || _byte4Order == _byte2Order || _byte4Order == _byte3Order
					|| _byte3Order == _byte0Order || _byte3Order == _byte1Order || _byte3Order == _byte2Order
					|| _byte2Order == _byte0Order || _byte2Order == _byte1Order
					|| _byte1Order == _byte0Order)
					return;
				// if args are valid, proceed
				// in the edge case that the order is 01234567, the basic invert order function is faster
				if (_byte7Order == 0 && _byte6Order == 1 && _byte5Order == 2 && _byte4Order == 3 && _byte3Order == 4 && _byte2Order == 5 && _byte1Order == 6 && _byte0Order == 7)
					for (unsigned int i = 0; i < _numValues; ++i)
						invertByteOrder(_values[i]);
				// otherwise, default to brute-force change order function
				else
					for (unsigned int i = 0; i < _numValues; ++i)
						changeByteOrder_NoValidation(_values[i], _byte7Order, _byte6Order, _byte5Order, _byte4Order, _byte3Order, _byte2Order, _byte1Order, _byte0Order);
			}

			// Linearly interpolates two colors by alpha channel using 0.8 fixed point arithmetic
			static inline Color fixedPointColorLerp(Color _start, Color _end)
			{
				// split colors into channels (ARGB channel order is stored in memory as BGRA due to little-endian byte order)
				ColorChannel start_bgra[4] =
				{
					ColorChannel((_start & CHANNEL_MASK_BLUE_ARGB)		),
					ColorChannel((_start & CHANNEL_MASK_GREEN_ARGB)		>> 8),
					ColorChannel((_start & CHANNEL_MASK_RED_ARGB)		>> 16),
					ColorChannel((_start & CHANNEL_MASK_ALPHA_ARGB)		>> 24)
				};
				ColorChannel end_bgra[4] =
				{
					ColorChannel((_end & CHANNEL_MASK_BLUE_ARGB)		),
					ColorChannel((_end & CHANNEL_MASK_GREEN_ARGB)		>> 8),
					ColorChannel((_end & CHANNEL_MASK_RED_ARGB)			>> 16),
					ColorChannel((_end & CHANNEL_MASK_ALPHA_ARGB)		>> 24)
				};
				// store alpha value of end color (used as ratio for blend)
				Color end_alpha = end_bgra[LITTLE_ENDIAN_BYTE_OFFSET_ALPHA_ARGB];
				// interpolate the resulting color
				ColorChannel result_bgra[4] =
				{
					ColorChannel((((end_bgra[0] - start_bgra[0]) * end_alpha) >> 8) + start_bgra[0]),
					ColorChannel((((end_bgra[1] - start_bgra[1]) * end_alpha) >> 8) + start_bgra[1]),
					ColorChannel((((end_bgra[2] - start_bgra[2]) * end_alpha) >> 8) + start_bgra[2]),
					ColorChannel((((end_bgra[3] - start_bgra[3]) * end_alpha) >> 8) + start_bgra[3])
				};
				return *(reinterpret_cast<Color*>(result_bgra));
			}

			// Applies bitmasking, then linearly interpolates between result and another color using 0.8 fixed point arithmetic
			static inline Color fixedPointColorLerp_Masked(Color _start, Color _end, Color _maskColor)
			{
				// apply bitmasking before blending (see maskedColorCopy for details on how this works)
				Color pseudoEnd = _end ^ _maskColor;
				Color mask = (-1 + (((pseudoEnd | (~pseudoEnd + 1)) >> 31) & 1));
				_end = (_start & mask) | ((pseudoEnd ^ _maskColor) & (~mask));

				return fixedPointColorLerp(_start, _end);
			}

			// Extracts data packets from an encoded RLE data buffer
			static inline std::vector<TgaRLEpacket> extractRLEpackets(const Byte* _src, unsigned int _numPixels, unsigned short _pixelSize)
			{
				std::vector<TgaRLEpacket> packetList;
				TgaRLEpacket packet;
				Byte packet_type_and_pixel_count;

				// read packets
				for (; _numPixels;)
				{
					packet_type_and_pixel_count = *_src++; // first byte indicates both type of packet and number of pixels in packet
					packet.packet_type = packet_type_and_pixel_count & 0b10000000 ? TgaRLEpacket::RLE_PACKET_TYPE::RUN_LENGTH : TgaRLEpacket::RLE_PACKET_TYPE::RAW; // bit 7 indicates type; if bit is on, packet is a run-length packet; otherwise, packet is a raw packet
					packet.pixel_count = (packet_type_and_pixel_count & 0b01111111) + 1; // the rest of the bits in the byte are the pixel count; +1 because packet pixel count is one less than number of pixels in order to maximize the range of the bits (ie, 0 = 1 pixel, 127 = 128 pixels)

					// read color values
					// run-length packet has only one color value
					if (packet.packet_type == TgaRLEpacket::RLE_PACKET_TYPE::RUN_LENGTH)
					{
						memcpy(&packet.pixel_data[0], _src, _pixelSize);
						_src += _pixelSize;
					}
					// raw packet has a list of color values
					else
					{
						memcpy(&packet.pixel_data[0], _src, packet.pixel_count * _pixelSize);
						_src += packet.pixel_count * _pixelSize;
					}
					packetList.push_back(packet);
					_numPixels -= packet.pixel_count;
				}

				return packetList;
			}

			// Converts raw data from a source file into normalized data ready to be converted into a source
			static inline void normalizeSourceData(const Byte* _src, Byte* _dst, TgaHeader _header, SOURCE_FILE_PIXEL_ATTRIBUTES::FORMAT _pixelFormat, unsigned int _dataType)
			{
				Byte* processBuffer = _dst;
				unsigned int numPixels = _header.width * _header.height;

				// color values are stored in little endian byte order, ie ARGB is stored as BGRA, RGBA as ABGR, AL as LA, etc
				//   (this means that channel orders here look backward, but aren't)
				switch (_pixelFormat)
				{
					case SOURCE_FILE_PIXEL_ATTRIBUTES::FORMAT::L_8:
					{
						switch (_dataType)
						{
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR: // 1 byte in -> 4 bytes out
								// duplicate luminance into color channels and set alpha to max
								for (; numPixels; --numPixels)
								{
									*_dst++ = *_src;				// luminance -> blue
									*_dst++ = *_src;				// luminance -> green
									*_dst++ = *_src++;				// luminance -> red
									*_dst++ = COLOR_CHANNEL_MAX;	// alpha
								}
								break;
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER: // 1 byte in -> 1 byte out
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL: // fallthrough is intentional, because the same processing needs to happen in both cases
								// copy data directly, since it is already in the correct format
								memcpy(_dst, _src, numPixels);
								break;
							default: break;
						} // end switch (_dataType)
					} break; // end case COLOR_FORMAT::L_8

					case SOURCE_FILE_PIXEL_ATTRIBUTES::FORMAT::AL_16:
					{
						switch (_dataType)
						{
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR: // 2 bytes in -> 4 bytes out
								// duplicate luminance into color channels and copy alpha
								for (; numPixels; --numPixels)
								{
									*_dst++ = *_src;	// luminance -> blue
									*_dst++ = *_src;	// luminance -> green
									*_dst++ = *_src++;	// luminance -> red
									*_dst++ = *_src++;	// alpha -> alpha
								}
								break;
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER: // 2 bytes in -> 1 byte out
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL: // fallthrough is intentional, because the same processing needs to happen in both cases
								// take only luminance channel
								_src += LITTLE_ENDIAN_BYTE_OFFSET_LUMINANCE_AL; // start at first pixel's luminance channel
								for (; numPixels; --numPixels)
								{
									*_dst++ = *_src;
									_src += SOURCE_FILE_PIXEL_SIZE_BYTES_AL_16; // advance to the next pixel's luminance channel
								}
								break;
							default: break;
						} // end switch (_dataType)
					} break; // end case COLOR_FORMAT::AL_16

					case SOURCE_FILE_PIXEL_ATTRIBUTES::FORMAT::RGB_24:
					{
						switch (_dataType)
						{
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR: // 3 bytes in -> 4 bytes out
								// set alpha to maximum and copy color channels
								for (; numPixels; --numPixels)
								{
									*_dst++ = *_src++;				// blue -> blue
									*_dst++ = *_src++;				// green -> green
									*_dst++ = *_src++;				// red -> red
									*_dst++ = COLOR_CHANNEL_MAX;	// alpha
								}
								break;
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER: // 3 bytes in -> 1 byte out
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL: // fallthrough is intentional, because the same processing needs to happen in both cases
								// take only red channel
								_src += LITTLE_ENDIAN_BYTE_OFFSET_RED_RGB; // start at first pixel's red channel
								for (; numPixels; --numPixels)
								{
									*_dst++ = *_src;
									_src += SOURCE_FILE_PIXEL_SIZE_BYTES_RGB_24; // advance to the next pixel's red channel
								}
								break;
							default: break;
						} // end switch (_dataType)
					} break; // end case COLOR_FORMAT::RGB_24

					case SOURCE_FILE_PIXEL_ATTRIBUTES::FORMAT::ARGB_32:
					{
						switch (_dataType)
						{
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR: // 4 bytes in -> 4 bytes out
								// copy data directly, since it is already in the correct format
								memcpy(_dst, _src, numPixels << 2);
								break;
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER: // 4 bytes in -> 1 byte out
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL: // fallthrough is intentional, because the same processing needs to happen in both cases
								// take only red channel
								_src += LITTLE_ENDIAN_BYTE_OFFSET_RED_ARGB; // skip to first pixel's red channel
								for (; numPixels; --numPixels)
								{
									*_dst++ = *_src;
									_src += SOURCE_FILE_PIXEL_SIZE_BYTES_ARGB_32; // advance to the next pixel's red channel
								}
								break;
							default: break;
						} // end switch (_dataType)
					} break; // end case COLOR_FORMAT::ARGB_32

					case SOURCE_FILE_PIXEL_ATTRIBUTES::FORMAT::RGB_LUT_8:
					{
						switch (_dataType)
						{
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR: // 1 byte in -> 4 bytes out
								for (; numPixels; --numPixels)
								{
									// get color value from LUT and set alpha to max
									// index in color map = color map origin + pixel value
									// start of color in color map = index * size of color values in color map
									// start of color channel in color map = start of color + byte offset of channel
									*_dst++ = _header.color_map[((_header.color_map_origin + *_src)		* SOURCE_FILE_PIXEL_SIZE_BYTES_RGB_24) + LITTLE_ENDIAN_BYTE_OFFSET_BLUE_RGB];	// blue -> blue
									*_dst++ = _header.color_map[((_header.color_map_origin + *_src)		* SOURCE_FILE_PIXEL_SIZE_BYTES_RGB_24) + LITTLE_ENDIAN_BYTE_OFFSET_GREEN_RGB];	// green -> green
									*_dst++ = _header.color_map[((_header.color_map_origin + *_src++)	* SOURCE_FILE_PIXEL_SIZE_BYTES_RGB_24) + LITTLE_ENDIAN_BYTE_OFFSET_RED_RGB];	// red -> red
									*_dst++ = COLOR_CHANNEL_MAX;																														// alpha
								}
								break;
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER: // 1 byte in -> 1 byte out
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL: // fallthrough is intentional, because the same processing needs to happen in both cases
								// take only red channel
								for (; numPixels; --numPixels)
									// get color value from LUT
									*_dst++ = _header.color_map[((_header.color_map_origin + *_src++) * SOURCE_FILE_PIXEL_SIZE_BYTES_RGB_24) + LITTLE_ENDIAN_BYTE_OFFSET_RED_RGB];
								break;
							default: break;
						} // end switch (_dataType)
					} break; // end case COLOR_FORMAT::RGB_LUT_8

					case SOURCE_FILE_PIXEL_ATTRIBUTES::FORMAT::L_8_RLE:
					{
						// extract packets from source buffer
						std::vector<TgaRLEpacket> packetList = extractRLEpackets(_src, numPixels, SOURCE_FILE_PIXEL_SIZE_BYTES_L_8);

						// decode packets into destination buffer
						switch (_dataType)
						{
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR: // 1 byte in -> 4 bytes out
								for (unsigned int i = 0; i < packetList.size(); ++i)
								{
									TgaRLEpacket packet = packetList[i];
									// for run-length packets, copy single color value from packet into destination buffer
									if (packet.packet_type == TgaRLEpacket::RLE_PACKET_TYPE::RUN_LENGTH)
									{
										for (; packet.pixel_count; --packet.pixel_count)
										{
											*_dst++ = packet.pixel_data[LITTLE_ENDIAN_BYTE_OFFSET_LUMINANCE_L];		// luminance -> blue
											*_dst++ = packet.pixel_data[LITTLE_ENDIAN_BYTE_OFFSET_LUMINANCE_L];		// luminance -> green
											*_dst++ = packet.pixel_data[LITTLE_ENDIAN_BYTE_OFFSET_LUMINANCE_L];		// luminance -> red
											*_dst++ = COLOR_CHANNEL_MAX;											// alpha
										}
									}
									// for raw packets, copy list of color values from packet into destination buffer
									else
									{
										Byte* pixelData = packet.pixel_data;
										for (; packet.pixel_count; --packet.pixel_count)
										{
											*_dst++ = *pixelData;			// luminance -> blue
											*_dst++ = *pixelData;			// luminance -> green
											*_dst++ = *pixelData++;			// luminance -> red
											*_dst++ = COLOR_CHANNEL_MAX;	// alpha
										}
									}
								}
								break;
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER: // 1 byte in -> 1 byte out
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL: // fallthrough is intentional, because the same processing needs to happen in both cases
								for (unsigned int i = 0; i < packetList.size(); ++i)
								{
									TgaRLEpacket packet = packetList[i];
									// for run-length packets, copy luminance channel of single color value from packet into destination buffer
									if (packet.packet_type == TgaRLEpacket::RLE_PACKET_TYPE::RUN_LENGTH)
									{
										for (; packet.pixel_count; --packet.pixel_count)
											*_dst++ = packet.pixel_data[LITTLE_ENDIAN_BYTE_OFFSET_LUMINANCE_L];
									}
									// for raw packets, copy luminance channels of list of color values from packet into destination buffer
									else
									{
										Byte* pixelData = packet.pixel_data;
										for (; packet.pixel_count; --packet.pixel_count)
											*_dst++ = *pixelData++;
									}
								}
								break;
							default: break;
						}
					} break; // end case COLOR_FORMAT::L_8_RLE

					case SOURCE_FILE_PIXEL_ATTRIBUTES::FORMAT::AL_16_RLE:
					{
						// extract packets from source buffer
						std::vector<TgaRLEpacket> packetList = extractRLEpackets(_src, numPixels, SOURCE_FILE_PIXEL_SIZE_BYTES_AL_16);

						// decode packets into destination buffer
						switch (_dataType)
						{
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR: // 2 bytes in -> 4 bytes out
								for (unsigned int i = 0; i < packetList.size(); ++i)
								{
									TgaRLEpacket packet = packetList[i];
									// for run-length packets, copy single color value from packet into destination buffer
									if (packet.packet_type == TgaRLEpacket::RLE_PACKET_TYPE::RUN_LENGTH)
									{
										for (; packet.pixel_count; --packet.pixel_count)
										{
											*_dst++ = packet.pixel_data[LITTLE_ENDIAN_BYTE_OFFSET_LUMINANCE_AL];	// luminance -> blue
											*_dst++ = packet.pixel_data[LITTLE_ENDIAN_BYTE_OFFSET_LUMINANCE_AL];	// luminance -> green
											*_dst++ = packet.pixel_data[LITTLE_ENDIAN_BYTE_OFFSET_LUMINANCE_AL];	// luminance -> red
											*_dst++ = packet.pixel_data[LITTLE_ENDIAN_BYTE_OFFSET_ALPHA_AL];		// alpha -> alpha
										}
									}
									// for raw packets, copy list of color values from packet into destination buffer
									else
									{
										Byte* pixelData = packet.pixel_data;
										for (; packet.pixel_count; --packet.pixel_count)
										{
											*_dst++ = *pixelData;		// luminance -> blue
											*_dst++ = *pixelData;		// luminance -> green
											*_dst++ = *pixelData++;		// luminance -> red
											*_dst++ = *pixelData++;		// alpha -> alpha
										}
									}
								}
								break;
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER: // 2 bytes in -> 1 byte out
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL: // fallthrough is intentional, because the same processing needs to happen in both cases
								for (unsigned int i = 0; i < packetList.size(); ++i)
								{
									TgaRLEpacket packet = packetList[i];
									// for run-length packets, copy luminance channel of single color value from packet into destination buffer
									if (packet.packet_type == TgaRLEpacket::RLE_PACKET_TYPE::RUN_LENGTH)
									{
										for (; packet.pixel_count; --packet.pixel_count)
											*_dst++ = packet.pixel_data[LITTLE_ENDIAN_BYTE_OFFSET_LUMINANCE_AL];
									}
									// for raw packets, copy luminance channels of list of color values from packet into destination buffer
									else
									{
										Byte* pixelData = packet.pixel_data + LITTLE_ENDIAN_BYTE_OFFSET_LUMINANCE_AL; // start at first pixel's luminance channel
										for (; packet.pixel_count; --packet.pixel_count)
										{
											*_dst++ = *pixelData;
											pixelData += SOURCE_FILE_PIXEL_SIZE_BYTES_AL_16; // advance to the next pixel's luminance channel
										}
									}
								}
								break;
							default: break;
						} // end switch (_dataType)
					} break; // end case COLOR_FORMAT::AL_16_RLE

					case SOURCE_FILE_PIXEL_ATTRIBUTES::FORMAT::RGB_24_RLE:
					{
						// extract packets from source buffer
						std::vector<TgaRLEpacket> packetList = extractRLEpackets(_src, numPixels, SOURCE_FILE_PIXEL_SIZE_BYTES_RGB_24);

						// decode packets into destination buffer
						switch (_dataType)
						{
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR: // 3 bytes in -> 4 bytes out
								for (unsigned int i = 0; i < packetList.size(); ++i)
								{
									TgaRLEpacket packet = packetList[i];
									// for run-length packets, copy single color value from packet into destination buffer
									if (packet.packet_type == TgaRLEpacket::RLE_PACKET_TYPE::RUN_LENGTH)
									{
										for (; packet.pixel_count; --packet.pixel_count)
										{
											*_dst++ = packet.pixel_data[0];		// blue -> blue
											*_dst++ = packet.pixel_data[1];		// green -> green
											*_dst++ = packet.pixel_data[2];		// red -> red
											*_dst++ = COLOR_CHANNEL_MAX;		// alpha
										}
									}
									// for raw packets, copy list of color values from packet into destination buffer
									else
									{
										Byte* pixelData = packet.pixel_data;
										for (; packet.pixel_count; --packet.pixel_count)
										{
											*_dst++ = *pixelData++;			// blue -> blue
											*_dst++ = *pixelData++;			// green -> green
											*_dst++ = *pixelData++;			// red -> red
											*_dst++ = COLOR_CHANNEL_MAX;	// alpha
										}
									}
								}
								break;
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER: // 3 bytes in -> 1 byte out
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL: // fallthrough is intentional, because the same processing needs to happen in both cases
								// keep only red channel
								for (unsigned int i = 0; i < packetList.size(); ++i)
								{
									TgaRLEpacket packet = packetList[i];
									// for run-length packets, copy red channel of single color value from packet into destination buffer
									if (packet.packet_type == TgaRLEpacket::RLE_PACKET_TYPE::RUN_LENGTH)
									{
										for (; packet.pixel_count; --packet.pixel_count)
											*_dst++ = packet.pixel_data[LITTLE_ENDIAN_BYTE_OFFSET_RED_RGB]; // offset to get red channel
									}
									// for raw packets, copy red channels of list of color values from packet into destination buffer
									else
									{
										Byte* pixelData = packet.pixel_data + LITTLE_ENDIAN_BYTE_OFFSET_RED_RGB; // offset to get red channel
										for (; packet.pixel_count; --packet.pixel_count)
										{
											*_dst++ = *pixelData;
											pixelData += SOURCE_FILE_PIXEL_SIZE_BYTES_RGB_24; // advance to the next pixel's red channel
										}
									}
								}
								break;
							default: break;
						} // end switch (_dataType)
					} break; // end case COLOR_FORMAT::RGB_24_RLE

					case SOURCE_FILE_PIXEL_ATTRIBUTES::FORMAT::ARGB_32_RLE:
					{
						// extract packets from source buffer
						std::vector<TgaRLEpacket> packetList = extractRLEpackets(_src, numPixels, SOURCE_FILE_PIXEL_SIZE_BYTES_ARGB_32);

						// decode packets into destination buffer
						switch (_dataType)
						{
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR: // 4 bytes in -> 4 bytes out
								for (unsigned int i = 0; i < packetList.size(); ++i)
								{
									TgaRLEpacket packet = packetList[i];
									// for run-length packets, copy single color value from packet into destination buffer
									if (packet.packet_type == TgaRLEpacket::RLE_PACKET_TYPE::RUN_LENGTH)
									{
										for (; packet.pixel_count; --packet.pixel_count)
										{
											*_dst++ = packet.pixel_data[LITTLE_ENDIAN_BYTE_OFFSET_BLUE_ARGB];	// blue -> blue
											*_dst++ = packet.pixel_data[LITTLE_ENDIAN_BYTE_OFFSET_GREEN_ARGB];	// green -> green
											*_dst++ = packet.pixel_data[LITTLE_ENDIAN_BYTE_OFFSET_RED_ARGB];	// red -> red
											*_dst++ = packet.pixel_data[LITTLE_ENDIAN_BYTE_OFFSET_ALPHA_ARGB];	// alpha -> alpha
										}
									}
									// for raw packets, copy list of color values from packet into destination buffer
									else
									{
										Byte* pixelData = packet.pixel_data;
										for (; packet.pixel_count; --packet.pixel_count)
										{
											*_dst++ = *pixelData++; // blue -> blue
											*_dst++ = *pixelData++; // green -> green
											*_dst++ = *pixelData++; // red -> red
											*_dst++ = *pixelData++; // alpha -> alpha
										}
									}
								}
								break;
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER: // 4 bytes in -> 1 byte out
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL: // fallthrough is intentional, because the same processing needs to happen in both cases
								// keep only red channel
								for (unsigned int i = 0; i < packetList.size(); ++i)
								{
									TgaRLEpacket packet = packetList[i];
									// for run-length packets, copy red channel of single color value from packet into destination buffer
									if (packet.packet_type == TgaRLEpacket::RLE_PACKET_TYPE::RUN_LENGTH)
									{
										for (; packet.pixel_count; --packet.pixel_count)
											*_dst++ = packet.pixel_data[LITTLE_ENDIAN_BYTE_OFFSET_RED_ARGB]; // offset to get red channel
									}
									// for raw packets, copy red channels of list of color values from packet into destination buffer
									else
									{
										Byte* pixelData = packet.pixel_data + LITTLE_ENDIAN_BYTE_OFFSET_RED_ARGB; // start at first pixel's red channel
										for (; packet.pixel_count; --packet.pixel_count)
										{
											*_dst++ = *pixelData;
											pixelData += SOURCE_FILE_PIXEL_SIZE_BYTES_ARGB_32; // advance to the next pixel's red channel
										}
									}
								}
								break;
							default: break;
						} // end switch (_dataType)
					} break; // end case COLOR_FORMAT::ARGB_32_RLE

					case SOURCE_FILE_PIXEL_ATTRIBUTES::FORMAT::RGB_LUT_8_RLE:
					{
						// extract packets from source buffer
						std::vector<TgaRLEpacket> packetList = extractRLEpackets(_src, numPixels, SOURCE_FILE_PIXEL_SIZE_BYTES_LUT_8);

						// decode packets into destination buffer
						switch (_dataType)
						{
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR: // 1 byte in -> 4 bytes out
								for (unsigned int i = 0; i < packetList.size(); ++i)
								{
									TgaRLEpacket packet = packetList[i];
									// for run-length packets, copy single color value from packet into destination buffer
									if (packet.packet_type == TgaRLEpacket::RLE_PACKET_TYPE::RUN_LENGTH)
									{
										for (; packet.pixel_count; --packet.pixel_count)
										{
											// get color value from LUT
											// index in color map = color map origin + pixel value
											// start of color in color map = index * size of color values in color map
											// start of color channel in color map = start of color + byte offset of channel
											*_dst++ = _header.color_map[((_header.color_map_origin + packet.pixel_data[0]) * SOURCE_FILE_PIXEL_SIZE_BYTES_RGB_24) + LITTLE_ENDIAN_BYTE_OFFSET_BLUE_RGB];	// blue -> blue
											*_dst++ = _header.color_map[((_header.color_map_origin + packet.pixel_data[0]) * SOURCE_FILE_PIXEL_SIZE_BYTES_RGB_24) + LITTLE_ENDIAN_BYTE_OFFSET_GREEN_RGB];	// green -> green
											*_dst++ = _header.color_map[((_header.color_map_origin + packet.pixel_data[0]) * SOURCE_FILE_PIXEL_SIZE_BYTES_RGB_24) + LITTLE_ENDIAN_BYTE_OFFSET_RED_RGB];		// red -> red
											*_dst++ = COLOR_CHANNEL_MAX;																																	// alpha
										}
									}
									// for raw packets, copy list of color values from packet into destination buffer
									else
									{
										Byte* pixelData = packet.pixel_data;
										for (; packet.pixel_count; --packet.pixel_count)
										{
											*_dst++ = _header.color_map[((_header.color_map_origin + *pixelData)	* SOURCE_FILE_PIXEL_SIZE_BYTES_RGB_24) + LITTLE_ENDIAN_BYTE_OFFSET_BLUE_RGB];		// blue -> blue
											*_dst++ = _header.color_map[((_header.color_map_origin + *pixelData)	* SOURCE_FILE_PIXEL_SIZE_BYTES_RGB_24) + LITTLE_ENDIAN_BYTE_OFFSET_GREEN_RGB];		// green -> green
											*_dst++ = _header.color_map[((_header.color_map_origin + *pixelData++)	* SOURCE_FILE_PIXEL_SIZE_BYTES_RGB_24) + LITTLE_ENDIAN_BYTE_OFFSET_RED_RGB];		// red -> red
											*_dst++ = COLOR_CHANNEL_MAX;																																// alpha
										}
									}
								}
								break;
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER: // 1 byte in -> 1 byte out
							case INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL: // fallthrough is intentional, because the same processing needs to happen in both cases
								// keep only red channel
								for (unsigned int i = 0; i < packetList.size(); ++i)
								{
									TgaRLEpacket packet = packetList[i];
									// for run-length packets, copy red channel of single color value from packet into destination buffer
									if (packet.packet_type == TgaRLEpacket::RLE_PACKET_TYPE::RUN_LENGTH)
									{
										for (; packet.pixel_count; --packet.pixel_count)
											// get red channel of color value from LUT
											*_dst++ = _header.color_map[((_header.color_map_origin + packet.pixel_data[0]) * SOURCE_FILE_PIXEL_SIZE_BYTES_RGB_24) + LITTLE_ENDIAN_BYTE_OFFSET_RED_RGB]; // offset to get red channel
									}
									// for raw packets, copy red channels of list of color values from packet into destination buffer
									else
									{
										Byte* pixelData = packet.pixel_data;
										for (; packet.pixel_count; --packet.pixel_count)
											// get red channel of color value from LUT
											*_dst++ = _header.color_map[((_header.color_map_origin + *pixelData++) * SOURCE_FILE_PIXEL_SIZE_BYTES_RGB_24) + LITTLE_ENDIAN_BYTE_OFFSET_RED_RGB]; // offset to get red channel
									}
								}
								break;
							default: break;
						} // end switch (_dataType)
					} break; // end case COLOR_FORMAT::RGB_LUT_8_RLE

					default: break;
				} // end switch (_pixelFormat)
				
				// flip horizontally and/or vertically if needed
				/*
					Image descriptor is a single-byte value representing alpha channel depth in bits 3-0 and image orientation in bits 5-4.
					Bits are numbered like so: (most significant bit) 7 6 5 4 3 2 1 0 (least significant bit)
					If bit 5 of image descriptor is 1, rows are arranged top to bottom; Otherwise, rows are arranged bottom to top. (i.e. if bit 5 is 0, image must be flipped vertically)
					If bit 4 of image descriptor is 1, colors within rows are arranged right to left; Otherwise, colors are arranged left to right. (i.e. if bit 4 is 1, image must be flipped horizontally)
				*/
				if (!(_header.image_descriptor & TGA_VERTICAL_ORIGIN_TOP) && (_header.image_descriptor & TGA_HORIZONTAL_ORIGIN_RIGHT))
					flipDataArrayDiagonal(processBuffer, _dataType, _header.width, _header.height);
				else if (!(_header.image_descriptor & TGA_VERTICAL_ORIGIN_TOP))
					flipDataArrayVertical(processBuffer, _dataType, _header.width, _header.height);
				else if (_header.image_descriptor & TGA_HORIZONTAL_ORIGIN_RIGHT)
					flipDataArrayHorizontal(processBuffer, _dataType, _header.width, _header.height);
			}

			// Flips an array of pixel data horizontally and/or vertically
			static inline void flipDataArrayHorizontal(Byte* _data, unsigned int _dataType, unsigned int _w, unsigned int _h)
			{
				// color data
				if (_dataType == INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR)
				{
					Color temp_color;
					Color* data = reinterpret_cast<Color*>(_data);
					for (unsigned int y = 0; y < _h; ++y)
						for (unsigned int x = 0; x < _w >> 1; ++x)
						{
							// swap values across center of row
							temp_color = data[x + (y * _w) * 4];
							data[x + (y * _w) * 4] = data[_w - 1 - x + (y * _w) * 4];
							data[_w - 1 - x + (y * _w) * 4] = temp_color;
						}
				}
				// layer/stencil data
				else
				{
					Byte temp_value;
					for (unsigned int y = 0; y < _h; ++y)
						for (unsigned int x = 0; x < _w >> 1; ++x)
						{
							// swap values across center of row
							temp_value = _data[x + (y * _w)];
							_data[x + (y * _w)] = _data[_w - 1 - x + (y * _w)];
							_data[_w - 1 - x + (y * _w)] = temp_value;
						}
				}
			}
			static inline void flipDataArrayVertical(Byte* _data, unsigned int _dataType, unsigned int _w, unsigned int _h)
			{
				// color data
				if (_dataType == INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR)
				{
					Color temp_row[MAX_SOURCE_WIDTH];
					Color* data = reinterpret_cast<Color*>(_data);
					for (unsigned int y = 0; y < _h >> 1; ++y)
					{
						// swap rows across center of array
						memcpy(&temp_row[0], &data[y * _w], _w << 2);
						memcpy(&data[y * _w], &data[(_h - 1 - y) * _w], _w << 2);
						memcpy(&data[(_h - 1 - y) * _w], &temp_row[0], _w << 2);
					}
				}
				// layer/stencil data
				else
				{
					Byte temp_row[MAX_SOURCE_WIDTH];
					for (unsigned int y = 0; y < _h >> 1; ++y)
					{
						// swap rows across center of array
						memcpy(&temp_row[0], &_data[y * _w], _w);
						memcpy(&_data[y * _w], &_data[(_h - 1 - y) * _w], _w);
						memcpy(&_data[(_h - 1 - y) * _w], &temp_row[0], _w);
					}
				}
			}
			static inline void flipDataArrayDiagonal(Byte* _data, unsigned int _dataType, unsigned int _w, unsigned int _h)
			{
				// color data
				if (_dataType == INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR)
				{
					Color temp_color;
					Color temp_row[MAX_SOURCE_WIDTH];
					Color* data = reinterpret_cast<Color*>(_data);
					for (unsigned int y = 0; y < _h >> 1; ++y)
					{
						for (unsigned int x = 0; x < _w >> 1; ++x)
						{
							// swap values across center of rows
							// row in top half
							temp_color = data[x + (y * _w)];
							data[x + (y * _w)] = data[_w - 1 - x + (y * _w)];
							data[_w - 1 - x + (y * _w)] = temp_color;
							// counterpart row in bottom half
							temp_color = data[x + ((_h - y) * _w)];
							data[x + ((_h - y) * _w)] = data[_w - 1 - x + ((_h - 1 - y) * _w)];
							data[_w - 1 - x + ((_h - 1 - y) * _w)] = temp_color;
						}
						// swap rows across center of array
						memcpy(&temp_row[0], &_data[y * _w * 4], _w << 2);
						memcpy(&_data[y * _w * 4], &_data[(_h - 1 - y) * _w * 4], _w << 2);
						memcpy(&_data[(_h - 1 - y) * _w * 4], &temp_row[0], _w << 2);
					}
				}
				// layer/stencil data
				else
				{
					Byte temp_value;
					Byte temp_row[MAX_SOURCE_WIDTH];
					for (unsigned int y = 0; y < _h >> 1; ++y)
					{
						for (unsigned int x = 0; x < _w >> 1; ++x)
						{
							// swap values across center of rows
							// row in top half
							temp_value = _data[x + (y * _w)];
							_data[x + (y * _w)] = _data[_w - 1 - x + (y * _w)];
							_data[_w - 1 - x + (y * _w)] = temp_value;
							// counterpart row in bottom half
							temp_value = _data[x + ((_h - y) * _w)];
							_data[x + ((_h - y) * _w)] = _data[_w - 1 - x + ((_h - 1 - y) * _w)];
							_data[_w - 1 - x + ((_h - 1 - y) * _w)] = temp_value;
						}
						// swap rows across center of array
						memcpy(&temp_row[0], &_data[y * _w], _w);
						memcpy(&_data[y * _w], &_data[(_h - 1 - y) * _w], _w);
						memcpy(&_data[(_h - 1 - y) * _w], &temp_row[0], _w);
					}
				}
			}

			// Copies data directly, in reverse order
			static inline void directColorCopyReverse(Color* _dst, const Color* _src, unsigned int _numPixels)
			{
				_src = _src + _numPixels - 1;
				for (; _numPixels; --_numPixels)
					*_dst++ = *_src--;
			}
			static inline void directMetadataCopyReverse(Byte* _dst, const Byte* _src, unsigned int _numPixels)
			{
				_src = _src + _numPixels - 1;
				for (; _numPixels; --_numPixels)
					*_dst++ = *_src--;
			}
			// Copies data directly, rotated 90*
			static inline void directColorCopyRotated(Color* _dst, const Color* _src, unsigned int _numPixels)
			{
				_src = _src + (_numPixels - 1) * SOURCE_BLOCK_WIDTH;
				for (; _numPixels; --_numPixels)
				{
					*_dst++ = *_src;
					_src -= SOURCE_BLOCK_WIDTH;
				}
			}
			static inline void directMetadataCopyRotated(Byte* _dst, const Byte* _src, unsigned int _numPixels)
			{
				_src = _src + (_numPixels - 1) * SOURCE_BLOCK_WIDTH;
				for (; _numPixels; --_numPixels)
				{
					*_dst++ = *_src;
					_src -= SOURCE_BLOCK_WIDTH;
				}
			}
			// Copies data directly, in reverse order and rotated 90*
			static inline void directColorCopyReverseRotated(Color* _dst, const Color* _src, unsigned int _numPixels)
			{
				for (; _numPixels; --_numPixels)
				{
					*_dst++ = *_src;
					_src += SOURCE_BLOCK_WIDTH;
				}
			}
			static inline void directMetadataCopyReverseRotated(Byte* _dst, const Byte* _src, unsigned int _numPixels)
			{
				for (; _numPixels; --_numPixels)
				{
					*_dst++ = *_src;
					_src += SOURCE_BLOCK_WIDTH;
				}
			}

			// Copies data using XOR transfer
			//   All of these functions are based on a function written by Lari Norri; See comments in maskedColorCopy for details on how they work
			static inline void maskedColorCopy(Color* _dst, const Color* _src, unsigned int _numPixels, Color _maskColor)
			{
				// store source and destination as uint64 pointers in order to operate on two pixels in one operation
				unsigned long long* write = reinterpret_cast<unsigned long long*>(_dst);
				const unsigned long long* read = reinterpret_cast<const unsigned long long*>(_src);

				// struct contaning two pixels' masks in one value
				union Mask
				{
					unsigned int partial[2];
					unsigned long long full;
				};
				Mask maskColors = {{ _maskColor, _maskColor }};

				// copy data, two pixels at a time
				for (; (_numPixels >> 1); _numPixels -= 2) // run until there are less than two pixels left to process
				{
					// store colors from source as a pseudo-color standin (any color matching _maskColor produces 0x00000000, anything else produces a nonzero value that can be turned back into the original color by XOR'ing it with the mask color)
					Mask pseudoSrc; pseudoSrc.full = *read++ ^ maskColors.full;
					// use pseudo-color to create a mask value for each color (any color matching _maskColor produces 0xFFFFFFFF, anything else produces 0x00000000)
					Mask mask =
					{{
						(-1 + (((pseudoSrc.partial[0] | (~pseudoSrc.partial[0] + 1)) >> 31) & 1)),
						(-1 + (((pseudoSrc.partial[1] | (~pseudoSrc.partial[1] + 1)) >> 31) & 1))
					}};
					// {A}	(*write & mask.full)				--> combine existing color with mask
					//												(preserves existing color for transparent pixels, becomes 0x00000000 for opaque pixels)
					// {B}	pseudoSrc.full ^ maskColors.full	--> XOR pseudo-color and color mask to retrieve the original color
					// {C}	({B} & ~mask.full)					--> combine color with inverse mask
					//												(becomes 0x00000000 for transparent pixels, preserves new color for opaque pixels)
					// {D}	{A} | {C}							--> combine the two colors to get the final color
					//												((existing color OR 0x00000000) for transparent pixels, (0x00000000 OR new color) for opaque pixels)
					*write = ((*write) & mask.full) | ((pseudoSrc.full ^ maskColors.full) & (~mask.full));
					++write;
				}
				if (_numPixels) // process the last pixel in case of an odd pixel count
				{
					_dst = reinterpret_cast<Color*>(write);
					_src = reinterpret_cast<const Color*>(read);
					Color pseudoSrc = *_src++ ^ _maskColor;
					Color mask = (-1 + (((pseudoSrc | (~pseudoSrc + 1)) >> 31) & 1));
					*_dst = ((*_dst) & mask) | ((pseudoSrc ^ _maskColor) & (~mask));
					++_dst;
				}
/*
				processing steps example using 4 bit values for human readability

				_maskColor	0110

				maskColors	0110											0110

				*read		0111											0110
							(opaque)										(transparent)

				source		0111 ^ 0110										0110 ^ 0110
							0001											0000

				mask		1111 + (((0001 | (~0001 + 1)) >> 3) & 0001)		1111 + (((0000 | (~0000 + 1)) >> 3) & 0001)
							1111 + (((0001 | (1110 + 1)) >> 3) & 0001)		1111 + (((0000 | (1111 + 1)) >> 3) & 0001)
							1111 + (((0001 | 1111) >> 3) & 0001)			1111 + (((0000 | 0000) >> 3) & 0001)
							1111 + ((1111 >> 3) & 0001)						1111 + ((0000 >> 3) & 0001)
							1111 + (0001 & 0001)							1111 + (0000 & 0001)
							1111 + 0001										1111 + 0000
							0000											1111

				*write		1011											1101
							(1011 & 0000) | ((0001 ^ 0110) & ~0000)			(1101 & 1111) | ((0000 ^ 0110) & ~1111)
							0000 | (0111 & 1111)							1101 | (0110 & 0000)
							0000 | 0111										1101 | 0000
							0111											1101
*/
			}
			static inline void maskedMetadataCopy(Byte* _dst, const Byte* _src, unsigned int _numPixels, Byte _maskValue)
			{
				// store source and destination as uint64 pointers in order to operate on eight pixels in one operation
				unsigned long long* write = reinterpret_cast<unsigned long long*>(_dst);
				const unsigned long long* read = reinterpret_cast<const unsigned long long*>(_src);

				// struct contaning eight pixels' masks in one value
				union Mask
				{
					Byte partial[8];
					unsigned long long full;
				};
				Mask maskValues = {{ _maskValue, _maskValue, _maskValue, _maskValue, _maskValue, _maskValue, _maskValue, _maskValue }};

				//copy data, eight pixels at a time
				for (; (_numPixels >> 3); _numPixels -= 8) // run until there are less than eight pixels left to process
				{
					Mask pseudoSrc; pseudoSrc.full = *read++ ^ maskValues.full;
					Mask mask =
					{{
						Byte(-1 + (((pseudoSrc.partial[0] | (~pseudoSrc.partial[0] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[1] | (~pseudoSrc.partial[1] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[2] | (~pseudoSrc.partial[2] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[3] | (~pseudoSrc.partial[3] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[4] | (~pseudoSrc.partial[4] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[5] | (~pseudoSrc.partial[5] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[6] | (~pseudoSrc.partial[6] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[7] | (~pseudoSrc.partial[7] + 1)) >> 7) & 1))
					}};
					*write = ((*write) & mask.full) | ((pseudoSrc.full ^ maskValues.full) & (~mask.full));
					++write;
				}
				if (_numPixels) // process the last pixels for non-integer-mutliple-of-eight number of pixels
				{
					_dst = reinterpret_cast<Byte*>(write);
					_src = reinterpret_cast<const Byte*>(read);
					for (; _numPixels; --_numPixels)
					{
						Byte pseudoSrc = *_src++ ^ _maskValue;
						Byte mask = (-1 + (((pseudoSrc | (~pseudoSrc + 1)) >> 7) & 1));
						*_dst = ((*_dst) & mask) | ((pseudoSrc ^ _maskValue) & (~mask));
						++_dst;
					}
				}
			}
			// Copies data in reversed order using XOR transfer
			static inline void maskedColorCopyReverse(Color* _dst, const Color* _src, unsigned int _numPixels, Color _maskColor)
			{
				unsigned long long* write = reinterpret_cast<unsigned long long*>(_dst);
				_src = _src + _numPixels - 1; // start at the end and work backward

				union Mask
				{
					unsigned int partial[2];
					unsigned long long full;
				};
				Mask maskColors = {{ _maskColor, _maskColor }};

				for (; (_numPixels >> 1); _numPixels -= 2)
				{
					Mask pseudoSrc; // data must be read from source one pixel at a time in reverse order
					pseudoSrc.partial[0] = *_src-- ^ maskColors.partial[0];
					pseudoSrc.partial[1] = *_src-- ^ maskColors.partial[1];
					Mask mask =
					{{
						(-1 + (((pseudoSrc.partial[0] | (~pseudoSrc.partial[0] + 1)) >> 31) & 1)),
						(-1 + (((pseudoSrc.partial[1] | (~pseudoSrc.partial[1] + 1)) >> 31) & 1))
					}};
					*write = ((*write) & mask.full) | ((pseudoSrc.full ^ maskColors.full) & (~mask.full));
					++write;
				}
				if (_numPixels)
				{
					_dst = reinterpret_cast<Color*>(write);
					Color pseudoSrc = *_src-- ^ _maskColor;
					Color mask = (-1 + (((pseudoSrc | (~pseudoSrc + 1)) >> 31) & 1));
					*_dst = ((*_dst) & mask) | ((pseudoSrc ^ _maskColor) & (~mask));
					++_dst;
				}
			}
			static inline void maskedMetadataCopyReverse(Byte* _dst, const Byte* _src, unsigned int _numPixels, Byte _maskValue)
			{
				unsigned long long* write = reinterpret_cast<unsigned long long*>(_dst);
				_src = _src + _numPixels - 1; // start at the end and work backward

				union Mask
				{
					Byte partial[8];
					unsigned long long full;
				};
				Mask maskValues = {{ _maskValue, _maskValue, _maskValue, _maskValue, _maskValue, _maskValue, _maskValue, _maskValue }};

				for (; (_numPixels >> 3); _numPixels -= 8)
				{
					Mask pseudoSrc; // data must be read from source one pixel at a time in reverse order
					pseudoSrc.partial[0] = *_src-- ^ maskValues.partial[0];
					pseudoSrc.partial[1] = *_src-- ^ maskValues.partial[1];
					pseudoSrc.partial[2] = *_src-- ^ maskValues.partial[2];
					pseudoSrc.partial[3] = *_src-- ^ maskValues.partial[3];
					pseudoSrc.partial[4] = *_src-- ^ maskValues.partial[4];
					pseudoSrc.partial[5] = *_src-- ^ maskValues.partial[5];
					pseudoSrc.partial[6] = *_src-- ^ maskValues.partial[6];
					pseudoSrc.partial[7] = *_src-- ^ maskValues.partial[7];
					Mask mask =
					{{
						Byte(-1 + (((pseudoSrc.partial[0] | (~pseudoSrc.partial[0] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[1] | (~pseudoSrc.partial[1] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[2] | (~pseudoSrc.partial[2] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[3] | (~pseudoSrc.partial[3] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[4] | (~pseudoSrc.partial[4] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[5] | (~pseudoSrc.partial[5] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[6] | (~pseudoSrc.partial[6] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[7] | (~pseudoSrc.partial[7] + 1)) >> 7) & 1))
					}};
					*write = ((*write) & mask.full) | ((pseudoSrc.full ^ maskValues.full) & (~mask.full));
					++write;
				}
				if (_numPixels)
				{
					_dst = reinterpret_cast<Byte*>(write);;
					for (; _numPixels; --_numPixels)
					{
						Byte pseudoSrc = *_src-- ^ _maskValue;
						Byte mask = (-1 + (((pseudoSrc | (~pseudoSrc + 1)) >> 7) & 1));
						*_dst = ((*_dst) & mask) | ((pseudoSrc ^ _maskValue) & (~mask));
						++_dst;
					}
				}
			}
			// Copies data rotated 90* using XOR transfer
			static inline void maskedColorCopyRotated(Color* _dst, const Color* _src, unsigned int _numPixels, Color _maskColor)
			{
				unsigned long long* write = reinterpret_cast<unsigned long long*>(_dst);
				_src = _src + (_numPixels - 1) * SOURCE_BLOCK_WIDTH; // start at the end and work backward

				union Mask
				{
					unsigned int partial[2];
					unsigned long long full;
				};
				Mask maskColors = {{ _maskColor, _maskColor }};

				for (; (_numPixels >> 1); _numPixels -= 2)
				{
					Mask pseudoSrc; // source colors are in a column, ie a full row apart, and must be read in reverse order
					pseudoSrc.partial[0] = *_src ^ maskColors.partial[0]; _src -= SOURCE_BLOCK_WIDTH;
					pseudoSrc.partial[1] = *_src ^ maskColors.partial[1]; _src -= SOURCE_BLOCK_WIDTH;
					Mask mask =
					{{
						(-1 + (((pseudoSrc.partial[0] | (~pseudoSrc.partial[0] + 1)) >> 31) & 1)),
						(-1 + (((pseudoSrc.partial[1] | (~pseudoSrc.partial[1] + 1)) >> 31) & 1))
					}};
					*write = ((*write) & mask.full) | ((pseudoSrc.full ^ maskColors.full) & (~mask.full));
					++write;
				}
				if (_numPixels)
				{
					_dst = reinterpret_cast<Color*>(write);
					Color pseudoSrc = *_src ^ _maskColor; _src -= SOURCE_BLOCK_WIDTH;
					Color mask = (-1 + (((pseudoSrc | (~pseudoSrc + 1)) >> 31) & 1));
					*_dst = ((*_dst) & mask) | ((pseudoSrc ^ _maskColor) & (~mask));
					++_dst;
				}
			}
			static inline void maskedMetadataCopyRotated(Byte* _dst, const Byte* _src, unsigned int _numPixels, Byte _maskValue)
			{
				unsigned long long* write = reinterpret_cast<unsigned long long*>(_dst);
				_src = _src + (_numPixels - 1) * SOURCE_BLOCK_WIDTH; // start at the end and work backward

				union Mask
				{
					Byte partial[8];
					unsigned long long full;
				};
				Mask maskValues = {{ _maskValue, _maskValue, _maskValue, _maskValue, _maskValue, _maskValue, _maskValue, _maskValue }};

				//copy data, eight pixels at a time
				for (; (_numPixels >> 3); _numPixels -= 8)
				{
					Mask pseudoSrc; // source colors are in a column, ie a full row apart from each other
					pseudoSrc.partial[0] = *_src ^ maskValues.partial[0]; _src -= SOURCE_BLOCK_WIDTH;
					pseudoSrc.partial[1] = *_src ^ maskValues.partial[1]; _src -= SOURCE_BLOCK_WIDTH;
					pseudoSrc.partial[2] = *_src ^ maskValues.partial[2]; _src -= SOURCE_BLOCK_WIDTH;
					pseudoSrc.partial[3] = *_src ^ maskValues.partial[3]; _src -= SOURCE_BLOCK_WIDTH;
					pseudoSrc.partial[4] = *_src ^ maskValues.partial[4]; _src -= SOURCE_BLOCK_WIDTH;
					pseudoSrc.partial[5] = *_src ^ maskValues.partial[5]; _src -= SOURCE_BLOCK_WIDTH;
					pseudoSrc.partial[6] = *_src ^ maskValues.partial[6]; _src -= SOURCE_BLOCK_WIDTH;
					pseudoSrc.partial[7] = *_src ^ maskValues.partial[7]; _src -= SOURCE_BLOCK_WIDTH;
					Mask mask =
					{{
						Byte(-1 + (((pseudoSrc.partial[0] | (~pseudoSrc.partial[0] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[1] | (~pseudoSrc.partial[1] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[2] | (~pseudoSrc.partial[2] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[3] | (~pseudoSrc.partial[3] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[4] | (~pseudoSrc.partial[4] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[5] | (~pseudoSrc.partial[5] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[6] | (~pseudoSrc.partial[6] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[7] | (~pseudoSrc.partial[7] + 1)) >> 7) & 1))
					}};
					*write = ((*write) & mask.full) | ((pseudoSrc.full ^ maskValues.full) & (~mask.full));
					++write;
				}
				if (_numPixels)
				{
					_dst = reinterpret_cast<Byte*>(write);
					for (; _numPixels; --_numPixels)
					{
						Byte pseudoSrc = *_src ^ _maskValue; _src -= SOURCE_BLOCK_WIDTH;
						Byte mask = (-1 + (((pseudoSrc | (~pseudoSrc + 1)) >> 7) & 1));
						*_dst = ((*_dst) & mask) | ((pseudoSrc ^ _maskValue) & (~mask));
						++_dst;
					}
				}
			}
			// Copies data in reverse order and rotated 90* using XOR transfer
			static inline void maskedColorCopyReverseRotated(Color* _dst, const Color* _src, unsigned int _numPixels, Color _maskColor)
			{
				unsigned long long* write = reinterpret_cast<unsigned long long*>(_dst);

				union Mask
				{
					unsigned int partial[2];
					unsigned long long full;
				};
				Mask maskColors = {{ _maskColor, _maskColor }};

				for (; (_numPixels >> 1); _numPixels -= 2)
				{
					Mask pseudoSrc; // source colors are in a column, ie a full row apart from each other
					pseudoSrc.partial[0] = *_src ^ maskColors.partial[0]; _src += SOURCE_BLOCK_WIDTH;
					pseudoSrc.partial[1] = *_src ^ maskColors.partial[1]; _src += SOURCE_BLOCK_WIDTH;
					Mask mask =
					{{
						(-1 + (((pseudoSrc.partial[0] | (~pseudoSrc.partial[0] + 1)) >> 31) & 1)),
						(-1 + (((pseudoSrc.partial[1] | (~pseudoSrc.partial[1] + 1)) >> 31) & 1))
					}};
					*write = ((*write) & mask.full) | ((pseudoSrc.full ^ maskColors.full) & (~mask.full));
					++write;
				}
				if (_numPixels)
				{
					_dst = reinterpret_cast<Color*>(write);
					Color pseudoSrc = *_src ^ _maskColor; _src += SOURCE_BLOCK_WIDTH;
					Color mask = (-1 + (((pseudoSrc | (~pseudoSrc + 1)) >> 31) & 1));
					*_dst = ((*_dst) & mask) | ((pseudoSrc ^ _maskColor) & (~mask));
					++_dst;
				}
			}
			static inline void maskedMetadataCopyReverseRotated(Byte* _dst, const Byte* _src, unsigned int _numPixels, Byte _maskValue)
			{
				unsigned long long* write = reinterpret_cast<unsigned long long*>(_dst);

				union Mask
				{
					Byte partial[8];
					unsigned long long full;
				};
				Mask maskValues = {{ _maskValue, _maskValue, _maskValue, _maskValue, _maskValue, _maskValue, _maskValue, _maskValue }};

				//copy data, eight pixels at a time
				for (; (_numPixels >> 3); _numPixels -= 8)
				{
					Mask pseudoSrc; // source colors are in a column, ie a full row apart from each other
					pseudoSrc.partial[0] = *_src ^ maskValues.partial[0]; _src += SOURCE_BLOCK_WIDTH;
					pseudoSrc.partial[1] = *_src ^ maskValues.partial[1]; _src += SOURCE_BLOCK_WIDTH;
					pseudoSrc.partial[2] = *_src ^ maskValues.partial[2]; _src += SOURCE_BLOCK_WIDTH;
					pseudoSrc.partial[3] = *_src ^ maskValues.partial[3]; _src += SOURCE_BLOCK_WIDTH;
					pseudoSrc.partial[4] = *_src ^ maskValues.partial[4]; _src += SOURCE_BLOCK_WIDTH;
					pseudoSrc.partial[5] = *_src ^ maskValues.partial[5]; _src += SOURCE_BLOCK_WIDTH;
					pseudoSrc.partial[6] = *_src ^ maskValues.partial[6]; _src += SOURCE_BLOCK_WIDTH;
					pseudoSrc.partial[7] = *_src ^ maskValues.partial[7]; _src += SOURCE_BLOCK_WIDTH;
					Mask mask =
					{{
						Byte(-1 + (((pseudoSrc.partial[0] | (~pseudoSrc.partial[0] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[1] | (~pseudoSrc.partial[1] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[2] | (~pseudoSrc.partial[2] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[3] | (~pseudoSrc.partial[3] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[4] | (~pseudoSrc.partial[4] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[5] | (~pseudoSrc.partial[5] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[6] | (~pseudoSrc.partial[6] + 1)) >> 7) & 1)),
						Byte(-1 + (((pseudoSrc.partial[7] | (~pseudoSrc.partial[7] + 1)) >> 7) & 1))
					}};
					*write = ((*write) & mask.full) | ((pseudoSrc.full ^ maskValues.full) & (~mask.full));
					++write;
				}
				if (_numPixels)
				{
					_dst = reinterpret_cast<Byte*>(write);
					for (; _numPixels; --_numPixels)
					{
						Byte pseudoSrc = *_src ^ _maskValue; _src += SOURCE_BLOCK_WIDTH;
						Byte mask = (-1 + (((pseudoSrc | (~pseudoSrc + 1)) >> 7) & 1));
						*_dst = ((*_dst) & mask) | ((pseudoSrc ^ _maskValue) & (~mask));
						++_dst;
					}
				}
			}

#pragma endregion PRIVATE_DATA_MANIPULATION_FUNCTIONS
#pragma region PRIVATE_MATRIX_FUNCTIONS

			// transposes a matrix (ie, row-major -> column-major or vice versa)
			static inline Matrix2x2 matrixTranspose(Matrix2x2 _m)
			{
				return
				{{{
					_m.matrix[0][0], _m.matrix[1][0],
					_m.matrix[0][1], _m.matrix[1][1],
				}}};
			}
			static inline Matrix3x3 matrixTranspose(Matrix3x3 _m)
			{
				return
				{{{
					_m.matrix[0][0], _m.matrix[1][0], _m.matrix[2][0],
					_m.matrix[0][1], _m.matrix[1][1], _m.matrix[2][1],
					_m.matrix[0][2], _m.matrix[1][2], _m.matrix[2][2],
				}}};
			}

			// multiplies two matrices together
			static inline Matrix2x2 matrixXMatrix_RM(Matrix2x2 _a, Matrix2x2 _b)
			{
				return
				{{{
					(_a.matrix[0][0] * _b.matrix[0][0]) + (_a.matrix[0][1] * _b.matrix[1][0]), //[0][0]
					(_a.matrix[0][0] * _b.matrix[0][1]) + (_a.matrix[0][1] * _b.matrix[1][1]), //[0][1]

					(_a.matrix[1][0] * _b.matrix[0][0]) + (_a.matrix[1][1] * _b.matrix[1][0]), //[1][0]
					(_a.matrix[1][0] * _b.matrix[0][1]) + (_a.matrix[1][1] * _b.matrix[1][1]), //[1][1]
				}}};
			}
			static inline Matrix3x3 matrixXMatrix_RM(Matrix3x3 _a, Matrix3x3 _b)
			{
				return
				{{{
					(_a.matrix[0][0] * _b.matrix[0][0]) + (_a.matrix[0][1] * _b.matrix[1][0]) + (_a.matrix[0][2] * _b.matrix[2][0]), //[0][0]
					(_a.matrix[0][0] * _b.matrix[0][1]) + (_a.matrix[0][1] * _b.matrix[1][1]) + (_a.matrix[0][2] * _b.matrix[2][1]), //[0][1]
					(_a.matrix[0][0] * _b.matrix[0][2]) + (_a.matrix[0][1] * _b.matrix[1][2]) + (_a.matrix[0][2] * _b.matrix[2][2]), //[0][2]

					(_a.matrix[1][0] * _b.matrix[0][0]) + (_a.matrix[1][1] * _b.matrix[1][0]) + (_a.matrix[1][2] * _b.matrix[2][0]), //[1][0]
					(_a.matrix[1][0] * _b.matrix[0][1]) + (_a.matrix[1][1] * _b.matrix[1][1]) + (_a.matrix[1][2] * _b.matrix[2][1]), //[1][1]
					(_a.matrix[1][0] * _b.matrix[0][2]) + (_a.matrix[1][1] * _b.matrix[1][2]) + (_a.matrix[1][2] * _b.matrix[2][2]), //[1][2]

					(_a.matrix[2][0] * _b.matrix[0][0]) + (_a.matrix[2][1] * _b.matrix[1][0]) + (_a.matrix[2][2] * _b.matrix[2][0]), //[2][0]
					(_a.matrix[2][0] * _b.matrix[0][1]) + (_a.matrix[2][1] * _b.matrix[1][1]) + (_a.matrix[2][2] * _b.matrix[2][1]), //[2][1]
					(_a.matrix[2][0] * _b.matrix[0][2]) + (_a.matrix[2][1] * _b.matrix[1][2]) + (_a.matrix[2][2] * _b.matrix[2][2]), //[2][2]
				}}};
			}
			static inline Matrix2x2 matrixXMatrix_CM(Matrix2x2 _a, Matrix2x2 _b)
			{
				return
				{{{
					(_a.matrix[0][0] * _b.matrix[0][0]) + (_a.matrix[1][0] * _b.matrix[0][1]), //[0][0]
					(_a.matrix[0][0] * _b.matrix[1][0]) + (_a.matrix[1][0] * _b.matrix[1][1]), //[0][1]

					(_a.matrix[0][1] * _b.matrix[0][0]) + (_a.matrix[1][1] * _b.matrix[0][1]), //[1][0]
					(_a.matrix[0][1] * _b.matrix[1][0]) + (_a.matrix[1][1] * _b.matrix[1][1]), //[1][1]
				}}};
			}
			static inline Matrix3x3 matrixXMatrix_CM(Matrix3x3 _a, Matrix3x3 _b)
			{
				return
				{{{
					(_a.matrix[0][0] * _b.matrix[0][0]) + (_a.matrix[1][0] * _b.matrix[0][1]) + (_a.matrix[2][0] * _b.matrix[0][2]), //[0][0]
					(_a.matrix[0][0] * _b.matrix[1][0]) + (_a.matrix[1][0] * _b.matrix[1][1]) + (_a.matrix[2][0] * _b.matrix[1][2]), //[0][1]
					(_a.matrix[0][0] * _b.matrix[2][0]) + (_a.matrix[1][0] * _b.matrix[2][1]) + (_a.matrix[2][0] * _b.matrix[2][2]), //[0][2]

					(_a.matrix[0][1] * _b.matrix[0][0]) + (_a.matrix[1][1] * _b.matrix[0][1]) + (_a.matrix[2][1] * _b.matrix[0][2]), //[1][0]
					(_a.matrix[0][1] * _b.matrix[1][0]) + (_a.matrix[1][1] * _b.matrix[1][1]) + (_a.matrix[2][1] * _b.matrix[1][2]), //[1][1]
					(_a.matrix[0][1] * _b.matrix[2][0]) + (_a.matrix[1][1] * _b.matrix[2][1]) + (_a.matrix[2][1] * _b.matrix[2][2]), //[1][2]

					(_a.matrix[0][2] * _b.matrix[0][0]) + (_a.matrix[1][2] * _b.matrix[0][1]) + (_a.matrix[2][2] * _b.matrix[0][2]), //[2][0]
					(_a.matrix[0][2] * _b.matrix[1][0]) + (_a.matrix[1][2] * _b.matrix[1][1]) + (_a.matrix[2][2] * _b.matrix[1][2]), //[2][1]
					(_a.matrix[0][2] * _b.matrix[2][0]) + (_a.matrix[1][2] * _b.matrix[2][1]) + (_a.matrix[2][2] * _b.matrix[2][2]), //[2][2]
				}}};
			}

			// multiplies a matrix and a vector together
			static inline Vector2 matrixXVector_RM(Matrix2x2 _m, Vector2 _v)
			{
				return
				{{{
					(_m.matrix[0][0] * _v.x) + (_m.matrix[0][1] * _v.y),
					(_m.matrix[1][0] * _v.x) + (_m.matrix[1][1] * _v.y),
				}}};
			}
			static inline Vector3 matrixXVector_RM(Matrix3x3 _m, Vector3 _v)
			{
				return
				{{{
					(_m.matrix[0][0] * _v.x) + (_m.matrix[0][1] * _v.y) + (_m.matrix[0][2] * _v.z),
					(_m.matrix[1][0] * _v.x) + (_m.matrix[1][1] * _v.y) + (_m.matrix[1][2] * _v.z),
					(_m.matrix[2][0] * _v.x) + (_m.matrix[2][1] * _v.y) + (_m.matrix[2][2] * _v.z),
				}}};
			}
			static inline Vector2 matrixXVector_CM(Matrix2x2 _m, Vector2 _v)
			{
				return
				{{{
					(_m.matrix[0][0] * _v.x) + (_m.matrix[1][0] * _v.y),
					(_m.matrix[0][1] * _v.x) + (_m.matrix[1][1] * _v.y),
				}}};
			}
			static inline Vector3 matrixXVector_CM(Matrix3x3 _m, Vector3 _v)
			{
				return
				{{{
					(_m.matrix[0][0] * _v.x) + (_m.matrix[1][0] * _v.y) + (_m.matrix[2][0] * _v.z),
					(_m.matrix[0][1] * _v.x) + (_m.matrix[1][1] * _v.y) + (_m.matrix[2][1] * _v.z),
					(_m.matrix[0][2] * _v.x) + (_m.matrix[1][2] * _v.y) + (_m.matrix[2][2] * _v.z),
				}}};
			}

			// calculates the determinant of a matrix
			static inline float matrixDeterminant(Matrix2x2 _m)
			{
				return (_m.a * _m.d) - (_m.b * _m.c);
			}
			static inline float matrixDeterminant(Matrix3x3 _m)
			{
				return _m.matrix[0][0] * matrixDeterminant(Matrix2x2{{{ _m.matrix[1][1], _m.matrix[1][2], _m.matrix[2][1], _m.matrix[2][2] }}})
						- _m.matrix[0][1] * matrixDeterminant(Matrix2x2{{{ _m.matrix[1][0], _m.matrix[1][2], _m.matrix[2][0], _m.matrix[2][2] }}})
						+ _m.matrix[0][2] * matrixDeterminant(Matrix2x2{{{ _m.matrix[1][0], _m.matrix[1][1], _m.matrix[2][0], _m.matrix[2][1] }}});
			}

			// calculates the cofactor matrix of a 3x3 matrix (ie, matrix of determinants of all minor 2x2 matrices)
			static inline Matrix3x3 cofactorMatrix(Matrix3x3 _m)
			{
				return
				{{{
					 matrixDeterminant(Matrix2x2{{{ _m.matrix[1][1], _m.matrix[1][2], _m.matrix[2][1], _m.matrix[2][2] }}}), //[0][0]
					-matrixDeterminant(Matrix2x2{{{ _m.matrix[1][0], _m.matrix[1][2], _m.matrix[2][0], _m.matrix[2][2] }}}), //[0][1]
					 matrixDeterminant(Matrix2x2{{{ _m.matrix[1][0], _m.matrix[1][1], _m.matrix[2][0], _m.matrix[2][1] }}}), //[0][2]

					-matrixDeterminant(Matrix2x2{{{ _m.matrix[0][1], _m.matrix[0][2], _m.matrix[2][1], _m.matrix[2][2] }}}), //[1][0]
					 matrixDeterminant(Matrix2x2{{{ _m.matrix[0][0], _m.matrix[0][2], _m.matrix[2][0], _m.matrix[2][2] }}}), //[1][1]
					-matrixDeterminant(Matrix2x2{{{ _m.matrix[0][0], _m.matrix[0][1], _m.matrix[2][0], _m.matrix[2][1] }}}), //[1][2]

					 matrixDeterminant(Matrix2x2{{{ _m.matrix[0][1], _m.matrix[0][2], _m.matrix[1][1], _m.matrix[1][2] }}}), //[2][0]
					-matrixDeterminant(Matrix2x2{{{ _m.matrix[0][0], _m.matrix[0][2], _m.matrix[1][0], _m.matrix[1][2] }}}), //[2][1]
					 matrixDeterminant(Matrix2x2{{{ _m.matrix[0][0], _m.matrix[0][1], _m.matrix[1][0], _m.matrix[1][1] }}}), //[2][2]
				}}};
			}

			// calculates the inverse of a matrix (if matrix has no inverse, its first value is incremented slightly to make it invertible)
			static inline Matrix2x2 matrixInverse(Matrix2x2 _m)
			{
				// get determinant of matrix
				float det = matrixDeterminant(_m);
				if (det == 0.0f)
				{
					_m.a += 0.000001f;
					det = matrixDeterminant(_m);
				}
				// pre-divide determinant to save processing time
				det = 1.0f / det;
				// use pre-divided determinant to calculate inverse
				return
				{{{
					( _m.d * det),	(-_m.b * det),
					(-_m.c * det),	( _m.a * det),
				}}};
			}
			static inline Matrix3x3 matrixInverse(Matrix3x3 _m)
			{
				// get determinant of matrix
				float det = matrixDeterminant(_m);
				if (det == 0.0f)
				{
					_m.a += 0.000001f;
					det = matrixDeterminant(_m);
				}
				// get cofactor matrix
				_m = cofactorMatrix(_m);
				// pre-divide determinant to save processing time
				det = 1.0f / det;
				// use pre-divided determinant to calculate inverse
				//   manually transposed so as to use adjugate matrix (ie, transposed cofactor matrix) instead of cofactor matrix
				//   (this could also be done by transposing the cofactor matrix, but that would take more processing time)
				return
				{{{
					(_m.a * det), (_m.d * det), (_m.g * det),
					(_m.b * det), (_m.e * det), (_m.h * det),
					(_m.c * det), (_m.f * det), (_m.i * det),
				}}};
			}

#pragma endregion PRIVATE_MATRIX_FUNCTIONS
#pragma region PRIVATE_DRAW_FUNCTIONS

			// Converts draw instructions to their corresponding result instructions, then sorts them into result blocks for later flushing to the result canvas
			void processDrawInstructions_Deferred(const DrawInstruction* _drawInstructions, const unsigned short _numInstructions)
			{
				// iterate through draw instructions
				for (unsigned short i = 0; i < _numInstructions; ++i)
				{
					// store draw instruction for neatness
					const DrawInstruction& drawInstr = static_cast<DrawInstruction>(_drawInstructions[i]);
					// process instruction depending on bit flags
					if (drawInstr.flags & RESULT_INSTRUCTION_FORMAT::TSF)
						processDrawInstruction_Deferred_Transformed(drawInstr);
					else
						processDrawInstruction_Deferred_Basic(drawInstr);
				} // end iterate through draw instructions
			}
			inline void processDrawInstruction_Deferred_Basic(const DrawInstruction& _drawInstr)
			{
				// store instruction's tile for neatness
				TileDefinition& tile = m_tiles[_drawInstr.tile_id];

				// ignore instructions that are completely outside result
				if (   _drawInstr.t[0] + tile.w - 1 < 0			// instruction is beyond left edge
					|| _drawInstr.t[0] >= m_result.w_image		// instruction is beyond right edge
					|| _drawInstr.t[1] + tile.h - 1 < 0			// instruction is beyond top edge
					|| _drawInstr.t[1] >= m_result.h_image)		// instruction is beyond bottom edge
					return;

				// convert draw instruction origin to integer form (using signed ints preserves the full range of an unsigned short, but allows the value to be negative)
				int draw_x_result = static_cast<int>(floorf(_drawInstr.t[0]));
				int draw_y_result = static_cast<int>(floorf(_drawInstr.t[1]));

				// store tile's source for neatness
				Source& src = m_sources[tile.source_id];
				// get height of source (depends on source's data format)
				unsigned short src_blockheight = getSourceBlockHeight(src.format);
				// calculate source blocks in source that instruction overlaps
				unsigned short src_blockMinX = tile.x / SOURCE_BLOCK_WIDTH;
				unsigned short src_blockMinY = tile.y / src_blockheight;
				unsigned short src_blockMaxX = (tile.x + tile.w - 1) / SOURCE_BLOCK_WIDTH;
				unsigned short src_blockMaxY = (tile.y + tile.h - 1) / src_blockheight;
				// iterate through overlapped source blocks
				for (unsigned short src_blockY = src_blockMinY; src_blockY <= src_blockMaxY; ++src_blockY)
					for (unsigned short src_blockX = src_blockMinX; src_blockX <= src_blockMaxX; ++src_blockX)
					{
						// calculate origin of source block in pixels
						unsigned short srcBlock_x_source = src_blockX * SOURCE_BLOCK_WIDTH;
						unsigned short srcBlock_y_source = src_blockY * src_blockheight;
						// calculate origin of subtile in source
						unsigned short subtile_x_source = tile.x < srcBlock_x_source ? srcBlock_x_source : tile.x; // if tile's x origin is not within block, store block's x origin as x; otherwise, store tile's x origin
						unsigned short subtile_y_source = tile.y < srcBlock_y_source ? srcBlock_y_source : tile.y; // same on y
						// calculate maximum x/y of subtile in source
						unsigned short subtile_xMax_source = (tile.x + tile.w) < (srcBlock_x_source + SOURCE_BLOCK_WIDTH)	? tile.x + tile.w	: srcBlock_x_source + SOURCE_BLOCK_WIDTH; // if tile's right edge is within block, store tile's edge; otherwise, store block's edge
						unsigned short subtile_yMax_source = (tile.y + tile.h) < (srcBlock_y_source + src_blockheight)		? tile.y + tile.h	: srcBlock_y_source + src_blockheight; // same on y
						// calculate width and height of subtile
						unsigned short subtile_w_source = subtile_xMax_source - subtile_x_source;
						unsigned short subtile_h_source = subtile_yMax_source - subtile_y_source;
						// calculate origin in result (instruction's result origin + difference between result instruction's source origin and data region's source origin)
						/*
							{tx}	-> tile x origin in result										(draw_x_result)
							{ty}	-> tile y origin in result										(draw_y_result)
							{dxs}	-> difference between subtile and tile x origin in source		(subtile_x_source - tile.x)
							{dys}	-> difference between subtile and tile y origin in source		(subtile_y_source - tile.y)
							{tw}	-> tile width													(tile.w)
							{th}	-> tile height													(tile.h)
							{sw}	-> subtile width												(subtile_w_source)
							{sh}	-> subtile height												(subtile_h_source)

							subtile x result =
								ROTATE ?
									MIRROR_HORIZONTAL ?
										{tx} + {dys}
									:
										{tx} + {th} - {dys} - {sh}
								:
									MIRROR_HORIZONTAL ?
										{tx} + {tw} - {dxs} - {sw}
									:
										{tx} + {dxs}

							subtile y result =
								ROTATE ?
									MIRROR_VERTICAL ?
										{ty} + {tw} - {dxs} - {sw}
									:
										{ty} + {dxs}
								:
									MIRROR_VERTICAL ?
										{ty} + {th} - {dys} - {sh}
									:
										{ty} + {dys}
						*/
						int subtile_x_result = draw_x_result;
						int subtile_y_result = draw_y_result;
						if (_drawInstr.flags & DrawOptions::ROTATE)
						{
							subtile_x_result += (_drawInstr.flags & DrawOptions::MIRROR_HORIZONTAL)	? (subtile_y_source - tile.y)								: tile.h - (subtile_y_source - tile.y) - subtile_h_source;
							subtile_y_result += (_drawInstr.flags & DrawOptions::MIRROR_VERTICAL)	? tile.w - (subtile_x_source - tile.x) - subtile_w_source	: (subtile_x_source - tile.x);
						}
						else
						{
							subtile_x_result += (_drawInstr.flags & DrawOptions::MIRROR_HORIZONTAL)	? tile.w - (subtile_x_source - tile.x) - subtile_w_source	: (subtile_x_source - tile.x);
							subtile_y_result += (_drawInstr.flags & DrawOptions::MIRROR_VERTICAL)	? tile.h - (subtile_y_source - tile.y) - subtile_h_source	: (subtile_y_source - tile.y);
						}

						// store subtile width and height after basic transformations (swapped if tile is rotated)
						unsigned short subtile_w_result = (_drawInstr.flags & DrawOptions::ROTATE) ? subtile_h_source : subtile_w_source;
						unsigned short subtile_h_result = (_drawInstr.flags & DrawOptions::ROTATE) ? subtile_w_source : subtile_h_source;
						// if subtile is completely outside result, skip it
						if (   subtile_x_result + subtile_w_result - 1 < 0	// subtile is beyond left edge
							|| subtile_x_result > m_result.w_image			// subtile is beyond right edge
							|| subtile_y_result + subtile_h_result - 1 < 0	// subtile is beyond top edge
							|| subtile_y_result > m_result.h_image)			// subtile is beyond bottom edge
							continue;

						// calculate result blocks overlapped by subtile (dimensions swapped if tile is rotated)
						unsigned short res_blockMinX = G_CLAMP_MIN(static_cast<short>(subtile_x_result / RESULT_BLOCK_WIDTH), 0);
						unsigned short res_blockMaxX = G_CLAMP_MAX(static_cast<short>((subtile_x_result + subtile_w_result - 1) / RESULT_BLOCK_HEIGHT), m_result.w_data - 1);
						unsigned short res_blockMinY = G_CLAMP_MIN(static_cast<short>(subtile_y_result / RESULT_BLOCK_HEIGHT), 0);
						unsigned short res_blockMaxY = G_CLAMP_MAX(static_cast<short>((subtile_y_result + subtile_h_result - 1) / RESULT_BLOCK_WIDTH), m_result.h_data - 1);

						// iterate through overlapped result blocks
						for (unsigned short res_blockY = res_blockMinY; res_blockY <= res_blockMaxY; ++res_blockY)
							for (unsigned short res_blockX = res_blockMinX; res_blockX <= res_blockMaxX; ++res_blockX)
							{
								// store result block by reference for neatness
								ResultBlock& resBlock = m_result.data[res_blockX + res_blockY * m_result.w_data];

								// reject new instructions if this block's bin is full
								if (resBlock.instruction_count >= INSTRUCTIONS_PER_RESULT_BLOCK)
									continue;

								// calculate result block origin in pixels
								unsigned short resBlock_x_result = res_blockX * RESULT_BLOCK_WIDTH;
								unsigned short resBlock_y_result = res_blockY * RESULT_BLOCK_HEIGHT;

								// create result instruction to sort into result block bins
								ResultInstruction resInstr = {};

								// store flags, source, and source block
								resInstr.flags = _drawInstr.flags;
								resInstr.source_id = tile.source_id;
								resInstr.source_block_id = src_blockX + (src_blockY * src.w_data);
								// calculate origin of data region inside block
								resInstr.x_result = subtile_x_result < resBlock_x_result ? resBlock_x_result : subtile_x_result < 0 ? 0 : subtile_x_result; // if instruction's x origin is not within block, store block's x origin as x; otherwise, store instruction's x origin (unless it is negative, in which case store 0)
								resInstr.y_result = subtile_y_result < resBlock_y_result ? resBlock_y_result : subtile_y_result < 0 ? 0 : subtile_y_result; // same on y
								// calculate maximum x/y of data region
								unsigned short resInstr_xMax_result = (subtile_x_result + subtile_w_result) < (resBlock_x_result + RESULT_BLOCK_WIDTH)	? subtile_x_result + subtile_w_result : resBlock_x_result + RESULT_BLOCK_WIDTH; // if instruction's right edge is within block, store instruction's edge; otherwise, store block's edge
								unsigned short resInstr_yMax_result = (subtile_y_result + subtile_h_result) < (resBlock_y_result + RESULT_BLOCK_HEIGHT)	? subtile_y_result + subtile_h_result : resBlock_y_result + RESULT_BLOCK_HEIGHT; // same on y
								// calculate width and height of instruction data region
								resInstr.w_result = resInstr_xMax_result - resInstr.x_result;
								resInstr.h_result = resInstr_yMax_result - resInstr.y_result;
								// for basic instructions, source w/h = result w/h (swapped if transformed)
								resInstr.w_source = (resInstr.flags & DrawOptions::ROTATE) ? resInstr.h_result : resInstr.w_result;
								resInstr.h_source = (resInstr.flags & DrawOptions::ROTATE) ? resInstr.w_result : resInstr.h_result;
								// calculate origin of result instruction in source
								/*
									{sx}	-> subtile x origin in source												(subtile_x_source)
									{sy}	-> subtile y origin in source												(subtile_y_source)
									{dxr}	-> difference between result instruction and subtile x origin in result		(resInstr.x_result - subtile_x_result)
									{dyr}	-> difference between result instruction and subtile y origin in result		(resInstr.y_result - subtile_y_result)
									{sw}	-> subtile width															(subtile_w_source)
									{sh}	-> subtile height															(subtile_h_source)
									{rw}	-> result instruction width													(resInstr.w_source)
									{rh}	-> result instruction height												(resInstr.h_source)

									res instr x source =
										ROTATE ?
											MIRROR_VERTICAL ?
												{sx} + {sw} - {dyr} - {rh}
											:
												{sx} + {dyr}
										:
											MIRROR_HORIZONTAL ?
												{sx} + {sw} - {dxr} - {rw}
											:
												{sx} + {dxr}

									res instr y source =
										ROTATE ?
											MIRROR_HORIZONTAL ?
												{sy} + {dxr}
											:
												{sy} + {sh} - {dxr} - {rw}
										:
											MIRROR_VERTICAL ?
												{sy} + {sh} - {dyr} - {rh}
											:
												{sy} + {dyr}
								*/
								resInstr.x_source = subtile_x_source;
								resInstr.y_source = subtile_y_source;
								if (_drawInstr.flags & DrawOptions::ROTATE)
								{
									resInstr.x_source += (_drawInstr.flags & DrawOptions::MIRROR_VERTICAL)		? subtile_w_source - (resInstr.y_result - subtile_y_result) - resInstr.h_result	: (resInstr.y_result - subtile_y_result);
									resInstr.y_source += (_drawInstr.flags & DrawOptions::MIRROR_HORIZONTAL)	? (resInstr.x_result - subtile_x_result)										: subtile_h_source - (resInstr.x_result - subtile_x_result) - resInstr.w_result;
								}
								else
								{
									resInstr.x_source += (_drawInstr.flags & DrawOptions::MIRROR_HORIZONTAL)	? subtile_w_source - (resInstr.x_result - subtile_x_result) - resInstr.w_result	: (resInstr.x_result - subtile_x_result);
									resInstr.y_source += (_drawInstr.flags & DrawOptions::MIRROR_VERTICAL)		? subtile_h_source - (resInstr.y_result - subtile_y_result) - resInstr.h_result	: (resInstr.y_result - subtile_y_result);
								}

								// adjust origins to be relative to block origins
								resInstr.x_source -= srcBlock_x_source;
								resInstr.y_source -= srcBlock_y_source;
								resInstr.x_result -= resBlock_x_result;
								resInstr.y_result -= resBlock_y_result;

								// calculate layer override value (draw instruction layer value + z value)
								resInstr.layer_override = Layer(_drawInstr.layer + _drawInstr.t[2]);
								// store stencil override value
								resInstr.stencil_override = _drawInstr.stencil;
								// store mask values
								resInstr.mask_color = tile.mask_color;
								resInstr.mask_layer = tile.mask_layer;
								resInstr.mask_stencil = tile.mask_stencil;

								// add new instruction into bin
								resBlock.instruction_bin[resBlock.instruction_count++] = resInstr;
								// insertion-sort new instruction into place
								for (unsigned short i = resBlock.instruction_count - 1; i > 0; --i)
								{
									// swap current item and next item if the next item's layer is lower
									if (resBlock.instruction_bin[i - 1].layer_override < resBlock.instruction_bin[i].layer_override)
									{
										// repurpose local instruction for swapping since new data is now in the bin
										resInstr = resBlock.instruction_bin[i - 1];
										resBlock.instruction_bin[i - 1] = resBlock.instruction_bin[i];
										resBlock.instruction_bin[i] = resInstr;
									}
									// otherwise, sorting is finished
									else
									{
										break;
									}
								} // end sort new instruction into place
							} // end iterate through overlapped result blocks
				} // end iterate through overlapped source blocks
			}
			inline void processDrawInstruction_Deferred_Transformed(const DrawInstruction& _drawInstr)
			{
				// store instruction's tile for neatness
				TileDefinition& tile = m_tiles[_drawInstr.tile_id];

				// store position in result, transform matrix (transposed from row-major to col-major), and pivot
				Vector2 draw_pos_result = {{{ _drawInstr.t[0], _drawInstr.t[1] }}};
				Matrix2x2 transformMatrix =
				{{{
					_drawInstr.m[0][0], _drawInstr.m[1][0],
					_drawInstr.m[0][1], _drawInstr.m[1][1],
				}}};
				Vector2 pivot = {{{ _drawInstr.p[0], _drawInstr.p[1] }}};

				// calculate size of tile after transformation
				// apply inverse transform matrix to tile corners
				Quad footprint =
				{
					matrixXVector_CM(transformMatrix, Vector2{{{ 0.0f,								0.0f }}}),								// top left
					matrixXVector_CM(transformMatrix, Vector2{{{ 0.0f + static_cast<float>(tile.w),	0.0f }}}),								// top right
					matrixXVector_CM(transformMatrix, Vector2{{{ 0.0f + static_cast<float>(tile.w), 0.0f + static_cast<float>(tile.h) }}}), // bottom right
					matrixXVector_CM(transformMatrix, Vector2{{{ 0.0f,								0.0f + static_cast<float>(tile.h) }}}),	// bottom left
				};

				// calculate min/max positions of corners after transformation
				//   this is essentially an AABB enclosing the draw with the draw's top-left corner fixed at the origin
				Vector2 draw_bounds_min =
				{{{
					static_cast<float>(G_SMALLER(footprint.a.x, G_SMALLER(footprint.b.x, G_SMALLER(footprint.c.x, footprint.d.x)))),
					static_cast<float>(G_SMALLER(footprint.a.y, G_SMALLER(footprint.b.y, G_SMALLER(footprint.c.y, footprint.d.y)))),
				}}};
				Vector2 draw_bounds_max =
				{{{
					static_cast<float>(G_LARGER(footprint.a.x, G_LARGER(footprint.b.x, G_LARGER(footprint.c.x, footprint.d.x)))),
					static_cast<float>(G_LARGER(footprint.a.y, G_LARGER(footprint.b.y, G_LARGER(footprint.c.y, footprint.d.y)))),
				}}};

				// use bounds to calculate size
				Vector2 draw_size_result =
				{{{
					floorf(draw_bounds_max.x - draw_bounds_min.x),
					floorf(draw_bounds_max.y - draw_bounds_min.y),
				}}};

				// calculate transformed pivot
				Vector2 pivot_transformed = matrixXVector_CM(transformMatrix, pivot);
				// calculate vector to move transformed pivot back to original position
				Vector2 pivot_reset =
				{{{
					pivot.x - pivot_transformed.x,
					pivot.y - pivot_transformed.y,
				}}};

				// apply pivot to draw position; the pivot is a fixed point that the transformation happens about, which means that the tile's position needs to be adjusted by the
				//	vector from the transformed pivot to the untransformed pivot in order to move the new position of the pivot back to its original position
				Vector2 draw_pos_result_adjusted =
				{{{
					floorf(draw_pos_result.x + pivot_reset.x),
					floorf(draw_pos_result.y + pivot_reset.y),
				}}};
				// add adjusted draw position to footprint quad
				footprint.a.x += static_cast<int>(draw_pos_result_adjusted.x);
				footprint.b.x += static_cast<int>(draw_pos_result_adjusted.x);
				footprint.c.x += static_cast<int>(draw_pos_result_adjusted.x);
				footprint.d.x += static_cast<int>(draw_pos_result_adjusted.x);
				footprint.a.y += static_cast<int>(draw_pos_result_adjusted.y);
				footprint.b.y += static_cast<int>(draw_pos_result_adjusted.y);
				footprint.c.y += static_cast<int>(draw_pos_result_adjusted.y);
				footprint.d.y += static_cast<int>(draw_pos_result_adjusted.y);

				// calculate inverse of transform matrix and translation vector (adjusted by the vector from the transformed pivot to the original pivot, to keep the pivot fixed in place after transformation)
				Matrix3x3 mInverse = matrixInverse({{{
					_drawInstr.m[0][0],				_drawInstr.m[1][0],				0.0f,
					_drawInstr.m[0][1],				_drawInstr.m[1][1],				0.0f,
					draw_pos_result_adjusted.x,		draw_pos_result_adjusted.y,		1.0f,
				}}});

				// the draw's position needs to be adjusted further by the minimum x/y bounds of the AABB to account for the other corners' positions changing relative to the top-left corner
				draw_pos_result_adjusted.x += draw_bounds_min.x;
				draw_pos_result_adjusted.y += draw_bounds_min.y;

				// calculate result blocks overlapped by draw
				short res_blockMinX = G_CLAMP_MIN(static_cast<short>( draw_pos_result_adjusted.x / RESULT_BLOCK_WIDTH), 0);
				short res_blockMaxX = G_CLAMP_MAX(static_cast<short>((draw_pos_result_adjusted.x + draw_size_result.x - 1) / RESULT_BLOCK_WIDTH), m_result.w_data - 1); // -1 because this is a pixel-space calculation
				short res_blockMinY = G_CLAMP_MIN(static_cast<short>( draw_pos_result_adjusted.y / RESULT_BLOCK_HEIGHT), 0);
				short res_blockMaxY = G_CLAMP_MAX(static_cast<short>((draw_pos_result_adjusted.y + draw_size_result.y - 1) / RESULT_BLOCK_HEIGHT), m_result.h_data - 1); // -1 because this is a pixel-space calculation

				// check overlapped blocks to determine if draw is within result; if not, skip it
				if (   res_blockMaxX < 0					// beyond left edge
					|| res_blockMinX >= m_result.w_data		// beyond right edge
					|| res_blockMaxY < 0					// beyond top edge
					|| res_blockMinY >= m_result.h_data)	// beyond bottom edge
					return;

				// create instruction to store in result blocks
				ResultInstruction resInstr =
				{
					_drawInstr.flags,												// flags
					tile.source_id,													// source id
					(std::numeric_limits<unsigned short>::max)(),					// source block id (not used by transformed instructions)
					tile.x,															// x source
					tile.y,															// y source
					tile.w,															// w source
					tile.h,															// h source
					static_cast<unsigned short>(draw_pos_result.x),					// x result
					static_cast<unsigned short>(draw_pos_result.y),					// y result
					static_cast<unsigned short>(draw_size_result.x),				// w result
					static_cast<unsigned short>(draw_size_result.y),				// h result
					Layer(G_CLAMP(_drawInstr.layer + _drawInstr.t[2], 0, 255)),		// layer override
					_drawInstr.stencil,												// stencil override
					tile.mask_color,												// mask color
					tile.mask_layer,												// mask layer
					tile.mask_stencil,												// mask stencil
					{},																// pad
					Matrix2x2{{{ mInverse.vectors[0].x, mInverse.vectors[0].y,
						mInverse.vectors[1].x, mInverse.vectors[1].y }}},			// m inverse (top-left corner of inverse matrix)
					Vector2{{{ mInverse.vectors[2].x, mInverse.vectors[2].y }}},	// t inverse (third vector of inverse matrix)
					footprint,														// footprint
				};

				// iterate through overlapped result blocks
				for (unsigned short res_blockY = res_blockMinY; res_blockY <= res_blockMaxY; ++res_blockY)
					for (unsigned short res_blockX = res_blockMinX; res_blockX <= res_blockMaxX; ++res_blockX)
					{
						// store result block by reference for neatness
						ResultBlock& resBlock = m_result.data[res_blockX + res_blockY * m_result.w_data];
						// reject new instructions if this block's bin is full
						if (resBlock.instruction_count >= INSTRUCTIONS_PER_RESULT_BLOCK)
							continue;
						// otherwise, insertion-sort new instruction into place
						ResultInstruction sort;
						resBlock.instruction_bin[resBlock.instruction_count++] = resInstr;
						for (unsigned short i = resBlock.instruction_count - 1; i > 0; --i)
						{
							// swap current item and next item if the next item's layer is lower
							if (resBlock.instruction_bin[i - 1].layer_override < resBlock.instruction_bin[i].layer_override)
							{
								sort = resBlock.instruction_bin[i - 1];
								resBlock.instruction_bin[i - 1] = resBlock.instruction_bin[i];
								resBlock.instruction_bin[i] = sort;
							}
							// otherwise, sorting is finished
							else
							{
								break;
							}
						} // end sort new instruction into bin
					} // end iterate through overlapped result blocks
			}

			// Pre-sorts draw instructions, converts them to their corresponding result instructions, then flushes them to the result canvas immediately
			void processDrawInstructions_Immediate(DrawInstruction* _drawInstructions, const unsigned short _numInstructions)
			{
				// reset instruction counts (discards any outstanding instructions)
				for (unsigned short i = 0; i < m_result.size_data; ++i)
					m_result.data[i].instruction_count = 0;

				// pre-sort instructions to ensure they get drawn correctly
				std::vector<unsigned short> sortedIndices;
				for (unsigned short i = 0; i < _numInstructions; ++i)
				{
					// add new index to end of list
					sortedIndices.push_back(i);
					// determine final layer value of instruction to sort
					Layer sort_layer = Layer(_drawInstructions[i].layer + _drawInstructions[i].t[2]);
					// insertion sort instruction's index into place
					for (unsigned short k = static_cast<unsigned short>(sortedIndices.size()) - 1; k > 0; --k)
					{
						// determine final layer value of instruction to compare to
						Layer compare_layer = Layer(_drawInstructions[sortedIndices[k - 1]].layer + _drawInstructions[sortedIndices[k - 1]].t[2]);
						// if previous instruction's layer is lower or equal to this one's, sorting is finished
						if (sort_layer <= compare_layer)
							break;
						// otherwise, swap this instruction's with the previous one's index and repeat
						unsigned short temp = sortedIndices[k - 1];
						sortedIndices[k - 1] = sortedIndices[k];
						sortedIndices[k] = temp;
					}
				}

				// process & draw instructions
				processDrawInstructions_Immediate_recurse(_drawInstructions, &sortedIndices[0], _numInstructions);
			}
			void processDrawInstructions_Immediate_recurse(const DrawInstruction* _drawInstructions, const unsigned short* _sortedIndices, const unsigned short _numInstructions)
			{
				// whether the result has filled up and needs to flush instructions and recursively process the rest
				bool flushAndRepeat = false;

				// iterate through draw instructions and process them
				for (unsigned short i = 0; i < _numInstructions; ++i)
				{
					// store draw instruction for neatness
					const DrawInstruction& drawInstr = static_cast<DrawInstruction>(_drawInstructions[_sortedIndices[i]]);
					// process instruction depending on bit flags
					if (drawInstr.flags & RESULT_INSTRUCTION_FORMAT::TSF)
						flushAndRepeat = processDrawInstruction_Immediate_Transformed(drawInstr);
					else
						flushAndRepeat = processDrawInstruction_Immediate_Basic(drawInstr);
					
					// if a bin is full, flush current instructions, then process any remaining draw instructions
					//   this happens between draw instructions to avoid problems with trying to pause mid-processing of a draw instruction
					//   this is possible because each draw instruction can add at most 4 instructions into any given result block,
					//     so by making the flush threshold at least 4, bins can be filled to between 3 and 0 instructions of their capacity without overflowing
					if (flushAndRepeat)
					{
						Flush();
						// if there are instructions remaining, call this function again, but starting from the next instruction
						if (i < _numInstructions)
							processDrawInstructions_Immediate_recurse(_drawInstructions, &_sortedIndices[i + 1], _numInstructions - i - 1);
						// all instructions have now been processed recursively, so there is no reason to continue in the loop
						break;
					}
				} // end iterate through draw instructions
				// if this is the last iteration and instructions are outstanding, flush the last batch of instructions
				if (!flushAndRepeat)
					Flush();
			}
			// returns true if draw instruction caused a result block to fill up
			inline bool processDrawInstruction_Immediate_Basic(const DrawInstruction& _drawInstr)
			{
				bool resultBlockFull = false;

				// store instruction's tile for neatness
				TileDefinition& tile = m_tiles[_drawInstr.tile_id];

				// ignore instructions that are completely outside result
				if (   _drawInstr.t[0] + tile.w - 1 < 0		// instruction is beyond left edge
					|| _drawInstr.t[0] >= m_result.w_image	// instruction is beyond right edge
					|| _drawInstr.t[1] + tile.h - 1 < 0		// instruction is beyond top edge
					|| _drawInstr.t[1] >= m_result.h_image)	// instruction is beyond bottom edge
					return false;

				// convert draw instruction origin to integer form (using signed ints preserves the full range of an unsigned short, but allows the value to be negative)
				int draw_x_result = static_cast<int>(floorf(_drawInstr.t[0]));
				int draw_y_result = static_cast<int>(floorf(_drawInstr.t[1]));

				// store tile's source for neatness
				Source& src = m_sources[tile.source_id];
				// get height of source (depends on source's data format)
				unsigned short src_blockheight = getSourceBlockHeight(src.format);
				// calculate source blocks in source that instruction overlaps
				unsigned short src_blockMinX = tile.x / SOURCE_BLOCK_WIDTH;
				unsigned short src_blockMinY = tile.y / src_blockheight;
				unsigned short src_blockMaxX = (tile.x + tile.w - 1) / SOURCE_BLOCK_WIDTH;
				unsigned short src_blockMaxY = (tile.y + tile.h - 1) / src_blockheight;
				// iterate through overlapped source blocks
				for (unsigned short src_blockY = src_blockMinY; src_blockY <= src_blockMaxY; ++src_blockY)
					for (unsigned short src_blockX = src_blockMinX; src_blockX <= src_blockMaxX; ++src_blockX)
					{
						// calculate origin of source block in pixels
						unsigned short srcBlock_x_source = src_blockX * SOURCE_BLOCK_WIDTH;
						unsigned short srcBlock_y_source = src_blockY * src_blockheight;
						// calculate origin of subtile in source
						unsigned short subtile_x_source = tile.x < srcBlock_x_source ? srcBlock_x_source : tile.x; // if tile's x origin is not within block, store block's x origin as x; otherwise, store tile's x origin
						unsigned short subtile_y_source = tile.y < srcBlock_y_source ? srcBlock_y_source : tile.y; // same on y
						// calculate maximum x/y of subtile in source
						unsigned short subtile_xMax_source = (tile.x + tile.w) < (srcBlock_x_source + SOURCE_BLOCK_WIDTH)	? tile.x + tile.w	: srcBlock_x_source + SOURCE_BLOCK_WIDTH; // if tile's right edge is within block, store tile's edge; otherwise, store block's edge
						unsigned short subtile_yMax_source = (tile.y + tile.h) < (srcBlock_y_source + src_blockheight)		? tile.y + tile.h	: srcBlock_y_source + src_blockheight; // same on y
						// calculate width and height of subtile
						unsigned short subtile_w_source = subtile_xMax_source - subtile_x_source;
						unsigned short subtile_h_source = subtile_yMax_source - subtile_y_source;
						// calculate origin in result (instruction's result origin + difference between result instruction's source origin and data region's source origin)
						// (see processDrawInstructions_Deferred for summary of how this operation happens)
						int subtile_x_result = draw_x_result;
						int subtile_y_result = draw_y_result;
						if (_drawInstr.flags & DrawOptions::ROTATE)
						{
							subtile_x_result += (_drawInstr.flags & DrawOptions::MIRROR_HORIZONTAL)	? (subtile_y_source - tile.y)								: tile.h - (subtile_y_source - tile.y) - subtile_h_source;
							subtile_y_result += (_drawInstr.flags & DrawOptions::MIRROR_VERTICAL)	? tile.w - (subtile_x_source - tile.x) - subtile_w_source	: (subtile_x_source - tile.x);
						}
						else
						{
							subtile_x_result += (_drawInstr.flags & DrawOptions::MIRROR_HORIZONTAL)	? tile.w - (subtile_x_source - tile.x) - subtile_w_source	: (subtile_x_source - tile.x);
							subtile_y_result += (_drawInstr.flags & DrawOptions::MIRROR_VERTICAL)	? tile.h - (subtile_y_source - tile.y) - subtile_h_source	: (subtile_y_source - tile.y);
						}

						// store subtile width and height (swapped if tile is rotated)
						unsigned short subtile_w_result = (_drawInstr.flags & DrawOptions::ROTATE) ? subtile_h_source : subtile_w_source;
						unsigned short subtile_h_result = (_drawInstr.flags & DrawOptions::ROTATE) ? subtile_w_source : subtile_h_source;
						// if subtile is completely outside result, skip it
						if (   subtile_x_result + subtile_w_result - 1 < 0	// subtile is beyond left edge
							|| subtile_x_result > m_result.w_image			// subtile is beyond right edge
							|| subtile_y_result + subtile_h_result - 1 < 0	// subtile is beyond top edge
							|| subtile_y_result > m_result.h_image)			// subtile is beyond bottom edge
							continue;

						// calculate result blocks overlapped by subtile (dimensions swapped if tile is rotated)
						unsigned short res_blockMinX = G_CLAMP_MIN(static_cast<short>(subtile_x_result / RESULT_BLOCK_WIDTH), 0);
						unsigned short res_blockMaxX = G_CLAMP_MAX(static_cast<short>((subtile_x_result + subtile_w_result - 1) / RESULT_BLOCK_HEIGHT), m_result.w_data - 1);
						unsigned short res_blockMinY = G_CLAMP_MIN(static_cast<short>(subtile_y_result / RESULT_BLOCK_HEIGHT), 0);
						unsigned short res_blockMaxY = G_CLAMP_MAX(static_cast<short>((subtile_y_result + subtile_h_result - 1) / RESULT_BLOCK_WIDTH), m_result.h_data - 1);

						// iterate through overlapped result blocks
						for (unsigned short res_blockY = res_blockMinY; res_blockY <= res_blockMaxY; ++res_blockY)
							for (unsigned short res_blockX = res_blockMinX; res_blockX <= res_blockMaxX; ++res_blockX)
							{
								// store result block by reference for neatness
								ResultBlock& resBlock = m_result.data[res_blockX + res_blockY * m_result.w_data];
								// calculate result block origin in pixels
								unsigned short resBlock_x_result = res_blockX * RESULT_BLOCK_WIDTH;
								unsigned short resBlock_y_result = res_blockY * RESULT_BLOCK_HEIGHT;

								// create result instruction to sort into result block bins
								ResultInstruction resInstr = {};

								// store flags, source, and source block
								resInstr.flags = _drawInstr.flags;
								resInstr.source_id = tile.source_id;
								resInstr.source_block_id = src_blockX + (src_blockY * src.w_data);
								// calculate origin of data region inside block
								resInstr.x_result = subtile_x_result < resBlock_x_result ? resBlock_x_result : subtile_x_result < 0 ? 0 : subtile_x_result; // if instruction's x origin is not within block, store block's x origin as x; otherwise, store instruction's x origin (unless it is negative, in which case store 0)
								resInstr.y_result = subtile_y_result < resBlock_y_result ? resBlock_y_result : subtile_y_result < 0 ? 0 : subtile_y_result; // same on y
								// calculate maximum x/y of data region
								unsigned short resInstr_xMax_result = (subtile_x_result + subtile_w_result) < (resBlock_x_result + RESULT_BLOCK_WIDTH)	? subtile_x_result + subtile_w_result : resBlock_x_result + RESULT_BLOCK_WIDTH; // if instruction's right edge is within block, store instruction's edge; otherwise, store block's edge
								unsigned short resInstr_yMax_result = (subtile_y_result + subtile_h_result) < (resBlock_y_result + RESULT_BLOCK_HEIGHT)	? subtile_y_result + subtile_h_result : resBlock_y_result + RESULT_BLOCK_HEIGHT; // same on y
								// calculate width and height of instruction data region
								resInstr.w_result = resInstr_xMax_result - resInstr.x_result;
								resInstr.h_result = resInstr_yMax_result - resInstr.y_result;
								// for basic instructions, source w/h = result w/h (swapped if transformed)
								resInstr.w_source = (resInstr.flags & DrawOptions::ROTATE) ? resInstr.h_result : resInstr.w_result;
								resInstr.h_source = (resInstr.flags & DrawOptions::ROTATE) ? resInstr.w_result : resInstr.h_result;
								// (see processDrawInstructions_Deferred for summary of how this operation happens)
								resInstr.x_source = subtile_x_source;
								resInstr.y_source = subtile_y_source;
								if (_drawInstr.flags & DrawOptions::ROTATE)
								{
									resInstr.x_source += (_drawInstr.flags & DrawOptions::MIRROR_VERTICAL)		? subtile_w_source - (resInstr.y_result - subtile_y_result) - resInstr.h_result	: (resInstr.y_result - subtile_y_result);
									resInstr.y_source += (_drawInstr.flags & DrawOptions::MIRROR_HORIZONTAL)	? (resInstr.x_result - subtile_x_result)										: subtile_h_source - (resInstr.x_result - subtile_x_result) - resInstr.w_result;
								}
								else
								{
									resInstr.x_source += (_drawInstr.flags & DrawOptions::MIRROR_HORIZONTAL)	? subtile_w_source - (resInstr.x_result - subtile_x_result) - resInstr.w_result	: (resInstr.x_result - subtile_x_result);
									resInstr.y_source += (_drawInstr.flags & DrawOptions::MIRROR_VERTICAL)		? subtile_h_source - (resInstr.y_result - subtile_y_result) - resInstr.h_result	: (resInstr.y_result - subtile_y_result);
								}
								// adjust origins to be relative to block origins
								resInstr.x_source -= srcBlock_x_source;
								resInstr.y_source -= srcBlock_y_source;
								resInstr.x_result -= resBlock_x_result;
								resInstr.y_result -= resBlock_y_result;

								// calculate layer override value (draw instruction layer value + z value)
								resInstr.layer_override = Layer(_drawInstr.layer + _drawInstr.t[2]);
								// store stencil override value
								resInstr.stencil_override = _drawInstr.stencil;
								// store mask values
								resInstr.mask_color = tile.mask_color;
								resInstr.mask_layer = tile.mask_layer;
								resInstr.mask_stencil = tile.mask_stencil;

								// add new instruction into bin (no sorting needed due to pre-sort)
								resBlock.instruction_bin[resBlock.instruction_count++] = resInstr;
								// if result block's bin has less space left than the flush threshold, set flag on to flush instructions
								if (INSTRUCTIONS_PER_RESULT_BLOCK - resBlock.instruction_count < RESULT_FLUSH_THRESHOLD)
									resultBlockFull = true;
							} // end iterate through overlapped result blocks
					} // end iterate through overlapped source blocks
				return resultBlockFull;
			}
			// returns true if draw instruction caused a result block to fill up
			inline bool processDrawInstruction_Immediate_Transformed(const DrawInstruction& _drawInstr)
			{
				bool resultBlockFull = false;

				// store instruction's tile for neatness
				TileDefinition& tile = m_tiles[_drawInstr.tile_id];

				// store position in result, transform matrix (transposed from row-major to col-major), and pivot
				Vector2 draw_pos_result = {{{ _drawInstr.t[0], _drawInstr.t[1] }}};
				Matrix2x2 transformMatrix =
				{{{
					_drawInstr.m[0][0], _drawInstr.m[1][0],
					_drawInstr.m[0][1], _drawInstr.m[1][1],
				}}};
				Vector2 pivot = {{{ _drawInstr.p[0], _drawInstr.p[1] }}};

				// calculate size of tile after transformation
				// apply inverse transform matrix to tile corners
				Quad footprint =
				{
					matrixXVector_CM(transformMatrix, Vector2{{{ 0.0f,								0.0f }}}),								// top left
					matrixXVector_CM(transformMatrix, Vector2{{{ 0.0f + static_cast<float>(tile.w),	0.0f }}}),								// top right
					matrixXVector_CM(transformMatrix, Vector2{{{ 0.0f + static_cast<float>(tile.w),	0.0f + static_cast<float>(tile.h) }}}),	// bottom right
					matrixXVector_CM(transformMatrix, Vector2{{{ 0.0f,								0.0f + static_cast<float>(tile.h) }}}),	// bottom left
				};

				// calculate min/max positions of corners after transformation
				//   this is essentially an AABB enclosing the draw with the draw's top-left corner fixed at the origin
				Vector2 draw_bounds_min =
				{{{
					static_cast<float>(G_SMALLER(footprint.a.x, G_SMALLER(footprint.b.x, G_SMALLER(footprint.c.x, footprint.d.x)))),
					static_cast<float>(G_SMALLER(footprint.a.y, G_SMALLER(footprint.b.y, G_SMALLER(footprint.c.y, footprint.d.y)))),
				}}};
				Vector2 draw_bounds_max =
				{{{
					static_cast<float>(G_LARGER(footprint.a.x, G_LARGER(footprint.b.x, G_LARGER(footprint.c.x, footprint.d.x)))),
					static_cast<float>(G_LARGER(footprint.a.y, G_LARGER(footprint.b.y, G_LARGER(footprint.c.y, footprint.d.y)))),
				}}};

				// use bounds to calculate size
				Vector2 draw_size_result =
				{{{
					floorf(draw_bounds_max.x - draw_bounds_min.x),
					floorf(draw_bounds_max.y - draw_bounds_min.y),
				}}};

				// calculate transformed pivot
				Vector2 pivot_transformed = matrixXVector_CM(transformMatrix, pivot);
				// calculate vector to move transformed pivot back to original position
				Vector2 pivot_reset =
				{{{
					pivot.x - pivot_transformed.x,
					pivot.y - pivot_transformed.y,
				}}};

				// apply pivot to draw position; the pivot is a fixed point that the transformation happens about, which means that the tile's position needs to be adjusted by the
				//	vector from the transformed pivot to the untransformed pivot in order to move the new position of the pivot back to its original position
				Vector2 draw_pos_result_adjusted =
				{{{
					floorf(draw_pos_result.x + pivot_reset.x),
					floorf(draw_pos_result.y + pivot_reset.y),
				}}};
				// add adjusted draw position to footprint quad
				footprint.a.x += static_cast<int>(draw_pos_result_adjusted.x);
				footprint.b.x += static_cast<int>(draw_pos_result_adjusted.x);
				footprint.c.x += static_cast<int>(draw_pos_result_adjusted.x);
				footprint.d.x += static_cast<int>(draw_pos_result_adjusted.x);
				footprint.a.y += static_cast<int>(draw_pos_result_adjusted.y);
				footprint.b.y += static_cast<int>(draw_pos_result_adjusted.y);
				footprint.c.y += static_cast<int>(draw_pos_result_adjusted.y);
				footprint.d.y += static_cast<int>(draw_pos_result_adjusted.y);

				// calculate inverse of transform matrix and translation vector (adjusted by the vector from the transformed pivot to the original pivot, to keep the pivot fixed in place after transformation)
				Matrix3x3 mInverse = matrixInverse({{{
					_drawInstr.m[0][0],				_drawInstr.m[1][0],				0.0f,
					_drawInstr.m[0][1],				_drawInstr.m[1][1],				0.0f,
					draw_pos_result_adjusted.x,		draw_pos_result_adjusted.y,		1.0f,
				}}});

				// the draw's position needs to be adjusted further by the minimum x/y bounds of the AABB to account for the other corners' positions changing relative to the top-left corner
				draw_pos_result_adjusted.x += draw_bounds_min.x;
				draw_pos_result_adjusted.y += draw_bounds_min.y;

				// calculate result blocks overlapped by draw
				short res_blockMinX = G_CLAMP_MIN(static_cast<short>( draw_pos_result_adjusted.x / RESULT_BLOCK_WIDTH), 0);
				short res_blockMaxX = G_CLAMP_MAX(static_cast<short>((draw_pos_result_adjusted.x + draw_size_result.x - 1) / RESULT_BLOCK_WIDTH), m_result.w_data - 1); // -1 because this is a pixel-space calculation
				short res_blockMinY = G_CLAMP_MIN(static_cast<short>( draw_pos_result_adjusted.y / RESULT_BLOCK_HEIGHT), 0);
				short res_blockMaxY = G_CLAMP_MAX(static_cast<short>((draw_pos_result_adjusted.y + draw_size_result.y - 1) / RESULT_BLOCK_HEIGHT), m_result.h_data - 1); // -1 because this is a pixel-space calculation

				// check overlapped blocks to determine if draw is within result; if not, skip it
				if (   res_blockMaxX < 0					// beyond left edge
					|| res_blockMinX >= m_result.w_data		// beyond right edge
					|| res_blockMaxY < 0					// beyond top edge
					|| res_blockMinY >= m_result.h_data)	// beyond bottom edge
					return resultBlockFull;

				// create instruction to store in result blocks
				ResultInstruction resInstr =
				{
					_drawInstr.flags,												// flags
					tile.source_id,													// source id
					(std::numeric_limits<unsigned short>::max)(),					// source block id (not used by transformed instructions)
					tile.x,															// x source
					tile.y,															// y source
					tile.w,															// w source
					tile.h,															// h source
					static_cast<unsigned short>(draw_pos_result.x),					// x result
					static_cast<unsigned short>(draw_pos_result.y),					// y result
					static_cast<unsigned short>(draw_size_result.x),				// w result
					static_cast<unsigned short>(draw_size_result.y),				// h result
					Layer(G_CLAMP(_drawInstr.layer + _drawInstr.t[2], 0, 255)),		// layer override
					_drawInstr.stencil,												// stencil override
					tile.mask_color,												// mask color
					tile.mask_layer,												// mask layer
					tile.mask_stencil,												// mask stencil
					{},																// pad
					Matrix2x2{{{ mInverse.vectors[0].x, mInverse.vectors[0].y,
						mInverse.vectors[1].x, mInverse.vectors[1].y }}},			// m inverse (top-left corner of inverse matrix)
					Vector2{{{ mInverse.vectors[2].x, mInverse.vectors[2].y }}},	// t inverse (third vector of inverse matrix)
					footprint,														// footprint
				};

				// iterate through overlapped result blocks
				for (unsigned short res_blockY = res_blockMinY; res_blockY <= res_blockMaxY; ++res_blockY)
					for (unsigned short res_blockX = res_blockMinX; res_blockX <= res_blockMaxX; ++res_blockX)
					{
						// store result block by reference for neatness
						ResultBlock& resBlock = m_result.data[res_blockX + res_blockY * m_result.w_data];
						// add new instruction into bin (no sorting needed due to pre-sort)
						resBlock.instruction_bin[resBlock.instruction_count++] = resInstr;
						// if result block's bin has less space left than the flush threshold, set flag on to flush instructions
						if (INSTRUCTIONS_PER_RESULT_BLOCK - resBlock.instruction_count < RESULT_FLUSH_THRESHOLD)
							resultBlockFull = true;
					} // end iterate through overlapped result blocks

				return resultBlockFull;
			}

#pragma endregion PRIVATE_DRAW_FUNCTIONS
#pragma region PRIVATE_FLUSH_FUNCTIONS

			// Processes result instructions for a single result block
			/*
			*	retval GReturn::SUCCESS				All outstanding instructions were flushed to the result.
			*	retval GReturn::REDUNDANT			No instructions were outstanding.
			*/
			inline GReturn flushResultBlock_Serial(ResultBlock& _blockToFlush)
			{
				// if there are no instructions to draw, return immediately
				if (_blockToFlush.instruction_count < 1)
					return GReturn::REDUNDANT;

				// iterate through basic instruction bin
				for (unsigned short i = 0; i < _blockToFlush.instruction_count; ++i)
				{
					// store instruction by reference for neatness
					ResultInstruction& resInstr = _blockToFlush.instruction_bin[i];
					// determine how to draw the instruction and draw it
					if (resInstr.flags & DrawOptions::USE_TRANSFORMATIONS)
						flushResultInstruction_Transformed(_blockToFlush, resInstr);
					else
						flushResultInstruction_Basic(_blockToFlush, resInstr);
				} // end iterate through basic instruction bin

				// reset instruction count
				_blockToFlush.instruction_count = 0;

				return GReturn::SUCCESS;
			}

			// GConcurrent-compatible function to flush a single block
			static void flushResultBlock_Parallel(const void* _unused, ResultBlock* _blockToFlush, unsigned int _blockIndex, const void* _blitter)
			{
				GBlitterImplementation* blitter = const_cast<GBlitterImplementation*>(reinterpret_cast<const GBlitterImplementation*>(_blitter));
				blitter->m_result.flush_results[_blockIndex] = blitter->flushResultBlock_Serial(*_blockToFlush);
			}

			// Gets pointers to source block color/layer/stencil data (if present) depending on source's format
			/*
				NOTE: Pointers are NOT the start of the source block's data; They are the start of the data region to copy.
				Doing this pre-offset saves a bit of processing time by only doing the pointer arithmetic once, instead of once per data copy operation.
			*/
			inline void getSourceBlockPixelDataRegionPointers(const ResultInstruction& _resInstr, Color*& _outSrcBlockColors, Layer*& _outSrcBlockLayers, Stencil*& _outSrcBlockStencils)
			{
				// store source block for neatness
				SourceBlock& srcBlock = m_sources[_resInstr.source_id].data[_resInstr.source_block_id];
				// get location in source block
				unsigned int sourceOffset = _resInstr.x_source + (_resInstr.y_source * SOURCE_BLOCK_WIDTH);
				switch (m_sources[_resInstr.source_id].format)
				{
					case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::C:
						if (!(_resInstr.flags & DrawOptions::IGNORE_SOURCE_COLORS))
							_outSrcBlockColors = srcBlock.c.colors + sourceOffset;
						break;
					case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::L:
						if (_resInstr.flags & DrawOptions::USE_SOURCE_LAYERS)
							_outSrcBlockLayers = srcBlock.l.layers + sourceOffset;
						break;
					case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::S:
						if (_resInstr.flags & DrawOptions::USE_SOURCE_STENCILS)
							_outSrcBlockStencils = srcBlock.s.stencils + sourceOffset;
						break;
					case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::CL:
						if (!(_resInstr.flags & DrawOptions::IGNORE_SOURCE_COLORS))
							_outSrcBlockColors = srcBlock.cl.colors + sourceOffset;
						if (_resInstr.flags & DrawOptions::USE_SOURCE_LAYERS)
							_outSrcBlockLayers = srcBlock.cl.layers + sourceOffset;
						break;
					case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::CS:
						if (!(_resInstr.flags & DrawOptions::IGNORE_SOURCE_COLORS))
							_outSrcBlockColors = srcBlock.cs.colors + sourceOffset;
						if (_resInstr.flags & DrawOptions::USE_SOURCE_STENCILS)
							_outSrcBlockStencils = srcBlock.cs.stencils + sourceOffset;
						break;
					case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::LS:
						if (_resInstr.flags & DrawOptions::USE_SOURCE_LAYERS)
							_outSrcBlockLayers = srcBlock.ls.layers + sourceOffset;
						if (_resInstr.flags & DrawOptions::USE_SOURCE_STENCILS)
							_outSrcBlockStencils = srcBlock.ls.stencils + sourceOffset;
						break;
					case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::CLS:
						if (!(_resInstr.flags & DrawOptions::IGNORE_SOURCE_COLORS))
							_outSrcBlockColors = srcBlock.cls.colors + sourceOffset;
						if (_resInstr.flags & DrawOptions::USE_SOURCE_LAYERS)
							_outSrcBlockLayers = srcBlock.cls.layers + sourceOffset;
						if (_resInstr.flags & DrawOptions::USE_SOURCE_STENCILS)
							_outSrcBlockStencils = srcBlock.cls.stencils + sourceOffset;
						break;
					default:
						break;
				}
			}

			// Applies inverse transformation to the center of a pixel in the result canvas
			static inline Vector2 getResInstrReverseLookupCoord(const ResultInstruction& _resInstr, const unsigned short _x, const unsigned short _y)
			{
				Vector3 v = matrixXVector_CM(
					Matrix3x3{{{
						_resInstr.m_inverse.a,	_resInstr.m_inverse.b,	0.0f,
						_resInstr.m_inverse.c,	_resInstr.m_inverse.d,	0.0f,
						_resInstr.t_inverse.x,	_resInstr.t_inverse.y,	1.0f
					}}}, Vector3{{{ _x + 0.5f, _y + 0.5f, 1.0f }}});
				return Vector2{{{ v.x + _resInstr.x_source, v.y + _resInstr.y_source }}};
			}

			// Checks a reverse-lookup coordinate against the dimensions of the tile being drawn to determine if the pixel in the result that it came from should be drawn to
			static inline bool checkResInstrReverseLookupCoord(const ResultInstruction& _resInstr, const Vector2 _coord)
			{
				return _coord.x >= _resInstr.x_source
					&& _coord.x <  _resInstr.x_source + _resInstr.w_source
					&& _coord.y >= _resInstr.y_source
					&& _coord.y <  _resInstr.y_source + _resInstr.h_source;
			}

			// Converts an x/y coordinate within a result block into a linear index into that result block's canvas
			static inline unsigned int getResultBlockPixelIndex(unsigned short _x, unsigned short _y)
			{
				return static_cast<unsigned int>(_x + (_y * RESULT_BLOCK_WIDTH));
			}

			// Uses a reverse-lookup coordinate to sample a color value from the source of the tile being drawn
			inline Color reverseLookupColorFromSource(const unsigned short _sourceId, Vector2 _coord)
			{
				// store source by reference for neatness
				Source& src = m_sources[_sourceId];
				// get height of blocks in source
				unsigned short src_blockheight = getSourceBlockHeight(src.format);
				// get x/y index of source block
				unsigned short block_x = static_cast<unsigned int>(_coord.x) / SOURCE_BLOCK_WIDTH;
				unsigned short block_y = static_cast<unsigned int>(_coord.y) / src_blockheight;
				// store block by reference for neatness
				SourceBlock& block = src.data[block_x + block_y * src.w_data];
				// convert x/y coordinate into a linear index into the source block's canvas
				unsigned int pixelindex = static_cast<unsigned int>(_coord.x) - (block_x * SOURCE_BLOCK_WIDTH) + ((static_cast<unsigned int>(_coord.y) - (block_y * src_blockheight)) * SOURCE_BLOCK_WIDTH);
				// sample the value from the canvas
				Color result;
				switch (src.format)
				{
					case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::C:
						result = block.c.colors[pixelindex];
						break;

					case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::CL:
						result = block.cl.colors[pixelindex];
						break;

					case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::CS:
						result = block.cs.colors[pixelindex];
						break;

					case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::CLS:
						result = block.cls.colors[pixelindex];
						break;
					default:
						result = 0x00000000;
						break;
				};
				return result;
			}
			// Uses a reverse-lookup coordinate to sample a layer value from the source of the tile being drawn
			inline Layer reverseLookupLayerFromSource(const unsigned short _sourceId, const Vector2 _coord)
			{
				// store source by reference for neatness
				Source& src = m_sources[_sourceId];
				// get height of blocks in source
				unsigned short src_blockheight = getSourceBlockHeight(src.format);
				// get x/y index of source block
				unsigned short block_x = static_cast<unsigned int>(_coord.x) / SOURCE_BLOCK_WIDTH;
				unsigned short block_y = static_cast<unsigned int>(_coord.y) / src_blockheight;
				// store block by reference for neatness
				SourceBlock& block = src.data[block_x + block_y * src.w_data];
				// convert x/y coordinate into a linear index into the source block's canvas
				unsigned int pixelindex = static_cast<unsigned int>(_coord.x) - (block_x * SOURCE_BLOCK_WIDTH) + ((static_cast<unsigned int>(_coord.y) - (block_y * src_blockheight)) * SOURCE_BLOCK_WIDTH);
				// sample the value from the canvas
				Layer result;
				switch (src.format)
				{
					case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::L:
						result = block.l.layers[pixelindex];
						break;

					case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::CL:
						result = block.cl.layers[pixelindex];
						break;

					case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::LS:
						result = block.ls.layers[pixelindex];
						break;

					case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::CLS:
						result = block.cls.layers[pixelindex];
						break;
					default:
						result = 0xff;
						break;
				};
				return result;
			}
			// Uses a reverse-lookup coordinate to sample a stencil value from the source of the tile being drawn
			inline Stencil reverseLookupStencilFromSource(const unsigned short _sourceId, const Vector2 _coord)
			{
				// store source by reference for neatness
				Source& src = m_sources[_sourceId];
				// get height of blocks in source
				unsigned short src_blockheight = getSourceBlockHeight(src.format);
				// get x/y index of source block
				unsigned short block_x = static_cast<unsigned int>(_coord.x) / SOURCE_BLOCK_WIDTH;
				unsigned short block_y = static_cast<unsigned int>(_coord.y) / src_blockheight;
				// store block by reference for neatness
				SourceBlock& block = src.data[block_x + block_y * src.w_data];
				// convert x/y coordinate into a linear index into the source block's canvas
				unsigned int pixelindex = static_cast<unsigned int>(_coord.x) - (block_x * SOURCE_BLOCK_WIDTH) + ((static_cast<unsigned int>(_coord.y) - (block_y * src_blockheight)) * SOURCE_BLOCK_WIDTH);
				// sample the value from the canvas
				Stencil result;
				switch (src.format)
				{
					case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::S:
						result = block.s.stencils[pixelindex];
						break;

					case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::CS:
						result = block.cs.stencils[pixelindex];
						break;

					case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::LS:
						result = block.ls.stencils[pixelindex];
						break;

					case INTERNAL_PIXEL_ATTRIBUTES::FORMAT::CLS:
						result = block.cls.stencils[pixelindex];
						break;
					default:
						result = 0x00;
						break;
				};
				return result;
			}

			// Process an untransformed result instruction
			inline void flushResultInstruction_Basic(ResultBlock& _resBlock, ResultInstruction& _resInstr)
			{
				// get locations to copy data from
				Color* sourceColors = nullptr;
				Layer* sourceLayers = nullptr;
				Stencil* sourceStencils = nullptr;
				getSourceBlockPixelDataRegionPointers(_resInstr, sourceColors, sourceLayers, sourceStencils);
				// if not using source's layers/stencils, temporary buffers will be used instead to transfer the instruction's layer/stencil values into the result
				Layer layerOverride[RESULT_BLOCK_WIDTH];
				Stencil stencilOverride[RESULT_BLOCK_WIDTH];
				if (!(_resInstr.flags & DrawOptions::USE_SOURCE_LAYERS))
					memset(layerOverride, _resInstr.layer_override, _resInstr.w_result);
				if (!(_resInstr.flags & DrawOptions::USE_SOURCE_STENCILS))
					memset(stencilOverride, _resInstr.stencil_override, _resInstr.w_result);
				// get locations to copy data to (start of result block data array + offset (instruction origin x/y))
				unsigned int resultOffset = _resInstr.x_result + (_resInstr.y_result * RESULT_BLOCK_WIDTH);
				Color* resultColors = _resBlock.color + resultOffset;
				Layer* resultLayers = _resBlock.layer + resultOffset;
				Stencil* resultStencils = _resBlock.stencil + resultOffset;
				// copy data (the only difference between these instruction formats is the way colors are drawn to the result)
				switch (_resInstr.flags & RESULT_INSTRUCTION_FORMAT::TSP_MSK)
				//switch (_resInstr.flags & RESULT_INSTRUCTION_FORMAT::ITP_TSP_MSK) // replace the above line with this one once interpolation is implemented
				{
				case RESULT_INSTRUCTION_FORMAT::DEFAULT: // direct transfer (opaque)
					flushResultInstruction_Basic_Default(resultColors, resultLayers, resultStencils, sourceColors, sourceLayers, sourceStencils, layerOverride, stencilOverride, _resInstr.w_result, _resInstr.h_result, _resInstr.flags);
					break;
				case RESULT_INSTRUCTION_FORMAT::MSK: // bitmasking (XOR transfer; opaque/transparent)
					flushResultInstruction_Basic_Masked(resultColors, resultLayers, resultStencils, sourceColors, sourceLayers, sourceStencils, layerOverride, stencilOverride, _resInstr.w_result, _resInstr.h_result, _resInstr.flags, _resInstr.mask_color, _resInstr.mask_layer, _resInstr.mask_stencil);
					break;
				case RESULT_INSTRUCTION_FORMAT::TSP: // alpha blending (semi-transparent)
					flushResultInstruction_Basic_Transparent(resultColors, resultLayers, resultStencils, sourceColors, sourceLayers, sourceStencils, layerOverride, stencilOverride, _resInstr.w_result, _resInstr.h_result, _resInstr.flags);
					break;
				case RESULT_INSTRUCTION_FORMAT::TSP_MSK: // bitmasking and alpha blending
					flushResultInstruction_Basic_Transparent_Masked(resultColors, resultLayers, resultStencils, sourceColors, sourceLayers, sourceStencils, layerOverride, stencilOverride, _resInstr.w_result, _resInstr.h_result, _resInstr.flags, _resInstr.mask_color, _resInstr.mask_layer, _resInstr.mask_stencil);
					break;
				}
			}
			static inline void flushResultInstruction_Basic_Default(
				Color* _dstColors, Layer* _dstLayers, Stencil* _dstStencils, const Color* _srcColors, const Layer* _srcLayers, const Stencil* _srcStencils,
				const Layer* _layerOverride, const Stencil* _stencilOverride, unsigned short _w, unsigned short _h, unsigned short _flags)
			{
				switch (_flags & BASIC_ORIENTATION::RVH_270)
				{
					case BASIC_ORIENTATION::XXX_0:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstColors + (y * RESULT_BLOCK_WIDTH), _srcColors + (y * SOURCE_BLOCK_WIDTH), _w << 2);
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + (y * SOURCE_BLOCK_WIDTH), _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + (y * SOURCE_BLOCK_WIDTH), _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::XXX_0

					case BASIC_ORIENTATION::XXH_0_INV:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								directColorCopyReverse(_dstColors + (y * RESULT_BLOCK_WIDTH), _srcColors + (y * SOURCE_BLOCK_WIDTH), _w);
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								directMetadataCopyReverse(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + (y * SOURCE_BLOCK_WIDTH), _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								directMetadataCopyReverse(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + (y * SOURCE_BLOCK_WIDTH), _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::XXH_0_INV

					case BASIC_ORIENTATION::XVX_180_INV:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstColors + (y * RESULT_BLOCK_WIDTH), _srcColors + ((_h - 1 - y) * SOURCE_BLOCK_WIDTH), _w << 2);
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + ((_h - 1 - y) * SOURCE_BLOCK_WIDTH), _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + ((_h - 1 - y) * SOURCE_BLOCK_WIDTH), _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::XVX_180_INV

					case BASIC_ORIENTATION::XVH_180:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								directColorCopyReverse(_dstColors + (y * RESULT_BLOCK_WIDTH), _srcColors + ((_h - 1 - y) * SOURCE_BLOCK_WIDTH), _w);
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								directMetadataCopyReverse(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + ((_h - 1 - y) * SOURCE_BLOCK_WIDTH), _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								directMetadataCopyReverse(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + ((_h - 1 - y) * SOURCE_BLOCK_WIDTH), _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::XVH_180

					case BASIC_ORIENTATION::RXX_90:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								directColorCopyRotated(_dstColors + (y * RESULT_BLOCK_WIDTH), _srcColors + y, _w);
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								directMetadataCopyRotated(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + y, _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								directMetadataCopyRotated(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + y, _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::RXX_90

					case BASIC_ORIENTATION::RXH_270_INV:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								directColorCopyReverseRotated(_dstColors + (y * RESULT_BLOCK_WIDTH), _srcColors + y, _w);
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								directMetadataCopyReverseRotated(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + y, _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								directMetadataCopyReverseRotated(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + y, _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::RXH_270_INV

					case BASIC_ORIENTATION::RVX_90_INV:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								directColorCopyRotated(_dstColors + (y * RESULT_BLOCK_WIDTH), _srcColors + (_h - 1 - y), _w);
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								directMetadataCopyRotated(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + (_h - 1 - y), _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								directMetadataCopyRotated(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + (_h - 1 - y), _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::RVX_90_INV

					case BASIC_ORIENTATION::RVH_270:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								directColorCopyReverseRotated(_dstColors + (y * RESULT_BLOCK_WIDTH), _srcColors + (_h - 1 - y), _w);
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								directMetadataCopyReverseRotated(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + (_h - 1 - y), _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								directMetadataCopyReverseRotated(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + (_h - 1 - y), _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::RVH_270
				}
			}
			static inline void flushResultInstruction_Basic_Masked(
				Color* _dstColors, Layer* _dstLayers, Stencil* _dstStencils, const Color* _srcColors, const Layer* _srcLayers, const Stencil* _srcStencils,
				const Layer* _layerOverride, const Stencil* _stencilOverride, unsigned short _w, unsigned short _h, unsigned short _flags,
				Color _maskColor, Layer _maskLayer, Stencil _maskStencil)
			{
				switch (_flags & BASIC_ORIENTATION::RVH_270)
				{
					case BASIC_ORIENTATION::XXX_0:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								maskedColorCopy(_dstColors + (y * RESULT_BLOCK_WIDTH), _srcColors + (y * SOURCE_BLOCK_WIDTH), _w, _maskColor);
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + (y * SOURCE_BLOCK_WIDTH), _w, _maskLayer);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + (y * SOURCE_BLOCK_WIDTH), _w, _maskStencil);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::XXX_0

					case BASIC_ORIENTATION::XXH_0_INV:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								maskedColorCopyReverse(_dstColors + (y * RESULT_BLOCK_WIDTH), _srcColors + (y * SOURCE_BLOCK_WIDTH), _w, _maskColor);
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopyReverse(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + (y * SOURCE_BLOCK_WIDTH), _w, _maskLayer);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopyReverse(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + (y * SOURCE_BLOCK_WIDTH), _w, _maskStencil);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::XXH_0_INV

					case BASIC_ORIENTATION::XVX_180_INV:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								maskedColorCopy(_dstColors + (y * RESULT_BLOCK_WIDTH), _srcColors + ((_h - 1 - y) * SOURCE_BLOCK_WIDTH), _w, _maskColor);
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + ((_h - 1 - y) * SOURCE_BLOCK_WIDTH), _w, _maskLayer);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + ((_h - 1 - y) * SOURCE_BLOCK_WIDTH), _w, _maskStencil);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::XVX_180_INV

					case BASIC_ORIENTATION::XVH_180:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								maskedColorCopyReverse(_dstColors + (y * RESULT_BLOCK_WIDTH), _srcColors + ((_h - 1 - y) * SOURCE_BLOCK_WIDTH), _w, _maskColor);
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopyReverse(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + ((_h - 1 - y) * SOURCE_BLOCK_WIDTH), _w, _maskLayer);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopyReverse(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + ((_h - 1 - y) * SOURCE_BLOCK_WIDTH), _w, _maskStencil);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::XVH_180

					case BASIC_ORIENTATION::RXX_90:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								maskedColorCopyRotated(_dstColors + (y * RESULT_BLOCK_WIDTH), _srcColors + y, _w, _maskColor);
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopyRotated(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + y, _w, _maskLayer);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopyRotated(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + y, _w, _maskStencil);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::RXX_90

					case BASIC_ORIENTATION::RXH_270_INV:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								maskedColorCopyReverseRotated(_dstColors + (y * RESULT_BLOCK_WIDTH), _srcColors + y, _w, _maskColor);
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopyReverseRotated(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + y, _w, _maskLayer);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopyReverseRotated(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + y, _w, _maskStencil);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::RXH_270_INV

					case BASIC_ORIENTATION::RVX_90_INV:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								maskedColorCopyRotated(_dstColors + (y * RESULT_BLOCK_WIDTH), _srcColors + (_h - 1 - y), _w, _maskColor);
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopyRotated(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + (_h - 1 - y), _w, _maskLayer);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopyRotated(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + (_h - 1 - y), _w, _maskStencil);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::RVX_90_INV

					case BASIC_ORIENTATION::RVH_270:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								maskedColorCopyReverseRotated(_dstColors + (y * RESULT_BLOCK_WIDTH), _srcColors + (_h - 1 - y), _w, _maskColor);
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopyReverseRotated(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + (_h - 1 - y), _w, _maskLayer);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopyReverseRotated(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + (_h - 1 - y), _w, _maskStencil);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::RVH_270
				}
			}
			static inline void flushResultInstruction_Basic_Transparent(
				Color* _dstColors, Layer* _dstLayers, Stencil* _dstStencils, const Color* _srcColors, const Layer* _srcLayers, const Stencil* _srcStencils,
				const Layer* _layerOverride, const Stencil* _stencilOverride, unsigned short _w, unsigned short _h, unsigned short _flags)
			{
				switch (_flags & BASIC_ORIENTATION::RVH_270)
				{
					case BASIC_ORIENTATION::XXX_0:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned int y = 0; y < _h; ++y)
								for (unsigned int x = 0; x < _w; ++x)
									_dstColors[x + (y * RESULT_BLOCK_WIDTH)] = fixedPointColorLerp(_dstColors[x + (y * RESULT_BLOCK_WIDTH)], _srcColors[x + (y * SOURCE_BLOCK_WIDTH)]);
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + (y * SOURCE_BLOCK_WIDTH), _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + (y * SOURCE_BLOCK_WIDTH), _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::XXX_0

					case BASIC_ORIENTATION::XXH_0_INV:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								for (unsigned int x = 0; x < _w; ++x)
									_dstColors[x + (y * RESULT_BLOCK_WIDTH)] = fixedPointColorLerp(_dstColors[x + (y * RESULT_BLOCK_WIDTH)], _srcColors[(_w - 1 - x) + (y * SOURCE_BLOCK_WIDTH)]);
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								directMetadataCopyReverse(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + (y * SOURCE_BLOCK_WIDTH), _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								directMetadataCopyReverse(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + (y * SOURCE_BLOCK_WIDTH), _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::XXH_0_INV

					case BASIC_ORIENTATION::XVX_180_INV:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								for (unsigned int x = 0; x < _w; ++x)
									_dstColors[x + (y * RESULT_BLOCK_WIDTH)] = fixedPointColorLerp(_dstColors[x + (y * RESULT_BLOCK_WIDTH)], _srcColors[x + ((_h - 1 - y) * SOURCE_BLOCK_WIDTH)]);
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + ((_h - 1 - y) * SOURCE_BLOCK_WIDTH), _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + ((_h - 1 - y) * SOURCE_BLOCK_WIDTH), _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::XVX_180_INV

					case BASIC_ORIENTATION::XVH_180:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								for (unsigned int x = 0; x < _w; ++x)
									_dstColors[x + (y * RESULT_BLOCK_WIDTH)] = fixedPointColorLerp(_dstColors[x + (y * RESULT_BLOCK_WIDTH)], _srcColors[(_w - 1 - x) + ((_h - 1 - y) * SOURCE_BLOCK_WIDTH)]);
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								directMetadataCopyReverse(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + ((_h - 1 - y) * SOURCE_BLOCK_WIDTH), _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								directMetadataCopyReverse(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + ((_h - 1 - y) * SOURCE_BLOCK_WIDTH), _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::XVH_180

					case BASIC_ORIENTATION::RXX_90:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								for (unsigned int x = 0; x < _w; ++x)
									_dstColors[x + (y * RESULT_BLOCK_WIDTH)] = fixedPointColorLerp(_dstColors[x + (y * RESULT_BLOCK_WIDTH)], _srcColors[y + ((_w - 1 - x) * SOURCE_BLOCK_WIDTH)]); // dst x = src y, dst w = src h and vice versa
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								directMetadataCopyRotated(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + y, _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								directMetadataCopyRotated(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + y, _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::RXX_90

					case BASIC_ORIENTATION::RXH_270_INV:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								for (unsigned int x = 0; x < _w; ++x)
									_dstColors[x + (y * RESULT_BLOCK_WIDTH)] = fixedPointColorLerp(_dstColors[x + (y * RESULT_BLOCK_WIDTH)], _srcColors[y + (x * SOURCE_BLOCK_WIDTH)]); // dst x = src y, dst w = src h and vice versa
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								directMetadataCopyReverseRotated(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + y, _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								directMetadataCopyReverseRotated(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + y, _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::RXH_270_INV

					case BASIC_ORIENTATION::RVX_90_INV:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								for (unsigned int x = 0; x < _w; ++x)
									_dstColors[x + (y * RESULT_BLOCK_WIDTH)] = fixedPointColorLerp(_dstColors[x + (y * RESULT_BLOCK_WIDTH)], _srcColors[(_h - 1 - y) + ((_w - 1 -x) * SOURCE_BLOCK_WIDTH)]); // dst x = src y, dst w = src h and vice versa
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								directMetadataCopyRotated(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + (_h - 1 - y), _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								directMetadataCopyRotated(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + (_h - 1 - y), _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::RVX_90_INV

					case BASIC_ORIENTATION::RVH_270:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								for (unsigned int x = 0; x < _w; ++x)
									_dstColors[x + (y * RESULT_BLOCK_WIDTH)] = fixedPointColorLerp(_dstColors[x + (y * RESULT_BLOCK_WIDTH)], _srcColors[(_h - 1 - y) + (x * SOURCE_BLOCK_WIDTH)]); // dst x = src y, dst w = src h and vice versa
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								directMetadataCopyReverseRotated(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + (_h - 1 - y), _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								directMetadataCopyReverseRotated(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + (_h - 1 - y), _w);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::RVH_270
				}
			}
			static inline void flushResultInstruction_Basic_Transparent_Masked(
				Color* _dstColors, Layer* _dstLayers, Stencil* _dstStencils, const Color* _srcColors, const Layer* _srcLayers, const Stencil* _srcStencils,
				const Layer* _layerOverride, const Stencil* _stencilOverride, unsigned short _w, unsigned short _h, unsigned short _flags,
				Color _maskColor, Layer _maskLayer, Stencil _maskStencil)
			{
				switch (_flags & BASIC_ORIENTATION::RVH_270)
				{
					case BASIC_ORIENTATION::XXX_0:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								for (unsigned int x = 0; x < _w; ++x)
									_dstColors[x + (y * RESULT_BLOCK_WIDTH)] = fixedPointColorLerp_Masked(_dstColors[x + (y * RESULT_BLOCK_WIDTH)], _srcColors[x + (y * SOURCE_BLOCK_WIDTH)], _maskColor);
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + (y * SOURCE_BLOCK_WIDTH), _w, _maskLayer);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + (y * SOURCE_BLOCK_WIDTH), _w, _maskStencil);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::XXX_0

					case BASIC_ORIENTATION::XXH_0_INV:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								for (unsigned int x = 0; x < _w; ++x)
									_dstColors[x + (y * RESULT_BLOCK_WIDTH)] = fixedPointColorLerp_Masked(_dstColors[x + (y * RESULT_BLOCK_WIDTH)], _srcColors[(_w - 1 - x) + (y * SOURCE_BLOCK_WIDTH)], _maskColor);
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopyReverse(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + (y * SOURCE_BLOCK_WIDTH), _w, _maskLayer);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopyReverse(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + (y * SOURCE_BLOCK_WIDTH), _w, _maskStencil);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::XXH_0_INV

					case BASIC_ORIENTATION::XVX_180_INV:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								for (unsigned int x = 0; x < _w; ++x)
									_dstColors[x + (y * RESULT_BLOCK_WIDTH)] = fixedPointColorLerp_Masked(_dstColors[x + (y * RESULT_BLOCK_WIDTH)], _srcColors[x + ((_h - 1 - y) * SOURCE_BLOCK_WIDTH)], _maskColor);
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + ((_h - 1 - y) * SOURCE_BLOCK_WIDTH), _w, _maskLayer);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + ((_h - 1 - y) * SOURCE_BLOCK_WIDTH), _w, _maskStencil);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::XVX_180_INV

					case BASIC_ORIENTATION::XVH_180:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								for (unsigned int x = 0; x < _w; ++x)
									_dstColors[x + (y * RESULT_BLOCK_WIDTH)] = fixedPointColorLerp_Masked(_dstColors[x + (y * RESULT_BLOCK_WIDTH)], _srcColors[(_w - 1 - x) + ((_h - 1 - y) * SOURCE_BLOCK_WIDTH)], _maskColor);
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopyReverse(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + ((_h - 1 - y) * SOURCE_BLOCK_WIDTH), _w, _maskLayer);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopyReverse(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + ((_h - 1 - y) * SOURCE_BLOCK_WIDTH), _w, _maskStencil);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::XVH_180

					case BASIC_ORIENTATION::RXX_90:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								for (unsigned int x = 0; x < _w; ++x)
									_dstColors[x + (y * RESULT_BLOCK_WIDTH)] = fixedPointColorLerp_Masked(_dstColors[x + (y * RESULT_BLOCK_WIDTH)], _srcColors[y + ((_w - 1 - x) * SOURCE_BLOCK_WIDTH)], _maskColor); // dst x = src y, dst w = src h and vice versa
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopyRotated(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + y, _w, _maskLayer);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopyRotated(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + y, _w, _maskStencil);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::RXX_90

					case BASIC_ORIENTATION::RXH_270_INV:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								for (unsigned int x = 0; x < _w; ++x)
									_dstColors[x + (y * RESULT_BLOCK_WIDTH)] = fixedPointColorLerp_Masked(_dstColors[x + (y * RESULT_BLOCK_WIDTH)], _srcColors[y + (x * SOURCE_BLOCK_WIDTH)], _maskColor); // dst x = src y, dst w = src h and vice versa
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopyReverseRotated(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + y, _w, _maskLayer);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopyReverseRotated(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + y, _w, _maskStencil);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::RXH_270_INV

					case BASIC_ORIENTATION::RVX_90_INV:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								for (unsigned int x = 0; x < _w; ++x)
									_dstColors[x + (y * RESULT_BLOCK_WIDTH)] = fixedPointColorLerp_Masked(_dstColors[x + (y * RESULT_BLOCK_WIDTH)], _srcColors[(_h - 1 - y) + ((_w - 1 - x) * SOURCE_BLOCK_WIDTH)], _maskColor); // dst x = src y, dst w = src h and vice versa
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopyRotated(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + (_h - 1 - y), _w, _maskLayer);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopyRotated(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + (_h - 1 - y), _w, _maskStencil);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::RVX_90_INV

					case BASIC_ORIENTATION::RVH_270:
					{
						// color
						if (!(_flags & DrawOptions::IGNORE_SOURCE_COLORS) && _srcColors)
							for (unsigned short y = 0; y < _h; ++y)
								for (unsigned int x = 0; x < _w; ++x)
									_dstColors[x + (y * RESULT_BLOCK_WIDTH)] = fixedPointColorLerp_Masked(_dstColors[x + (y * RESULT_BLOCK_WIDTH)], _srcColors[(_h - 1 - y) + (x * SOURCE_BLOCK_WIDTH)], _maskColor); // dst x = src y, dst w = src h and vice versa
						// layer
						if ((_flags & DrawOptions::USE_SOURCE_LAYERS) && _srcLayers)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopyReverseRotated(_dstLayers + (y * RESULT_BLOCK_WIDTH), _srcLayers + (_h - 1 - y), _w, _maskLayer);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstLayers + (y * RESULT_BLOCK_WIDTH), _layerOverride, _w);
						// stencil
						if ((_flags & DrawOptions::USE_SOURCE_STENCILS) && _srcStencils)
							for (unsigned short y = 0; y < _h; ++y)
								maskedMetadataCopyReverseRotated(_dstStencils + (y * RESULT_BLOCK_WIDTH), _srcStencils + (_h - 1 - y), _w, _maskStencil);
						else
							for (unsigned short y = 0; y < _h; ++y)
								memcpy(_dstStencils + (y * RESULT_BLOCK_WIDTH), _stencilOverride, _w);
					} break; // end case BASIC_ORIENTATION::RVH_270
				}
			}

			// Processes a transformed result instruction
			inline void flushResultInstruction_Transformed(ResultBlock& _resBlock, ResultInstruction& _resInstr)
			{
#if defined(GBLITTER_DEBUG_OUTLINE_TRANFORMED_BOUNDS) || defined(GBLITTER_DEBUG_FILL_TRANFORMED_BOUNDS)
				int bounds_left = static_cast<int>(
					G_CLAMP_MIN(
						G_SMALLER(_resInstr.footprint.a.x, G_SMALLER(_resInstr.footprint.b.x, G_SMALLER(_resInstr.footprint.c.x, _resInstr.footprint.d.x))),
						_resBlock.x_result)
					- _resBlock.x_result
					);
				int bounds_top = static_cast<int>(
					G_CLAMP_MIN(
						G_SMALLER(_resInstr.footprint.a.y, G_SMALLER(_resInstr.footprint.b.y, G_SMALLER(_resInstr.footprint.c.y, _resInstr.footprint.d.y))),
						_resBlock.y_result)
					- _resBlock.y_result
					);
				int bounds_right = static_cast<int>(
					G_CLAMP_MAX(
						G_LARGER(_resInstr.footprint.a.x, G_LARGER(_resInstr.footprint.b.x, G_LARGER(_resInstr.footprint.c.x, _resInstr.footprint.d.x))),
						_resBlock.x_result + RESULT_BLOCK_WIDTH)
					- (_resBlock.x_result + 1)
					);
				int bounds_bottom = static_cast<int>(
					G_CLAMP_MAX(
						G_LARGER(_resInstr.footprint.a.y, G_LARGER(_resInstr.footprint.b.y, G_LARGER(_resInstr.footprint.c.y, _resInstr.footprint.d.y))),
						_resBlock.y_result + RESULT_BLOCK_HEIGHT)
					- (_resBlock.y_result + 1)
					);
#endif
#if defined(GBLITTER_DEBUG_FILL_TRANFORMED_BOUNDS)
				// fill instruction bounds with solid color
				for (int y = bounds_top; y <= bounds_bottom; ++y)
					for (int x = bounds_left; x <= bounds_right; ++x)
						_resBlock.color[getResultBlockPixelIndex(x, y)] = 0xffff0000;
#elif defined(GBLITTER_DEBUG_OUTLINE_TRANFORMED_BOUNDS)
				// outline instruction bounds with solid color
				// if row is the first or last row, fill entire row
				for (int x = bounds_left; x <= bounds_right; ++x)
				{
					_resBlock.color[getResultBlockPixelIndex(x, bounds_top)] = 0xffff0000;
					_resBlock.color[getResultBlockPixelIndex(x, bounds_bottom)] = 0xffff0000;
				}
				// otherwise, fill first and last pixel in row
				for (int y = bounds_top + 1; y <= bounds_bottom - 1; ++y)
				{
					_resBlock.color[getResultBlockPixelIndex(bounds_left, y)] = 0xffff0000;
					_resBlock.color[getResultBlockPixelIndex(bounds_right, y)] = 0xffff0000;
				}
#endif

				// store instruction's source by reference for neatness
				Source& src = m_sources[_resInstr.source_id];
				// get source's format as flags
				unsigned short srcFormatFlags = pixelFormatToFlags(src.format);

				// determine which data types to draw and store the result in a bit-flag set
				//   (this could be done much more simply with bools, but bools need 64 bits each and only use 1 of them, whereas this uses 8 bits total, even if another type of metadata is added later)
				Byte dataTypesToDrawFlags = 0;
				// color
				dataTypesToDrawFlags |= (
						// get flag for if color data is present in source
							((srcFormatFlags & INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR) // isolate flag value from source format flags
							>> 0) // shift flag value to first position
						& // combine flag values
						// get flag for if source color data should be ignored by instruction
							(~((_resInstr.flags & DrawOptions::IGNORE_SOURCE_COLORS) // isolate flag value from instruction draw option flags
							>> 3) & 1) // shift flag value to first position (isolated value is inverted and &'ed with 1, since color should be used if IGNORE_SOURCE_COLORS is off and ignored if it is on)
					) << 0; // shift resulting flag value into position
				// layer
				dataTypesToDrawFlags |= (
						// get flag for if layer data is present in source
							((srcFormatFlags & INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER) // isolate flag value from source format flags
							>> 1) // shift flag value to first position
						& // combine flag values
						// get flag for if source layer data should be used by instruction
							((_resInstr.flags & DrawOptions::USE_SOURCE_LAYERS) // isolate flag value from instruction draw option flags
							>> 4) // shift flag value to first position
					) << 1; // shift resulting flag value into position
				// stencil
				dataTypesToDrawFlags |= (
						// get flag for if stencil data is present in source
							((srcFormatFlags & INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL) // isolate flag value from source format flags
							>> 2) // shift flag value to first position
						& // combine flag values
						// get flag for if source stencil data should be used by instruction
							((_resInstr.flags & DrawOptions::USE_SOURCE_STENCILS) // isolate flag value from instruction draw option flags
							>> 5) // shift flag value to first position
					) << 2; // shift resulting flag value into position

				// DEBUG triangle fill/corner colors
				static constexpr Color triangleAcolor = 0xff00ff00;
				static constexpr Color triangleAcornerColor = 0xffff00ff;
				static constexpr Color triangleBcolor = 0xff0000ff;
				static constexpr Color triangleBcornerColor = 0xffffff00;

				// call the appropriate draw helper function for the format specified by flags
				switch (_resInstr.flags & RESULT_INSTRUCTION_FORMAT::TSP_MSK)
				{
					case RESULT_INSTRUCTION_FORMAT::DEFAULT:
						drawClippedTriangle_Default(_resBlock, _resInstr, Triangle{ _resInstr.footprint.a, _resInstr.footprint.b, _resInstr.footprint.c }, dataTypesToDrawFlags, triangleAcolor, triangleAcornerColor);
						drawClippedTriangle_Default(_resBlock, _resInstr, Triangle{ _resInstr.footprint.a, _resInstr.footprint.c, _resInstr.footprint.d }, dataTypesToDrawFlags, triangleBcolor, triangleBcornerColor);
						break;
					case RESULT_INSTRUCTION_FORMAT::MSK:
						drawClippedTriangle_Masked(_resBlock, _resInstr, Triangle{ _resInstr.footprint.a, _resInstr.footprint.b, _resInstr.footprint.c }, dataTypesToDrawFlags, triangleAcolor, triangleAcornerColor);
						drawClippedTriangle_Masked(_resBlock, _resInstr, Triangle{ _resInstr.footprint.a, _resInstr.footprint.c, _resInstr.footprint.d }, dataTypesToDrawFlags, triangleBcolor, triangleBcornerColor);
						break;
					case RESULT_INSTRUCTION_FORMAT::TSP:
						drawClippedTriangle_Transparent(_resBlock, _resInstr, Triangle{ _resInstr.footprint.a, _resInstr.footprint.b, _resInstr.footprint.c }, dataTypesToDrawFlags, triangleAcolor, triangleAcornerColor);
						drawClippedTriangle_Transparent(_resBlock, _resInstr, Triangle{ _resInstr.footprint.a, _resInstr.footprint.c, _resInstr.footprint.d }, dataTypesToDrawFlags, triangleBcolor, triangleBcornerColor);
						break;
					case RESULT_INSTRUCTION_FORMAT::TSP_MSK:
						drawClippedTriangle_Transparent_Masked(_resBlock, _resInstr, Triangle{ _resInstr.footprint.a, _resInstr.footprint.b, _resInstr.footprint.c }, dataTypesToDrawFlags, triangleAcolor, triangleAcornerColor);
						drawClippedTriangle_Transparent_Masked(_resBlock, _resInstr, Triangle{ _resInstr.footprint.a, _resInstr.footprint.c, _resInstr.footprint.d }, dataTypesToDrawFlags, triangleBcolor, triangleBcornerColor);
						break;
				}
			}

			// Draws a textured triangle parametrically, clipped to the bounds of a result block
			//   Based on a function written by Lari Norri
			inline void drawClippedTriangle_Default(ResultBlock& _resBlock, const ResultInstruction& _resInstr, Triangle _tri, const Byte _dataTypesToDrawFlags, Color _color = 0x00000000, Color _cornerColor = 0x00000000)
			{
				// get clipping bounds
				int clipLeft	= _resBlock.x_result;
				int clipRight	= _resBlock.x_result + RESULT_BLOCK_WIDTH;
				int clipTop		= _resBlock.y_result;
				int clipBottom	= _resBlock.y_result + RESULT_BLOCK_HEIGHT;

				// reject triangles not within horizontal bounds
				if (_tri.a.x < clipLeft && _tri.b.x < clipLeft && _tri.c.x < clipLeft)
					return;
				if (_tri.a.x > clipRight && _tri.b.x > clipRight && _tri.c.x > clipRight)
					return;

				// sort triangle points from top to bottom
				Point swap;
				if (_tri.a.y > _tri.b.y)
				{
					swap = _tri.a;
					_tri.a = _tri.b;
					_tri.b = swap;
				}
				if (_tri.a.y > _tri.c.y)
				{
					swap = _tri.c;
					_tri.c = _tri.a;
					_tri.a = swap;
				}
				if (_tri.b.y > _tri.c.y)
				{
					swap = _tri.c;
					_tri.c = _tri.b;
					_tri.b = swap;
				}

				// reject triangles not within vertical bounds
				if (_tri.c.y < clipTop || _tri.a.y > clipBottom)
					return;

				// calculate slopes between all points
				float slope_ac = (_tri.c.x - _tri.a.x) / static_cast<float>(_tri.c.y - _tri.a.y);
				float slope_ab = (_tri.b.x - _tri.a.x) / static_cast<float>(_tri.b.y - _tri.a.y);
				float slope_bc = (_tri.c.x - _tri.b.x) / static_cast<float>(_tri.c.y - _tri.b.y);

				// start at top point if it is within vertical bounds, otherwise start at top of block
				int start_y = (_tri.a.y > clipTop) ? _tri.a.y : clipTop;
				// end at middle point if it is within vertical bounds, otherwise end at bottom of block
				int end_y = (_tri.b.y < clipBottom) ? _tri.b.y : clipBottom;

				// compute start and end x
				float start_x = ((_tri.c.x - _tri.a.x) * ((start_y - _tri.a.y) / static_cast<float>(_tri.c.y - _tri.a.y))) + _tri.a.x;
				float end_x = static_cast<float>(_tri.b.x); // initializing to the middle point's x handles edge cases where a triangle has a flat top
				if (start_y < _tri.b.y)
					end_x = ((_tri.b.x - _tri.a.x) * ((start_y - _tri.a.y) / static_cast<float>(_tri.b.y - _tri.a.y))) + _tri.a.x;
				else if (start_y > _tri.b.y)
					end_x = ((_tri.c.x - _tri.b.x) * (1.0f - ((_tri.c.y - start_y) / static_cast<float>(_tri.c.y - _tri.b.y)))) + _tri.b.x;

				// flip start and end if needed to make the rest of the logic simpler
				float flip = std::numeric_limits<float>::quiet_NaN();
				if (start_x + slope_ac > end_x + slope_ab)
				{
					flip = start_x;
					start_x = end_x;
					end_x = flip;
					flip = slope_ac;
					slope_ac = slope_ab;
					slope_ab = flip;
				}

				// draw data types indicated by flags
				// color data
				if (_dataTypesToDrawFlags & INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR)
				{
					float color_start_x = start_x;
					int color_start_y = start_y;
					float color_end_x = end_x;
					int color_end_y = end_y;
					float color_slope_ab = slope_ab;
					float color_slope_ac = slope_ac;
					float color_slope_bc = slope_bc;
					// execute the following logic twice
					for (int i = 0; i < 2; ++i)
					{
						// loop while start_y < end_y (might be skipped)
						for (; color_start_y < color_end_y; ++color_start_y)
						{
							// clip start and end x to boundary (temporary)
							int left = static_cast<int>(color_start_x + 0.5f);
							if (left < clipLeft)
								left = clipLeft;
							int right = static_cast<int>(color_end_x + 0.5f);
							if (right > clipRight)
								right = clipRight;
							unsigned int index = getResultBlockPixelIndex(left - _resBlock.x_result, color_start_y - _resBlock.y_result); // offset to be relative to this result block
							// traverse and fill
							for (; left < right; ++left, ++index)
							{
#if defined(GBLITTER_DEBUG_DISABLE_TRANSFORMED_COLOR_LOOKUP) || defined(GBLITTER_DEBUG_FILL_TRANSFORMED_TRIANGLES)
								_resBlock.color[index] = _color;
#endif
#if !defined(GBLITTER_DEBUG_DISABLE_TRANSFORMED_COLOR_LOOKUP)
								// draw reverse-lookup color with false-positive checking
								//   (theoretically, this error checking doesn't need to be here; however, at the moment the triangle drawing algorithm produces false
								//     positives around the edges, which can cause an out-of-bounds exception when trying to reverse-lookup colors for those pixels)
								Vector2 coord = getResInstrReverseLookupCoord(_resInstr, left, color_start_y);
								if (checkResInstrReverseLookupCoord(_resInstr, coord))
									_resBlock.color[index] = reverseLookupColorFromSource(_resInstr.source_id, coord);

								// draw reverse-lookup color with no error checking
								//   (this can't be used until the false positives mentioned above have been dealt with)
								//_resBlock.color[index] = reverseLookupColorFromSource(_resInstr.source_id, getResInstrReverseLookupCoord(_resInstr, left, color_start_y));
#endif
							}
							// adjust start and end x by slope
							color_start_x += color_slope_ac;
							color_end_x += color_slope_ab;
						}
						color_end_y = (_tri.c.y < clipBottom) ? static_cast<int>(_tri.c.y) : clipBottom;
						// if direction was flipped previously, adjust slope traversal
						std::isnan(flip) ? color_slope_ab = color_slope_bc : color_slope_ac = color_slope_bc;
					}
				}
				// layer data
				float layer_start_x = start_x;
				int layer_start_y = start_y;
				float layer_end_x = end_x;
				int layer_end_y = end_y;
				float layer_slope_ab = slope_ab;
				float layer_slope_ac = slope_ac;
				float layer_slope_bc = slope_bc;
				// use layer data from source if set, otherwise use instruction's layer override value
				if (_dataTypesToDrawFlags & INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER)
					// execute the following logic twice
					for (int i = 0; i < 2; ++i)
					{
						// loop while start_y < end_y (might be skipped)
						for (; layer_start_y < layer_end_y; ++layer_start_y)
						{
							// clip start and end x to boundary (temporary)
							int left = static_cast<int>(layer_start_x + 0.5f);
							if (left < clipLeft)
								left = clipLeft;
							int right = static_cast<int>(layer_end_x + 0.5f);
							if (right > clipRight)
								right = clipRight;
							unsigned int index = getResultBlockPixelIndex(left - _resBlock.x_result, layer_start_y - _resBlock.y_result); // offset to be relative to this result block
							// traverse and fill
							for (; left < right; ++left, ++index)
							{
								// draw reverse-lookup layer with false-positive checking
								//   (theoretically, this error checking doesn't need to be here; however, at the moment the triangle drawing algorithm produces false
								//     positives around the edges, which can cause an out-of-bounds exception when trying to reverse-lookup colors for those pixels)
								Vector2 coord = getResInstrReverseLookupCoord(_resInstr, left, layer_start_y);
								if (checkResInstrReverseLookupCoord(_resInstr, coord))
									_resBlock.layer[index] = reverseLookupLayerFromSource(_resInstr.source_id, coord);

								// draw reverse-lookup layer with no error checking
								//   (this can't be used until the false positives mentioned above have been dealt with)
								//_resBlock.layer[index] = reverseLookupLayerFromSource(_resInstr.source_id, getResInstrReverseLookupCoord(_resInstr, left, layer_start_y));
							}
							// adjust start and end x by slope
							layer_start_x += layer_slope_ac;
							layer_end_x += layer_slope_ab;
						}
						layer_end_y = (_tri.c.y < clipBottom) ? static_cast<int>(_tri.c.y) : clipBottom;
						// if direction was flipped previously, adjust slope traversal
						std::isnan(flip) ? layer_slope_ab = layer_slope_bc : layer_slope_ac = layer_slope_bc;
					}
				else
					// execute the following logic twice
					for (int i = 0; i < 2; ++i)
					{
						// loop while start_y < end_y (might be skipped)
						for (; layer_start_y < layer_end_y; ++layer_start_y)
						{
							// clip start and end x to boundary (temporary)
							int left = static_cast<int>(layer_start_x + 0.5f);
							if (left < clipLeft)
								left = clipLeft;
							int right = static_cast<int>(layer_end_x + 0.5f);
							if (right > clipRight)
								right = clipRight;
							unsigned int index = getResultBlockPixelIndex(left - _resBlock.x_result, layer_start_y - _resBlock.y_result); // offset to be relative to this result block
							// traverse and fill
							for (; left < right; ++left, ++index)
							{
								// draw reverse-lookup layer with false-positive checking
								//   (theoretically, this error checking doesn't need to be here; however, at the moment the triangle drawing algorithm produces false
								//     positives around the edges, which can cause an out-of-bounds exception when trying to reverse-lookup colors for those pixels)
								Vector2 coord = getResInstrReverseLookupCoord(_resInstr, left, layer_start_y);
								if (checkResInstrReverseLookupCoord(_resInstr, coord))
									_resBlock.layer[index] = _resInstr.layer_override;

								// draw reverse-lookup layer with no error checking
								//   (this can't be used until the false positives mentioned above have been dealt with)
								//_resBlock.layer[index] = _resInstr.layer_override;
							}
							// adjust start and end x by slope
							layer_start_x += layer_slope_ac;
							layer_end_x += layer_slope_ab;
						}
						layer_end_y = (_tri.c.y < clipBottom) ? static_cast<int>(_tri.c.y) : clipBottom;
						// if direction was flipped previously, adjust slope traversal
						std::isnan(flip) ? layer_slope_ab = layer_slope_bc : layer_slope_ac = layer_slope_bc;
					}
				// stencil data
				float stencil_start_x = start_x;
				int stencil_start_y = start_y;
				float stencil_end_x = end_x;
				int stencil_end_y = end_y;
				float stencil_slope_ab = slope_ab;
				float stencil_slope_ac = slope_ac;
				float stencil_slope_bc = slope_bc;
				// use stencil data from source if set, otherwise use instruction's stencil override value
				if (_dataTypesToDrawFlags & INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL)
					// execute the following logic twice
					for (int i = 0; i < 2; ++i)
					{
						// loop while start_y < end_y (might be skipped)
						for (; stencil_start_y < stencil_end_y; ++stencil_start_y)
						{
							// clip start and end x to boundary (temporary)
							int left = static_cast<int>(stencil_start_x + 0.5f);
							if (left < clipLeft)
								left = clipLeft;
							int right = static_cast<int>(stencil_end_x + 0.5f);
							if (right > clipRight)
								right = clipRight;
							unsigned int index = getResultBlockPixelIndex(left - _resBlock.x_result, stencil_start_y - _resBlock.y_result); // offset to be relative to this result block
							// traverse and fill
							for (; left < right; ++left, ++index)
							{
								// draw reverse-lookup stencil with false-positive checking
								//   (theoretically, this error checking doesn't need to be here; however, at the moment the triangle drawing algorithm produces false
								//     positives around the edges, which can cause an out-of-bounds exception when trying to reverse-lookup colors for those pixels)
								Vector2 coord = getResInstrReverseLookupCoord(_resInstr, left, stencil_start_y);
								if (checkResInstrReverseLookupCoord(_resInstr, coord))
									_resBlock.stencil[index] = reverseLookupStencilFromSource(_resInstr.source_id, coord);

								// draw reverse-lookup stencil with no error checking
								//   (this can't be used until the false positives mentioned above have been dealt with)
								//_resBlock.stencil[index] = reverseLookupStencilFromSource(_resInstr.source_id, getResInstrReverseLookupCoord(_resInstr, left, start_y));
							}
							// adjust start and end x by slope
							stencil_start_x += stencil_slope_ac;
							stencil_end_x += stencil_slope_ab;
						}
						stencil_end_y = (_tri.c.y < clipBottom) ? static_cast<int>(_tri.c.y) : clipBottom;
						// if direction was flipped previously, adjust slope traversal
						std::isnan(flip) ? stencil_slope_ab = stencil_slope_bc : stencil_slope_ac = stencil_slope_bc;
					}
				else
					// execute the following logic twice
					for (int i = 0; i < 2; ++i)
					{
						// loop while start_y < end_y (might be skipped)
						for (; stencil_start_y < stencil_end_y; ++stencil_start_y)
						{
							// clip start and end x to boundary (temporary)
							int left = static_cast<int>(stencil_start_x + 0.5f);
							if (left < clipLeft)
								left = clipLeft;
							int right = static_cast<int>(stencil_end_x + 0.5f);
							if (right > clipRight)
								right = clipRight;
							unsigned int index = getResultBlockPixelIndex(left - _resBlock.x_result, stencil_start_y - _resBlock.y_result); // offset to be relative to this result block
							// traverse and fill
							for (; left < right; ++left, ++index)
							{
								// draw reverse-lookup stencil with false-positive checking
								//   (theoretically, this error checking doesn't need to be here; however, at the moment the triangle drawing algorithm produces false
								//     positives around the edges, which can cause an out-of-bounds exception when trying to reverse-lookup colors for those pixels)
								Vector2 coord = getResInstrReverseLookupCoord(_resInstr, left, stencil_start_y);
								if (checkResInstrReverseLookupCoord(_resInstr, coord))
									_resBlock.stencil[index] = _resInstr.stencil_override;

								// draw reverse-lookup stencil with no error checking
								//   (this can't be used until the false positives mentioned above have been dealt with)
								//_resBlock.stencil[index] = _resInstr.stencil_override;
							}
							// adjust start and end x by slope
							stencil_start_x += stencil_slope_ac;
							stencil_end_x += stencil_slope_ab;
						}
						stencil_end_y = (_tri.c.y < clipBottom) ? static_cast<int>(_tri.c.y) : clipBottom;
						// if direction was flipped previously, adjust slope traversal
						std::isnan(flip) ? stencil_slope_ab = stencil_slope_bc : stencil_slope_ac = stencil_slope_bc;
					}

				// DEBUG draw corners
#if defined(GBLITTER_DEBUG_DRAW_TRANSFORMED_TRIANGLE_CORNERS)
				// max corners in each dimension are 1 pixel past the last pixels drawn to, since corner positions are geometric rather than pixel-space
				//   (pixel-space coordinates use integers only, which means a pixel-space shape spans [min, max), rather than a geometric shape which spans [min, max] )
				if (_tri.a.x >= clipLeft && _tri.a.x < clipRight && _tri.a.y >= clipTop && _tri.a.y < clipBottom)
					_resBlock.color[getResultBlockPixelIndex(_tri.a.x - _resBlock.x_result, _tri.a.y - _resBlock.y_result)] = _cornerColor;
				if (_tri.b.x >= clipLeft && _tri.b.x < clipRight && _tri.b.y >= clipTop && _tri.b.y < clipBottom)
					_resBlock.color[getResultBlockPixelIndex(_tri.b.x - _resBlock.x_result, _tri.b.y - _resBlock.y_result)] = _cornerColor;
				if (_tri.c.x >= clipLeft && _tri.c.x < clipRight && _tri.c.y >= clipTop && _tri.c.y < clipBottom)
					_resBlock.color[getResultBlockPixelIndex(_tri.c.x - _resBlock.x_result, _tri.c.y - _resBlock.y_result)] = _cornerColor;
#endif
			}
			inline void drawClippedTriangle_Masked(ResultBlock& _resBlock, const ResultInstruction& _resInstr, Triangle _tri, const Byte _dataTypesToDrawFlags, Color _color = 0x00000000, Color _cornerColor = 0x00000000)
			{
				// get clipping bounds
				int clipLeft	= _resBlock.x_result;
				int clipRight	= _resBlock.x_result + RESULT_BLOCK_WIDTH;
				int clipTop		= _resBlock.y_result;
				int clipBottom	= _resBlock.y_result + RESULT_BLOCK_HEIGHT;

				// reject triangles not within horizontal bounds
				if (_tri.a.x < clipLeft && _tri.b.x < clipLeft && _tri.c.x < clipLeft)
					return;
				if (_tri.a.x > clipRight && _tri.b.x > clipRight && _tri.c.x > clipRight)
					return;

				// sort triangle points from top to bottom
				Point swap;
				if (_tri.a.y > _tri.b.y)
				{
					swap = _tri.a;
					_tri.a = _tri.b;
					_tri.b = swap;
				}
				if (_tri.a.y > _tri.c.y)
				{
					swap = _tri.c;
					_tri.c = _tri.a;
					_tri.a = swap;
				}
				if (_tri.b.y > _tri.c.y)
				{
					swap = _tri.c;
					_tri.c = _tri.b;
					_tri.b = swap;
				}

				// reject triangles not within vertical bounds
				if (_tri.c.y < clipTop || _tri.a.y > clipBottom)
					return;

				// calculate slopes between all points
				float slope_ac = (_tri.c.x - _tri.a.x) / static_cast<float>(_tri.c.y - _tri.a.y);
				float slope_ab = (_tri.b.x - _tri.a.x) / static_cast<float>(_tri.b.y - _tri.a.y);
				float slope_bc = (_tri.c.x - _tri.b.x) / static_cast<float>(_tri.c.y - _tri.b.y);

				// start at top point if it is within vertical bounds, otherwise start at top of block
				int start_y = (_tri.a.y > clipTop) ? _tri.a.y : clipTop;
				// end at middle point if it is within vertical bounds, otherwise end at bottom of block
				int end_y = (_tri.b.y < clipBottom) ? _tri.b.y : clipBottom;

				// compute start and end x
				float start_x = ((_tri.c.x - _tri.a.x) * ((start_y - _tri.a.y) / static_cast<float>(_tri.c.y - _tri.a.y))) + _tri.a.x;
				float end_x = static_cast<float>(_tri.b.x); // initializing to the middle point's x handles edge cases where a triangle has a flat top
				if (start_y < _tri.b.y)
					end_x = ((_tri.b.x - _tri.a.x) * ((start_y - _tri.a.y) / static_cast<float>(_tri.b.y - _tri.a.y))) + _tri.a.x;
				else if (start_y > _tri.b.y)
					end_x = ((_tri.c.x - _tri.b.x) * (1.0f - ((_tri.c.y - start_y) / static_cast<float>(_tri.c.y - _tri.b.y)))) + _tri.b.x;

				// flip start and end if needed to make the rest of the logic simpler
				float flip = std::numeric_limits<float>::quiet_NaN();
				if (start_x + slope_ac > end_x + slope_ab)
				{
					flip = start_x;
					start_x = end_x;
					end_x = flip;
					flip = slope_ac;
					slope_ac = slope_ab;
					slope_ab = flip;
				}

				// draw data types indicated by flags
				// color data
				if (_dataTypesToDrawFlags & INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR)
				{
					float color_start_x = start_x;
					int color_start_y = start_y;
					float color_end_x = end_x;
					int color_end_y = end_y;
					float color_slope_ab = slope_ab;
					float color_slope_ac = slope_ac;
					float color_slope_bc = slope_bc;
					// execute the following logic twice
					for (int i = 0; i < 2; ++i)
					{
						// loop while start_y < end_y (might be skipped)
						for (; color_start_y < color_end_y; ++color_start_y)
						{
							// clip start and end x to boundary (temporary)
							int left = static_cast<int>(color_start_x + 0.5f);
							if (left < clipLeft)
								left = clipLeft;
							int right = static_cast<int>(color_end_x + 0.5f);
							if (right > clipRight)
								right = clipRight;
							unsigned int index = getResultBlockPixelIndex(left - _resBlock.x_result, color_start_y - _resBlock.y_result); // offset to be relative to this result block
							// traverse and fill
							for (; left < right; ++left, ++index)
							{
#if defined(GBLITTER_DEBUG_DISABLE_TRANSFORMED_COLOR_LOOKUP) || defined(GBLITTER_DEBUG_FILL_TRANSFORMED_TRIANGLES)
								_resBlock.color[index] = _color;
#endif
#if !defined(GBLITTER_DEBUG_DISABLE_TRANSFORMED_COLOR_LOOKUP)
								// draw reverse-lookup color with false-positive checking
								//   (theoretically, this error checking doesn't need to be here; however, at the moment the triangle drawing algorithm produces false
								//     positives around the edges, which can cause an out-of-bounds exception when trying to reverse-lookup colors for those pixels)
								Vector2 coord = getResInstrReverseLookupCoord(_resInstr, left, color_start_y);
								if (checkResInstrReverseLookupCoord(_resInstr, coord))
								{
									// sample color from source and XOR it with instruction's mask color
									Color color_pseudoSrc = reverseLookupColorFromSource(_resInstr.source_id, coord) ^ _resInstr.mask_color;
									// use pseudo-source color to generate blending mask value
									Color color_mask = (-1 + (((color_pseudoSrc | (~color_pseudoSrc + 1)) >> 31) & 1));
									// draw color to result using mask (color drawn will either be existing color in result or new color from source)
									_resBlock.color[index] = (_resBlock.color[index] & color_mask) | ((color_pseudoSrc ^ _resInstr.mask_color) & (~color_mask));
								}

								// draw reverse-lookup color with no error checking
								//   (this can't be used until the false positives mentioned above have been dealt with)
								//// sample color from source and XOR it with instruction's mask color
								//Color color_pseudoSrc = reverseLookupColorFromSource(_resInstr.source_id, getResInstrReverseLookupCoord(_resInstr, left, color_start_y)) ^ _resInstr.mask_color;
								//// use pseudo-source color to generate blending mask value
								//Color color_mask = (-1 + (((color_pseudoSrc | (~color_pseudoSrc + 1)) >> 31) & 1));
								//// draw color to result using mask (color drawn will either be existing color in result or new color from source)
								//_resBlock.color[index] = (_resBlock.color[index] & color_mask) | ((color_pseudoSrc ^ _resInstr.mask_color & ~color_mask));
#endif
							}
							// adjust start and end x by slope
							color_start_x += color_slope_ac;
							color_end_x += color_slope_ab;
						}
						color_end_y = (_tri.c.y < clipBottom) ? static_cast<int>(_tri.c.y) : clipBottom;
						// if direction was flipped previously, adjust slope traversal
						std::isnan(flip) ? color_slope_ab = color_slope_bc : color_slope_ac = color_slope_bc;
					}
				}
				// layer data
				float layer_start_x = start_x;
				int layer_start_y = start_y;
				float layer_end_x = end_x;
				int layer_end_y = end_y;
				float layer_slope_ab = slope_ab;
				float layer_slope_ac = slope_ac;
				float layer_slope_bc = slope_bc;
				// use layer data from source if set, otherwise use instruction's layer override value
				if (_dataTypesToDrawFlags & INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER)
					// execute the following logic twice
					for (int i = 0; i < 2; ++i)
					{
						// loop while start_y < end_y (might be skipped)
						for (; layer_start_y < layer_end_y; ++layer_start_y)
						{
							// clip start and end x to boundary (temporary)
							int left = static_cast<int>(layer_start_x + 0.5f);
							if (left < clipLeft)
								left = clipLeft;
							int right = static_cast<int>(layer_end_x + 0.5f);
							if (right > clipRight)
								right = clipRight;
							unsigned int index = getResultBlockPixelIndex(left - _resBlock.x_result, layer_start_y - _resBlock.y_result); // offset to be relative to this result block
							// traverse and fill
							for (; left < right; ++left, ++index)
							{
								// draw reverse-lookup layer with false-positive checking
								//   (theoretically, this error checking doesn't need to be here; however, at the moment the triangle drawing algorithm produces false
								//     positives around the edges, which can cause an out-of-bounds exception when trying to reverse-lookup colors for those pixels)
								Vector2 coord = getResInstrReverseLookupCoord(_resInstr, left, layer_start_y);
								if (checkResInstrReverseLookupCoord(_resInstr, coord))
									_resBlock.layer[index] = reverseLookupLayerFromSource(_resInstr.source_id, coord);

								// draw reverse-lookup layer with no error checking
								//   (this can't be used until the false positives mentioned above have been dealt with)
								//_resBlock.layer[index] = reverseLookupLayerFromSource(_resInstr.source_id, getResInstrReverseLookupCoord(_resInstr, left, layer_start_y));
							}
							// adjust start and end x by slope
							layer_start_x += layer_slope_ac;
							layer_end_x += layer_slope_ab;
						}
						layer_end_y = (_tri.c.y < clipBottom) ? static_cast<int>(_tri.c.y) : clipBottom;
						// if direction was flipped previously, adjust slope traversal
						std::isnan(flip) ? layer_slope_ab = layer_slope_bc : layer_slope_ac = layer_slope_bc;
					}
				else
					// execute the following logic twice
					for (int i = 0; i < 2; ++i)
					{
						// loop while start_y < end_y (might be skipped)
						for (; layer_start_y < layer_end_y; ++layer_start_y)
						{
							// clip start and end x to boundary (temporary)
							int left = static_cast<int>(layer_start_x + 0.5f);
							if (left < clipLeft)
								left = clipLeft;
							int right = static_cast<int>(layer_end_x + 0.5f);
							if (right > clipRight)
								right = clipRight;
							unsigned int index = getResultBlockPixelIndex(left - _resBlock.x_result, layer_start_y - _resBlock.y_result); // offset to be relative to this result block
							// traverse and fill
							for (; left < right; ++left, ++index)
							{
								// draw reverse-lookup layer with false-positive checking
								//   (theoretically, this error checking doesn't need to be here; however, at the moment the triangle drawing algorithm produces false
								//     positives around the edges, which can cause an out-of-bounds exception when trying to reverse-lookup colors for those pixels)
								Vector2 coord = getResInstrReverseLookupCoord(_resInstr, left, layer_start_y);
								if (checkResInstrReverseLookupCoord(_resInstr, coord))
									_resBlock.layer[index] = _resInstr.layer_override;

								// draw reverse-lookup layer with no error checking
								//   (this can't be used until the false positives mentioned above have been dealt with)
								//_resBlock.layer[index] = _resInstr.layer_override;
							}
							// adjust start and end x by slope
							layer_start_x += layer_slope_ac;
							layer_end_x += layer_slope_ab;
						}
						layer_end_y = (_tri.c.y < clipBottom) ? static_cast<int>(_tri.c.y) : clipBottom;
						// if direction was flipped previously, adjust slope traversal
						std::isnan(flip) ? layer_slope_ab = layer_slope_bc : layer_slope_ac = layer_slope_bc;
					}
				// stencil data
				float stencil_start_x = start_x;
				int stencil_start_y = start_y;
				float stencil_end_x = end_x;
				int stencil_end_y = end_y;
				float stencil_slope_ab = slope_ab;
				float stencil_slope_ac = slope_ac;
				float stencil_slope_bc = slope_bc;
				// use stencil data from source if set, otherwise use instruction's stencil override value
				if (_dataTypesToDrawFlags & INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL)
					// execute the following logic twice
					for (int i = 0; i < 2; ++i)
					{
						// loop while start_y < end_y (might be skipped)
						for (; stencil_start_y < stencil_end_y; ++stencil_start_y)
						{
							// clip start and end x to boundary (temporary)
							int left = static_cast<int>(stencil_start_x + 0.5f);
							if (left < clipLeft)
								left = clipLeft;
							int right = static_cast<int>(stencil_end_x + 0.5f);
							if (right > clipRight)
								right = clipRight;
							unsigned int index = getResultBlockPixelIndex(left - _resBlock.x_result, stencil_start_y - _resBlock.y_result); // offset to be relative to this result block
							// traverse and fill
							for (; left < right; ++left, ++index)
							{
								// draw reverse-lookup stencil with false-positive checking
								//   (theoretically, this error checking doesn't need to be here; however, at the moment the triangle drawing algorithm produces false
								//     positives around the edges, which can cause an out-of-bounds exception when trying to reverse-lookup colors for those pixels)
								Vector2 coord = getResInstrReverseLookupCoord(_resInstr, left, stencil_start_y);
								if (checkResInstrReverseLookupCoord(_resInstr, coord))
									_resBlock.stencil[index] = reverseLookupStencilFromSource(_resInstr.source_id, coord);

								// draw reverse-lookup stencil with no error checking
								//   (this can't be used until the false positives mentioned above have been dealt with)
								//_resBlock.stencil[index] = reverseLookupStencilFromSource(_resInstr.source_id, getResInstrReverseLookupCoord(_resInstr, left, start_y));
							}
							// adjust start and end x by slope
							stencil_start_x += stencil_slope_ac;
							stencil_end_x += stencil_slope_ab;
						}
						stencil_end_y = (_tri.c.y < clipBottom) ? static_cast<int>(_tri.c.y) : clipBottom;
						// if direction was flipped previously, adjust slope traversal
						std::isnan(flip) ? stencil_slope_ab = stencil_slope_bc : stencil_slope_ac = stencil_slope_bc;
					}
				else
					// execute the following logic twice
					for (int i = 0; i < 2; ++i)
					{
						// loop while start_y < end_y (might be skipped)
						for (; stencil_start_y < stencil_end_y; ++stencil_start_y)
						{
							// clip start and end x to boundary (temporary)
							int left = static_cast<int>(stencil_start_x + 0.5f);
							if (left < clipLeft)
								left = clipLeft;
							int right = static_cast<int>(stencil_end_x + 0.5f);
							if (right > clipRight)
								right = clipRight;
							unsigned int index = getResultBlockPixelIndex(left - _resBlock.x_result, stencil_start_y - _resBlock.y_result); // offset to be relative to this result block
							// traverse and fill
							for (; left < right; ++left, ++index)
							{
								// draw reverse-lookup stencil with false-positive checking
								//   (theoretically, this error checking doesn't need to be here; however, at the moment the triangle drawing algorithm produces false
								//     positives around the edges, which can cause an out-of-bounds exception when trying to reverse-lookup colors for those pixels)
								Vector2 coord = getResInstrReverseLookupCoord(_resInstr, left, stencil_start_y);
								if (checkResInstrReverseLookupCoord(_resInstr, coord))
									_resBlock.stencil[index] = _resInstr.stencil_override;

								// draw reverse-lookup stencil with no error checking
								//   (this can't be used until the false positives mentioned above have been dealt with)
								//_resBlock.stencil[index] = _resInstr.stencil_override;
							}
							// adjust start and end x by slope
							stencil_start_x += stencil_slope_ac;
							stencil_end_x += stencil_slope_ab;
						}
						stencil_end_y = (_tri.c.y < clipBottom) ? static_cast<int>(_tri.c.y) : clipBottom;
						// if direction was flipped previously, adjust slope traversal
						std::isnan(flip) ? stencil_slope_ab = stencil_slope_bc : stencil_slope_ac = stencil_slope_bc;
					}

				// DEBUG draw corners
#if defined(GBLITTER_DEBUG_DRAW_TRANSFORMED_TRIANGLE_CORNERS)
				// max corners in each dimension are 1 pixel past the last pixels drawn to, since corner positions are geometric rather than pixel-space
				//   (pixel-space coordinates use integers only, which means a pixel-space shape spans [min, max), rather than a geometric shape which spans [min, max] )
				if (_tri.a.x >= clipLeft && _tri.a.x < clipRight && _tri.a.y >= clipTop && _tri.a.y < clipBottom)
					_resBlock.color[getResultBlockPixelIndex(_tri.a.x - _resBlock.x_result, _tri.a.y - _resBlock.y_result)] = _cornerColor;
				if (_tri.b.x >= clipLeft && _tri.b.x < clipRight && _tri.b.y >= clipTop && _tri.b.y < clipBottom)
					_resBlock.color[getResultBlockPixelIndex(_tri.b.x - _resBlock.x_result, _tri.b.y - _resBlock.y_result)] = _cornerColor;
				if (_tri.c.x >= clipLeft && _tri.c.x < clipRight && _tri.c.y >= clipTop && _tri.c.y < clipBottom)
					_resBlock.color[getResultBlockPixelIndex(_tri.c.x - _resBlock.x_result, _tri.c.y - _resBlock.y_result)] = _cornerColor;
#endif
			}
			inline void drawClippedTriangle_Transparent(ResultBlock& _resBlock, const ResultInstruction& _resInstr, Triangle _tri, const Byte _dataTypesToDrawFlags, Color _color = 0x00000000, Color _cornerColor = 0x00000000)
			{
				// get clipping bounds
				int clipLeft	= _resBlock.x_result;
				int clipRight	= _resBlock.x_result + RESULT_BLOCK_WIDTH;
				int clipTop		= _resBlock.y_result;
				int clipBottom	= _resBlock.y_result + RESULT_BLOCK_HEIGHT;

				// reject triangles not within horizontal bounds
				if (_tri.a.x < clipLeft && _tri.b.x < clipLeft && _tri.c.x < clipLeft)
					return;
				if (_tri.a.x > clipRight && _tri.b.x > clipRight && _tri.c.x > clipRight)
					return;

				// sort triangle points from top to bottom
				Point swap;
				if (_tri.a.y > _tri.b.y)
				{
					swap = _tri.a;
					_tri.a = _tri.b;
					_tri.b = swap;
				}
				if (_tri.a.y > _tri.c.y)
				{
					swap = _tri.c;
					_tri.c = _tri.a;
					_tri.a = swap;
				}
				if (_tri.b.y > _tri.c.y)
				{
					swap = _tri.c;
					_tri.c = _tri.b;
					_tri.b = swap;
				}

				// reject triangles not within vertical bounds
				if (_tri.c.y < clipTop || _tri.a.y > clipBottom)
					return;

				// calculate slopes between all points
				float slope_ac = (_tri.c.x - _tri.a.x) / static_cast<float>(_tri.c.y - _tri.a.y);
				float slope_ab = (_tri.b.x - _tri.a.x) / static_cast<float>(_tri.b.y - _tri.a.y);
				float slope_bc = (_tri.c.x - _tri.b.x) / static_cast<float>(_tri.c.y - _tri.b.y);

				// start at top point if it is within vertical bounds, otherwise start at top of block
				int start_y = (_tri.a.y > clipTop) ? _tri.a.y : clipTop;
				// end at middle point if it is within vertical bounds, otherwise end at bottom of block
				int end_y = (_tri.b.y < clipBottom) ? _tri.b.y : clipBottom;

				// compute start and end x
				float start_x = ((_tri.c.x - _tri.a.x) * ((start_y - _tri.a.y) / static_cast<float>(_tri.c.y - _tri.a.y))) + _tri.a.x;
				float end_x = static_cast<float>(_tri.b.x); // initializing to the middle point's x handles edge cases where a triangle has a flat top
				if (start_y < _tri.b.y)
					end_x = ((_tri.b.x - _tri.a.x) * ((start_y - _tri.a.y) / static_cast<float>(_tri.b.y - _tri.a.y))) + _tri.a.x;
				else if (start_y > _tri.b.y)
					end_x = ((_tri.c.x - _tri.b.x) * (1.0f - ((_tri.c.y - start_y) / static_cast<float>(_tri.c.y - _tri.b.y)))) + _tri.b.x;

				// flip start and end if needed to make the rest of the logic simpler
				float flip = std::numeric_limits<float>::quiet_NaN();
				if (start_x + slope_ac > end_x + slope_ab)
				{
					flip = start_x;
					start_x = end_x;
					end_x = flip;
					flip = slope_ac;
					slope_ac = slope_ab;
					slope_ab = flip;
				}

				// draw data types indicated by flags
				// color data
				if (_dataTypesToDrawFlags & INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR)
				{
					float color_start_x = start_x;
					int color_start_y = start_y;
					float color_end_x = end_x;
					int color_end_y = end_y;
					float color_slope_ab = slope_ab;
					float color_slope_ac = slope_ac;
					float color_slope_bc = slope_bc;
					// execute the following logic twice
					for (int i = 0; i < 2; ++i)
					{
						// loop while start_y < end_y (might be skipped)
						for (; color_start_y < color_end_y; ++color_start_y)
						{
							// clip start and end x to boundary (temporary)
							int left = static_cast<int>(color_start_x + 0.5f);
							if (left < clipLeft)
								left = clipLeft;
							int right = static_cast<int>(color_end_x + 0.5f);
							if (right > clipRight)
								right = clipRight;
							unsigned int index = getResultBlockPixelIndex(left - _resBlock.x_result, color_start_y - _resBlock.y_result); // offset to be relative to this result block
							// traverse and fill
							for (; left < right; ++left, ++index)
							{
#if defined(GBLITTER_DEBUG_DISABLE_TRANSFORMED_COLOR_LOOKUP) || defined(GBLITTER_DEBUG_FILL_TRANSFORMED_TRIANGLES)
								_resBlock.color[index] = _color;
#endif
#if !defined(GBLITTER_DEBUG_DISABLE_TRANSFORMED_COLOR_LOOKUP)
								// draw reverse-lookup color with false-positive checking
								//   (theoretically, this error checking doesn't need to be here; however, at the moment the triangle drawing algorithm produces false
								//     positives around the edges, which can cause an out-of-bounds exception when trying to reverse-lookup colors for those pixels)
								Vector2 coord = getResInstrReverseLookupCoord(_resInstr, left, color_start_y);
								if (checkResInstrReverseLookupCoord(_resInstr, coord))
									_resBlock.color[index] = fixedPointColorLerp(_resBlock.color[index], reverseLookupColorFromSource(_resInstr.source_id, coord));

								// draw reverse-lookup color with no error checking
								//   (this can't be used until the false positives mentioned above have been dealt with)
								//_resBlock.color[index] = fixedPointColorLerp(_resBlock.color[index], reverseLookupColorFromSource(_resInstr.source_id, getResInstrReverseLookupCoord(_resInstr, left, color_start_y)));
#endif
							}
							// adjust start and end x by slope
							color_start_x += color_slope_ac;
							color_end_x += color_slope_ab;
						}
						color_end_y = (_tri.c.y < clipBottom) ? static_cast<int>(_tri.c.y) : clipBottom;
						// if direction was flipped previously, adjust slope traversal
						std::isnan(flip) ? color_slope_ab = color_slope_bc : color_slope_ac = color_slope_bc;
					}
				}
				// layer data
				float layer_start_x = start_x;
				int layer_start_y = start_y;
				float layer_end_x = end_x;
				int layer_end_y = end_y;
				float layer_slope_ab = slope_ab;
				float layer_slope_ac = slope_ac;
				float layer_slope_bc = slope_bc;
				// use source layers if flag is set, otherwise use override value from instruction
				if (_dataTypesToDrawFlags & INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER)
					// execute the following logic twice
					for (int i = 0; i < 2; ++i)
					{
						// loop while start_y < end_y (might be skipped)
						for (; layer_start_y < layer_end_y; ++layer_start_y)
						{
							// clip start and end x to boundary (temporary)
							int left = static_cast<int>(layer_start_x + 0.5f);
							if (left < clipLeft)
								left = clipLeft;
							int right = static_cast<int>(layer_end_x + 0.5f);
							if (right > clipRight)
								right = clipRight;
							unsigned int index = getResultBlockPixelIndex(left - _resBlock.x_result, layer_start_y - _resBlock.y_result); // offset to be relative to this result block
							// traverse and fill
							for (; left < right; ++left, ++index)
							{
								// draw reverse-lookup layer with false-positive checking
								//   (theoretically, this error checking doesn't need to be here; however, at the moment the triangle drawing algorithm produces false
								//     positives around the edges, which can cause an out-of-bounds exception when trying to reverse-lookup colors for those pixels)
								Vector2 coord = getResInstrReverseLookupCoord(_resInstr, left, layer_start_y);
								if (checkResInstrReverseLookupCoord(_resInstr, coord))
									_resBlock.layer[index] = reverseLookupLayerFromSource(_resInstr.source_id, coord);

								// draw reverse-lookup layer with no error checking
								//   (this can't be used until the false positives mentioned above have been dealt with)
								//_resBlock.layer[index] = reverseLookupLayerFromSource(_resInstr.source_id, getResInstrReverseLookupCoord(_resInstr, left, layer_start_y));
							}
							// adjust start and end x by slope
							layer_start_x += layer_slope_ac;
							layer_end_x += layer_slope_ab;
						}
						layer_end_y = (_tri.c.y < clipBottom) ? static_cast<int>(_tri.c.y) : clipBottom;
						// if direction was flipped previously, adjust slope traversal
						std::isnan(flip) ? layer_slope_ab = layer_slope_bc : layer_slope_ac = layer_slope_bc;
					}
				else
					// execute the following logic twice
					for (int i = 0; i < 2; ++i)
					{
						// loop while start_y < end_y (might be skipped)
						for (; layer_start_y < layer_end_y; ++layer_start_y)
						{
							// clip start and end x to boundary (temporary)
							int left = static_cast<int>(layer_start_x + 0.5f);
							if (left < clipLeft)
								left = clipLeft;
							int right = static_cast<int>(layer_end_x + 0.5f);
							if (right > clipRight)
								right = clipRight;
							unsigned int index = getResultBlockPixelIndex(left - _resBlock.x_result, layer_start_y - _resBlock.y_result); // offset to be relative to this result block
							// traverse and fill
							for (; left < right; ++left, ++index)
							{
								// draw reverse-lookup layer with false-positive checking
								//   (theoretically, this error checking doesn't need to be here; however, at the moment the triangle drawing algorithm produces false
								//     positives around the edges, which can cause an out-of-bounds exception when trying to reverse-lookup colors for those pixels)
								Vector2 coord = getResInstrReverseLookupCoord(_resInstr, left, layer_start_y);
								if (checkResInstrReverseLookupCoord(_resInstr, coord))
									_resBlock.layer[index] = _resInstr.layer_override;

								// draw reverse-lookup layer with no error checking
								//   (this can't be used until the false positives mentioned above have been dealt with)
								//_resBlock.layer[index] = _resInstr.layer_override;
							}
							// adjust start and end x by slope
							layer_start_x += layer_slope_ac;
							layer_end_x += layer_slope_ab;
						}
						layer_end_y = (_tri.c.y < clipBottom) ? static_cast<int>(_tri.c.y) : clipBottom;
						// if direction was flipped previously, adjust slope traversal
						std::isnan(flip) ? layer_slope_ab = layer_slope_bc : layer_slope_ac = layer_slope_bc;
					}
				// stencil data
				float stencil_start_x = start_x;
				int stencil_start_y = start_y;
				float stencil_end_x = end_x;
				int stencil_end_y = end_y;
				float stencil_slope_ab = slope_ab;
				float stencil_slope_ac = slope_ac;
				float stencil_slope_bc = slope_bc;
				if (_dataTypesToDrawFlags & INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL)
					// execute the following logic twice
					for (int i = 0; i < 2; ++i)
					{
						// loop while start_y < end_y (might be skipped)
						for (; stencil_start_y < stencil_end_y; ++stencil_start_y)
						{
							// clip start and end x to boundary (temporary)
							int left = static_cast<int>(stencil_start_x + 0.5f);
							if (left < clipLeft)
								left = clipLeft;
							int right = static_cast<int>(stencil_end_x + 0.5f);
							if (right > clipRight)
								right = clipRight;
							unsigned int index = getResultBlockPixelIndex(left - _resBlock.x_result, stencil_start_y - _resBlock.y_result); // offset to be relative to this result block
							// traverse and fill
							for (; left < right; ++left, ++index)
							{
								// draw reverse-lookup stencil with false-positive checking
								//   (theoretically, this error checking doesn't need to be here; however, at the moment the triangle drawing algorithm produces false
								//     positives around the edges, which can cause an out-of-bounds exception when trying to reverse-lookup colors for those pixels)
								Vector2 coord = getResInstrReverseLookupCoord(_resInstr, left, stencil_start_y);
								if (checkResInstrReverseLookupCoord(_resInstr, coord))
									_resBlock.stencil[index] = reverseLookupStencilFromSource(_resInstr.source_id, coord);

								// draw reverse-lookup stencil with no error checking
								//   (this can't be used until the false positives mentioned above have been dealt with)
								//_resBlock.stencil[index] = reverseLookupStencilFromSource(_resInstr.source_id, getResInstrReverseLookupCoord(_resInstr, left, start_y));
							}
							// adjust start and end x by slope
							stencil_start_x += stencil_slope_ac;
							stencil_end_x += stencil_slope_ab;
						}
						stencil_end_y = (_tri.c.y < clipBottom) ? static_cast<int>(_tri.c.y) : clipBottom;
						// if direction was flipped previously, adjust slope traversal
						std::isnan(flip) ? stencil_slope_ab = stencil_slope_bc : stencil_slope_ac = stencil_slope_bc;
					}
				else
					// execute the following logic twice
					for (int i = 0; i < 2; ++i)
					{
						// loop while start_y < end_y (might be skipped)
						for (; stencil_start_y < stencil_end_y; ++stencil_start_y)
						{
							// clip start and end x to boundary (temporary)
							int left = static_cast<int>(stencil_start_x + 0.5f);
							if (left < clipLeft)
								left = clipLeft;
							int right = static_cast<int>(stencil_end_x + 0.5f);
							if (right > clipRight)
								right = clipRight;
							unsigned int index = getResultBlockPixelIndex(left - _resBlock.x_result, stencil_start_y - _resBlock.y_result); // offset to be relative to this result block
							// traverse and fill
							for (; left < right; ++left, ++index)
							{
								// draw reverse-lookup stencil with false-positive checking
								//   (theoretically, this error checking doesn't need to be here; however, at the moment the triangle drawing algorithm produces false
								//     positives around the edges, which can cause an out-of-bounds exception when trying to reverse-lookup colors for those pixels)
								Vector2 coord = getResInstrReverseLookupCoord(_resInstr, left, stencil_start_y);
								if (checkResInstrReverseLookupCoord(_resInstr, coord))
									_resBlock.stencil[index] = _resInstr.stencil_override;

								// draw reverse-lookup stencil with no error checking
								//   (this can't be used until the false positives mentioned above have been dealt with)
								//_resBlock.stencil[index] = _resInstr.stencil_override;
							}
							// adjust start and end x by slope
							stencil_start_x += stencil_slope_ac;
							stencil_end_x += stencil_slope_ab;
						}
						stencil_end_y = (_tri.c.y < clipBottom) ? static_cast<int>(_tri.c.y) : clipBottom;
						// if direction was flipped previously, adjust slope traversal
						std::isnan(flip) ? stencil_slope_ab = stencil_slope_bc : stencil_slope_ac = stencil_slope_bc;
					}

				// DEBUG draw corners
#if defined(GBLITTER_DEBUG_DRAW_TRANSFORMED_TRIANGLE_CORNERS)
				// max corners in each dimension are 1 pixel past the last pixels drawn to, since corner positions are geometric rather than pixel-space
				//   (pixel-space coordinates use integers only, which means a pixel-space shape spans [min, max), rather than a geometric shape which spans [min, max] )
				if (_tri.a.x >= clipLeft && _tri.a.x < clipRight && _tri.a.y >= clipTop && _tri.a.y < clipBottom)
					_resBlock.color[getResultBlockPixelIndex(_tri.a.x - _resBlock.x_result, _tri.a.y - _resBlock.y_result)] = _cornerColor;
				if (_tri.b.x >= clipLeft && _tri.b.x < clipRight && _tri.b.y >= clipTop && _tri.b.y < clipBottom)
					_resBlock.color[getResultBlockPixelIndex(_tri.b.x - _resBlock.x_result, _tri.b.y - _resBlock.y_result)] = _cornerColor;
				if (_tri.c.x >= clipLeft && _tri.c.x < clipRight && _tri.c.y >= clipTop && _tri.c.y < clipBottom)
					_resBlock.color[getResultBlockPixelIndex(_tri.c.x - _resBlock.x_result, _tri.c.y - _resBlock.y_result)] = _cornerColor;
#endif
			}
			inline void drawClippedTriangle_Transparent_Masked(ResultBlock& _resBlock, const ResultInstruction& _resInstr, Triangle _tri, const Byte _dataTypesToDrawFlags, Color _color = 0x00000000, Color _cornerColor = 0x00000000)
			{
				// get clipping bounds
				int clipLeft	= _resBlock.x_result;
				int clipRight	= _resBlock.x_result + RESULT_BLOCK_WIDTH;
				int clipTop		= _resBlock.y_result;
				int clipBottom	= _resBlock.y_result + RESULT_BLOCK_HEIGHT;

				// reject triangles not within horizontal bounds
				if (_tri.a.x < clipLeft && _tri.b.x < clipLeft && _tri.c.x < clipLeft)
					return;
				if (_tri.a.x > clipRight && _tri.b.x > clipRight && _tri.c.x > clipRight)
					return;

				// sort triangle points from top to bottom
				Point swap;
				if (_tri.a.y > _tri.b.y)
				{
					swap = _tri.a;
					_tri.a = _tri.b;
					_tri.b = swap;
				}
				if (_tri.a.y > _tri.c.y)
				{
					swap = _tri.c;
					_tri.c = _tri.a;
					_tri.a = swap;
				}
				if (_tri.b.y > _tri.c.y)
				{
					swap = _tri.c;
					_tri.c = _tri.b;
					_tri.b = swap;
				}

				// reject triangles not within vertical bounds
				if (_tri.c.y < clipTop || _tri.a.y > clipBottom)
					return;

				// calculate slopes between all points
				float slope_ac = (_tri.c.x - _tri.a.x) / static_cast<float>(_tri.c.y - _tri.a.y);
				float slope_ab = (_tri.b.x - _tri.a.x) / static_cast<float>(_tri.b.y - _tri.a.y);
				float slope_bc = (_tri.c.x - _tri.b.x) / static_cast<float>(_tri.c.y - _tri.b.y);

				// start at top point if it is within vertical bounds, otherwise start at top of block
				int start_y = (_tri.a.y > clipTop) ? _tri.a.y : clipTop;
				// end at middle point if it is within vertical bounds, otherwise end at bottom of block
				int end_y = (_tri.b.y < clipBottom) ? _tri.b.y : clipBottom;

				// compute start and end x
				float start_x = ((_tri.c.x - _tri.a.x) * ((start_y - _tri.a.y) / static_cast<float>(_tri.c.y - _tri.a.y))) + _tri.a.x;
				float end_x = static_cast<float>(_tri.b.x); // initializing to the middle point's x handles edge cases where a triangle has a flat top
				if (start_y < _tri.b.y)
					end_x = ((_tri.b.x - _tri.a.x) * ((start_y - _tri.a.y) / static_cast<float>(_tri.b.y - _tri.a.y))) + _tri.a.x;
				else if (start_y > _tri.b.y)
					end_x = ((_tri.c.x - _tri.b.x) * (1.0f - ((_tri.c.y - start_y) / static_cast<float>(_tri.c.y - _tri.b.y)))) + _tri.b.x;

				// flip start and end if needed to make the rest of the logic simpler
				float flip = std::numeric_limits<float>::quiet_NaN();
				if (start_x + slope_ac > end_x + slope_ab)
				{
					flip = start_x;
					start_x = end_x;
					end_x = flip;
					flip = slope_ac;
					slope_ac = slope_ab;
					slope_ab = flip;
				}

				// draw data types indicated by flags
				// color data
				if (_dataTypesToDrawFlags & INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR)
				{
					float color_start_x = start_x;
					int color_start_y = start_y;
					float color_end_x = end_x;
					int color_end_y = end_y;
					float color_slope_ab = slope_ab;
					float color_slope_ac = slope_ac;
					float color_slope_bc = slope_bc;
					// execute the following logic twice
					for (int i = 0; i < 2; ++i)
					{
						// loop while start_y < end_y (might be skipped)
						for (; color_start_y < color_end_y; ++color_start_y)
						{
							// clip start and end x to boundary (temporary)
							int left = static_cast<int>(color_start_x + 0.5f);
							if (left < clipLeft)
								left = clipLeft;
							int right = static_cast<int>(color_end_x + 0.5f);
							if (right > clipRight)
								right = clipRight;
							unsigned int index = getResultBlockPixelIndex(left - _resBlock.x_result, color_start_y - _resBlock.y_result); // offset to be relative to this result block
							// traverse and fill
							for (; left < right; ++left, ++index)
							{
#if defined(GBLITTER_DEBUG_DISABLE_TRANSFORMED_COLOR_LOOKUP) || defined(GBLITTER_DEBUG_FILL_TRANSFORMED_TRIANGLES)
								_resBlock.color[index] = _color;
#endif
#if !defined(GBLITTER_DEBUG_DISABLE_TRANSFORMED_COLOR_LOOKUP)
								// draw reverse-lookup color with false-positive checking
								//   (theoretically, this error checking doesn't need to be here; however, at the moment the triangle drawing algorithm produces false
								//     positives around the edges, which can cause an out-of-bounds exception when trying to reverse-lookup colors for those pixels)
								Vector2 coord = getResInstrReverseLookupCoord(_resInstr, left, color_start_y);
								if (checkResInstrReverseLookupCoord(_resInstr, coord))
								{
									// sample color from source and XOR it with instruction's mask color
									Color color_pseudoSrc = reverseLookupColorFromSource(_resInstr.source_id, coord) ^ _resInstr.mask_color;
									// use pseudo-source color to generate blending mask value
									Color color_mask = (-1 + (((color_pseudoSrc | (~color_pseudoSrc + 1)) >> 31) & 1));
									// draw color to result using alpha blending and mask (color blended will either be existing color in result or new color from source)
									_resBlock.color[index] = fixedPointColorLerp(_resBlock.color[index], (_resBlock.color[index] & color_mask) | ((color_pseudoSrc ^ _resInstr.mask_color) & (~color_mask)));
								}

								// draw reverse-lookup color with no error checking
								//   (this can't be used until the false positives mentioned above have been dealt with)
								//// sample color from source and XOR it with instruction's mask color
								//Color color_pseudoSrc = reverseLookupColorFromSource(_resInstr.source_id, getResInstrReverseLookupCoord(_resInstr, left, color_start_y)) ^ _resInstr.mask_color;
								//// use pseudo-source color to generate blending mask value
								//Color color_mask = (-1 + (((color_pseudoSrc | (~color_pseudoSrc + 1)) >> 31) & 1));
								//// draw color to result using alpha blending and mask (color blended will either be existing color in result or new color from source)
								//_resBlock.color[index] = fixedPointColorLerp(_resBlock.color[index], (_resBlock.color[index] & color_mask) | ((color_pseudoSrc ^ _resInstr.mask_color & ~color_mask)));
#endif
							}
							// adjust start and end x by slope
							color_start_x += color_slope_ac;
							color_end_x += color_slope_ab;
						}
						color_end_y = (_tri.c.y < clipBottom) ? static_cast<int>(_tri.c.y) : clipBottom;
						// if direction was flipped previously, adjust slope traversal
						std::isnan(flip) ? color_slope_ab = color_slope_bc : color_slope_ac = color_slope_bc;
					}
				}
				// layer data
				float layer_start_x = start_x;
				int layer_start_y = start_y;
				float layer_end_x = end_x;
				int layer_end_y = end_y;
				float layer_slope_ab = slope_ab;
				float layer_slope_ac = slope_ac;
				float layer_slope_bc = slope_bc;
				// use source layers if flag is set, otherwise use override value from instruction
				if (_dataTypesToDrawFlags & INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER)
					// execute the following logic twice
					for (int i = 0; i < 2; ++i)
					{
						// loop while start_y < end_y (might be skipped)
						for (; layer_start_y < layer_end_y; ++layer_start_y)
						{
							// clip start and end x to boundary (temporary)
							int left = static_cast<int>(layer_start_x + 0.5f);
							if (left < clipLeft)
								left = clipLeft;
							int right = static_cast<int>(layer_end_x + 0.5f);
							if (right > clipRight)
								right = clipRight;
							unsigned int index = getResultBlockPixelIndex(left - _resBlock.x_result, layer_start_y - _resBlock.y_result); // offset to be relative to this result block
							// traverse and fill
							for (; left < right; ++left, ++index)
							{
								// draw reverse-lookup layer with false-positive checking
								//   (theoretically, this error checking doesn't need to be here; however, at the moment the triangle drawing algorithm produces false
								//     positives around the edges, which can cause an out-of-bounds exception when trying to reverse-lookup colors for those pixels)
								Vector2 coord = getResInstrReverseLookupCoord(_resInstr, left, layer_start_y);
								if (checkResInstrReverseLookupCoord(_resInstr, coord))
									_resBlock.layer[index] = reverseLookupLayerFromSource(_resInstr.source_id, coord);

								// draw reverse-lookup layer with no error checking
								//   (this can't be used until the false positives mentioned above have been dealt with)
								//_resBlock.layer[index] = reverseLookupLayerFromSource(_resInstr.source_id, getResInstrReverseLookupCoord(_resInstr, left, layer_start_y));
							}
							// adjust start and end x by slope
							layer_start_x += layer_slope_ac;
							layer_end_x += layer_slope_ab;
						}
						layer_end_y = (_tri.c.y < clipBottom) ? static_cast<int>(_tri.c.y) : clipBottom;
						// if direction was flipped previously, adjust slope traversal
						std::isnan(flip) ? layer_slope_ab = layer_slope_bc : layer_slope_ac = layer_slope_bc;
					}
				else
					// execute the following logic twice
					for (int i = 0; i < 2; ++i)
					{
						// loop while start_y < end_y (might be skipped)
						for (; layer_start_y < layer_end_y; ++layer_start_y)
						{
							// clip start and end x to boundary (temporary)
							int left = static_cast<int>(layer_start_x + 0.5f);
							if (left < clipLeft)
								left = clipLeft;
							int right = static_cast<int>(layer_end_x + 0.5f);
							if (right > clipRight)
								right = clipRight;
							unsigned int index = getResultBlockPixelIndex(left - _resBlock.x_result, layer_start_y - _resBlock.y_result); // offset to be relative to this result block
							// traverse and fill
							for (; left < right; ++left, ++index)
							{
								// draw reverse-lookup layer with false-positive checking
								//   (theoretically, this error checking doesn't need to be here; however, at the moment the triangle drawing algorithm produces false
								//     positives around the edges, which can cause an out-of-bounds exception when trying to reverse-lookup colors for those pixels)
								Vector2 coord = getResInstrReverseLookupCoord(_resInstr, left, layer_start_y);
								if (checkResInstrReverseLookupCoord(_resInstr, coord))
									_resBlock.layer[index] = _resInstr.layer_override;

								// draw reverse-lookup layer with no error checking
								//   (this can't be used until the false positives mentioned above have been dealt with)
								//_resBlock.layer[index] = _resInstr.layer_override;
							}
							// adjust start and end x by slope
							layer_start_x += layer_slope_ac;
							layer_end_x += layer_slope_ab;
						}
						layer_end_y = (_tri.c.y < clipBottom) ? static_cast<int>(_tri.c.y) : clipBottom;
						// if direction was flipped previously, adjust slope traversal
						std::isnan(flip) ? layer_slope_ab = layer_slope_bc : layer_slope_ac = layer_slope_bc;
					}
				// stencil data
				float stencil_start_x = start_x;
				int stencil_start_y = start_y;
				float stencil_end_x = end_x;
				int stencil_end_y = end_y;
				float stencil_slope_ab = slope_ab;
				float stencil_slope_ac = slope_ac;
				float stencil_slope_bc = slope_bc;
				if (_dataTypesToDrawFlags & INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL)
					// execute the following logic twice
					for (int i = 0; i < 2; ++i)
					{
						// loop while start_y < end_y (might be skipped)
						for (; stencil_start_y < stencil_end_y; ++stencil_start_y)
						{
							// clip start and end x to boundary (temporary)
							int left = static_cast<int>(stencil_start_x + 0.5f);
							if (left < clipLeft)
								left = clipLeft;
							int right = static_cast<int>(stencil_end_x + 0.5f);
							if (right > clipRight)
								right = clipRight;
							unsigned int index = getResultBlockPixelIndex(left - _resBlock.x_result, stencil_start_y - _resBlock.y_result); // offset to be relative to this result block
							// traverse and fill
							for (; left < right; ++left, ++index)
							{
								// draw reverse-lookup stencil with false-positive checking
								//   (theoretically, this error checking doesn't need to be here; however, at the moment the triangle drawing algorithm produces false
								//     positives around the edges, which can cause an out-of-bounds exception when trying to reverse-lookup colors for those pixels)
								Vector2 coord = getResInstrReverseLookupCoord(_resInstr, left, stencil_start_y);
								if (checkResInstrReverseLookupCoord(_resInstr, coord))
									_resBlock.stencil[index] = reverseLookupStencilFromSource(_resInstr.source_id, coord);

								// draw reverse-lookup stencil with no error checking
								//   (this can't be used until the false positives mentioned above have been dealt with)
								//_resBlock.stencil[index] = reverseLookupStencilFromSource(_resInstr.source_id, getResInstrReverseLookupCoord(_resInstr, left, start_y));
							}
							// adjust start and end x by slope
							stencil_start_x += stencil_slope_ac;
							stencil_end_x += stencil_slope_ab;
						}
						stencil_end_y = (_tri.c.y < clipBottom) ? static_cast<int>(_tri.c.y) : clipBottom;
						// if direction was flipped previously, adjust slope traversal
						std::isnan(flip) ? stencil_slope_ab = stencil_slope_bc : stencil_slope_ac = stencil_slope_bc;
					}
				else
					// execute the following logic twice
					for (int i = 0; i < 2; ++i)
					{
						// loop while start_y < end_y (might be skipped)
						for (; stencil_start_y < stencil_end_y; ++stencil_start_y)
						{
							// clip start and end x to boundary (temporary)
							int left = static_cast<int>(stencil_start_x + 0.5f);
							if (left < clipLeft)
								left = clipLeft;
							int right = static_cast<int>(stencil_end_x + 0.5f);
							if (right > clipRight)
								right = clipRight;
							unsigned int index = getResultBlockPixelIndex(left - _resBlock.x_result, stencil_start_y - _resBlock.y_result); // offset to be relative to this result block
							// traverse and fill
							for (; left < right; ++left, ++index)
							{
								// draw reverse-lookup stencil with false-positive checking
								//   (theoretically, this error checking doesn't need to be here; however, at the moment the triangle drawing algorithm produces false
								//     positives around the edges, which can cause an out-of-bounds exception when trying to reverse-lookup colors for those pixels)
								Vector2 coord = getResInstrReverseLookupCoord(_resInstr, left, stencil_start_y);
								if (checkResInstrReverseLookupCoord(_resInstr, coord))
									_resBlock.stencil[index] = _resInstr.stencil_override;

								// draw reverse-lookup stencil with no error checking
								//   (this can't be used until the false positives mentioned above have been dealt with)
								//_resBlock.stencil[index] = _resInstr.stencil_override;
							}
							// adjust start and end x by slope
							stencil_start_x += stencil_slope_ac;
							stencil_end_x += stencil_slope_ab;
						}
						stencil_end_y = (_tri.c.y < clipBottom) ? static_cast<int>(_tri.c.y) : clipBottom;
						// if direction was flipped previously, adjust slope traversal
						std::isnan(flip) ? stencil_slope_ab = stencil_slope_bc : stencil_slope_ac = stencil_slope_bc;
					}

				// DEBUG draw corners
#if defined(GBLITTER_DEBUG_DRAW_TRANSFORMED_TRIANGLE_CORNERS)
				// max corners in each dimension are 1 pixel past the last pixels drawn to, since corner positions are geometric rather than pixel-space
				//   (pixel-space coordinates use integers only, which means a pixel-space shape spans [min, max), rather than a geometric shape which spans [min, max] )
				if (_tri.a.x >= clipLeft && _tri.a.x < clipRight && _tri.a.y >= clipTop && _tri.a.y < clipBottom)
					_resBlock.color[getResultBlockPixelIndex(_tri.a.x - _resBlock.x_result, _tri.a.y - _resBlock.y_result)] = _cornerColor;
				if (_tri.b.x >= clipLeft && _tri.b.x < clipRight && _tri.b.y >= clipTop && _tri.b.y < clipBottom)
					_resBlock.color[getResultBlockPixelIndex(_tri.b.x - _resBlock.x_result, _tri.b.y - _resBlock.y_result)] = _cornerColor;
				if (_tri.c.x >= clipLeft && _tri.c.x < clipRight && _tri.c.y >= clipTop && _tri.c.y < clipBottom)
					_resBlock.color[getResultBlockPixelIndex(_tri.c.x - _resBlock.x_result, _tri.c.y - _resBlock.y_result)] = _cornerColor;
#endif
			}

#pragma endregion PRIVATE_FLUSH_FUNCTIONS

		public:

#pragma region CREATE_AND_DESTROY_FUNCTIONS

			~GBlitterImplementation()
			{
				m_sources.clear();
				m_tiles.clear();
				m_result.data.clear();
			}

			GReturn Create(unsigned short _width, unsigned short _height)
			{
				// validate arguments
				if (_width < 1 || _height < 1)
					return GReturn::INVALID_ARGUMENT;
				// if arguments are valid, continue

				// initialize result
				initResult(_width, _height);
				// create GConcurrent for flushing instructions to result
				m_gFlushThread.Create(false);
				// clear result
				Clear(0xff000000, 255, 0);
				// return success
				return GReturn::SUCCESS;
			}

#pragma endregion CREATE_AND_DESTROY_FUNCTIONS
#pragma region IMPORT_FUNCTIONS

			GReturn LoadSource(
				const char* _colorsFilepath, const char* _layersFilepath, const char* _stencilsFilepath,
				unsigned short &_outIndex) override
			{
				// validate arguments
				// ensure max sources would not be exceeded
				if (m_sources.size() > MAX_SOURCES)
					return GReturn::IGNORED;
				// ensure at least one filepath was passed
				if (_colorsFilepath == nullptr
					&& _layersFilepath == nullptr
					&& _stencilsFilepath == nullptr)
					return GReturn::INVALID_ARGUMENT;
				// determine which filepaths are used
				SOURCE_FILE_TYPE colorFiletype = _colorsFilepath ? SOURCE_FILE_TYPE::UNSUPPORTED : SOURCE_FILE_TYPE::UNUSED;
				SOURCE_FILE_TYPE layerFiletype = _layersFilepath ? SOURCE_FILE_TYPE::UNSUPPORTED : SOURCE_FILE_TYPE::UNUSED;
				SOURCE_FILE_TYPE stencilFiletype = _stencilsFilepath ? SOURCE_FILE_TYPE::UNSUPPORTED : SOURCE_FILE_TYPE::UNUSED;
				// ensure used filepaths have extensions (if filtering file extension fails, filepath does not have a valid extension)
				if (colorFiletype != SOURCE_FILE_TYPE::UNUSED)
					if (-filterFileExtension(_colorsFilepath, colorFiletype))
						return GReturn::INVALID_ARGUMENT;
				if (layerFiletype != SOURCE_FILE_TYPE::UNUSED)
					if (-filterFileExtension(_layersFilepath, layerFiletype))
						return GReturn::INVALID_ARGUMENT;
				if (stencilFiletype != SOURCE_FILE_TYPE::UNUSED)
					if (-filterFileExtension(_stencilsFilepath, stencilFiletype))
						return GReturn::INVALID_ARGUMENT;
				// ensure filetypes are supported (a valid extension does not guarantee a supported extension)
				if (   colorFiletype == SOURCE_FILE_TYPE::UNSUPPORTED
					|| layerFiletype == SOURCE_FILE_TYPE::UNSUPPORTED
					|| stencilFiletype == SOURCE_FILE_TYPE::UNSUPPORTED)
					return GReturn::FORMAT_UNSUPPORTED;
				// if arguments are valid, continue

				// store pixel data types in source data buffer (the buffer cannot be initialized until the first time data is read from a file, since image dimensions are unknown before that; this initialization happens in the data read helper functions)
				SourceDataBuffer sourceDataBuffer = {};
				if (colorFiletype != SOURCE_FILE_TYPE::UNUSED)
					sourceDataBuffer.dataTypes |= INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR;
				if (layerFiletype != SOURCE_FILE_TYPE::UNUSED)
					sourceDataBuffer.dataTypes |= INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER;
				if (stencilFiletype != SOURCE_FILE_TYPE::UNUSED)
					sourceDataBuffer.dataTypes |= INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL;

				// attempt to read data from files
				GReturn gr;
				// color
				if (colorFiletype != SOURCE_FILE_TYPE::UNUSED)
				{
					switch (colorFiletype)
					{
						case SOURCE_FILE_TYPE::TGA:
							gr = readSourceDataFromTGA(_colorsFilepath, INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR, sourceDataBuffer);
							break;
						default:
							gr = GReturn::FORMAT_UNSUPPORTED;
							break;
					}
					// ensure data was read; if not, discard any source data and return the failure code
					if (G_FAIL(gr))
					{
						discardSourceDataBuffer(sourceDataBuffer);
						return gr;
					}
				}
				// layer
				if (layerFiletype != SOURCE_FILE_TYPE::UNUSED)
				{
					switch (layerFiletype)
					{
						case SOURCE_FILE_TYPE::TGA:
							gr = readSourceDataFromTGA(_layersFilepath, INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER, sourceDataBuffer);
							break;
						default:
							gr = GReturn::FORMAT_UNSUPPORTED;
							break;
					}
					// ensure data was read; if not, discard any source data and return the failure code
					if (G_FAIL(gr))
					{
						discardSourceDataBuffer(sourceDataBuffer);
						return gr;
					}
				}
				// stencil
				if (stencilFiletype != SOURCE_FILE_TYPE::UNUSED)
				{
					switch (stencilFiletype)
					{
						case SOURCE_FILE_TYPE::TGA:
							gr = readSourceDataFromTGA(_stencilsFilepath, INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL, sourceDataBuffer);
							break;
						default:
							gr = GReturn::FORMAT_UNSUPPORTED;
							break;
					}
					// ensure data was read; if not, discard any source data and return the failure code
					if (G_FAIL(gr))
					{
						discardSourceDataBuffer(sourceDataBuffer);
						return gr;
					}
				}

				// create and store source, and return index to user
				createAndStoreSource(sourceDataBuffer, _outIndex);
				// discard loaded data since it is no longer needed
				discardSourceDataBuffer(sourceDataBuffer);

				return GReturn::SUCCESS;
			}
			GReturn ImportSource(
				const Color* _colors, const Layer* _layers, const Stencil* _stencils,
				unsigned short _width, unsigned short _height, unsigned short _pixelOffset, unsigned short _rowPixelStride,
				unsigned short& _outIndex) override
			{
				// validate arguments
				// ensure max sources would not be exceeded
				if (m_sources.size() > MAX_SOURCES)
					return GReturn::IGNORED;
				// ensure at least one data type was passed
				if (_colors == nullptr
					&& _layers == nullptr
					&& _stencils == nullptr)
					return GReturn::INVALID_ARGUMENT;
				// ensure width and height are nonzero
				if (_width < 1 || _height < 1)
					return GReturn::INVALID_ARGUMENT;
				// ensure stride is not less than width, if nonzero
				if (_rowPixelStride > 0 && _rowPixelStride < _width)
					return GReturn::INVALID_ARGUMENT;
				// if arguments are valid, continue

				// if stride is zero, set it to width
				if (_rowPixelStride == 0)
					_rowPixelStride = _width;
				// create source data buffer to copy data into for transfer into source
				SourceDataBuffer sourceDataBuffer = {};
				if (_colors)
					sourceDataBuffer.dataTypes |= INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR;
				if (_layers)
					sourceDataBuffer.dataTypes |= INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER;
				if (_stencils)
					sourceDataBuffer.dataTypes |= INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL;
				initSourceDataBuffer(sourceDataBuffer, _width, _height);
				// copy data into source data buffer
				for (unsigned short y = 0; y < _height; ++y)
				{
					unsigned int inputIndex = _pixelOffset + (y * _rowPixelStride);
					unsigned int bufferIndex = y * _width;
					// copy row of pixel data
					if (_colors)
						memcpy(&sourceDataBuffer.colors[bufferIndex], &_colors[inputIndex], _width << 2);
					// copy row of layer data, if passed
					if (_layers)
						memcpy(&sourceDataBuffer.layers[bufferIndex], &_layers[inputIndex], _width);
					// copy row of stencil data, if passed
					if (_stencils)
						memcpy(&sourceDataBuffer.stencils[bufferIndex], &_stencils[inputIndex], _width);
				}
				// create and store source, and return index to user
				createAndStoreSource(sourceDataBuffer, _outIndex);
				// discard source buffer since it is no longer needed
				discardSourceDataBuffer(sourceDataBuffer);
				// return success
				return GReturn::SUCCESS;
			}
			GReturn ImportSourceComplex(
				const Color* _colors, unsigned short _colorByteStride, unsigned short _colorRowByteStride,
				const Layer* _layers, unsigned short _layerByteStride, unsigned short _layerRowByteStride,
				const Stencil* _stencils, unsigned short _stencilByteStride, unsigned short _stencilRowByteStride,
				unsigned short _width, unsigned short _height, unsigned short& _outIndex) override
			{
				// validate arguments
				// ensure max sources would not be exceeded
				if (m_sources.size() > MAX_SOURCES)
					return GReturn::IGNORED;
				// ensure at least one data type was passed
				if (_colors == nullptr
					&& _layers == nullptr
					&& _stencils == nullptr)
					return GReturn::INVALID_ARGUMENT;
				// ensure width and height are nonzero
				if (_width < 1 || _height < 1)
					return GReturn::INVALID_ARGUMENT;
				// ensure data byte and row strides are nonzero, if used
				if (_colors && (_colorByteStride < 1 || _colorRowByteStride < 1))
					return GReturn::INVALID_ARGUMENT;
				if (_layers && (_layerByteStride < 1 || _layerRowByteStride < 1))
					return GReturn::INVALID_ARGUMENT;
				if (_stencils && (_stencilByteStride < 1 || _stencilRowByteStride < 1))
					return GReturn::INVALID_ARGUMENT;
				// ensure row strides are >= width * byte strides, if used
				if (_colors && _colorRowByteStride < _colorByteStride * _width)
					return GReturn::INVALID_ARGUMENT;
				if (_layers && _layerRowByteStride < _layerByteStride * _width)
					return GReturn::INVALID_ARGUMENT;
				if (_stencils && _stencilRowByteStride < _stencilByteStride * _width)
					return GReturn::INVALID_ARGUMENT;
				// ensure data byte strides are <= row strides, if used
				if (_colors && _colorByteStride > _colorRowByteStride)
					return GReturn::INVALID_ARGUMENT;
				if (_layers && _layerByteStride > _layerRowByteStride)
					return GReturn::INVALID_ARGUMENT;
				if (_stencils && _stencilByteStride > _stencilRowByteStride)
					return GReturn::INVALID_ARGUMENT;
				// if arguments are valid, continue

				// create source data buffer to copy data into for transfer into source
				SourceDataBuffer sourceDataBuffer = {};
				if (_colors)
					sourceDataBuffer.dataTypes |= INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::COLOR;
				if (_layers)
					sourceDataBuffer.dataTypes |= INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::LAYER;
				if (_stencils)
					sourceDataBuffer.dataTypes |= INTERNAL_PIXEL_ATTRIBUTES::ELEMENT::STENCIL;
				initSourceDataBuffer(sourceDataBuffer, _width, _height);
				// copy data into source data buffer
				if (_colors)
				{
					if (_colorByteStride == sizeof(Color)) // if colors are contiguous, memcpy can be used
						for (unsigned short y = 0; y < _height; ++y)
						{
							const Byte* readColor = reinterpret_cast<const Byte*>(_colors) + (y * _colorRowByteStride);
							memcpy(&sourceDataBuffer.colors[y * _width], readColor, _width << 2);
						} // end iterate through color rows
					else // otherwise, use pointer arithmetic instead
						for (unsigned short y = 0; y < _height; ++y)
						{
							const Byte* readColor = reinterpret_cast<const Byte*>(_colors) + (y * _colorRowByteStride);
							for (unsigned short x = 0; x < _width; ++x)
							{
								sourceDataBuffer.colors[x + y * _width] = *(reinterpret_cast<const unsigned int*>(readColor));
								readColor += _colorByteStride;
							} // end iterate through colors in row
						} // end iterate through color rows
				} // end copy colors
				if (_layers)
				{
					if (_layerByteStride == sizeof(Layer)) // if layers are contiguous, memcpy can be used
						for (unsigned short y = 0; y < _height; ++y)
						{
							const Byte* readLayer = reinterpret_cast<const Byte*>(_layers) + (y * _layerRowByteStride);
							memcpy(&sourceDataBuffer.layers[y * _width], readLayer, _width);
						} // end iterate through layer rows
					else
						for (unsigned short y = 0; y < _height; ++y)
						{
							const Byte* readLayer = reinterpret_cast<const Byte*>(_layers) + (y * _layerRowByteStride);
							for (unsigned short x = 0; x < _width; ++x)
							{
								sourceDataBuffer.layers[x + (y * _width)] = *readLayer;
								readLayer += _layerByteStride;
							} // end iterate through layers in row
						} // end iterate through layer rows
				} // end copy layers
				if (_stencils)
				{
					if (_stencilByteStride == sizeof(Stencil)) // if stencils are contiguous, memcpy can be used
						for (unsigned short y = 0; y < _height; ++y)
						{
							const Byte* readStencil = reinterpret_cast<const Byte*>(_stencils) + (y *  _stencilRowByteStride);
							memcpy(&sourceDataBuffer.stencils[y * _width], readStencil, _width);
						} // end iterate through stencil rows
					else
						for (unsigned short y = 0; y < _height; ++y)
						{
							const Byte* readStencil = reinterpret_cast<const Byte*>(_stencils) + (y *  _stencilRowByteStride);
							for (unsigned short x = 0; x < _width; ++x)
							{
								sourceDataBuffer.stencils[x + (y * _width)] = *readStencil;
								readStencil += _stencilByteStride;
							} // end iterate through stencils in row
						} // end iterate through stencil rows
				} // end copy stencils
				// create and store source, and return index to user
				createAndStoreSource(sourceDataBuffer, _outIndex);
				// discard source buffer since it is no longer needed
				discardSourceDataBuffer(sourceDataBuffer);
				// return success
				return GReturn::SUCCESS;
			}
			GReturn DefineTiles(
				const TileDefinition* _tileDefinitions,
				const unsigned int _numTiles, unsigned int *_outIndices) override
			{
				// validate arguments
				// ensure valid tile definition array was passed
				if (_tileDefinitions == nullptr)
					return GReturn::INVALID_ARGUMENT;
				// ensure valid index result array was passed
				if (_outIndices == nullptr)
					return GReturn::INVALID_ARGUMENT;
				// ensure tile count is nonzero
				if (_numTiles < 1)
					return GReturn::INVALID_ARGUMENT;
				// ensure max number of tiles would not be exceeded
				if (static_cast<unsigned long long>(m_tiles.size() + _numTiles) > MAX_TILES)
					return GReturn::IGNORED;
				// ensure tile definitions are valid
				bool definitionsValid = true;
				for (unsigned int i = 0; i < _numTiles; ++i)
				{
					TileDefinition def = _tileDefinitions[i];
					// ensure source index is set
					if (!(~def.source_id))
					{
						definitionsValid = false;
						break;
					}
					// ensure source index is in factory
					if (!m_sources.is_valid(def.source_id))
					{
						definitionsValid = false;
						break;
					}
					Source& source = m_sources[def.source_id];
					// ensure tile dimensions are nonzero
					if (def.w < 1 || def.h < 1)
					{
						definitionsValid = false;
						break;
					}
					// ensure tile origin is within source
					if (def.x >= source.w_image || def.y >= source.h_image)
					{
						definitionsValid = false;
						break;
					}
					// ensure tile bounds are within source bounds
					if (def.x + def.w > source.w_image
						|| def.y + def.h > source.h_image)
					{
						definitionsValid = false;
						break;
					}
				}
				if (!definitionsValid)
					return GReturn::INVALID_ARGUMENT;
				// if arguments are valid, continue

				// add tile definitions to pool
				for (unsigned int i = 0; i < _numTiles; ++i)
					_outIndices[i] = m_tiles.push_back(_tileDefinitions[i]);
				// return success
				return GReturn::SUCCESS;
			}
			GReturn SetTileMaskValues(
				unsigned int* _tileIndices, unsigned int _numTiles,
				Color _maskColor, Layer _maskLayer, Stencil _maskStencil) override
			{
				// validate arguments
				// ensure valid index array was passed
				if (_tileIndices == nullptr)
					return GReturn::INVALID_ARGUMENT;
				// ensure number of indices is nonzero
				if (_numTiles < 1)
					return GReturn::INVALID_ARGUMENT;
				// ensure number of indices does not exceed number of tiles
				if (_numTiles > m_tiles.size())
					return GReturn::INVALID_ARGUMENT;
				// ensure indices are valid
				bool indicesValid = true;
				for (unsigned short i = 0; i < _numTiles; ++i)
				{
					// ensure index is in the tile pool
					if (!m_tiles.is_valid(_tileIndices[i]))
					{
						indicesValid = false;
						break;
					}
				}
				if (!indicesValid)
					return GReturn::INVALID_ARGUMENT;
				// if arguments are valid, continue

				// iterate through list of indices and set values for each one
				for (unsigned int i = 0; i < _numTiles; ++i)
				{
					TileDefinition& tile = m_tiles[_tileIndices[i]];
					tile.mask_color = _maskColor;
					tile.mask_layer = _maskLayer;
					tile.mask_stencil = _maskStencil;
				}
				// return success
				return GReturn::SUCCESS;
			}

#pragma endregion IMPORT_FUNCTIONS
#pragma region DISCARD_FUNCTIONS

			GReturn DiscardSources(unsigned short* _sourceIndices, unsigned short _numSources) override
			{
				// validate arguments
				// ensure valid index array was passed
				if (_sourceIndices == nullptr)
					return GReturn::INVALID_ARGUMENT;
				// ensure number of indices is nonzero
				if (_numSources < 1)
					return GReturn::INVALID_ARGUMENT;
				// ensure number of indices does not exceed number of sources
				if (_numSources > m_sources.size())
					return GReturn::INVALID_ARGUMENT;
				// ensure indices are valid
				bool indicesValid = true;
				for (unsigned short i = 0; i < _numSources; ++i)
				{
					// ensure index is in the source pool
					if (!m_sources.is_valid(_sourceIndices[i]))
					{
						indicesValid = false;
						break;
					}
				}
				if (!indicesValid)
					return GReturn::INVALID_ARGUMENT;
				// if arguments are valid, continue

				// remove sources from pool
				for (unsigned int i = 0; i < _numSources; ++i)
					m_sources.set_valid(_sourceIndices[i], false);
				// return success
				return GReturn::SUCCESS;
			}
			GReturn DiscardTiles(unsigned int* _tileIndices, unsigned int _numTiles) override
			{
				// validate arguments
				// ensure valid index array was passed
				if (_tileIndices == nullptr)
					return GReturn::INVALID_ARGUMENT;
				// ensure number of indices is nonzero
				if (_numTiles < 1)
					return GReturn::INVALID_ARGUMENT;
				// ensure number of indices does not exceed number of tiles
				if (_numTiles > m_tiles.size())
					return GReturn::INVALID_ARGUMENT;
				// ensure indices are valid
				bool indicesValid = true;
				for (unsigned short i = 0; i < _numTiles; ++i)
				{
					// ensure index is in the tile pool
					if (!m_tiles.is_valid(_tileIndices[i]))
					{
						indicesValid = false;
						break;
					}
				}
				if (!indicesValid)
					return GReturn::INVALID_ARGUMENT;
				// if arguments are valid, continue

				// remove tiles from pool
				for (unsigned int i = 0; i < _numTiles; ++i)
					m_tiles.set_valid(_tileIndices[i], false);
				// return success
				return GReturn::SUCCESS;
			}

#pragma endregion DISCARD_FUNCTIONS
#pragma region DRAW_FUNCTIONS

			GReturn Clear(Color _color, Layer _layer, Stencil _stencil) override
			{
				ClearColor(_color);
				ClearLayer(_layer);
				ClearStencil(_stencil);
				// return success (this operation cannot reasonably fail)
				return GReturn::SUCCESS;
			}
			GReturn ClearColor(Color _color) override
			{
				// clear first row of first block
				for (unsigned short x = 0; x < RESULT_BLOCK_WIDTH; ++x)
					m_result.data[0].color[x]	= _color;
				// copy cleared row into other rows of first block
				for (unsigned short y = 1; y < RESULT_BLOCK_HEIGHT; ++y)
					memcpy(&m_result.data[0].color[y * RESULT_BLOCK_WIDTH], &m_result.data[0].color[0], RESULT_BLOCK_WIDTH << 2);
				// copy cleared block into other blocks
				for (unsigned short b = 1; b < m_result.data.size(); ++b)
					memcpy(&m_result.data[b].color[0], &m_result.data[0].color[0], (RESULT_BLOCK_WIDTH * RESULT_BLOCK_HEIGHT) << 2);
				// return success (this operation cannot reasonably fail)
				return GReturn::SUCCESS;
			}
			GReturn ClearLayer(Layer _layer) override
			{
				// clear first row of first block
				for (unsigned short x = 0; x < RESULT_BLOCK_WIDTH; ++x)
					m_result.data[0].layer[x]	= _layer;
				// copy cleared row into other rows of first block
				for (unsigned short y = 1; y < RESULT_BLOCK_HEIGHT; ++y)
					memcpy(&m_result.data[0].layer[y * RESULT_BLOCK_WIDTH], &m_result.data[0].layer[0], RESULT_BLOCK_WIDTH);
				// copy cleared block into other blocks
				for (unsigned short b = 1; b < m_result.data.size(); ++b)
					memcpy(&m_result.data[b].layer[0], &m_result.data[0].layer[0], (RESULT_BLOCK_WIDTH * RESULT_BLOCK_HEIGHT));
				// return success (this operation cannot reasonably fail)
				return GReturn::SUCCESS;
			}
			GReturn ClearStencil(Stencil _stencil) override
			{
				// clear first row of first block
				for (unsigned short x = 0; x < RESULT_BLOCK_WIDTH; ++x)
					m_result.data[0].stencil[x]	= _stencil;
				// copy cleared row into other rows of first block
				for (unsigned short y = 1; y < RESULT_BLOCK_HEIGHT; ++y)
					memcpy(&m_result.data[0].stencil[y * RESULT_BLOCK_WIDTH], &m_result.data[0].stencil[0], RESULT_BLOCK_WIDTH);
				// copy cleared block into other blocks
				for (unsigned short b = 1; b < m_result.data.size(); ++b)
					memcpy(&m_result.data[b].stencil[0], &m_result.data[0].stencil[0], (RESULT_BLOCK_WIDTH * RESULT_BLOCK_HEIGHT));
				// return success (this operation cannot reasonably fail)
				return GReturn::SUCCESS;
			}

			GReturn DrawDeferred(const DrawInstruction* _drawInstructions, const unsigned short _numInstructions) override
			{
				// validate arguments
				// ensure valid instruction array was passed
				if (_drawInstructions == nullptr)
					return GReturn::INVALID_ARGUMENT;
				// ensure number of instructions is nonzero
				if (_numInstructions < 1)
					return GReturn::INVALID_ARGUMENT;
				// ensure instructions are valid
				bool instructionsvalid = true;
				for (unsigned short i = 0; i < _numInstructions; ++i)
				{
					const DrawInstruction& instr = static_cast<DrawInstruction>(_drawInstructions[i]);
					// ensure tile index is set
					if (!(~instr.tile_id))
					{
						instructionsvalid = false;
						break;
					}
					// ensure tile index is in factory
					if (!m_tiles.is_valid(instr.tile_id))
					{
						instructionsvalid = false;
						break;
					}
				}
				if (!instructionsvalid)
					return GReturn::INVALID_ARGUMENT;
				// if arguments are valid, continue

				// convert draw instructions to result instructions
				processDrawInstructions_Deferred(_drawInstructions, _numInstructions);
				// return success
				return GReturn::SUCCESS;
			}
			GReturn DrawImmediate(const DrawInstruction* _drawInstructions, const unsigned short _numInstructions) override
			{
				// validate arguments
				// ensure valid instruction array was passed
				if (_drawInstructions == nullptr)
					return GReturn::INVALID_ARGUMENT;
				// ensure number of instructions is nonzero
				if (_numInstructions < 1)
					return GReturn::INVALID_ARGUMENT;
				// ensure instructions are valid
				bool instructionsvalid = true;
				for (unsigned short i = 0; i < _numInstructions; ++i)
				{
					const DrawInstruction& instr = static_cast<DrawInstruction>(_drawInstructions[i]);
					// ensure tile index is set
					if (!(~instr.tile_id))
					{
						instructionsvalid = false;
						break;
					}
					// ensure tile index is in factory
					if (!m_tiles.is_valid(instr.tile_id))
					{
						instructionsvalid = false;
						break;
					}
				}
				if (!instructionsvalid)
					return GReturn::INVALID_ARGUMENT;
				// if arguments are valid, continue

				// convert draw instructions to result instructions and draw them to the result
				processDrawInstructions_Immediate(const_cast<DrawInstruction*>(_drawInstructions), _numInstructions);
				// return success
				return GReturn::SUCCESS;
			}

#pragma endregion DRAW_FUNCTIONS
#pragma region FLUSH_FUNCTIONS

			GReturn Flush() override
			{
				GReturn result = GReturn::REDUNDANT;

#ifdef GBLITTER_DEBUG_SERIAL_FLUSH
				// iterate through result blocks
				for (unsigned short b = 0; b < m_result.size_data; ++b)
					// flush the current block and store the result of the operation
					m_result.flush_results[b] = flushResultBlock_Serial(m_result.data[b]);
#else // process blocks in parallel with GConcurrent; default
				// flush all blocks' instructions to result
				m_gFlushThread.BranchParallel(flushResultBlock_Parallel, 1, m_result.size_data, reinterpret_cast<const void*>(this), 0, static_cast<const void*>(nullptr), 0, &m_result.data[0]);
				// wait until flush finishes
				m_gFlushThread.Converge(0);
#endif

				// determine the result of the flush (if at least one block was flushed, operation was successful; otherwise, operation was redundant)
				for (unsigned short b = 0; b < m_result.size_data; ++b)
					if (m_result.flush_results[b] == GReturn::SUCCESS)
					{
						result = GReturn::SUCCESS;
						break;
					}

				return result;
			}

#pragma endregion FLUSH_FUNCTIONS
#pragma region EXPORT_FUNCTIONS

			GReturn ExportResult(
				bool _flush,
				unsigned short _width, unsigned short _height, unsigned short _pixelOffset, unsigned short _rowPixelStride,
				Color* _outColors, Layer* _outLayers, Stencil* _outStencils) override
			{
				// validate arguments
				// ensure at least one output buffer was passed
				if (_outColors == nullptr
					&& _outLayers == nullptr
					&& _outStencils == nullptr)
					return GReturn::INVALID_ARGUMENT;
				// ensure width and height are nonzero
				if (_width < 1 || _height < 1)
					return GReturn::INVALID_ARGUMENT;
				// ensure stride is not lower than width if stride is nonzero
				if (_rowPixelStride > 0 && _rowPixelStride < _width)
					return GReturn::INVALID_ARGUMENT;
				// if arguments are valid, continue

				// flush any outstanding instructions to the result, if requested
				if (_flush)
					Flush();
				// if stride is zero, set to width
				if (_rowPixelStride == 0)
					_rowPixelStride = _width;
				// set values to use while transferring data
				unsigned short w = (_width < m_result.w_image) ? _width : m_result.w_image; // only copy as much data as will fit into output buffers/only copy as much data as is in result
				unsigned short h = (_height < m_result.h_image) ? _height : m_result.h_image; // same on y
				// determine how many blocks will fit in output buffers
				unsigned short blockSpanX = w / RESULT_BLOCK_WIDTH + ((w % RESULT_BLOCK_WIDTH) ? 1 : 0);
				unsigned short blockSpanY = h / RESULT_BLOCK_HEIGHT + ((h % RESULT_BLOCK_HEIGHT) ? 1 : 0);
				// iterate through blocks
				for (unsigned short blockY = 0; blockY < blockSpanY; ++blockY)
					for (unsigned short blockX = 0; blockX < blockSpanX; ++blockX)
					{
						// store block by reference for neatness
						ResultBlock& block = m_result.data[blockX + (blockY * m_result.w_data)];
						// calculate block x/y in pixels
						unsigned short x_resultBlock = blockX * RESULT_BLOCK_WIDTH;
						unsigned short y_resultBlock = blockY * RESULT_BLOCK_HEIGHT;
						// determine region to copy
						unsigned short regionWidth = ((x_resultBlock + RESULT_BLOCK_WIDTH) > w) ? w - x_resultBlock : RESULT_BLOCK_WIDTH; // if entire width won't fit, clamp to output buffer width
						unsigned short regionHeight = ((y_resultBlock + RESULT_BLOCK_HEIGHT) > h) ? h - y_resultBlock : RESULT_BLOCK_HEIGHT; // same on y
						// determine starting index of region in output buffers
						unsigned int outputStartIndex = _pixelOffset + x_resultBlock + (y_resultBlock * _rowPixelStride);

						// iterate through rows in block and copy data to output buffers
						if (_outColors)
							for (unsigned short y = 0; y < regionHeight; ++y)
								memcpy(&_outColors[outputStartIndex + (y * _rowPixelStride)], &block.color[y * RESULT_BLOCK_WIDTH], regionWidth << 2);
						if (_outLayers)
							for (unsigned short y = 0; y < regionHeight; ++y)
								memcpy(&_outLayers[outputStartIndex + (y * _rowPixelStride)], &block.layer[y * RESULT_BLOCK_WIDTH], regionWidth);
						if (_outStencils)
							for (unsigned short y = 0; y < regionHeight; ++y)
								memcpy(&_outStencils[outputStartIndex + (y * _rowPixelStride)], &block.stencil[y * RESULT_BLOCK_WIDTH], regionWidth);
					}
				// return success
				return GReturn::SUCCESS;
			}
			GReturn ExportResultComplex(
				bool _flush,
				unsigned short _colorByteStride, unsigned short _colorRowByteStride,
				unsigned short _layerByteStride, unsigned short _layerRowByteStride,
				unsigned short _stencilByteStride, unsigned short _stencilRowByteStride,
				unsigned short _width, unsigned short _height,
				Color* _outColors, Layer* _outLayers, Stencil* _outStencils) override
			{
				// validate arguments
				// ensure at least one output buffer was passed
				if (   _outColors == nullptr
					&& _outLayers == nullptr
					&& _outStencils == nullptr)
					return GReturn::INVALID_ARGUMENT;
				// ensure width and height are nonzero
				if (_width < 1 || _height < 1)
					return GReturn::INVALID_ARGUMENT;
				// ensure data byte and row strides are nonzero, if used
				if (_outColors && (_colorByteStride < 1 || _colorRowByteStride < 1))
					return GReturn::INVALID_ARGUMENT;
				if (_outLayers && (_layerByteStride < 1 || _layerRowByteStride < 1))
					return GReturn::INVALID_ARGUMENT;
				if (_outStencils && (_stencilByteStride < 1 || _stencilRowByteStride < 1))
					return GReturn::INVALID_ARGUMENT;
				// ensure row strides are >= width * byte strides, if used
				if (_outColors && _colorRowByteStride < _colorByteStride * _width)
					return GReturn::INVALID_ARGUMENT;
				if (_outLayers && _layerRowByteStride < _layerByteStride * _width)
					return GReturn::INVALID_ARGUMENT;
				if (_outStencils && _stencilRowByteStride < _stencilByteStride * _width)
					return GReturn::INVALID_ARGUMENT;
				// ensure data byte strides are <= row strides, if used
				if (_outColors && _colorByteStride > _colorRowByteStride)
					return GReturn::INVALID_ARGUMENT;
				if (_outLayers && _layerByteStride > _layerRowByteStride)
					return GReturn::INVALID_ARGUMENT;
				if (_outStencils && _stencilByteStride > _stencilRowByteStride)
					return GReturn::INVALID_ARGUMENT;
				// if arguments are valid, continue

				// flush any outstanding instructions to the result, if requested
				if (_flush)
					Flush();
				// set values to use while transferring data
				unsigned short w = (_width < m_result.w_image) ? _width : m_result.w_image; // only copy as much data as will fit into output buffers/only copy as much data as is in result
				unsigned short h = (_height < m_result.h_image) ? _height : m_result.h_image; // same on y
				// determine how many blocks will fit in output buffers
				unsigned short blockSpanX = w / RESULT_BLOCK_WIDTH + ((w % RESULT_BLOCK_WIDTH) ? 1 : 0);
				unsigned short blockSpanY = h / RESULT_BLOCK_HEIGHT + ((h % RESULT_BLOCK_HEIGHT) ? 1 : 0);
				// iterate through blocks
				for (unsigned short blockY = 0; blockY < blockSpanY; ++blockY)
					for (unsigned short blockX = 0; blockX < blockSpanX; ++blockX)
					{
						// store block by reference for neatness
						ResultBlock& block = m_result.data[blockX + (blockY * m_result.w_data)];
						// calculate block x/y in pixels
						unsigned short x_sourceBlock = blockX * RESULT_BLOCK_WIDTH;
						unsigned short y_sourceBlock = blockY * RESULT_BLOCK_HEIGHT;
						// determine region to copy
						unsigned short regionWidth = ((x_sourceBlock + RESULT_BLOCK_WIDTH) > w) ? w - x_sourceBlock : RESULT_BLOCK_WIDTH; // if entire width won't fit, clamp to output buffer width
						unsigned short regionHeight = ((y_sourceBlock + RESULT_BLOCK_HEIGHT) > h) ? h - y_sourceBlock : RESULT_BLOCK_HEIGHT; // same on y

						// copy data into output buffers
						if (_outColors)
						{
							if (_colorByteStride == sizeof(Color)) // if colors are contiguous, memcpy can be used
								for (unsigned short y = 0; y < regionHeight; ++y)
								{
									Byte* writeColor = reinterpret_cast<Byte*>(_outColors) + (y * _colorRowByteStride);
									memcpy(writeColor, &block.color[y * RESULT_BLOCK_WIDTH], regionWidth << 2);
								}
							else // otherwise, use pointer arithmetic instead
								for (unsigned short y = 0; y < regionHeight; ++y)
								{
									Byte* writeColor = reinterpret_cast<Byte*>(_outColors) + (y * _colorRowByteStride);
									for (unsigned short x = 0; x < regionWidth; ++x)
									{
										*(reinterpret_cast<unsigned int*>(writeColor)) = block.color[x + y * RESULT_BLOCK_WIDTH];
										writeColor += _colorByteStride;
									} // end iterate through colors in row
								} // end iterate through color rows
						} // end copy colors
						if (_outLayers)
						{
							if (_layerByteStride == sizeof(Layer)) // if layers are contiguous, memcpy can be used
								for (unsigned short y = 0; y < regionHeight; ++y)
								{
									Byte* writeLayer = reinterpret_cast<Byte*>(_outLayers) + (y * _layerRowByteStride);
									memcpy(writeLayer, &block.layer[y * RESULT_BLOCK_WIDTH], regionWidth);
								}
							else
								for (unsigned short y = 0; y < regionHeight; ++y)
								{
									Byte* writeLayer = reinterpret_cast<Byte*>(_outLayers) + (y * _layerRowByteStride);
									for (unsigned short x = 0; x < regionWidth; ++x)
									{
										*writeLayer = block.layer[x + y * RESULT_BLOCK_WIDTH];
										writeLayer += _layerByteStride;
									} // end iterate through layers in row
								} // end iterate through layer rows
						} // end copy layers
						if (_outStencils)
						{
							if (_stencilByteStride == sizeof(Stencil)) // if stencils are contiguous, memcpy can be used
								for (unsigned short y = 0; y < regionHeight; ++y)
								{
									Byte* writeStencil = reinterpret_cast<Byte*>(_outStencils) + (y * _stencilRowByteStride);
									memcpy(writeStencil, &block.stencil[y * RESULT_BLOCK_WIDTH], regionWidth);
								}
							else
								for (unsigned short y = 0; y < regionHeight; ++y)
								{
									Byte* writeStencil = reinterpret_cast<Byte*>(_outStencils) + (y * _stencilRowByteStride);
									for (unsigned short x = 0; x < regionWidth; ++x)
									{
										*writeStencil = block.stencil[x + y * RESULT_BLOCK_WIDTH];
										writeStencil += _stencilByteStride;
									} // end iterate through stencils in row
								} // end iterate through stencil rows
						} // end copy stencils
					} // end iterate through blocks
				// return success
				return GReturn::SUCCESS;
			}

#pragma endregion EXPORT_FUNCTIONS

		}; // end class GBlitterImplementation
	} // end I namespace
} // end GW namespace


#if defined(_WIN32) && !defined(NDEBUG) && defined(GBLITTER_DEBUG_VERBOSE_NEW)
#undef new
#endif

#if defined(GBLITTER_DEBUG_VERBOSE_NEW)
#undef GBLITTER_DEBUG_VERBOSE_NEW
#endif
#if defined(GBLITTER_DEBUG_SERIAL_FLUSH)
#undef GBLITTER_DEBUG_SERIAL_FLUSH
#endif
#if defined(GBLITTER_DEBUG_OUTLINE_TRANFORMED_BOUNDS)
#undef GBLITTER_DEBUG_OUTLINE_TRANFORMED_BOUNDS
#endif
#if defined(GBLITTER_DEBUG_FILL_TRANFORMED_BOUNDS)
#undef GBLITTER_DEBUG_FILL_TRANFORMED_BOUNDS
#endif
#if defined(GBLITTER_DEBUG_FILL_TRANSFORMED_TRIANGLES)
#undef GBLITTER_DEBUG_FILL_TRANSFORMED_TRIANGLES
#endif
#if defined(GBLITTER_DEBUG_DISABLE_TRANSFORMED_COLOR_LOOKUP)
#undef GBLITTER_DEBUG_DISABLE_TRANSFORMED_COLOR_LOOKUP
#endif
#if defined(GBLITTER_DEBUG_DRAW_TRANSFORMED_TRIANGLE_CORNERS)
#undef GBLITTER_DEBUG_DRAW_TRANSFORMED_TRIANGLE_CORNERS
#endif


#endif



namespace GW
{
	namespace GRAPHICS
	{
		class GBlitter final : public I::GProxy<I::GBlitterInterface, I::GBlitterImplementation, unsigned short, unsigned short>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GBlitter)
			GATEWARE_TYPEDEF(DrawOptions)
			GATEWARE_TYPEDEF(TileDefinition)
			GATEWARE_TYPEDEF(DrawInstruction)
			GATEWARE_FUNCTION(LoadSource)
			GATEWARE_FUNCTION(ImportSource)
			GATEWARE_FUNCTION(ImportSourceComplex)
			GATEWARE_FUNCTION(DefineTiles)
			GATEWARE_FUNCTION(SetTileMaskValues)
			GATEWARE_FUNCTION(DiscardSources)
			GATEWARE_FUNCTION(DiscardTiles)
			GATEWARE_FUNCTION(Clear)
			GATEWARE_FUNCTION(ClearColor)
			GATEWARE_FUNCTION(ClearLayer)
			GATEWARE_FUNCTION(ClearStencil)
			GATEWARE_FUNCTION(DrawDeferred)
			GATEWARE_FUNCTION(DrawImmediate)
			GATEWARE_FUNCTION(Flush)
			GATEWARE_FUNCTION(ExportResult)
			GATEWARE_FUNCTION(ExportResultComplex)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	};
};

#endif // GBLITTER_H


/*---------------------------------
|	End of GBlitter.h
----------------------------------*/


/*---------------------------------
|	Begin of GDirectX11Surface.h
----------------------------------*/
#ifndef GDIRECTX11SURFACE_H
#define GDIRECTX11SURFACE_H





namespace GW
{
	namespace I
	{
		class GDirectX11SurfaceInterface : public virtual GEventResponderInterface
		{
		public:
			virtual GReturn GetAspectRatio(float& _outRatio) const = 0;
			virtual GReturn GetDevice(void** _outDevice) const = 0;
			virtual GReturn GetImmediateContext(void** _outContext) const = 0;
			virtual GReturn GetSwapchain(void** _outSwapchain) const = 0;
			virtual GReturn GetRenderTargetView(void** _outRenderTarget) const = 0;
			virtual GReturn GetDepthStencilView(void** _outDepthStencilView) const = 0;
		};
	}
}

// Implementaion for GDirectX11Surface.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_GRAPHICS) || defined(GATEWARE_DISABLE_GDIRECTX11SURFACE) || defined(__APPLE__) || defined(__linux__) || \
    (defined(GATEWARE_ENABLE_GRAPHICS) && !defined(GATEWARE_DISABLE_GDIRECTX11SURFACE) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
	namespace I
	{
		class GDirectX11SurfaceImplementation : public virtual GDirectX11SurfaceInterface
		{
		public:
			GReturn Create(GW::SYSTEM::GWindow _gwindow, unsigned long long _initMask) {
				return GReturn::FEATURE_UNSUPPORTED; 
			}
			GReturn GetAspectRatio(float& _outRatio) const override {
				return GReturn::FAILURE; 
			}
			GReturn GetDevice(void** _outDevice) const override {
				return GReturn::FAILURE; 
			}
			GReturn GetImmediateContext(void** _outContext) const override {
				return GReturn::FAILURE; 
			}
			GReturn GetSwapchain(void** _outSwapchain) const override {
				return GReturn::FAILURE; 
			}
			GReturn GetRenderTargetView(void** _outRenderTarget) const override {
				return GReturn::FAILURE; 
			}
			GReturn GetDepthStencilView(void** _outDepthStencilView) const override {
				return GReturn::FAILURE; 
			}
			//GEventResponderInterface
			GReturn Assign(std::function<void()> _newHandler) override {
				return GReturn::FAILURE;
			}
			GReturn Assign(std::function<void(const GEvent&)> _newEventHandler) override {
				return GReturn::FAILURE;
			}
			GReturn Invoke() const override {
				return GReturn::FAILURE;
			}
			GReturn Invoke(const GEvent& _incomingEvent) const override {
				return GReturn::FAILURE;
			}
		};
	}
}

#elif defined(_WIN32)
    #include <wrl/client.h>
#include <d3d11.h>
#include <d2d1.h>
#pragma comment(lib, "d3d11.lib")
#pragma comment(lib, "d2d1.lib")

namespace GW
{
	namespace I
	{
		class GDirectX11SurfaceImplementation : public virtual GDirectX11SurfaceInterface,
			private virtual GEventResponderImplementation, private virtual GThreadSharedImplementation
		{
		private:
			GW::SYSTEM::GWindow gwindow;
			GW::CORE::GEventResponder responder;
			GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE UWH = {nullptr, nullptr};
			Microsoft::WRL::ComPtr<ID3D11Device> pDevice = nullptr;
			Microsoft::WRL::ComPtr<ID3D11DeviceContext> pImmediateContext = nullptr;
			Microsoft::WRL::ComPtr<IDXGISwapChain> pSwapChain = nullptr;
			Microsoft::WRL::ComPtr<ID3D11RenderTargetView> pBackBufferView = nullptr;
			Microsoft::WRL::ComPtr<ID3D11DepthStencilView> pDepthStencilView = nullptr;
			unsigned int width = 0;
			unsigned int height = 0;
			float aspectRatio = 0.0f;
		public:
			GReturn Create(GW::SYSTEM::GWindow _gwindow, unsigned long long _initMask)
			{
				if (!_gwindow)
					return GReturn::INVALID_ARGUMENT;

				gwindow = _gwindow;
				//Check if valid _initMask was passed in
				unsigned long long allowed = ~(GW::GRAPHICS::COLOR_10_BIT | GW::GRAPHICS::DEPTH_BUFFER_SUPPORT | GW::GRAPHICS::DEPTH_STENCIL_SUPPORT | GW::GRAPHICS::DIRECT2D_SUPPORT);
				if (allowed & _initMask)
				{
					return GReturn::FEATURE_UNSUPPORTED;
				}

				gwindow.GetWindowHandle(UWH);
				gwindow.GetClientWidth(width);
				gwindow.GetClientHeight(height);
				aspectRatio = static_cast<float>(width) / static_cast<float>(height);

				D3D_FEATURE_LEVEL featureLevels[] =
				{
					D3D_FEATURE_LEVEL_11_1,
					D3D_FEATURE_LEVEL_11_0,
					D3D_FEATURE_LEVEL_10_1,
					D3D_FEATURE_LEVEL_10_0,
					D3D_FEATURE_LEVEL_9_3,
					D3D_FEATURE_LEVEL_9_2,
					D3D_FEATURE_LEVEL_9_1
				};

				D3D11_CREATE_DEVICE_FLAG deviceFlag = D3D11_CREATE_DEVICE_FLAG(0);

#ifdef _DEBUG
				deviceFlag = D3D11_CREATE_DEVICE_FLAG(deviceFlag | D3D11_CREATE_DEVICE_DEBUG);
#endif

				if (_initMask & GW::GRAPHICS::DIRECT2D_SUPPORT)
				{
					deviceFlag = D3D11_CREATE_DEVICE_FLAG(deviceFlag | D3D11_CREATE_DEVICE_BGRA_SUPPORT); // | D3D11_CREATE_DEVICE_VIDEO_SUPPORT);
				}

				DXGI_SWAP_CHAIN_DESC swapChainStruct;
				swapChainStruct.BufferCount = 1;

				if (_initMask & GW::GRAPHICS::COLOR_10_BIT)
					swapChainStruct.BufferDesc.Format = DXGI_FORMAT_R10G10B10A2_UNORM;
				else if (_initMask & GW::GRAPHICS::DIRECT2D_SUPPORT)
					swapChainStruct.BufferDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;
				else
					swapChainStruct.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;

				swapChainStruct.BufferDesc.Width = width;
				swapChainStruct.BufferDesc.Height = height;
				ZeroMemory(&swapChainStruct.BufferDesc.RefreshRate, sizeof(swapChainStruct.BufferDesc.RefreshRate));
				ZeroMemory(&swapChainStruct.BufferDesc.Scaling, sizeof(swapChainStruct.BufferDesc.Scaling));
				ZeroMemory(&swapChainStruct.BufferDesc.ScanlineOrdering, sizeof(swapChainStruct.BufferDesc.ScanlineOrdering));
				swapChainStruct.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
				swapChainStruct.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
				swapChainStruct.OutputWindow = static_cast<HWND>(UWH.window);
				swapChainStruct.Windowed = TRUE;
				swapChainStruct.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
				swapChainStruct.SampleDesc.Count = 1;
				swapChainStruct.SampleDesc.Quality = 0;

				HRESULT hr = D3D11CreateDeviceAndSwapChain(
					nullptr,
					D3D_DRIVER_TYPE_HARDWARE,
					nullptr,
					deviceFlag,
					featureLevels,
					ARRAYSIZE(featureLevels),
					D3D11_SDK_VERSION,
					&swapChainStruct,
					&pSwapChain,
					&pDevice,
					nullptr,
					&pImmediateContext
				);
				if (hr != S_OK)
					return GReturn::HARDWARE_UNAVAILABLE;

				ID3D11Resource* buffer;
				pSwapChain->GetBuffer(0, __uuidof(buffer), reinterpret_cast<void**>(&buffer));

				if (buffer)
					pDevice->CreateRenderTargetView(buffer, nullptr, &pBackBufferView);

				buffer->Release();

				if (_initMask & GW::GRAPHICS::DEPTH_BUFFER_SUPPORT)
				{
					/////////////////////////////////
					// Create Depth Buffer Texture //
					/////////////////////////////////

					D3D11_TEXTURE2D_DESC depthTextureDesc = { 0 };
					depthTextureDesc.Width = width;
					depthTextureDesc.Height = height;
					depthTextureDesc.ArraySize = 1;
					depthTextureDesc.MipLevels = 1;
					depthTextureDesc.SampleDesc.Count = 1;

					if (_initMask & GW::GRAPHICS::DEPTH_STENCIL_SUPPORT)
						depthTextureDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
					else
						depthTextureDesc.Format = DXGI_FORMAT_D32_FLOAT;

					depthTextureDesc.BindFlags = D3D11_BIND_DEPTH_STENCIL;

					ID3D11Texture2D* depthBuffer;
					pDevice->CreateTexture2D(&depthTextureDesc, nullptr, &depthBuffer);

					///////////////////////////////
					// Create Depth Stencil View //
					///////////////////////////////

					D3D11_DEPTH_STENCIL_VIEW_DESC depthStencilViewDesc;
					ZeroMemory(&depthStencilViewDesc, sizeof(depthStencilViewDesc));

					if (_initMask & GW::GRAPHICS::DEPTH_STENCIL_SUPPORT)
						depthStencilViewDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
					else
						depthStencilViewDesc.Format = DXGI_FORMAT_D32_FLOAT;

					depthStencilViewDesc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2D;

					if (depthBuffer)
						hr = pDevice->CreateDepthStencilView(depthBuffer, &depthStencilViewDesc, &pDepthStencilView);

					depthBuffer->Release();
				}

				/////////////////////////
				// Initialize Viewport //
				/////////////////////////

				D3D11_VIEWPORT viewport;
				viewport.Width = static_cast<float>(width);
				viewport.Height = static_cast<float>(height);
				viewport.MinDepth = 0.0f;
				viewport.MaxDepth = 1.0f;

				unsigned int nTopLeftX = 0;
				unsigned int nTopLeftY = 0;
				gwindow.GetClientTopLeft(nTopLeftX, nTopLeftY);

				viewport.TopLeftX = static_cast<float>(nTopLeftX);
				viewport.TopLeftY = static_cast<float>(nTopLeftY);

				pImmediateContext->RSSetViewports(1, &viewport);
				// Call back event handler for DX11
				GReturn result = responder.Create([&](const GEvent& event)
				{
					GW::SYSTEM::GWindow::Events windowEvent;
					GW::SYSTEM::GWindow::EVENT_DATA windowEventData;
					if (+event.Read(windowEvent, windowEventData))
					{
						switch (windowEvent)
						{
						case GW::SYSTEM::GWindow::Events::MINIMIZE: {} break;
						case GW::SYSTEM::GWindow::Events::DESTROY: {} break;

						case GW::SYSTEM::GWindow::Events::MAXIMIZE:
						case GW::SYSTEM::GWindow::Events::RESIZE:
						{
							gwindow.GetClientWidth(width);
								gwindow.GetClientHeight(height);

							aspectRatio = static_cast<float>(width) / static_cast<float>(height);

							if (pSwapChain)
							{
								pBackBufferView.Reset();

								HRESULT hr = pSwapChain->ResizeBuffers(0, width, height, DXGI_FORMAT_UNKNOWN, 0);
								if (hr != S_OK)
									return;

								ID3D11Texture2D* newRTVBuffer;
								hr = pSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast<void**>(&newRTVBuffer));

								if (hr != S_OK)
									return;

								hr = pDevice->CreateRenderTargetView(newRTVBuffer, nullptr, &pBackBufferView);
								newRTVBuffer->Release();

								if (hr != S_OK)
									return;

								D3D11_TEXTURE2D_DESC depthTextureDesc = { 0 };
								depthTextureDesc.Width = width;
								depthTextureDesc.Height = height;
								depthTextureDesc.ArraySize = 1;
								depthTextureDesc.MipLevels = 1;
								depthTextureDesc.SampleDesc.Count = 1;
								depthTextureDesc.Format = DXGI_FORMAT_D32_FLOAT;
								depthTextureDesc.BindFlags = D3D11_BIND_DEPTH_STENCIL;

								if (pDepthStencilView)
								{
									pDepthStencilView.Reset();
									ID3D11Texture2D* depthBuffer;
									pDevice->CreateTexture2D(&depthTextureDesc, nullptr, &depthBuffer);

									D3D11_DEPTH_STENCIL_VIEW_DESC newDSVdesc;
									ZeroMemory(&newDSVdesc, sizeof(D3D11_DEPTH_STENCIL_VIEW_DESC));
									newDSVdesc.Format = DXGI_FORMAT_D32_FLOAT;
									newDSVdesc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2DMS;

									if (depthBuffer)
										pDevice->CreateDepthStencilView(depthBuffer, &newDSVdesc, &pDepthStencilView);

									depthBuffer->Release();
								}

								D3D11_VIEWPORT viewport;
								viewport.TopLeftX = 0;
								viewport.TopLeftY = 0;
								viewport.Width = static_cast<float>(width);
								viewport.Height = static_cast<float>(height);
								viewport.MinDepth = 0.0f;
								viewport.MaxDepth = 1.0f;

								pImmediateContext->RSSetViewports(1, &viewport);
							}
						}
						break;

						case GW::SYSTEM::GWindow::Events::MOVE:
						{
							gwindow.GetClientWidth(width);
							gwindow.GetClientHeight(height);

							D3D11_VIEWPORT viewport;
							viewport.TopLeftX = 0;
							viewport.TopLeftY = 0;
							viewport.Width = static_cast<float>(width);
							viewport.Height = static_cast<float>(height);
							viewport.MinDepth = 0.0f;
							viewport.MaxDepth = 1.0f;

							pImmediateContext->RSSetViewports(1, &viewport);
						}
						break;
						}
					}
				});
				if (G_PASS(result))
				{
					gwindow.Register(responder);
				}
				return result;
			}

			GReturn GetAspectRatio(float& _outRatio) const override
			{
				if (!gwindow)
					return GReturn::FAILURE;

				_outRatio = aspectRatio;
				return GReturn::SUCCESS;
			}

			GReturn GetDevice(void** _outDevice) const override
			{
				if (!pDevice)
					return GReturn::FAILURE;

				*_outDevice = pDevice.Get();
				pDevice->AddRef();
				return GReturn::SUCCESS;
			}

			GReturn GetImmediateContext(void** _outContext) const override
			{
				if (!pImmediateContext)
					return GReturn::FAILURE;

				*_outContext = pImmediateContext.Get();
				pImmediateContext->AddRef();
				return GReturn::SUCCESS;
			}

			GReturn GetSwapchain(void** _outSwapchain) const override
			{
				if (!pSwapChain)
					return GReturn::FAILURE;

				*_outSwapchain = pSwapChain.Get();
				pSwapChain->AddRef();
				return GReturn::SUCCESS;
			}

			GReturn GetRenderTargetView(void** _outRenderTarget) const override
			{
				if (!pBackBufferView)
					return GReturn::FAILURE;

				*_outRenderTarget = pBackBufferView.Get();
				pBackBufferView->AddRef();
				return GReturn::SUCCESS;
			}

			GReturn GetDepthStencilView(void** _outDepthStencilView) const override
			{
				if (!pDepthStencilView)
					return GReturn::FAILURE;

				*_outDepthStencilView = pDepthStencilView.Get();
				pDepthStencilView->AddRef();
				return GReturn::SUCCESS;
			}
			//GEventResponderInterface
			GReturn Assign(std::function<void()> _newHandler) override {
				return responder.Assign(_newHandler);
			}
			GReturn Assign(std::function<void(const GEvent&)> _newEventHandler) override {
				return responder.Assign(_newEventHandler);
			}
			GReturn Invoke() const override {
				return responder.Invoke();
			}
			GReturn Invoke(const GEvent& _incomingEvent) const override {
				return responder.Invoke(_incomingEvent);
			}
		};
	}
}

#endif


namespace GW
{
	namespace GRAPHICS
	{
		class GDirectX11Surface final
			: public I::GProxy<I::GDirectX11SurfaceInterface, I::GDirectX11SurfaceImplementation, GW::SYSTEM::GWindow, unsigned long long>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GDirectX11Surface)
			GATEWARE_CONST_FUNCTION(GetAspectRatio)
			GATEWARE_CONST_FUNCTION(GetDevice)
			GATEWARE_CONST_FUNCTION(GetImmediateContext)
			GATEWARE_CONST_FUNCTION(GetSwapchain)
			GATEWARE_CONST_FUNCTION(GetRenderTargetView)
			GATEWARE_CONST_FUNCTION(GetDepthStencilView)

			// reimplemented functions
			// from GEventResponderInterface
			GATEWARE_FUNCTION(Assign)
			GATEWARE_CONST_FUNCTION(Invoke)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GDIRECTX11SURFACE_H

/*---------------------------------
|	End of GDirectX11Surface.h
----------------------------------*/


/*---------------------------------
|	Begin of GOpenGLSurface.h
----------------------------------*/
#ifndef GOPENGLSURFACE_H
#define GOPENGLSURFACE_H






namespace GW
{
	namespace I
	{
		class GOpenGLSurfaceInterface : public virtual GEventResponderInterface
		{
		public:
			virtual GReturn GetAspectRatio(float& _outRatio) const = 0;
			virtual GReturn GetContext(void** _outContext) const = 0;
			virtual GReturn UniversalSwapBuffers() = 0;
			virtual GReturn QueryExtensionFunction(const char* _extension, const char* _funcName, void** _outFuncAddress) = 0;
			virtual GReturn EnableSwapControl(bool _setSwapControl) = 0;
		};
	}
}

// Implementaion for GOpenGLSurface.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_GRAPHICS) || defined(GATEWARE_DISABLE_GOPENGLSURFACE) || defined(__APPLE__) || \
    (defined(GATEWARE_ENABLE_GRAPHICS) && !defined(GATEWARE_DISABLE_GOPENGLSURFACE) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW {
	namespace I 	{
		class GOpenGLSurfaceImplementation : public virtual GOpenGLSurfaceInterface 		{
		public:
			GReturn Create(GW::SYSTEM::GWindow _gwindow, unsigned long long _initMask) {
				return GReturn::FEATURE_UNSUPPORTED;
			}
			GReturn GetAspectRatio(float& _outRatio) const override {
				return GReturn::FAILURE;
			}
			GReturn GetContext(void** _outContext) const override {
				return GReturn::FAILURE;
			}
			GReturn UniversalSwapBuffers() override {
				return GReturn::FAILURE;
			}
			GReturn QueryExtensionFunction(const char* _extension, const char* _funcName,
										   void** _outFuncAddress) override {
				return GReturn::FAILURE;
			}
			GReturn EnableSwapControl(bool _setSwapControl) override {
				return GReturn::FAILURE;
			}

			//GEventResponderInterface
			GReturn Assign(std::function<void()> _newHandler) override {
				return GReturn::FAILURE;
			}
			GReturn Assign(std::function<void(const GEvent&)> _newEventHandler) override {
				return GReturn::FAILURE;
			}
			GReturn Invoke() const override {
				return GReturn::FAILURE;
			}
			GReturn Invoke(const GEvent& _incomingEvent) const override {
				return GReturn::FAILURE;
			}
		};
	}
}


#elif defined(__linux__)
    #include <X11/Xlib.h>
#include <GL/gl.h>
#include <GL/glx.h>
#include <unistd.h>
#ifndef __glxext_h_
#define __glxext_h_ 1

#ifdef __cplusplus
extern "C" {
#endif

/*
** Copyright (c) 2013-2017 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/
/*
** This header is generated from the Khronos OpenGL / OpenGL ES XML
** API Registry. The current version of the Registry, generator scripts
** used to make the header, and the header can be found at
**   https://github.com/KhronosGroup/OpenGL-Registry
*/

#ifndef GLX_GLXEXT_VERSION
    #define GLX_GLXEXT_VERSION 20170926
#endif

/* Generated C header for:
 * API: glx
 * Versions considered: .*
 * Versions emitted: 1\.[3-9]
 * Default extensions included: glx
 * Additional extensions included: _nomatch_^
 * Extensions removed: _nomatch_^
 */

#ifndef GLX_VERSION_1_3
#define GLX_VERSION_1_3 1
typedef XID GLXContextID;
typedef struct __GLXFBConfigRec *GLXFBConfig;
typedef XID GLXWindow;
typedef XID GLXPbuffer;
#define GLX_WINDOW_BIT                    0x00000001
#define GLX_PIXMAP_BIT                    0x00000002
#define GLX_PBUFFER_BIT                   0x00000004
#define GLX_RGBA_BIT                      0x00000001
#define GLX_COLOR_INDEX_BIT               0x00000002
#define GLX_PBUFFER_CLOBBER_MASK          0x08000000
#define GLX_FRONT_LEFT_BUFFER_BIT         0x00000001
#define GLX_FRONT_RIGHT_BUFFER_BIT        0x00000002
#define GLX_BACK_LEFT_BUFFER_BIT          0x00000004
#define GLX_BACK_RIGHT_BUFFER_BIT         0x00000008
#define GLX_AUX_BUFFERS_BIT               0x00000010
#define GLX_DEPTH_BUFFER_BIT              0x00000020
#define GLX_STENCIL_BUFFER_BIT            0x00000040
#define GLX_ACCUM_BUFFER_BIT              0x00000080
#define GLX_CONFIG_CAVEAT                 0x20
#define GLX_X_VISUAL_TYPE                 0x22
#define GLX_TRANSPARENT_TYPE              0x23
#define GLX_TRANSPARENT_INDEX_VALUE       0x24
#define GLX_TRANSPARENT_RED_VALUE         0x25
#define GLX_TRANSPARENT_GREEN_VALUE       0x26
#define GLX_TRANSPARENT_BLUE_VALUE        0x27
#define GLX_TRANSPARENT_ALPHA_VALUE       0x28
#define GLX_DONT_CARE                     0xFFFFFFFF
#define GLX_NONE                          0x8000
#define GLX_SLOW_CONFIG                   0x8001
#define GLX_TRUE_COLOR                    0x8002
#define GLX_DIRECT_COLOR                  0x8003
#define GLX_PSEUDO_COLOR                  0x8004
#define GLX_STATIC_COLOR                  0x8005
#define GLX_GRAY_SCALE                    0x8006
#define GLX_STATIC_GRAY                   0x8007
#define GLX_TRANSPARENT_RGB               0x8008
#define GLX_TRANSPARENT_INDEX             0x8009
#define GLX_VISUAL_ID                     0x800B
#define GLX_SCREEN                        0x800C
#define GLX_NON_CONFORMANT_CONFIG         0x800D
#define GLX_DRAWABLE_TYPE                 0x8010
#define GLX_RENDER_TYPE                   0x8011
#define GLX_X_RENDERABLE                  0x8012
#define GLX_FBCONFIG_ID                   0x8013
#define GLX_RGBA_TYPE                     0x8014
#define GLX_COLOR_INDEX_TYPE              0x8015
#define GLX_MAX_PBUFFER_WIDTH             0x8016
#define GLX_MAX_PBUFFER_HEIGHT            0x8017
#define GLX_MAX_PBUFFER_PIXELS            0x8018
#define GLX_PRESERVED_CONTENTS            0x801B
#define GLX_LARGEST_PBUFFER               0x801C
#define GLX_WIDTH                         0x801D
#define GLX_HEIGHT                        0x801E
#define GLX_EVENT_MASK                    0x801F
#define GLX_DAMAGED                       0x8020
#define GLX_SAVED                         0x8021
#define GLX_WINDOW                        0x8022
#define GLX_PBUFFER                       0x8023
#define GLX_PBUFFER_HEIGHT                0x8040
#define GLX_PBUFFER_WIDTH                 0x8041
typedef GLXFBConfig *( *PFNGLXGETFBCONFIGSPROC) (Display *dpy, int screen, int *nelements);
typedef GLXFBConfig *( *PFNGLXCHOOSEFBCONFIGPROC) (Display *dpy, int screen, const int *attrib_list, int *nelements);
typedef int ( *PFNGLXGETFBCONFIGATTRIBPROC) (Display *dpy, GLXFBConfig config, int attribute, int *value);
typedef XVisualInfo *( *PFNGLXGETVISUALFROMFBCONFIGPROC) (Display *dpy, GLXFBConfig config);
typedef GLXWindow ( *PFNGLXCREATEWINDOWPROC) (Display *dpy, GLXFBConfig config, Window win, const int *attrib_list);
typedef void ( *PFNGLXDESTROYWINDOWPROC) (Display *dpy, GLXWindow win);
typedef GLXPixmap ( *PFNGLXCREATEPIXMAPPROC) (Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attrib_list);
typedef void ( *PFNGLXDESTROYPIXMAPPROC) (Display *dpy, GLXPixmap pixmap);
typedef GLXPbuffer ( *PFNGLXCREATEPBUFFERPROC) (Display *dpy, GLXFBConfig config, const int *attrib_list);
typedef void ( *PFNGLXDESTROYPBUFFERPROC) (Display *dpy, GLXPbuffer pbuf);
typedef void ( *PFNGLXQUERYDRAWABLEPROC) (Display *dpy, GLXDrawable draw, int attribute, unsigned int *value);
typedef GLXContext ( *PFNGLXCREATENEWCONTEXTPROC) (Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct);
typedef Bool ( *PFNGLXMAKECONTEXTCURRENTPROC) (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
typedef GLXDrawable ( *PFNGLXGETCURRENTREADDRAWABLEPROC) (void);
typedef int ( *PFNGLXQUERYCONTEXTPROC) (Display *dpy, GLXContext ctx, int attribute, int *value);
typedef void ( *PFNGLXSELECTEVENTPROC) (Display *dpy, GLXDrawable draw, unsigned long event_mask);
typedef void ( *PFNGLXGETSELECTEDEVENTPROC) (Display *dpy, GLXDrawable draw, unsigned long *event_mask);
#ifdef GLX_GLXEXT_PROTOTYPES
GLXFBConfig *glXGetFBConfigs (Display *dpy, int screen, int *nelements);
GLXFBConfig *glXChooseFBConfig (Display *dpy, int screen, const int *attrib_list, int *nelements);
int glXGetFBConfigAttrib (Display *dpy, GLXFBConfig config, int attribute, int *value);
XVisualInfo *glXGetVisualFromFBConfig (Display *dpy, GLXFBConfig config);
GLXWindow glXCreateWindow (Display *dpy, GLXFBConfig config, Window win, const int *attrib_list);
void glXDestroyWindow (Display *dpy, GLXWindow win);
GLXPixmap glXCreatePixmap (Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attrib_list);
void glXDestroyPixmap (Display *dpy, GLXPixmap pixmap);
GLXPbuffer glXCreatePbuffer (Display *dpy, GLXFBConfig config, const int *attrib_list);
void glXDestroyPbuffer (Display *dpy, GLXPbuffer pbuf);
void glXQueryDrawable (Display *dpy, GLXDrawable draw, int attribute, unsigned int *value);
GLXContext glXCreateNewContext (Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct);
Bool glXMakeContextCurrent (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
GLXDrawable glXGetCurrentReadDrawable (void);
int glXQueryContext (Display *dpy, GLXContext ctx, int attribute, int *value);
void glXSelectEvent (Display *dpy, GLXDrawable draw, unsigned long event_mask);
void glXGetSelectedEvent (Display *dpy, GLXDrawable draw, unsigned long *event_mask);
#endif
#endif /* GLX_VERSION_1_3 */

#ifndef GLX_VERSION_1_4
#define GLX_VERSION_1_4 1
typedef void ( *__GLXextFuncPtr)(void);
#define GLX_SAMPLE_BUFFERS                100000
#define GLX_SAMPLES                       100001
typedef __GLXextFuncPtr ( *PFNGLXGETPROCADDRESSPROC) (const GLubyte *procName);
#ifdef GLX_GLXEXT_PROTOTYPES
__GLXextFuncPtr glXGetProcAddress (const GLubyte *procName);
#endif
#endif /* GLX_VERSION_1_4 */

#ifndef GLX_ARB_context_flush_control
#define GLX_ARB_context_flush_control 1
#define GLX_CONTEXT_RELEASE_BEHAVIOR_ARB  0x2097
#define GLX_CONTEXT_RELEASE_BEHAVIOR_NONE_ARB 0
#define GLX_CONTEXT_RELEASE_BEHAVIOR_FLUSH_ARB 0x2098
#endif /* GLX_ARB_context_flush_control */

#ifndef GLX_ARB_create_context
#define GLX_ARB_create_context 1
#define GLX_CONTEXT_DEBUG_BIT_ARB         0x00000001
#define GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB 0x00000002
#define GLX_CONTEXT_MAJOR_VERSION_ARB     0x2091
#define GLX_CONTEXT_MINOR_VERSION_ARB     0x2092
#define GLX_CONTEXT_FLAGS_ARB             0x2094
typedef GLXContext ( *PFNGLXCREATECONTEXTATTRIBSARBPROC) (Display *dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *attrib_list);
#ifdef GLX_GLXEXT_PROTOTYPES
GLXContext glXCreateContextAttribsARB (Display *dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *attrib_list);
#endif
#endif /* GLX_ARB_create_context */

#ifndef GLX_ARB_create_context_no_error
#define GLX_ARB_create_context_no_error 1
#define GLX_CONTEXT_OPENGL_NO_ERROR_ARB   0x31B3
#endif /* GLX_ARB_create_context_no_error */

#ifndef GLX_ARB_create_context_profile
#define GLX_ARB_create_context_profile 1
#define GLX_CONTEXT_CORE_PROFILE_BIT_ARB  0x00000001
#define GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB 0x00000002
#define GLX_CONTEXT_PROFILE_MASK_ARB      0x9126
#endif /* GLX_ARB_create_context_profile */

#ifndef GLX_ARB_create_context_robustness
#define GLX_ARB_create_context_robustness 1
#define GLX_CONTEXT_ROBUST_ACCESS_BIT_ARB 0x00000004
#define GLX_LOSE_CONTEXT_ON_RESET_ARB     0x8252
#define GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB 0x8256
#define GLX_NO_RESET_NOTIFICATION_ARB     0x8261
#endif /* GLX_ARB_create_context_robustness */

#ifndef GLX_ARB_fbconfig_float
#define GLX_ARB_fbconfig_float 1
#define GLX_RGBA_FLOAT_TYPE_ARB           0x20B9
#define GLX_RGBA_FLOAT_BIT_ARB            0x00000004
#endif /* GLX_ARB_fbconfig_float */

#ifndef GLX_ARB_framebuffer_sRGB
#define GLX_ARB_framebuffer_sRGB 1
#define GLX_FRAMEBUFFER_SRGB_CAPABLE_ARB  0x20B2
#endif /* GLX_ARB_framebuffer_sRGB */

#ifndef GLX_ARB_get_proc_address
#define GLX_ARB_get_proc_address 1
typedef __GLXextFuncPtr ( *PFNGLXGETPROCADDRESSARBPROC) (const GLubyte *procName);
#ifdef GLX_GLXEXT_PROTOTYPES
__GLXextFuncPtr glXGetProcAddressARB (const GLubyte *procName);
#endif
#endif /* GLX_ARB_get_proc_address */

#ifndef GLX_ARB_multisample
#define GLX_ARB_multisample 1
#define GLX_SAMPLE_BUFFERS_ARB            100000
#define GLX_SAMPLES_ARB                   100001
#endif /* GLX_ARB_multisample */

#ifndef GLX_ARB_robustness_application_isolation
#define GLX_ARB_robustness_application_isolation 1
#define GLX_CONTEXT_RESET_ISOLATION_BIT_ARB 0x00000008
#endif /* GLX_ARB_robustness_application_isolation */

#ifndef GLX_ARB_robustness_share_group_isolation
#define GLX_ARB_robustness_share_group_isolation 1
#endif /* GLX_ARB_robustness_share_group_isolation */

#ifndef GLX_ARB_vertex_buffer_object
#define GLX_ARB_vertex_buffer_object 1
#define GLX_CONTEXT_ALLOW_BUFFER_BYTE_ORDER_MISMATCH_ARB 0x2095
#endif /* GLX_ARB_vertex_buffer_object */

#ifndef GLX_3DFX_multisample
#define GLX_3DFX_multisample 1
#define GLX_SAMPLE_BUFFERS_3DFX           0x8050
#define GLX_SAMPLES_3DFX                  0x8051
#endif /* GLX_3DFX_multisample */

#ifndef GLX_AMD_gpu_association
#define GLX_AMD_gpu_association 1
#define GLX_GPU_VENDOR_AMD                0x1F00
#define GLX_GPU_RENDERER_STRING_AMD       0x1F01
#define GLX_GPU_OPENGL_VERSION_STRING_AMD 0x1F02
#define GLX_GPU_FASTEST_TARGET_GPUS_AMD   0x21A2
#define GLX_GPU_RAM_AMD                   0x21A3
#define GLX_GPU_CLOCK_AMD                 0x21A4
#define GLX_GPU_NUM_PIPES_AMD             0x21A5
#define GLX_GPU_NUM_SIMD_AMD              0x21A6
#define GLX_GPU_NUM_RB_AMD                0x21A7
#define GLX_GPU_NUM_SPI_AMD               0x21A8
typedef unsigned int ( *PFNGLXGETGPUIDSAMDPROC) (unsigned int maxCount, unsigned int *ids);
typedef int ( *PFNGLXGETGPUINFOAMDPROC) (unsigned int id, int property, GLenum dataType, unsigned int size, void *data);
typedef unsigned int ( *PFNGLXGETCONTEXTGPUIDAMDPROC) (GLXContext ctx);
typedef GLXContext ( *PFNGLXCREATEASSOCIATEDCONTEXTAMDPROC) (unsigned int id, GLXContext share_list);
typedef GLXContext ( *PFNGLXCREATEASSOCIATEDCONTEXTATTRIBSAMDPROC) (unsigned int id, GLXContext share_context, const int *attribList);
typedef Bool ( *PFNGLXDELETEASSOCIATEDCONTEXTAMDPROC) (GLXContext ctx);
typedef Bool ( *PFNGLXMAKEASSOCIATEDCONTEXTCURRENTAMDPROC) (GLXContext ctx);
typedef GLXContext ( *PFNGLXGETCURRENTASSOCIATEDCONTEXTAMDPROC) (void);
typedef void ( *PFNGLXBLITCONTEXTFRAMEBUFFERAMDPROC) (GLXContext dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
#ifdef GLX_GLXEXT_PROTOTYPES
unsigned int glXGetGPUIDsAMD (unsigned int maxCount, unsigned int *ids);
int glXGetGPUInfoAMD (unsigned int id, int property, GLenum dataType, unsigned int size, void *data);
unsigned int glXGetContextGPUIDAMD (GLXContext ctx);
GLXContext glXCreateAssociatedContextAMD (unsigned int id, GLXContext share_list);
GLXContext glXCreateAssociatedContextAttribsAMD (unsigned int id, GLXContext share_context, const int *attribList);
Bool glXDeleteAssociatedContextAMD (GLXContext ctx);
Bool glXMakeAssociatedContextCurrentAMD (GLXContext ctx);
GLXContext glXGetCurrentAssociatedContextAMD (void);
void glXBlitContextFramebufferAMD (GLXContext dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
#endif
#endif /* GLX_AMD_gpu_association */

#ifndef GLX_EXT_buffer_age
#define GLX_EXT_buffer_age 1
#define GLX_BACK_BUFFER_AGE_EXT           0x20F4
#endif /* GLX_EXT_buffer_age */

#ifndef GLX_EXT_create_context_es2_profile
#define GLX_EXT_create_context_es2_profile 1
#define GLX_CONTEXT_ES2_PROFILE_BIT_EXT   0x00000004
#endif /* GLX_EXT_create_context_es2_profile */

#ifndef GLX_EXT_create_context_es_profile
#define GLX_EXT_create_context_es_profile 1
#define GLX_CONTEXT_ES_PROFILE_BIT_EXT    0x00000004
#endif /* GLX_EXT_create_context_es_profile */

#ifndef GLX_EXT_fbconfig_packed_float
#define GLX_EXT_fbconfig_packed_float 1
#define GLX_RGBA_UNSIGNED_FLOAT_TYPE_EXT  0x20B1
#define GLX_RGBA_UNSIGNED_FLOAT_BIT_EXT   0x00000008
#endif /* GLX_EXT_fbconfig_packed_float */

#ifndef GLX_EXT_framebuffer_sRGB
#define GLX_EXT_framebuffer_sRGB 1
#define GLX_FRAMEBUFFER_SRGB_CAPABLE_EXT  0x20B2
#endif /* GLX_EXT_framebuffer_sRGB */

#ifndef GLX_EXT_import_context
#define GLX_EXT_import_context 1
#define GLX_SHARE_CONTEXT_EXT             0x800A
#define GLX_VISUAL_ID_EXT                 0x800B
#define GLX_SCREEN_EXT                    0x800C
typedef Display *( *PFNGLXGETCURRENTDISPLAYEXTPROC) (void);
typedef int ( *PFNGLXQUERYCONTEXTINFOEXTPROC) (Display *dpy, GLXContext context, int attribute, int *value);
typedef GLXContextID ( *PFNGLXGETCONTEXTIDEXTPROC) (const GLXContext context);
typedef GLXContext ( *PFNGLXIMPORTCONTEXTEXTPROC) (Display *dpy, GLXContextID contextID);
typedef void ( *PFNGLXFREECONTEXTEXTPROC) (Display *dpy, GLXContext context);
#ifdef GLX_GLXEXT_PROTOTYPES
Display *glXGetCurrentDisplayEXT (void);
int glXQueryContextInfoEXT (Display *dpy, GLXContext context, int attribute, int *value);
GLXContextID glXGetContextIDEXT (const GLXContext context);
GLXContext glXImportContextEXT (Display *dpy, GLXContextID contextID);
void glXFreeContextEXT (Display *dpy, GLXContext context);
#endif
#endif /* GLX_EXT_import_context */

#ifndef GLX_EXT_libglvnd
#define GLX_EXT_libglvnd 1
#define GLX_VENDOR_NAMES_EXT              0x20F6
#endif /* GLX_EXT_libglvnd */

#ifndef GLX_EXT_stereo_tree
#define GLX_EXT_stereo_tree 1
typedef struct {
    int type;
    unsigned long serial;
    Bool send_event;
    Display *display;
    int extension;
    int evtype;
    GLXDrawable window;
    Bool stereo_tree;
} GLXStereoNotifyEventEXT;
#define GLX_STEREO_TREE_EXT               0x20F5
#define GLX_STEREO_NOTIFY_MASK_EXT        0x00000001
#define GLX_STEREO_NOTIFY_EXT             0x00000000
#endif /* GLX_EXT_stereo_tree */

#ifndef GLX_EXT_swap_control
#define GLX_EXT_swap_control 1
#define GLX_SWAP_INTERVAL_EXT             0x20F1
#define GLX_MAX_SWAP_INTERVAL_EXT         0x20F2
typedef void ( *PFNGLXSWAPINTERVALEXTPROC) (Display *dpy, GLXDrawable drawable, int interval);
#ifdef GLX_GLXEXT_PROTOTYPES
void glXSwapIntervalEXT (Display *dpy, GLXDrawable drawable, int interval);
#endif
#endif /* GLX_EXT_swap_control */

#ifndef GLX_EXT_swap_control_tear
#define GLX_EXT_swap_control_tear 1
#define GLX_LATE_SWAPS_TEAR_EXT           0x20F3
#endif /* GLX_EXT_swap_control_tear */

#ifndef GLX_EXT_texture_from_pixmap
#define GLX_EXT_texture_from_pixmap 1
#define GLX_TEXTURE_1D_BIT_EXT            0x00000001
#define GLX_TEXTURE_2D_BIT_EXT            0x00000002
#define GLX_TEXTURE_RECTANGLE_BIT_EXT     0x00000004
#define GLX_BIND_TO_TEXTURE_RGB_EXT       0x20D0
#define GLX_BIND_TO_TEXTURE_RGBA_EXT      0x20D1
#define GLX_BIND_TO_MIPMAP_TEXTURE_EXT    0x20D2
#define GLX_BIND_TO_TEXTURE_TARGETS_EXT   0x20D3
#define GLX_Y_INVERTED_EXT                0x20D4
#define GLX_TEXTURE_FORMAT_EXT            0x20D5
#define GLX_TEXTURE_TARGET_EXT            0x20D6
#define GLX_MIPMAP_TEXTURE_EXT            0x20D7
#define GLX_TEXTURE_FORMAT_NONE_EXT       0x20D8
#define GLX_TEXTURE_FORMAT_RGB_EXT        0x20D9
#define GLX_TEXTURE_FORMAT_RGBA_EXT       0x20DA
#define GLX_TEXTURE_1D_EXT                0x20DB
#define GLX_TEXTURE_2D_EXT                0x20DC
#define GLX_TEXTURE_RECTANGLE_EXT         0x20DD
#define GLX_FRONT_LEFT_EXT                0x20DE
#define GLX_FRONT_RIGHT_EXT               0x20DF
#define GLX_BACK_LEFT_EXT                 0x20E0
#define GLX_BACK_RIGHT_EXT                0x20E1
#define GLX_FRONT_EXT                     0x20DE
#define GLX_BACK_EXT                      0x20E0
#define GLX_AUX0_EXT                      0x20E2
#define GLX_AUX1_EXT                      0x20E3
#define GLX_AUX2_EXT                      0x20E4
#define GLX_AUX3_EXT                      0x20E5
#define GLX_AUX4_EXT                      0x20E6
#define GLX_AUX5_EXT                      0x20E7
#define GLX_AUX6_EXT                      0x20E8
#define GLX_AUX7_EXT                      0x20E9
#define GLX_AUX8_EXT                      0x20EA
#define GLX_AUX9_EXT                      0x20EB
typedef void ( *PFNGLXBINDTEXIMAGEEXTPROC) (Display *dpy, GLXDrawable drawable, int buffer, const int *attrib_list);
typedef void ( *PFNGLXRELEASETEXIMAGEEXTPROC) (Display *dpy, GLXDrawable drawable, int buffer);
#ifdef GLX_GLXEXT_PROTOTYPES
void glXBindTexImageEXT (Display *dpy, GLXDrawable drawable, int buffer, const int *attrib_list);
void glXReleaseTexImageEXT (Display *dpy, GLXDrawable drawable, int buffer);
#endif
#endif /* GLX_EXT_texture_from_pixmap */

#ifndef GLX_EXT_visual_info
#define GLX_EXT_visual_info 1
#define GLX_X_VISUAL_TYPE_EXT             0x22
#define GLX_TRANSPARENT_TYPE_EXT          0x23
#define GLX_TRANSPARENT_INDEX_VALUE_EXT   0x24
#define GLX_TRANSPARENT_RED_VALUE_EXT     0x25
#define GLX_TRANSPARENT_GREEN_VALUE_EXT   0x26
#define GLX_TRANSPARENT_BLUE_VALUE_EXT    0x27
#define GLX_TRANSPARENT_ALPHA_VALUE_EXT   0x28
#define GLX_NONE_EXT                      0x8000
#define GLX_TRUE_COLOR_EXT                0x8002
#define GLX_DIRECT_COLOR_EXT              0x8003
#define GLX_PSEUDO_COLOR_EXT              0x8004
#define GLX_STATIC_COLOR_EXT              0x8005
#define GLX_GRAY_SCALE_EXT                0x8006
#define GLX_STATIC_GRAY_EXT               0x8007
#define GLX_TRANSPARENT_RGB_EXT           0x8008
#define GLX_TRANSPARENT_INDEX_EXT         0x8009
#endif /* GLX_EXT_visual_info */

#ifndef GLX_EXT_visual_rating
#define GLX_EXT_visual_rating 1
#define GLX_VISUAL_CAVEAT_EXT             0x20
#define GLX_SLOW_VISUAL_EXT               0x8001
#define GLX_NON_CONFORMANT_VISUAL_EXT     0x800D
#endif /* GLX_EXT_visual_rating */

#ifndef GLX_INTEL_swap_event
#define GLX_INTEL_swap_event 1
#define GLX_BUFFER_SWAP_COMPLETE_INTEL_MASK 0x04000000
#define GLX_EXCHANGE_COMPLETE_INTEL       0x8180
#define GLX_COPY_COMPLETE_INTEL           0x8181
#define GLX_FLIP_COMPLETE_INTEL           0x8182
#endif /* GLX_INTEL_swap_event */

#ifndef GLX_MESA_agp_offset
#define GLX_MESA_agp_offset 1
typedef unsigned int ( *PFNGLXGETAGPOFFSETMESAPROC) (const void *pointer);
#ifdef GLX_GLXEXT_PROTOTYPES
unsigned int glXGetAGPOffsetMESA (const void *pointer);
#endif
#endif /* GLX_MESA_agp_offset */

#ifndef GLX_MESA_copy_sub_buffer
#define GLX_MESA_copy_sub_buffer 1
typedef void ( *PFNGLXCOPYSUBBUFFERMESAPROC) (Display *dpy, GLXDrawable drawable, int x, int y, int width, int height);
#ifdef GLX_GLXEXT_PROTOTYPES
void glXCopySubBufferMESA (Display *dpy, GLXDrawable drawable, int x, int y, int width, int height);
#endif
#endif /* GLX_MESA_copy_sub_buffer */

#ifndef GLX_MESA_pixmap_colormap
#define GLX_MESA_pixmap_colormap 1
typedef GLXPixmap ( *PFNGLXCREATEGLXPIXMAPMESAPROC) (Display *dpy, XVisualInfo *visual, Pixmap pixmap, Colormap cmap);
#ifdef GLX_GLXEXT_PROTOTYPES
GLXPixmap glXCreateGLXPixmapMESA (Display *dpy, XVisualInfo *visual, Pixmap pixmap, Colormap cmap);
#endif
#endif /* GLX_MESA_pixmap_colormap */

#ifndef GLX_MESA_query_renderer
#define GLX_MESA_query_renderer 1
#define GLX_RENDERER_VENDOR_ID_MESA       0x8183
#define GLX_RENDERER_DEVICE_ID_MESA       0x8184
#define GLX_RENDERER_VERSION_MESA         0x8185
#define GLX_RENDERER_ACCELERATED_MESA     0x8186
#define GLX_RENDERER_VIDEO_MEMORY_MESA    0x8187
#define GLX_RENDERER_UNIFIED_MEMORY_ARCHITECTURE_MESA 0x8188
#define GLX_RENDERER_PREFERRED_PROFILE_MESA 0x8189
#define GLX_RENDERER_OPENGL_CORE_PROFILE_VERSION_MESA 0x818A
#define GLX_RENDERER_OPENGL_COMPATIBILITY_PROFILE_VERSION_MESA 0x818B
#define GLX_RENDERER_OPENGL_ES_PROFILE_VERSION_MESA 0x818C
#define GLX_RENDERER_OPENGL_ES2_PROFILE_VERSION_MESA 0x818D
#define GLX_RENDERER_ID_MESA              0x818E
typedef Bool ( *PFNGLXQUERYCURRENTRENDERERINTEGERMESAPROC) (int attribute, unsigned int *value);
typedef const char *( *PFNGLXQUERYCURRENTRENDERERSTRINGMESAPROC) (int attribute);
typedef Bool ( *PFNGLXQUERYRENDERERINTEGERMESAPROC) (Display *dpy, int screen, int renderer, int attribute, unsigned int *value);
typedef const char *( *PFNGLXQUERYRENDERERSTRINGMESAPROC) (Display *dpy, int screen, int renderer, int attribute);
#ifdef GLX_GLXEXT_PROTOTYPES
Bool glXQueryCurrentRendererIntegerMESA (int attribute, unsigned int *value);
const char *glXQueryCurrentRendererStringMESA (int attribute);
Bool glXQueryRendererIntegerMESA (Display *dpy, int screen, int renderer, int attribute, unsigned int *value);
const char *glXQueryRendererStringMESA (Display *dpy, int screen, int renderer, int attribute);
#endif
#endif /* GLX_MESA_query_renderer */

#ifndef GLX_MESA_release_buffers
#define GLX_MESA_release_buffers 1
typedef Bool ( *PFNGLXRELEASEBUFFERSMESAPROC) (Display *dpy, GLXDrawable drawable);
#ifdef GLX_GLXEXT_PROTOTYPES
Bool glXReleaseBuffersMESA (Display *dpy, GLXDrawable drawable);
#endif
#endif /* GLX_MESA_release_buffers */

#ifndef GLX_MESA_set_3dfx_mode
#define GLX_MESA_set_3dfx_mode 1
#define GLX_3DFX_WINDOW_MODE_MESA         0x1
#define GLX_3DFX_FULLSCREEN_MODE_MESA     0x2
typedef Bool ( *PFNGLXSET3DFXMODEMESAPROC) (int mode);
#ifdef GLX_GLXEXT_PROTOTYPES
Bool glXSet3DfxModeMESA (int mode);
#endif
#endif /* GLX_MESA_set_3dfx_mode */

#ifndef GLX_MESA_swap_control
#define GLX_MESA_swap_control 1
typedef int ( *PFNGLXGETSWAPINTERVALMESAPROC) (void);
typedef void ( *PFNGLXSWAPINTERVALMESAPROC) (unsigned int interval);
#ifdef GLX_GLXEXT_PROTOTYPES
int glXGetSwapIntervalMESA (void);
void glXSwapIntervalMESA (unsigned int interval);
#endif
#endif /* GLX_MESA_swap_control */

#ifndef GLX_NV_copy_buffer
#define GLX_NV_copy_buffer 1
typedef void ( *PFNGLXCOPYBUFFERSUBDATANVPROC) (Display *dpy, GLXContext readCtx, GLXContext writeCtx, GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void ( *PFNGLXNAMEDCOPYBUFFERSUBDATANVPROC) (Display *dpy, GLXContext readCtx, GLXContext writeCtx, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
#ifdef GLX_GLXEXT_PROTOTYPES
void glXCopyBufferSubDataNV (Display *dpy, GLXContext readCtx, GLXContext writeCtx, GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
void glXNamedCopyBufferSubDataNV (Display *dpy, GLXContext readCtx, GLXContext writeCtx, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
#endif
#endif /* GLX_NV_copy_buffer */

#ifndef GLX_NV_copy_image
#define GLX_NV_copy_image 1
typedef void ( *PFNGLXCOPYIMAGESUBDATANVPROC) (Display *dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
#ifdef GLX_GLXEXT_PROTOTYPES
void glXCopyImageSubDataNV (Display *dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
#endif
#endif /* GLX_NV_copy_image */

#ifndef GLX_NV_delay_before_swap
#define GLX_NV_delay_before_swap 1
typedef Bool ( *PFNGLXDELAYBEFORESWAPNVPROC) (Display *dpy, GLXDrawable drawable, GLfloat seconds);
#ifdef GLX_GLXEXT_PROTOTYPES
Bool glXDelayBeforeSwapNV (Display *dpy, GLXDrawable drawable, GLfloat seconds);
#endif
#endif /* GLX_NV_delay_before_swap */

#ifndef GLX_NV_float_buffer
#define GLX_NV_float_buffer 1
#define GLX_FLOAT_COMPONENTS_NV           0x20B0
#endif /* GLX_NV_float_buffer */

#ifndef GLX_NV_multisample_coverage
#define GLX_NV_multisample_coverage 1
#define GLX_COVERAGE_SAMPLES_NV           100001
#define GLX_COLOR_SAMPLES_NV              0x20B3
#endif /* GLX_NV_multisample_coverage */

#ifndef GLX_NV_present_video
#define GLX_NV_present_video 1
#define GLX_NUM_VIDEO_SLOTS_NV            0x20F0
typedef unsigned int *( *PFNGLXENUMERATEVIDEODEVICESNVPROC) (Display *dpy, int screen, int *nelements);
typedef int ( *PFNGLXBINDVIDEODEVICENVPROC) (Display *dpy, unsigned int video_slot, unsigned int video_device, const int *attrib_list);
#ifdef GLX_GLXEXT_PROTOTYPES
unsigned int *glXEnumerateVideoDevicesNV (Display *dpy, int screen, int *nelements);
int glXBindVideoDeviceNV (Display *dpy, unsigned int video_slot, unsigned int video_device, const int *attrib_list);
#endif
#endif /* GLX_NV_present_video */

#ifndef GLX_NV_robustness_video_memory_purge
#define GLX_NV_robustness_video_memory_purge 1
#define GLX_GENERATE_RESET_ON_VIDEO_MEMORY_PURGE_NV 0x20F7
#endif /* GLX_NV_robustness_video_memory_purge */

#ifndef GLX_NV_swap_group
#define GLX_NV_swap_group 1
typedef Bool ( *PFNGLXJOINSWAPGROUPNVPROC) (Display *dpy, GLXDrawable drawable, GLuint group);
typedef Bool ( *PFNGLXBINDSWAPBARRIERNVPROC) (Display *dpy, GLuint group, GLuint barrier);
typedef Bool ( *PFNGLXQUERYSWAPGROUPNVPROC) (Display *dpy, GLXDrawable drawable, GLuint *group, GLuint *barrier);
typedef Bool ( *PFNGLXQUERYMAXSWAPGROUPSNVPROC) (Display *dpy, int screen, GLuint *maxGroups, GLuint *maxBarriers);
typedef Bool ( *PFNGLXQUERYFRAMECOUNTNVPROC) (Display *dpy, int screen, GLuint *count);
typedef Bool ( *PFNGLXRESETFRAMECOUNTNVPROC) (Display *dpy, int screen);
#ifdef GLX_GLXEXT_PROTOTYPES
Bool glXJoinSwapGroupNV (Display *dpy, GLXDrawable drawable, GLuint group);
Bool glXBindSwapBarrierNV (Display *dpy, GLuint group, GLuint barrier);
Bool glXQuerySwapGroupNV (Display *dpy, GLXDrawable drawable, GLuint *group, GLuint *barrier);
Bool glXQueryMaxSwapGroupsNV (Display *dpy, int screen, GLuint *maxGroups, GLuint *maxBarriers);
Bool glXQueryFrameCountNV (Display *dpy, int screen, GLuint *count);
Bool glXResetFrameCountNV (Display *dpy, int screen);
#endif
#endif /* GLX_NV_swap_group */

#ifndef GLX_NV_video_capture
#define GLX_NV_video_capture 1
typedef XID GLXVideoCaptureDeviceNV;
#define GLX_DEVICE_ID_NV                  0x20CD
#define GLX_UNIQUE_ID_NV                  0x20CE
#define GLX_NUM_VIDEO_CAPTURE_SLOTS_NV    0x20CF
typedef int ( *PFNGLXBINDVIDEOCAPTUREDEVICENVPROC) (Display *dpy, unsigned int video_capture_slot, GLXVideoCaptureDeviceNV device);
typedef GLXVideoCaptureDeviceNV *( *PFNGLXENUMERATEVIDEOCAPTUREDEVICESNVPROC) (Display *dpy, int screen, int *nelements);
typedef void ( *PFNGLXLOCKVIDEOCAPTUREDEVICENVPROC) (Display *dpy, GLXVideoCaptureDeviceNV device);
typedef int ( *PFNGLXQUERYVIDEOCAPTUREDEVICENVPROC) (Display *dpy, GLXVideoCaptureDeviceNV device, int attribute, int *value);
typedef void ( *PFNGLXRELEASEVIDEOCAPTUREDEVICENVPROC) (Display *dpy, GLXVideoCaptureDeviceNV device);
#ifdef GLX_GLXEXT_PROTOTYPES
int glXBindVideoCaptureDeviceNV (Display *dpy, unsigned int video_capture_slot, GLXVideoCaptureDeviceNV device);
GLXVideoCaptureDeviceNV *glXEnumerateVideoCaptureDevicesNV (Display *dpy, int screen, int *nelements);
void glXLockVideoCaptureDeviceNV (Display *dpy, GLXVideoCaptureDeviceNV device);
int glXQueryVideoCaptureDeviceNV (Display *dpy, GLXVideoCaptureDeviceNV device, int attribute, int *value);
void glXReleaseVideoCaptureDeviceNV (Display *dpy, GLXVideoCaptureDeviceNV device);
#endif
#endif /* GLX_NV_video_capture */

#ifndef GLX_NV_video_out
#define GLX_NV_video_out 1
typedef unsigned int GLXVideoDeviceNV;
#define GLX_VIDEO_OUT_COLOR_NV            0x20C3
#define GLX_VIDEO_OUT_ALPHA_NV            0x20C4
#define GLX_VIDEO_OUT_DEPTH_NV            0x20C5
#define GLX_VIDEO_OUT_COLOR_AND_ALPHA_NV  0x20C6
#define GLX_VIDEO_OUT_COLOR_AND_DEPTH_NV  0x20C7
#define GLX_VIDEO_OUT_FRAME_NV            0x20C8
#define GLX_VIDEO_OUT_FIELD_1_NV          0x20C9
#define GLX_VIDEO_OUT_FIELD_2_NV          0x20CA
#define GLX_VIDEO_OUT_STACKED_FIELDS_1_2_NV 0x20CB
#define GLX_VIDEO_OUT_STACKED_FIELDS_2_1_NV 0x20CC
typedef int ( *PFNGLXGETVIDEODEVICENVPROC) (Display *dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *pVideoDevice);
typedef int ( *PFNGLXRELEASEVIDEODEVICENVPROC) (Display *dpy, int screen, GLXVideoDeviceNV VideoDevice);
typedef int ( *PFNGLXBINDVIDEOIMAGENVPROC) (Display *dpy, GLXVideoDeviceNV VideoDevice, GLXPbuffer pbuf, int iVideoBuffer);
typedef int ( *PFNGLXRELEASEVIDEOIMAGENVPROC) (Display *dpy, GLXPbuffer pbuf);
typedef int ( *PFNGLXSENDPBUFFERTOVIDEONVPROC) (Display *dpy, GLXPbuffer pbuf, int iBufferType, unsigned long *pulCounterPbuffer, GLboolean bBlock);
typedef int ( *PFNGLXGETVIDEOINFONVPROC) (Display *dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo);
#ifdef GLX_GLXEXT_PROTOTYPES
int glXGetVideoDeviceNV (Display *dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *pVideoDevice);
int glXReleaseVideoDeviceNV (Display *dpy, int screen, GLXVideoDeviceNV VideoDevice);
int glXBindVideoImageNV (Display *dpy, GLXVideoDeviceNV VideoDevice, GLXPbuffer pbuf, int iVideoBuffer);
int glXReleaseVideoImageNV (Display *dpy, GLXPbuffer pbuf);
int glXSendPbufferToVideoNV (Display *dpy, GLXPbuffer pbuf, int iBufferType, unsigned long *pulCounterPbuffer, GLboolean bBlock);
int glXGetVideoInfoNV (Display *dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo);
#endif
#endif /* GLX_NV_video_out */

#ifndef GLX_OML_swap_method
#define GLX_OML_swap_method 1
#define GLX_SWAP_METHOD_OML               0x8060
#define GLX_SWAP_EXCHANGE_OML             0x8061
#define GLX_SWAP_COPY_OML                 0x8062
#define GLX_SWAP_UNDEFINED_OML            0x8063
#endif /* GLX_OML_swap_method */

#ifndef GLX_OML_sync_control
#define GLX_OML_sync_control 1
#ifndef GLEXT_64_TYPES_DEFINED
/* This code block is duplicated in glext.h, so must be protected */
#define GLEXT_64_TYPES_DEFINED
/* Define int32_t, int64_t, and uint64_t types for UST/MSC */
/* (as used in the GLX_OML_sync_control extension). */
#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
#include <inttypes.h>
#elif defined(__sun__) || defined(__digital__)
#include <inttypes.h>
#if defined(__STDC__)
#if defined(__arch64__) || defined(_LP64)
typedef long int int64_t;
typedef unsigned long int uint64_t;
#else
typedef long long int int64_t;
typedef unsigned long long int uint64_t;
#endif /* __arch64__ */
#endif /* __STDC__ */
#elif defined( __VMS ) || defined(__sgi)
#include <inttypes.h>
#elif defined(__SCO__) || defined(__USLC__)
#include <stdint.h>
#elif defined(__UNIXOS2__) || defined(__SOL64__)
typedef long int int32_t;
typedef long long int int64_t;
typedef unsigned long long int uint64_t;
#elif defined(_WIN32) && defined(__GNUC__)
#include <stdint.h>
#elif defined(_WIN32)
typedef __int32 int32_t;
typedef __int64 int64_t;
typedef unsigned __int64 uint64_t;
#else
/* Fallback if nothing above works */
#include <inttypes.h>
#endif
#endif
typedef Bool ( *PFNGLXGETSYNCVALUESOMLPROC) (Display *dpy, GLXDrawable drawable, int64_t *ust, int64_t *msc, int64_t *sbc);
typedef Bool ( *PFNGLXGETMSCRATEOMLPROC) (Display *dpy, GLXDrawable drawable, int32_t *numerator, int32_t *denominator);
typedef int64_t ( *PFNGLXSWAPBUFFERSMSCOMLPROC) (Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder);
typedef Bool ( *PFNGLXWAITFORMSCOMLPROC) (Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *ust, int64_t *msc, int64_t *sbc);
typedef Bool ( *PFNGLXWAITFORSBCOMLPROC) (Display *dpy, GLXDrawable drawable, int64_t target_sbc, int64_t *ust, int64_t *msc, int64_t *sbc);
#ifdef GLX_GLXEXT_PROTOTYPES
Bool glXGetSyncValuesOML (Display *dpy, GLXDrawable drawable, int64_t *ust, int64_t *msc, int64_t *sbc);
Bool glXGetMscRateOML (Display *dpy, GLXDrawable drawable, int32_t *numerator, int32_t *denominator);
int64_t glXSwapBuffersMscOML (Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder);
Bool glXWaitForMscOML (Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *ust, int64_t *msc, int64_t *sbc);
Bool glXWaitForSbcOML (Display *dpy, GLXDrawable drawable, int64_t target_sbc, int64_t *ust, int64_t *msc, int64_t *sbc);
#endif
#endif /* GLX_OML_sync_control */

#ifndef GLX_SGIS_blended_overlay
#define GLX_SGIS_blended_overlay 1
#define GLX_BLENDED_RGBA_SGIS             0x8025
#endif /* GLX_SGIS_blended_overlay */

#ifndef GLX_SGIS_multisample
#define GLX_SGIS_multisample 1
#define GLX_SAMPLE_BUFFERS_SGIS           100000
#define GLX_SAMPLES_SGIS                  100001
#endif /* GLX_SGIS_multisample */

#ifndef GLX_SGIS_shared_multisample
#define GLX_SGIS_shared_multisample 1
#define GLX_MULTISAMPLE_SUB_RECT_WIDTH_SGIS 0x8026
#define GLX_MULTISAMPLE_SUB_RECT_HEIGHT_SGIS 0x8027
#endif /* GLX_SGIS_shared_multisample */

#ifndef GLX_SGIX_dmbuffer
#define GLX_SGIX_dmbuffer 1
typedef XID GLXPbufferSGIX;
#ifdef _DM_BUFFER_H_
#define GLX_DIGITAL_MEDIA_PBUFFER_SGIX    0x8024
typedef Bool ( *PFNGLXASSOCIATEDMPBUFFERSGIXPROC) (Display *dpy, GLXPbufferSGIX pbuffer, DMparams *params, DMbuffer dmbuffer);
#ifdef GLX_GLXEXT_PROTOTYPES
Bool glXAssociateDMPbufferSGIX (Display *dpy, GLXPbufferSGIX pbuffer, DMparams *params, DMbuffer dmbuffer);
#endif
#endif /* _DM_BUFFER_H_ */
#endif /* GLX_SGIX_dmbuffer */

#ifndef GLX_SGIX_fbconfig
#define GLX_SGIX_fbconfig 1
typedef struct __GLXFBConfigRec *GLXFBConfigSGIX;
#define GLX_WINDOW_BIT_SGIX               0x00000001
#define GLX_PIXMAP_BIT_SGIX               0x00000002
#define GLX_RGBA_BIT_SGIX                 0x00000001
#define GLX_COLOR_INDEX_BIT_SGIX          0x00000002
#define GLX_DRAWABLE_TYPE_SGIX            0x8010
#define GLX_RENDER_TYPE_SGIX              0x8011
#define GLX_X_RENDERABLE_SGIX             0x8012
#define GLX_FBCONFIG_ID_SGIX              0x8013
#define GLX_RGBA_TYPE_SGIX                0x8014
#define GLX_COLOR_INDEX_TYPE_SGIX         0x8015
typedef int ( *PFNGLXGETFBCONFIGATTRIBSGIXPROC) (Display *dpy, GLXFBConfigSGIX config, int attribute, int *value);
typedef GLXFBConfigSGIX *( *PFNGLXCHOOSEFBCONFIGSGIXPROC) (Display *dpy, int screen, int *attrib_list, int *nelements);
typedef GLXPixmap ( *PFNGLXCREATEGLXPIXMAPWITHCONFIGSGIXPROC) (Display *dpy, GLXFBConfigSGIX config, Pixmap pixmap);
typedef GLXContext ( *PFNGLXCREATECONTEXTWITHCONFIGSGIXPROC) (Display *dpy, GLXFBConfigSGIX config, int render_type, GLXContext share_list, Bool direct);
typedef XVisualInfo *( *PFNGLXGETVISUALFROMFBCONFIGSGIXPROC) (Display *dpy, GLXFBConfigSGIX config);
typedef GLXFBConfigSGIX ( *PFNGLXGETFBCONFIGFROMVISUALSGIXPROC) (Display *dpy, XVisualInfo *vis);
#ifdef GLX_GLXEXT_PROTOTYPES
int glXGetFBConfigAttribSGIX (Display *dpy, GLXFBConfigSGIX config, int attribute, int *value);
GLXFBConfigSGIX *glXChooseFBConfigSGIX (Display *dpy, int screen, int *attrib_list, int *nelements);
GLXPixmap glXCreateGLXPixmapWithConfigSGIX (Display *dpy, GLXFBConfigSGIX config, Pixmap pixmap);
GLXContext glXCreateContextWithConfigSGIX (Display *dpy, GLXFBConfigSGIX config, int render_type, GLXContext share_list, Bool direct);
XVisualInfo *glXGetVisualFromFBConfigSGIX (Display *dpy, GLXFBConfigSGIX config);
GLXFBConfigSGIX glXGetFBConfigFromVisualSGIX (Display *dpy, XVisualInfo *vis);
#endif
#endif /* GLX_SGIX_fbconfig */

#ifndef GLX_SGIX_hyperpipe
#define GLX_SGIX_hyperpipe 1
typedef struct {
    char    pipeName[80]; /* Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX] */
    int     networkId;
} GLXHyperpipeNetworkSGIX;
typedef struct {
    char    pipeName[80]; /* Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX] */
    int     channel;
    unsigned int participationType;
    int     timeSlice;
} GLXHyperpipeConfigSGIX;
typedef struct {
    char pipeName[80]; /* Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX] */
    int srcXOrigin, srcYOrigin, srcWidth, srcHeight;
    int destXOrigin, destYOrigin, destWidth, destHeight;
} GLXPipeRect;
typedef struct {
    char pipeName[80]; /* Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX] */
    int XOrigin, YOrigin, maxHeight, maxWidth;
} GLXPipeRectLimits;
#define GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX 80
#define GLX_BAD_HYPERPIPE_CONFIG_SGIX     91
#define GLX_BAD_HYPERPIPE_SGIX            92
#define GLX_HYPERPIPE_DISPLAY_PIPE_SGIX   0x00000001
#define GLX_HYPERPIPE_RENDER_PIPE_SGIX    0x00000002
#define GLX_PIPE_RECT_SGIX                0x00000001
#define GLX_PIPE_RECT_LIMITS_SGIX         0x00000002
#define GLX_HYPERPIPE_STEREO_SGIX         0x00000003
#define GLX_HYPERPIPE_PIXEL_AVERAGE_SGIX  0x00000004
#define GLX_HYPERPIPE_ID_SGIX             0x8030
typedef GLXHyperpipeNetworkSGIX *( *PFNGLXQUERYHYPERPIPENETWORKSGIXPROC) (Display *dpy, int *npipes);
typedef int ( *PFNGLXHYPERPIPECONFIGSGIXPROC) (Display *dpy, int networkId, int npipes, GLXHyperpipeConfigSGIX *cfg, int *hpId);
typedef GLXHyperpipeConfigSGIX *( *PFNGLXQUERYHYPERPIPECONFIGSGIXPROC) (Display *dpy, int hpId, int *npipes);
typedef int ( *PFNGLXDESTROYHYPERPIPECONFIGSGIXPROC) (Display *dpy, int hpId);
typedef int ( *PFNGLXBINDHYPERPIPESGIXPROC) (Display *dpy, int hpId);
typedef int ( *PFNGLXQUERYHYPERPIPEBESTATTRIBSGIXPROC) (Display *dpy, int timeSlice, int attrib, int size, void *attribList, void *returnAttribList);
typedef int ( *PFNGLXHYPERPIPEATTRIBSGIXPROC) (Display *dpy, int timeSlice, int attrib, int size, void *attribList);
typedef int ( *PFNGLXQUERYHYPERPIPEATTRIBSGIXPROC) (Display *dpy, int timeSlice, int attrib, int size, void *returnAttribList);
#ifdef GLX_GLXEXT_PROTOTYPES
GLXHyperpipeNetworkSGIX *glXQueryHyperpipeNetworkSGIX (Display *dpy, int *npipes);
int glXHyperpipeConfigSGIX (Display *dpy, int networkId, int npipes, GLXHyperpipeConfigSGIX *cfg, int *hpId);
GLXHyperpipeConfigSGIX *glXQueryHyperpipeConfigSGIX (Display *dpy, int hpId, int *npipes);
int glXDestroyHyperpipeConfigSGIX (Display *dpy, int hpId);
int glXBindHyperpipeSGIX (Display *dpy, int hpId);
int glXQueryHyperpipeBestAttribSGIX (Display *dpy, int timeSlice, int attrib, int size, void *attribList, void *returnAttribList);
int glXHyperpipeAttribSGIX (Display *dpy, int timeSlice, int attrib, int size, void *attribList);
int glXQueryHyperpipeAttribSGIX (Display *dpy, int timeSlice, int attrib, int size, void *returnAttribList);
#endif
#endif /* GLX_SGIX_hyperpipe */

#ifndef GLX_SGIX_pbuffer
#define GLX_SGIX_pbuffer 1
#define GLX_PBUFFER_BIT_SGIX              0x00000004
#define GLX_BUFFER_CLOBBER_MASK_SGIX      0x08000000
#define GLX_FRONT_LEFT_BUFFER_BIT_SGIX    0x00000001
#define GLX_FRONT_RIGHT_BUFFER_BIT_SGIX   0x00000002
#define GLX_BACK_LEFT_BUFFER_BIT_SGIX     0x00000004
#define GLX_BACK_RIGHT_BUFFER_BIT_SGIX    0x00000008
#define GLX_AUX_BUFFERS_BIT_SGIX          0x00000010
#define GLX_DEPTH_BUFFER_BIT_SGIX         0x00000020
#define GLX_STENCIL_BUFFER_BIT_SGIX       0x00000040
#define GLX_ACCUM_BUFFER_BIT_SGIX         0x00000080
#define GLX_SAMPLE_BUFFERS_BIT_SGIX       0x00000100
#define GLX_MAX_PBUFFER_WIDTH_SGIX        0x8016
#define GLX_MAX_PBUFFER_HEIGHT_SGIX       0x8017
#define GLX_MAX_PBUFFER_PIXELS_SGIX       0x8018
#define GLX_OPTIMAL_PBUFFER_WIDTH_SGIX    0x8019
#define GLX_OPTIMAL_PBUFFER_HEIGHT_SGIX   0x801A
#define GLX_PRESERVED_CONTENTS_SGIX       0x801B
#define GLX_LARGEST_PBUFFER_SGIX          0x801C
#define GLX_WIDTH_SGIX                    0x801D
#define GLX_HEIGHT_SGIX                   0x801E
#define GLX_EVENT_MASK_SGIX               0x801F
#define GLX_DAMAGED_SGIX                  0x8020
#define GLX_SAVED_SGIX                    0x8021
#define GLX_WINDOW_SGIX                   0x8022
#define GLX_PBUFFER_SGIX                  0x8023
typedef GLXPbufferSGIX ( *PFNGLXCREATEGLXPBUFFERSGIXPROC) (Display *dpy, GLXFBConfigSGIX config, unsigned int width, unsigned int height, int *attrib_list);
typedef void ( *PFNGLXDESTROYGLXPBUFFERSGIXPROC) (Display *dpy, GLXPbufferSGIX pbuf);
typedef int ( *PFNGLXQUERYGLXPBUFFERSGIXPROC) (Display *dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int *value);
typedef void ( *PFNGLXSELECTEVENTSGIXPROC) (Display *dpy, GLXDrawable drawable, unsigned long mask);
typedef void ( *PFNGLXGETSELECTEDEVENTSGIXPROC) (Display *dpy, GLXDrawable drawable, unsigned long *mask);
#ifdef GLX_GLXEXT_PROTOTYPES
GLXPbufferSGIX glXCreateGLXPbufferSGIX (Display *dpy, GLXFBConfigSGIX config, unsigned int width, unsigned int height, int *attrib_list);
void glXDestroyGLXPbufferSGIX (Display *dpy, GLXPbufferSGIX pbuf);
int glXQueryGLXPbufferSGIX (Display *dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int *value);
void glXSelectEventSGIX (Display *dpy, GLXDrawable drawable, unsigned long mask);
void glXGetSelectedEventSGIX (Display *dpy, GLXDrawable drawable, unsigned long *mask);
#endif
#endif /* GLX_SGIX_pbuffer */

#ifndef GLX_SGIX_swap_barrier
#define GLX_SGIX_swap_barrier 1
typedef void ( *PFNGLXBINDSWAPBARRIERSGIXPROC) (Display *dpy, GLXDrawable drawable, int barrier);
typedef Bool ( *PFNGLXQUERYMAXSWAPBARRIERSSGIXPROC) (Display *dpy, int screen, int *max);
#ifdef GLX_GLXEXT_PROTOTYPES
void glXBindSwapBarrierSGIX (Display *dpy, GLXDrawable drawable, int barrier);
Bool glXQueryMaxSwapBarriersSGIX (Display *dpy, int screen, int *max);
#endif
#endif /* GLX_SGIX_swap_barrier */

#ifndef GLX_SGIX_swap_group
#define GLX_SGIX_swap_group 1
typedef void ( *PFNGLXJOINSWAPGROUPSGIXPROC) (Display *dpy, GLXDrawable drawable, GLXDrawable member);
#ifdef GLX_GLXEXT_PROTOTYPES
void glXJoinSwapGroupSGIX (Display *dpy, GLXDrawable drawable, GLXDrawable member);
#endif
#endif /* GLX_SGIX_swap_group */

#ifndef GLX_SGIX_video_resize
#define GLX_SGIX_video_resize 1
#define GLX_SYNC_FRAME_SGIX               0x00000000
#define GLX_SYNC_SWAP_SGIX                0x00000001
typedef int ( *PFNGLXBINDCHANNELTOWINDOWSGIXPROC) (Display *display, int screen, int channel, Window window);
typedef int ( *PFNGLXCHANNELRECTSGIXPROC) (Display *display, int screen, int channel, int x, int y, int w, int h);
typedef int ( *PFNGLXQUERYCHANNELRECTSGIXPROC) (Display *display, int screen, int channel, int *dx, int *dy, int *dw, int *dh);
typedef int ( *PFNGLXQUERYCHANNELDELTASSGIXPROC) (Display *display, int screen, int channel, int *x, int *y, int *w, int *h);
typedef int ( *PFNGLXCHANNELRECTSYNCSGIXPROC) (Display *display, int screen, int channel, GLenum synctype);
#ifdef GLX_GLXEXT_PROTOTYPES
int glXBindChannelToWindowSGIX (Display *display, int screen, int channel, Window window);
int glXChannelRectSGIX (Display *display, int screen, int channel, int x, int y, int w, int h);
int glXQueryChannelRectSGIX (Display *display, int screen, int channel, int *dx, int *dy, int *dw, int *dh);
int glXQueryChannelDeltasSGIX (Display *display, int screen, int channel, int *x, int *y, int *w, int *h);
int glXChannelRectSyncSGIX (Display *display, int screen, int channel, GLenum synctype);
#endif
#endif /* GLX_SGIX_video_resize */

#ifndef GLX_SGIX_video_source
#define GLX_SGIX_video_source 1
typedef XID GLXVideoSourceSGIX;
#ifdef _VL_H
typedef GLXVideoSourceSGIX ( *PFNGLXCREATEGLXVIDEOSOURCESGIXPROC) (Display *display, int screen, VLServer server, VLPath path, int nodeClass, VLNode drainNode);
typedef void ( *PFNGLXDESTROYGLXVIDEOSOURCESGIXPROC) (Display *dpy, GLXVideoSourceSGIX glxvideosource);
#ifdef GLX_GLXEXT_PROTOTYPES
GLXVideoSourceSGIX glXCreateGLXVideoSourceSGIX (Display *display, int screen, VLServer server, VLPath path, int nodeClass, VLNode drainNode);
void glXDestroyGLXVideoSourceSGIX (Display *dpy, GLXVideoSourceSGIX glxvideosource);
#endif
#endif /* _VL_H */
#endif /* GLX_SGIX_video_source */

#ifndef GLX_SGIX_visual_select_group
#define GLX_SGIX_visual_select_group 1
#define GLX_VISUAL_SELECT_GROUP_SGIX      0x8028
#endif /* GLX_SGIX_visual_select_group */

#ifndef GLX_SGI_cushion
#define GLX_SGI_cushion 1
typedef void ( *PFNGLXCUSHIONSGIPROC) (Display *dpy, Window window, float cushion);
#ifdef GLX_GLXEXT_PROTOTYPES
void glXCushionSGI (Display *dpy, Window window, float cushion);
#endif
#endif /* GLX_SGI_cushion */

#ifndef GLX_SGI_make_current_read
#define GLX_SGI_make_current_read 1
typedef Bool ( *PFNGLXMAKECURRENTREADSGIPROC) (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
typedef GLXDrawable ( *PFNGLXGETCURRENTREADDRAWABLESGIPROC) (void);
#ifdef GLX_GLXEXT_PROTOTYPES
Bool glXMakeCurrentReadSGI (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
GLXDrawable glXGetCurrentReadDrawableSGI (void);
#endif
#endif /* GLX_SGI_make_current_read */

#ifndef GLX_SGI_swap_control
#define GLX_SGI_swap_control 1
typedef int ( *PFNGLXSWAPINTERVALSGIPROC) (int interval);
#ifdef GLX_GLXEXT_PROTOTYPES
int glXSwapIntervalSGI (int interval);
#endif
#endif /* GLX_SGI_swap_control */

#ifndef GLX_SGI_video_sync
#define GLX_SGI_video_sync 1
typedef int ( *PFNGLXGETVIDEOSYNCSGIPROC) (unsigned int *count);
typedef int ( *PFNGLXWAITVIDEOSYNCSGIPROC) (int divisor, int remainder, unsigned int *count);
#ifdef GLX_GLXEXT_PROTOTYPES
int glXGetVideoSyncSGI (unsigned int *count);
int glXWaitVideoSyncSGI (int divisor, int remainder, unsigned int *count);
#endif
#endif /* GLX_SGI_video_sync */

#ifndef GLX_SUN_get_transparent_index
#define GLX_SUN_get_transparent_index 1
typedef Status ( *PFNGLXGETTRANSPARENTINDEXSUNPROC) (Display *dpy, Window overlay, Window underlay, long *pTransparentIndex);
#ifdef GLX_GLXEXT_PROTOTYPES
Status glXGetTransparentIndexSUN (Display *dpy, Window overlay, Window underlay, long *pTransparentIndex);
#endif
#endif /* GLX_SUN_get_transparent_index */

#ifdef __cplusplus
}
#endif

#endif


#include <cstring>
#include <string>

class glXQueryVersion;
namespace GW
{
	namespace I
	{
		class GOpenGLSurfaceImplementation : public virtual GOpenGLSurfaceInterface,
			private virtual GEventResponderImplementation
		{
		private:
			GW::SYSTEM::GWindow gwindow;
			GW::CORE::GEventResponder responder;
			GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE UWH;
			unsigned int clientX;
			unsigned int clientY;
			unsigned int width = 0;
			unsigned int height = 0;
			float aspectRatio = 0;

			GLint extensionCount = 0;
			const char* glExtensions;

#define GLX_CONTEXT_MAJOR_VERSION_ARB 0x2091
#define GLX_CONTEXT_MINOR_VERSION_ARB 0x2092

			// GLX FUNCTION POINTERS //
			PFNGLXCREATECONTEXTATTRIBSARBPROC glXCreateContextAttribsARB;
			PFNGLXSWAPINTERVALEXTPROC glXSwapIntervalEXT;

			GLint attributes[5] = { GLX_RGBA, GLX_DEPTH_SIZE, 24, GLX_DOUBLEBUFFER, None };
			GLXContext OGLXContext;
		public:
			GReturn Create(GW::SYSTEM::GWindow _gwindow, unsigned long long _initMask)
			{
				if (!_gwindow)
					return GReturn::INVALID_ARGUMENT;
					
				gwindow = _gwindow;
				//Check if valid _initMask was passed in
				unsigned long long allowed = ~(GW::GRAPHICS::COLOR_10_BIT | GW::GRAPHICS::DEPTH_BUFFER_SUPPORT | GW::GRAPHICS::DEPTH_STENCIL_SUPPORT | GW::GRAPHICS::OPENGL_ES_SUPPORT);
				if (allowed & _initMask)
				{
					return GReturn::FEATURE_UNSUPPORTED;
				}

				gwindow.GetWindowHandle(UWH);
				gwindow.GetClientTopLeft(clientX, clientY);
				gwindow.GetClientWidth(width);
				gwindow.GetClientHeight(height);
				aspectRatio = static_cast<float>(width) / static_cast<float>(height);

				static int frameBufferAttributes[] =
				{
					GLX_RENDER_TYPE, GLX_RGBA_BIT,
					GLX_DRAWABLE_TYPE, GLX_WINDOW_BIT,
					GLX_DOUBLEBUFFER, true,
					GLX_RED_SIZE, 8,
					GLX_GREEN_SIZE, 8,
					GLX_BLUE_SIZE, 8,
					GLX_ALPHA_SIZE, 8,
					GLX_DEPTH_SIZE, 0,
					GLX_STENCIL_SIZE, 0,
					None
				};

				if (_initMask & GW::GRAPHICS::COLOR_10_BIT)
				{
					frameBufferAttributes[7] = 10;
					frameBufferAttributes[9] = 10;
					frameBufferAttributes[11] = 10;
					frameBufferAttributes[13] = 2;
				}

				if (_initMask & GW::GRAPHICS::DEPTH_BUFFER_SUPPORT)
					frameBufferAttributes[15] = 24;

				if (_initMask & GW::GRAPHICS::DEPTH_STENCIL_SUPPORT)
				{
					frameBufferAttributes[15] = 24;
					frameBufferAttributes[17] = 8;
				}

				// Select the default Frame buffer configuration //
				XLockDisplay(static_cast<Display*>(UWH.display));
				// use null attribs to scan for available formats and check against request
				int queryCount = 0;
				bool formatMatch = false;
				GLXFBConfig* queryConfig;
				if (queryConfig = glXGetFBConfigs(	static_cast<Display*>(UWH.display), 
													DefaultScreen(static_cast<Display*>(UWH.display)), &queryCount))
				{
					int numAttrib2Search = sizeof(frameBufferAttributes) / sizeof(int) / 2;
					// scan for matching frame attributes, fail if not found
					for (int i = 0; i < queryCount; ++i)
					{
						// search attrib pairs to see if all items match
						int attribMatch = 0;
						for (int j = 0; j < numAttrib2Search; ++j)
						{
							int attribVal; int errCode;	
							// if the attribute we are looking for is DC we don't care about it, mark it anyway
							if (frameBufferAttributes[j*2+1] != GLX_DONT_CARE)
							{
								errCode = glXGetFBConfigAttrib(	static_cast<Display*>(UWH.display), queryConfig[i], 
																frameBufferAttributes[j*2], &attribVal);
								if (errCode != GLX_NO_EXTENSION && errCode != GLX_BAD_ATTRIBUTE)
								{
									if (frameBufferAttributes[j*2] == GLX_DRAWABLE_TYPE ||
										frameBufferAttributes[j*2] == GLX_RENDER_TYPE)
									{
										if ((frameBufferAttributes[j*2+1] & attribVal) ==
											frameBufferAttributes[j*2+1])
											++attribMatch;
									} 
									else if(frameBufferAttributes[j*2+1] == attribVal)	
										++attribMatch;
								}
							}
							else // this is not something we intend to use so whatever it is, is fine
								++attribMatch;
						}
						//std::cout << "OGL FBCONFIG: " << attribMatch << " ATTRIBS MATCHED" << std::endl;
						if (attribMatch == numAttrib2Search)
						{
							formatMatch = true;
							queryCount = i; // save the first match
							break;
						}
					}
				}
				// fail if no matching format found
				if (!queryConfig || formatMatch == false)
					return GReturn::HARDWARE_UNAVAILABLE;
				/*
				int ver[2];// does not find ogl version
				if (glXQueryVersion(static_cast<Display*>(UWH.display),&ver[0],&ver[1]) == false) // is OpenGL available?
					return GReturn::HARDWARE_UNAVAILABLE;
				// I need to detect OpenGL 3.3 if we request HDR 1010102
				
				int frameBufferCount;
				GLXFBConfig* frameBufferConfig = glXChooseFBConfig(static_cast<Display*>(UWH.display), DefaultScreen(static_cast<Display*>(UWH.display)), frameBufferAttributes, &frameBufferCount);
				
				if (!frameBufferConfig)
					return GReturn::HARDWARE_UNAVAILABLE;
				*/
				XVisualInfo* visualInfo = glXGetVisualFromFBConfig(
					static_cast<Display*>(UWH.display), queryConfig[queryCount]);
				//Colormap colorMap = XCreateColormap(static_cast<Display*>(UWH.display), 
				//	RootWindow(static_cast<Display*>(UWH.display), visualInfo->screen), visualInfo->visual, AllocNone);

				XWindowAttributes curWinAttrib; // Current window attributes
				XGetWindowAttributes(static_cast<Display*>(UWH.display), *(static_cast<Window*>(UWH.window)), &curWinAttrib);

				XSetWindowAttributes swa;
				swa.event_mask = SubstructureNotifyMask | PropertyChangeMask | ExposureMask | curWinAttrib.all_event_masks;

				unsigned long valueMask = CWEventMask;

				XChangeWindowAttributes(static_cast<Display*>(UWH.display), *(static_cast<Window*>(UWH.window)), valueMask, &swa);
				GLXContext oldContext = glXCreateContext(static_cast<Display*>(UWH.display), visualInfo, 0, GL_TRUE);
				
				XFree(visualInfo);

				// Load GLX Extensions //
				glExtensions = glXQueryExtensionsString(static_cast<Display*>(UWH.display), DefaultScreen(static_cast<Display*>(UWH.display)));

				glXCreateContextAttribsARB = (PFNGLXCREATECONTEXTATTRIBSARBPROC)glXGetProcAddressARB((const GLubyte*)"glXCreateContextAttribsARB");
				glXSwapIntervalEXT = (PFNGLXSWAPINTERVALEXTPROC)glXGetProcAddressARB((const GLubyte*)"glXSwapIntervalEXT");

				if (!glXMakeCurrent(static_cast<Display*>(UWH.display), *(static_cast<Window*>(UWH.window)), oldContext))
				{
					XUnlockDisplay(static_cast<Display*>(UWH.display));
					XFree(queryConfig);
					return GReturn::FAILURE;
				}
				
				// print openGL version
				std::string ver = reinterpret_cast<const char*>(glGetString(GL_VERSION));
				//std::cout << ver << std::endl;

				glXDestroyContext(static_cast<Display*>(UWH.display), oldContext);
				
				// Extract the version number only contiue if 3.0 or better
				float glVer = std::stof(ver) + 0.000001f; // remove round down
				if (glVer < 3.0f)
				{					
					XFree(queryConfig);
					return GReturn::HARDWARE_UNAVAILABLE;
				}

				// Create new context //
				int contextAttribs[] =
				{
					GLX_CONTEXT_MAJOR_VERSION_ARB, 3,
					GLX_CONTEXT_MINOR_VERSION_ARB, 0,
					GLX_CONTEXT_PROFILE_MASK_ARB, GLX_CONTEXT_CORE_PROFILE_BIT_ARB,
					None
				};

				if (_initMask & GW::GRAPHICS::OPENGL_ES_SUPPORT)
					contextAttribs[5] = GLX_CONTEXT_ES2_PROFILE_BIT_EXT;
					
				OGLXContext = glXCreateContextAttribsARB(static_cast<Display*>(UWH.display), 
					queryConfig[queryCount], NULL, true, contextAttribs);
				
				XFree(queryConfig);
					
				if (!glXMakeCurrent(static_cast<Display*>(UWH.display), 
					*static_cast<Window*>(UWH.window), OGLXContext))
				{
					XUnlockDisplay(static_cast<Display*>(UWH.display));
					return GReturn::FAILURE;
				}

				XUnlockDisplay(static_cast<Display*>(UWH.display));

				if (_initMask & GW::GRAPHICS::DEPTH_BUFFER_SUPPORT)
					glEnable(GL_DEPTH_TEST);

				if (_initMask & GW::GRAPHICS::DEPTH_STENCIL_SUPPORT)
					glEnable(GL_STENCIL_TEST);

				// CHECK IF INIT FLAGS WERE MET //
				// 10 BIT COLOR //
				if (_initMask & GW::GRAPHICS::COLOR_10_BIT)
				{
					GLint red, green, blue;
					glGetIntegerv(GL_RED_BITS, &red);
					glGetIntegerv(GL_GREEN_BITS, &green);
					glGetIntegerv(GL_BLUE_BITS, &blue);
					if (red != 0 && green != 10 && blue != 10)
						return GReturn::FEATURE_UNSUPPORTED;
				}

				// DEPTH BUFFER SUPPORT //
				if (_initMask & GW::GRAPHICS::DEPTH_BUFFER_SUPPORT)
				{
					GLint depth;
					glGetIntegerv(GL_DEPTH_BITS, &depth);
					if (depth == 0 || !glIsEnabled(GL_DEPTH_TEST))
						return GReturn::FEATURE_UNSUPPORTED;
				}

				// DEPTH STENCIL SUPPORT //
				if (_initMask & GW::GRAPHICS::DEPTH_STENCIL_SUPPORT)
				{
					GLint stencil;
					glGetIntegerv(GL_STENCIL_BITS, &stencil);
					if (stencil == 0 || !glIsEnabled(GL_STENCIL_TEST))
						return GReturn::FEATURE_UNSUPPORTED;
				}

				// ES CONTEXT SUPPORT //
				if (_initMask & GW::GRAPHICS::OPENGL_ES_SUPPORT)
				{
					char* version = (char*)glGetString(GL_VERSION);

					if (strstr(version, "OpenGL ES") == NULL)
						return GReturn::FEATURE_UNSUPPORTED;
				}

				// DIRECT2D SUPPORT //
				if (_initMask & GW::GRAPHICS::DIRECT2D_SUPPORT)
				{
					return GReturn::FEATURE_UNSUPPORTED;
				}

				//XFree(frameBufferConfig);

				// Call back event handler for OpenGL
				GReturn result = responder.Create([&](const GEvent& g)
				{
					GW::SYSTEM::GWindow::Events e;
					GW::SYSTEM::GWindow::EVENT_DATA d;
					if(+g.Read(e, d)) 
					{
						switch (e)
						{
							case GW::SYSTEM::GWindow::Events::MINIMIZE: {} break;
							case GW::SYSTEM::GWindow::Events::DESTROY:
							{
								gwindow.GetWindowHandle(UWH);
								glXMakeCurrent(static_cast<Display*>(UWH.display), None, NULL);
								glXDestroyContext(static_cast<Display*>(UWH.display), OGLXContext);
								OGLXContext = nullptr;
							}
							break;

							case GW::SYSTEM::GWindow::Events::MAXIMIZE:
							case GW::SYSTEM::GWindow::Events::RESIZE:
							case GW::SYSTEM::GWindow::Events::MOVE:
							{
								gwindow.GetClientWidth(width);
								gwindow.GetClientHeight(height);
								aspectRatio = static_cast<float>(width) / static_cast<float>(height);
								glViewport(0, 0, width, height);
							}
							break;
						}
					}
				});
				if (G_PASS(result)) {
					gwindow.Register(responder);
				}
				
				return result;
			}

			GReturn GetAspectRatio(float& _outRatio) const override
			{
				if (!gwindow)
					return GReturn::FAILURE;

				_outRatio = aspectRatio;
				return GReturn::SUCCESS;
			}

			GReturn GetContext(void** _outContext) const override
			{
				if (!OGLXContext)
					return GReturn::FAILURE;

				*_outContext = OGLXContext;
				return GReturn::SUCCESS;
			}

			GReturn UniversalSwapBuffers() override
			{
				if (!gwindow)
					return GReturn::FAILURE;

				if (-gwindow.GetWindowHandle(UWH))
					return GReturn::FAILURE;

				if (!static_cast<Display*>(UWH.display) || *static_cast<Window*>(UWH.window) == 0)
					return GReturn::FAILURE;

				glXSwapBuffers(static_cast<Display*>(UWH.display), *static_cast<Window*>(UWH.window));
				return GReturn::SUCCESS;
			}

			GReturn QueryExtensionFunction(const char* _extension, const char* _funcName, void** _outFuncAddress) override
			{
				if ((_funcName == nullptr && _outFuncAddress != nullptr) ||
					(_funcName != nullptr && _outFuncAddress == nullptr) ||
					_extension == nullptr && _funcName == nullptr)
					return GReturn::INVALID_ARGUMENT;

				// User only passed in function name, without extension //
				if (_extension == nullptr && _funcName != nullptr && _outFuncAddress != nullptr)
				{
					*_outFuncAddress = (void**)glXGetProcAddress((const GLubyte*)_funcName);
					if (*_outFuncAddress == nullptr)
						return GReturn::FAILURE;
					return GReturn::SUCCESS;
				}

				// User only passed in extension name, without function //
				if (_funcName == nullptr && _outFuncAddress == nullptr)
				{
					if (strstr(glExtensions, _extension) != NULL)
						return GReturn::FAILURE;
					return GReturn::SUCCESS;
				}

				// User passed in extension name and function name //
				if (strstr(glExtensions, _extension) != NULL)
				{
					if (_funcName != NULL)
						*_outFuncAddress = (void**)glXGetProcAddress((const GLubyte*)_funcName);
					else
						*_outFuncAddress = (void**)glXGetProcAddress((const GLubyte*)_extension);
					return GReturn::SUCCESS;
				}
				return GReturn::FAILURE;
			}

			GReturn EnableSwapControl(bool _setSwapControl)
			{
				if (!glXSwapIntervalEXT)
					return GW::GReturn::FEATURE_UNSUPPORTED;

				if (!OGLXContext)
					return GW::GReturn::FAILURE;

				if (!gwindow)
					return GW::GReturn::FAILURE;

				gwindow.GetWindowHandle(UWH);
				XLockDisplay(static_cast<Display*>(UWH.display));
				if (_setSwapControl)
					glXSwapIntervalEXT(static_cast<Display*>(UWH.display), *static_cast<Window*>(UWH.window), 1);
				else
					glXSwapIntervalEXT(static_cast<Display*>(UWH.display), *static_cast<Window*>(UWH.window), 0);
				XUnlockDisplay(static_cast<Display*>(UWH.display));
				return GReturn::SUCCESS;
			}

			//GEventResponderInterface
			GReturn Assign(std::function<void()> _newHandler) override {
				return responder.Assign(_newHandler);
			}
			GReturn Assign(std::function<void(const GEvent&)> _newEventHandler) override {
				return responder.Assign(_newEventHandler);
			}
			GReturn Invoke() const override {
				return responder.Invoke();
			}
			GReturn Invoke(const GEvent& _incomingEvent) const override {
				return responder.Invoke(_incomingEvent);
			}
		};
	}
}

#elif defined(_WIN32)
    #define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <gl/GL.h>

#ifndef GATEWARE_FORCE_OPENGLES
	#ifndef __gl_glcorearb_h_
#define __gl_glcorearb_h_ 1

#ifdef __cplusplus
extern "C" {
#endif

	/*
	** Copyright 2013-2020 The Khronos Group Inc.
	** SPDX-License-Identifier: MIT
	**
	** This header is generated from the Khronos OpenGL / OpenGL ES XML
	** API Registry. The current version of the Registry, generator scripts
	** used to make the header, and the header can be found at
	**   https://github.com/KhronosGroup/OpenGL-Registry
	*/

#if defined(_WIN32) && !defined(APIENTRY) && !defined(__CYGWIN__) && !defined(__SCITECH_SNAP__)
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif
#include <windows.h>
#endif

#ifndef APIENTRY
#define APIENTRY
#endif
#ifndef APIENTRYP
#define APIENTRYP APIENTRY *
#endif
#ifndef GLAPI
#define GLAPI extern
#endif

	/* glcorearb.h is for use with OpenGL core profile implementations.
	** It should should be placed in the same directory as gl.h and
	** included as <GL/glcorearb.h>.
	**
	** glcorearb.h includes only APIs in the latest OpenGL core profile
	** implementation together with APIs in newer ARB extensions which
	** can be supported by the core profile. It does not, and never will
	** include functionality removed from the core profile, such as
	** fixed-function vertex and fragment processing.
	**
	** Do not #include both <GL/glcorearb.h> and either of <GL/gl.h> or
	** <GL/glext.h> in the same source file.
	*/

	/* Generated C header for:
	 * API: gl
	 * Profile: core
	 * Versions considered: .*
	 * Versions emitted: .*
	 * Default extensions included: glcore
	 * Additional extensions included: _nomatch_^
	 * Extensions removed: _nomatch_^
	 */

#ifndef GL_VERSION_1_0
#define GL_VERSION_1_0 1
	typedef void GLvoid;
	typedef unsigned int GLenum;
#ifndef __khrplatform_h_
#define __khrplatform_h_

/*
** Copyright (c) 2008-2009 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

/* Khronos platform-specific types and definitions.
*
* $Revision: 32517 $ on $Date: 2016-03-11 02:41:19 -0800 (Fri, 11 Mar 2016) $
*
* Adopters may modify this file to suit their platform. Adopters are
* encouraged to submit platform specific modifications to the Khronos
* group so that they can be included in future versions of this file.
* Please submit changes by sending them to the public Khronos Bugzilla
* (http://khronos.org/bugzilla) by filing a bug against product
* "Khronos (general)" component "Registry".
*
* A predefined template which fills in some of the bug fields can be
* reached using http://tinyurl.com/khrplatform-h-bugreport, but you
* must create a Bugzilla login first.
*
*
* See the Implementer's Guidelines for information about where this file
* should be located on your system and for more details of its use:
*    http://www.khronos.org/registry/implementers_guide.pdf
*
* This file should be included as
*        #include <KHR/khrplatform.h>
* by Khronos client API header files that use its types and defines.
*
* The types in khrplatform.h should only be used to define API-specific types.
*
* Types defined in khrplatform.h:
*    khronos_int8_t              signed   8  bit
*    khronos_uint8_t             unsigned 8  bit
*    khronos_int16_t             signed   16 bit
*    khronos_uint16_t            unsigned 16 bit
*    khronos_int32_t             signed   32 bit
*    khronos_uint32_t            unsigned 32 bit
*    khronos_int64_t             signed   64 bit
*    khronos_uint64_t            unsigned 64 bit
*    khronos_intptr_t            signed   same number of bits as a pointer
*    khronos_uintptr_t           unsigned same number of bits as a pointer
*    khronos_ssize_t             signed   size
*    khronos_usize_t             unsigned size
*    khronos_float_t             signed   32 bit floating point
*    khronos_time_ns_t           unsigned 64 bit time in nanoseconds
*    khronos_utime_nanoseconds_t unsigned time interval or absolute time in
*                                         nanoseconds
*    khronos_stime_nanoseconds_t signed time interval in nanoseconds
*    khronos_boolean_enum_t      enumerated boolean type. This should
*      only be used as a base type when a client API's boolean type is
*      an enum. Client APIs which use an integer or other type for
*      booleans cannot use this as the base type for their boolean.
*
* Tokens defined in khrplatform.h:
*
*    KHRONOS_FALSE, KHRONOS_TRUE Enumerated boolean false/true values.
*
*    KHRONOS_SUPPORT_INT64 is 1 if 64 bit integers are supported; otherwise 0.
*    KHRONOS_SUPPORT_FLOAT is 1 if floats are supported; otherwise 0.
*
* Calling convention macros defined in this file:
*    KHRONOS_APICALL
*    KHRONOS_APIENTRY
*    KHRONOS_APIATTRIBUTES
*
* These may be used in function prototypes as:
*
*      KHRONOS_APICALL void KHRONOS_APIENTRY funcname(
*                                  int arg1,
*                                  int arg2) KHRONOS_APIATTRIBUTES;
*/

/*-------------------------------------------------------------------------
* Definition of KHRONOS_APICALL
*-------------------------------------------------------------------------
* This precedes the return type of the function in the function prototype.
*/
#if defined(_WIN32) && !defined(__SCITECH_SNAP__)
#   define KHRONOS_APICALL __declspec(dllimport)
#elif defined (__SYMBIAN32__)
#   define KHRONOS_APICALL IMPORT_C
#elif defined(__ANDROID__)
#   define KHRONOS_APICALL __attribute__((visibility("default")))
#else
#   define KHRONOS_APICALL
#endif

/*-------------------------------------------------------------------------
* Definition of KHRONOS_APIENTRY
*-------------------------------------------------------------------------
* This follows the return type of the function  and precedes the function
* name in the function prototype.
*/
#if defined(_WIN32) && !defined(_WIN32_WCE) && !defined(__SCITECH_SNAP__)
/* Win32 but not WinCE */
#   define KHRONOS_APIENTRY __stdcall
#else
#   define KHRONOS_APIENTRY
#endif

/*-------------------------------------------------------------------------
* Definition of KHRONOS_APIATTRIBUTES
*-------------------------------------------------------------------------
* This follows the closing parenthesis of the function prototype arguments.
*/
#if defined (__ARMCC_2__)
#define KHRONOS_APIATTRIBUTES __softfp
#else
#define KHRONOS_APIATTRIBUTES
#endif

/*-------------------------------------------------------------------------
* basic type definitions
*-----------------------------------------------------------------------*/
#if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || defined(__GNUC__) || defined(__SCO__) || defined(__USLC__)


/*
* Using <stdint.h>
*/
#include <stdint.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(__VMS ) || defined(__sgi)

/*
* Using <inttypes.h>
*/
#include <inttypes.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(_WIN32) && !defined(__SCITECH_SNAP__)

/*
* Win32
*/
typedef __int32                 khronos_int32_t;
typedef unsigned __int32        khronos_uint32_t;
typedef __int64                 khronos_int64_t;
typedef unsigned __int64        khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(__sun__) || defined(__digital__)

/*
* Sun or Digital
*/
typedef int                     khronos_int32_t;
typedef unsigned int            khronos_uint32_t;
#if defined(__arch64__) || defined(_LP64)
typedef long int                khronos_int64_t;
typedef unsigned long int       khronos_uint64_t;
#else
typedef long long int           khronos_int64_t;
typedef unsigned long long int  khronos_uint64_t;
#endif /* __arch64__ */
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif 0

/*
* Hypothetical platform with no float or int64 support
*/
typedef int                     khronos_int32_t;
typedef unsigned int            khronos_uint32_t;
#define KHRONOS_SUPPORT_INT64   0
#define KHRONOS_SUPPORT_FLOAT   0

#else

/*
* Generic fallback
*/
#include <stdint.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#endif


/*
* Types that are (so far) the same on all platforms
*/
typedef signed   char          khronos_int8_t;
typedef unsigned char          khronos_uint8_t;
typedef signed   short int     khronos_int16_t;
typedef unsigned short int     khronos_uint16_t;

/*
* Types that differ between LLP64 and LP64 architectures - in LLP64,
* pointers are 64 bits, but 'long' is still 32 bits. Win64 appears
* to be the only LLP64 architecture in current use.
*/
#ifdef _WIN64
typedef signed   long long int khronos_intptr_t;
typedef unsigned long long int khronos_uintptr_t;
typedef signed   long long int khronos_ssize_t;
typedef unsigned long long int khronos_usize_t;
#else
typedef signed   long  int     khronos_intptr_t;
typedef unsigned long  int     khronos_uintptr_t;
typedef signed   long  int     khronos_ssize_t;
typedef unsigned long  int     khronos_usize_t;
#endif

#if KHRONOS_SUPPORT_FLOAT
/*
* Float type
*/
typedef          float         khronos_float_t;
#endif

#if KHRONOS_SUPPORT_INT64
/* Time types
*
* These types can be used to represent a time interval in nanoseconds or
* an absolute Unadjusted System Time.  Unadjusted System Time is the number
* of nanoseconds since some arbitrary system event (e.g. since the last
* time the system booted).  The Unadjusted System Time is an unsigned
* 64 bit value that wraps back to 0 every 584 years.  Time intervals
* may be either signed or unsigned.
*/
typedef khronos_uint64_t       khronos_utime_nanoseconds_t;
typedef khronos_int64_t        khronos_stime_nanoseconds_t;
#endif

/*
* Dummy value used to pad enum types to 32 bits.
*/
#ifndef KHRONOS_MAX_ENUM
#define KHRONOS_MAX_ENUM 0x7FFFFFFF
#endif

/*
* Enumerated boolean type
*
* Values other than zero should be considered to be true.  Therefore
* comparisons should not be made against KHRONOS_TRUE.
*/
typedef enum {
	KHRONOS_FALSE = 0,
	KHRONOS_TRUE = 1,
	KHRONOS_BOOLEAN_ENUM_FORCE_SIZE = KHRONOS_MAX_ENUM
} khronos_boolean_enum_t;

#endif /* __khrplatform_h_ */

	typedef khronos_float_t GLfloat;
	typedef int GLint;
	typedef int GLsizei;
	typedef unsigned int GLbitfield;
	typedef double GLdouble;
	typedef unsigned int GLuint;
	typedef unsigned char GLboolean;
	typedef khronos_uint8_t GLubyte;
#define GL_DEPTH_BUFFER_BIT               0x00000100
#define GL_STENCIL_BUFFER_BIT             0x00000400
#define GL_COLOR_BUFFER_BIT               0x00004000
#define GL_FALSE                          0
#define GL_TRUE                           1
#define GL_POINTS                         0x0000
#define GL_LINES                          0x0001
#define GL_LINE_LOOP                      0x0002
#define GL_LINE_STRIP                     0x0003
#define GL_TRIANGLES                      0x0004
#define GL_TRIANGLE_STRIP                 0x0005
#define GL_TRIANGLE_FAN                   0x0006
#define GL_QUADS                          0x0007
#define GL_NEVER                          0x0200
#define GL_LESS                           0x0201
#define GL_EQUAL                          0x0202
#define GL_LEQUAL                         0x0203
#define GL_GREATER                        0x0204
#define GL_NOTEQUAL                       0x0205
#define GL_GEQUAL                         0x0206
#define GL_ALWAYS                         0x0207
#define GL_ZERO                           0
#define GL_ONE                            1
#define GL_SRC_COLOR                      0x0300
#define GL_ONE_MINUS_SRC_COLOR            0x0301
#define GL_SRC_ALPHA                      0x0302
#define GL_ONE_MINUS_SRC_ALPHA            0x0303
#define GL_DST_ALPHA                      0x0304
#define GL_ONE_MINUS_DST_ALPHA            0x0305
#define GL_DST_COLOR                      0x0306
#define GL_ONE_MINUS_DST_COLOR            0x0307
#define GL_SRC_ALPHA_SATURATE             0x0308
#define GL_NONE                           0
#define GL_FRONT_LEFT                     0x0400
#define GL_FRONT_RIGHT                    0x0401
#define GL_BACK_LEFT                      0x0402
#define GL_BACK_RIGHT                     0x0403
#define GL_FRONT                          0x0404
#define GL_BACK                           0x0405
#define GL_LEFT                           0x0406
#define GL_RIGHT                          0x0407
#define GL_FRONT_AND_BACK                 0x0408
#define GL_NO_ERROR                       0
#define GL_INVALID_ENUM                   0x0500
#define GL_INVALID_VALUE                  0x0501
#define GL_INVALID_OPERATION              0x0502
#define GL_OUT_OF_MEMORY                  0x0505
#define GL_CW                             0x0900
#define GL_CCW                            0x0901
#define GL_POINT_SIZE                     0x0B11
#define GL_POINT_SIZE_RANGE               0x0B12
#define GL_POINT_SIZE_GRANULARITY         0x0B13
#define GL_LINE_SMOOTH                    0x0B20
#define GL_LINE_WIDTH                     0x0B21
#define GL_LINE_WIDTH_RANGE               0x0B22
#define GL_LINE_WIDTH_GRANULARITY         0x0B23
#define GL_POLYGON_MODE                   0x0B40
#define GL_POLYGON_SMOOTH                 0x0B41
#define GL_CULL_FACE                      0x0B44
#define GL_CULL_FACE_MODE                 0x0B45
#define GL_FRONT_FACE                     0x0B46
#define GL_DEPTH_RANGE                    0x0B70
#define GL_DEPTH_TEST                     0x0B71
#define GL_DEPTH_WRITEMASK                0x0B72
#define GL_DEPTH_CLEAR_VALUE              0x0B73
#define GL_DEPTH_FUNC                     0x0B74
#define GL_STENCIL_TEST                   0x0B90
#define GL_STENCIL_CLEAR_VALUE            0x0B91
#define GL_STENCIL_FUNC                   0x0B92
#define GL_STENCIL_VALUE_MASK             0x0B93
#define GL_STENCIL_FAIL                   0x0B94
#define GL_STENCIL_PASS_DEPTH_FAIL        0x0B95
#define GL_STENCIL_PASS_DEPTH_PASS        0x0B96
#define GL_STENCIL_REF                    0x0B97
#define GL_STENCIL_WRITEMASK              0x0B98
#define GL_VIEWPORT                       0x0BA2
#define GL_DITHER                         0x0BD0
#define GL_BLEND_DST                      0x0BE0
#define GL_BLEND_SRC                      0x0BE1
#define GL_BLEND                          0x0BE2
#define GL_LOGIC_OP_MODE                  0x0BF0
#define GL_DRAW_BUFFER                    0x0C01
#define GL_READ_BUFFER                    0x0C02
#define GL_SCISSOR_BOX                    0x0C10
#define GL_SCISSOR_TEST                   0x0C11
#define GL_COLOR_CLEAR_VALUE              0x0C22
#define GL_COLOR_WRITEMASK                0x0C23
#define GL_DOUBLEBUFFER                   0x0C32
#define GL_STEREO                         0x0C33
#define GL_LINE_SMOOTH_HINT               0x0C52
#define GL_POLYGON_SMOOTH_HINT            0x0C53
#define GL_UNPACK_SWAP_BYTES              0x0CF0
#define GL_UNPACK_LSB_FIRST               0x0CF1
#define GL_UNPACK_ROW_LENGTH              0x0CF2
#define GL_UNPACK_SKIP_ROWS               0x0CF3
#define GL_UNPACK_SKIP_PIXELS             0x0CF4
#define GL_UNPACK_ALIGNMENT               0x0CF5
#define GL_PACK_SWAP_BYTES                0x0D00
#define GL_PACK_LSB_FIRST                 0x0D01
#define GL_PACK_ROW_LENGTH                0x0D02
#define GL_PACK_SKIP_ROWS                 0x0D03
#define GL_PACK_SKIP_PIXELS               0x0D04
#define GL_PACK_ALIGNMENT                 0x0D05
#define GL_MAX_TEXTURE_SIZE               0x0D33
#define GL_MAX_VIEWPORT_DIMS              0x0D3A
#define GL_SUBPIXEL_BITS                  0x0D50
#define GL_TEXTURE_1D                     0x0DE0
#define GL_TEXTURE_2D                     0x0DE1
#define GL_TEXTURE_WIDTH                  0x1000
#define GL_TEXTURE_HEIGHT                 0x1001
#define GL_TEXTURE_BORDER_COLOR           0x1004
#define GL_DONT_CARE                      0x1100
#define GL_FASTEST                        0x1101
#define GL_NICEST                         0x1102
#define GL_BYTE                           0x1400
#define GL_UNSIGNED_BYTE                  0x1401
#define GL_SHORT                          0x1402
#define GL_UNSIGNED_SHORT                 0x1403
#define GL_INT                            0x1404
#define GL_UNSIGNED_INT                   0x1405
#define GL_FLOAT                          0x1406
#define GL_STACK_OVERFLOW                 0x0503
#define GL_STACK_UNDERFLOW                0x0504
#define GL_CLEAR                          0x1500
#define GL_AND                            0x1501
#define GL_AND_REVERSE                    0x1502
#define GL_COPY                           0x1503
#define GL_AND_INVERTED                   0x1504
#define GL_NOOP                           0x1505
#define GL_XOR                            0x1506
#define GL_OR                             0x1507
#define GL_NOR                            0x1508
#define GL_EQUIV                          0x1509
#define GL_INVERT                         0x150A
#define GL_OR_REVERSE                     0x150B
#define GL_COPY_INVERTED                  0x150C
#define GL_OR_INVERTED                    0x150D
#define GL_NAND                           0x150E
#define GL_SET                            0x150F
#define GL_TEXTURE                        0x1702
#define GL_COLOR                          0x1800
#define GL_DEPTH                          0x1801
#define GL_STENCIL                        0x1802
#define GL_STENCIL_INDEX                  0x1901
#define GL_DEPTH_COMPONENT                0x1902
#define GL_RED                            0x1903
#define GL_GREEN                          0x1904
#define GL_BLUE                           0x1905
#define GL_ALPHA                          0x1906
#define GL_RGB                            0x1907
#define GL_RGBA                           0x1908
#define GL_POINT                          0x1B00
#define GL_LINE                           0x1B01
#define GL_FILL                           0x1B02
#define GL_KEEP                           0x1E00
#define GL_REPLACE                        0x1E01
#define GL_INCR                           0x1E02
#define GL_DECR                           0x1E03
#define GL_VENDOR                         0x1F00
#define GL_RENDERER                       0x1F01
#define GL_VERSION                        0x1F02
#define GL_EXTENSIONS                     0x1F03
#define GL_NEAREST                        0x2600
#define GL_LINEAR                         0x2601
#define GL_NEAREST_MIPMAP_NEAREST         0x2700
#define GL_LINEAR_MIPMAP_NEAREST          0x2701
#define GL_NEAREST_MIPMAP_LINEAR          0x2702
#define GL_LINEAR_MIPMAP_LINEAR           0x2703
#define GL_TEXTURE_MAG_FILTER             0x2800
#define GL_TEXTURE_MIN_FILTER             0x2801
#define GL_TEXTURE_WRAP_S                 0x2802
#define GL_TEXTURE_WRAP_T                 0x2803
#define GL_REPEAT                         0x2901
	typedef void (APIENTRYP PFNGLCULLFACEPROC) (GLenum mode);
	typedef void (APIENTRYP PFNGLFRONTFACEPROC) (GLenum mode);
	typedef void (APIENTRYP PFNGLHINTPROC) (GLenum target, GLenum mode);
	typedef void (APIENTRYP PFNGLLINEWIDTHPROC) (GLfloat width);
	typedef void (APIENTRYP PFNGLPOINTSIZEPROC) (GLfloat size);
	typedef void (APIENTRYP PFNGLPOLYGONMODEPROC) (GLenum face, GLenum mode);
	typedef void (APIENTRYP PFNGLSCISSORPROC) (GLint x, GLint y, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLTEXPARAMETERFPROC) (GLenum target, GLenum pname, GLfloat param);
	typedef void (APIENTRYP PFNGLTEXPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat* params);
	typedef void (APIENTRYP PFNGLTEXPARAMETERIPROC) (GLenum target, GLenum pname, GLint param);
	typedef void (APIENTRYP PFNGLTEXPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint* params);
	typedef void (APIENTRYP PFNGLTEXIMAGE1DPROC) (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void* pixels);
	typedef void (APIENTRYP PFNGLTEXIMAGE2DPROC) (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void* pixels);
	typedef void (APIENTRYP PFNGLDRAWBUFFERPROC) (GLenum buf);
	typedef void (APIENTRYP PFNGLCLEARPROC) (GLbitfield mask);
	typedef void (APIENTRYP PFNGLCLEARCOLORPROC) (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
	typedef void (APIENTRYP PFNGLCLEARSTENCILPROC) (GLint s);
	typedef void (APIENTRYP PFNGLCLEARDEPTHPROC) (GLdouble depth);
	typedef void (APIENTRYP PFNGLSTENCILMASKPROC) (GLuint mask);
	typedef void (APIENTRYP PFNGLCOLORMASKPROC) (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
	typedef void (APIENTRYP PFNGLDEPTHMASKPROC) (GLboolean flag);
	typedef void (APIENTRYP PFNGLDISABLEPROC) (GLenum cap);
	typedef void (APIENTRYP PFNGLENABLEPROC) (GLenum cap);
	typedef void (APIENTRYP PFNGLFINISHPROC) (void);
	typedef void (APIENTRYP PFNGLFLUSHPROC) (void);
	typedef void (APIENTRYP PFNGLBLENDFUNCPROC) (GLenum sfactor, GLenum dfactor);
	typedef void (APIENTRYP PFNGLLOGICOPPROC) (GLenum opcode);
	typedef void (APIENTRYP PFNGLSTENCILFUNCPROC) (GLenum func, GLint ref, GLuint mask);
	typedef void (APIENTRYP PFNGLSTENCILOPPROC) (GLenum fail, GLenum zfail, GLenum zpass);
	typedef void (APIENTRYP PFNGLDEPTHFUNCPROC) (GLenum func);
	typedef void (APIENTRYP PFNGLPIXELSTOREFPROC) (GLenum pname, GLfloat param);
	typedef void (APIENTRYP PFNGLPIXELSTOREIPROC) (GLenum pname, GLint param);
	typedef void (APIENTRYP PFNGLREADBUFFERPROC) (GLenum src);
	typedef void (APIENTRYP PFNGLREADPIXELSPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void* pixels);
	typedef void (APIENTRYP PFNGLGETBOOLEANVPROC) (GLenum pname, GLboolean* data);
	typedef void (APIENTRYP PFNGLGETDOUBLEVPROC) (GLenum pname, GLdouble* data);
	typedef GLenum(APIENTRYP PFNGLGETERRORPROC) (void);
	typedef void (APIENTRYP PFNGLGETFLOATVPROC) (GLenum pname, GLfloat* data);
	typedef void (APIENTRYP PFNGLGETINTEGERVPROC) (GLenum pname, GLint* data);
	typedef const GLubyte* (APIENTRYP PFNGLGETSTRINGPROC) (GLenum name);
	typedef void (APIENTRYP PFNGLGETTEXIMAGEPROC) (GLenum target, GLint level, GLenum format, GLenum type, void* pixels);
	typedef void (APIENTRYP PFNGLGETTEXPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat* params);
	typedef void (APIENTRYP PFNGLGETTEXPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLGETTEXLEVELPARAMETERFVPROC) (GLenum target, GLint level, GLenum pname, GLfloat* params);
	typedef void (APIENTRYP PFNGLGETTEXLEVELPARAMETERIVPROC) (GLenum target, GLint level, GLenum pname, GLint* params);
	typedef GLboolean(APIENTRYP PFNGLISENABLEDPROC) (GLenum cap);
	typedef void (APIENTRYP PFNGLDEPTHRANGEPROC) (GLdouble n, GLdouble f);
	typedef void (APIENTRYP PFNGLVIEWPORTPROC) (GLint x, GLint y, GLsizei width, GLsizei height);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glCullFace(GLenum mode);
	GLAPI void APIENTRY glFrontFace(GLenum mode);
	GLAPI void APIENTRY glHint(GLenum target, GLenum mode);
	GLAPI void APIENTRY glLineWidth(GLfloat width);
	GLAPI void APIENTRY glPointSize(GLfloat size);
	GLAPI void APIENTRY glPolygonMode(GLenum face, GLenum mode);
	GLAPI void APIENTRY glScissor(GLint x, GLint y, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glTexParameterf(GLenum target, GLenum pname, GLfloat param);
	GLAPI void APIENTRY glTexParameterfv(GLenum target, GLenum pname, const GLfloat* params);
	GLAPI void APIENTRY glTexParameteri(GLenum target, GLenum pname, GLint param);
	GLAPI void APIENTRY glTexParameteriv(GLenum target, GLenum pname, const GLint* params);
	GLAPI void APIENTRY glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void* pixels);
	GLAPI void APIENTRY glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void* pixels);
	GLAPI void APIENTRY glDrawBuffer(GLenum buf);
	GLAPI void APIENTRY glClear(GLbitfield mask);
	GLAPI void APIENTRY glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
	GLAPI void APIENTRY glClearStencil(GLint s);
	GLAPI void APIENTRY glClearDepth(GLdouble depth);
	GLAPI void APIENTRY glStencilMask(GLuint mask);
	GLAPI void APIENTRY glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
	GLAPI void APIENTRY glDepthMask(GLboolean flag);
	GLAPI void APIENTRY glDisable(GLenum cap);
	GLAPI void APIENTRY glEnable(GLenum cap);
	GLAPI void APIENTRY glFinish(void);
	GLAPI void APIENTRY glFlush(void);
	GLAPI void APIENTRY glBlendFunc(GLenum sfactor, GLenum dfactor);
	GLAPI void APIENTRY glLogicOp(GLenum opcode);
	GLAPI void APIENTRY glStencilFunc(GLenum func, GLint ref, GLuint mask);
	GLAPI void APIENTRY glStencilOp(GLenum fail, GLenum zfail, GLenum zpass);
	GLAPI void APIENTRY glDepthFunc(GLenum func);
	GLAPI void APIENTRY glPixelStoref(GLenum pname, GLfloat param);
	GLAPI void APIENTRY glPixelStorei(GLenum pname, GLint param);
	GLAPI void APIENTRY glReadBuffer(GLenum src);
	GLAPI void APIENTRY glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void* pixels);
	GLAPI void APIENTRY glGetBooleanv(GLenum pname, GLboolean* data);
	GLAPI void APIENTRY glGetDoublev(GLenum pname, GLdouble* data);
	GLAPI GLenum APIENTRY glGetError(void);
	GLAPI void APIENTRY glGetFloatv(GLenum pname, GLfloat* data);
	GLAPI void APIENTRY glGetIntegerv(GLenum pname, GLint* data);
	GLAPI const GLubyte* APIENTRY glGetString(GLenum name);
	GLAPI void APIENTRY glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, void* pixels);
	GLAPI void APIENTRY glGetTexParameterfv(GLenum target, GLenum pname, GLfloat* params);
	GLAPI void APIENTRY glGetTexParameteriv(GLenum target, GLenum pname, GLint* params);
	GLAPI void APIENTRY glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat* params);
	GLAPI void APIENTRY glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint* params);
	GLAPI GLboolean APIENTRY glIsEnabled(GLenum cap);
	GLAPI void APIENTRY glDepthRange(GLdouble n, GLdouble f);
	GLAPI void APIENTRY glViewport(GLint x, GLint y, GLsizei width, GLsizei height);
#endif
#endif /* GL_VERSION_1_0 */

#ifndef GL_VERSION_1_1
#define GL_VERSION_1_1 1
	typedef khronos_float_t GLclampf;
	typedef double GLclampd;
#define GL_COLOR_LOGIC_OP                 0x0BF2
#define GL_POLYGON_OFFSET_UNITS           0x2A00
#define GL_POLYGON_OFFSET_POINT           0x2A01
#define GL_POLYGON_OFFSET_LINE            0x2A02
#define GL_POLYGON_OFFSET_FILL            0x8037
#define GL_POLYGON_OFFSET_FACTOR          0x8038
#define GL_TEXTURE_BINDING_1D             0x8068
#define GL_TEXTURE_BINDING_2D             0x8069
#define GL_TEXTURE_INTERNAL_FORMAT        0x1003
#define GL_TEXTURE_RED_SIZE               0x805C
#define GL_TEXTURE_GREEN_SIZE             0x805D
#define GL_TEXTURE_BLUE_SIZE              0x805E
#define GL_TEXTURE_ALPHA_SIZE             0x805F
#define GL_DOUBLE                         0x140A
#define GL_PROXY_TEXTURE_1D               0x8063
#define GL_PROXY_TEXTURE_2D               0x8064
#define GL_R3_G3_B2                       0x2A10
#define GL_RGB4                           0x804F
#define GL_RGB5                           0x8050
#define GL_RGB8                           0x8051
#define GL_RGB10                          0x8052
#define GL_RGB12                          0x8053
#define GL_RGB16                          0x8054
#define GL_RGBA2                          0x8055
#define GL_RGBA4                          0x8056
#define GL_RGB5_A1                        0x8057
#define GL_RGBA8                          0x8058
#define GL_RGB10_A2                       0x8059
#define GL_RGBA12                         0x805A
#define GL_RGBA16                         0x805B
#define GL_VERTEX_ARRAY                   0x8074
	typedef void (APIENTRYP PFNGLDRAWARRAYSPROC) (GLenum mode, GLint first, GLsizei count);
	typedef void (APIENTRYP PFNGLDRAWELEMENTSPROC) (GLenum mode, GLsizei count, GLenum type, const void* indices);
	typedef void (APIENTRYP PFNGLGETPOINTERVPROC) (GLenum pname, void** params);
	typedef void (APIENTRYP PFNGLPOLYGONOFFSETPROC) (GLfloat factor, GLfloat units);
	typedef void (APIENTRYP PFNGLCOPYTEXIMAGE1DPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
	typedef void (APIENTRYP PFNGLCOPYTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
	typedef void (APIENTRYP PFNGLCOPYTEXSUBIMAGE1DPROC) (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
	typedef void (APIENTRYP PFNGLCOPYTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLTEXSUBIMAGE1DPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void* pixels);
	typedef void (APIENTRYP PFNGLTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels);
	typedef void (APIENTRYP PFNGLBINDTEXTUREPROC) (GLenum target, GLuint texture);
	typedef void (APIENTRYP PFNGLDELETETEXTURESPROC) (GLsizei n, const GLuint* textures);
	typedef void (APIENTRYP PFNGLGENTEXTURESPROC) (GLsizei n, GLuint* textures);
	typedef GLboolean(APIENTRYP PFNGLISTEXTUREPROC) (GLuint texture);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glDrawArrays(GLenum mode, GLint first, GLsizei count);
	GLAPI void APIENTRY glDrawElements(GLenum mode, GLsizei count, GLenum type, const void* indices);
	GLAPI void APIENTRY glGetPointerv(GLenum pname, void** params);
	GLAPI void APIENTRY glPolygonOffset(GLfloat factor, GLfloat units);
	GLAPI void APIENTRY glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
	GLAPI void APIENTRY glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
	GLAPI void APIENTRY glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
	GLAPI void APIENTRY glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void* pixels);
	GLAPI void APIENTRY glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels);
	GLAPI void APIENTRY glBindTexture(GLenum target, GLuint texture);
	GLAPI void APIENTRY glDeleteTextures(GLsizei n, const GLuint* textures);
	GLAPI void APIENTRY glGenTextures(GLsizei n, GLuint* textures);
	GLAPI GLboolean APIENTRY glIsTexture(GLuint texture);
#endif
#endif /* GL_VERSION_1_1 */

#ifndef GL_VERSION_1_2
#define GL_VERSION_1_2 1
#define GL_UNSIGNED_BYTE_3_3_2            0x8032
#define GL_UNSIGNED_SHORT_4_4_4_4         0x8033
#define GL_UNSIGNED_SHORT_5_5_5_1         0x8034
#define GL_UNSIGNED_INT_8_8_8_8           0x8035
#define GL_UNSIGNED_INT_10_10_10_2        0x8036
#define GL_TEXTURE_BINDING_3D             0x806A
#define GL_PACK_SKIP_IMAGES               0x806B
#define GL_PACK_IMAGE_HEIGHT              0x806C
#define GL_UNPACK_SKIP_IMAGES             0x806D
#define GL_UNPACK_IMAGE_HEIGHT            0x806E
#define GL_TEXTURE_3D                     0x806F
#define GL_PROXY_TEXTURE_3D               0x8070
#define GL_TEXTURE_DEPTH                  0x8071
#define GL_TEXTURE_WRAP_R                 0x8072
#define GL_MAX_3D_TEXTURE_SIZE            0x8073
#define GL_UNSIGNED_BYTE_2_3_3_REV        0x8362
#define GL_UNSIGNED_SHORT_5_6_5           0x8363
#define GL_UNSIGNED_SHORT_5_6_5_REV       0x8364
#define GL_UNSIGNED_SHORT_4_4_4_4_REV     0x8365
#define GL_UNSIGNED_SHORT_1_5_5_5_REV     0x8366
#define GL_UNSIGNED_INT_8_8_8_8_REV       0x8367
#define GL_UNSIGNED_INT_2_10_10_10_REV    0x8368
#define GL_BGR                            0x80E0
#define GL_BGRA                           0x80E1
#define GL_MAX_ELEMENTS_VERTICES          0x80E8
#define GL_MAX_ELEMENTS_INDICES           0x80E9
#define GL_CLAMP_TO_EDGE                  0x812F
#define GL_TEXTURE_MIN_LOD                0x813A
#define GL_TEXTURE_MAX_LOD                0x813B
#define GL_TEXTURE_BASE_LEVEL             0x813C
#define GL_TEXTURE_MAX_LEVEL              0x813D
#define GL_SMOOTH_POINT_SIZE_RANGE        0x0B12
#define GL_SMOOTH_POINT_SIZE_GRANULARITY  0x0B13
#define GL_SMOOTH_LINE_WIDTH_RANGE        0x0B22
#define GL_SMOOTH_LINE_WIDTH_GRANULARITY  0x0B23
#define GL_ALIASED_LINE_WIDTH_RANGE       0x846E
	typedef void (APIENTRYP PFNGLDRAWRANGEELEMENTSPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void* indices);
	typedef void (APIENTRYP PFNGLTEXIMAGE3DPROC) (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void* pixels);
	typedef void (APIENTRYP PFNGLTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels);
	typedef void (APIENTRYP PFNGLCOPYTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void* indices);
	GLAPI void APIENTRY glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void* pixels);
	GLAPI void APIENTRY glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels);
	GLAPI void APIENTRY glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
#endif
#endif /* GL_VERSION_1_2 */

#ifndef GL_VERSION_1_3
#define GL_VERSION_1_3 1
#define GL_TEXTURE0                       0x84C0
#define GL_TEXTURE1                       0x84C1
#define GL_TEXTURE2                       0x84C2
#define GL_TEXTURE3                       0x84C3
#define GL_TEXTURE4                       0x84C4
#define GL_TEXTURE5                       0x84C5
#define GL_TEXTURE6                       0x84C6
#define GL_TEXTURE7                       0x84C7
#define GL_TEXTURE8                       0x84C8
#define GL_TEXTURE9                       0x84C9
#define GL_TEXTURE10                      0x84CA
#define GL_TEXTURE11                      0x84CB
#define GL_TEXTURE12                      0x84CC
#define GL_TEXTURE13                      0x84CD
#define GL_TEXTURE14                      0x84CE
#define GL_TEXTURE15                      0x84CF
#define GL_TEXTURE16                      0x84D0
#define GL_TEXTURE17                      0x84D1
#define GL_TEXTURE18                      0x84D2
#define GL_TEXTURE19                      0x84D3
#define GL_TEXTURE20                      0x84D4
#define GL_TEXTURE21                      0x84D5
#define GL_TEXTURE22                      0x84D6
#define GL_TEXTURE23                      0x84D7
#define GL_TEXTURE24                      0x84D8
#define GL_TEXTURE25                      0x84D9
#define GL_TEXTURE26                      0x84DA
#define GL_TEXTURE27                      0x84DB
#define GL_TEXTURE28                      0x84DC
#define GL_TEXTURE29                      0x84DD
#define GL_TEXTURE30                      0x84DE
#define GL_TEXTURE31                      0x84DF
#define GL_ACTIVE_TEXTURE                 0x84E0
#define GL_MULTISAMPLE                    0x809D
#define GL_SAMPLE_ALPHA_TO_COVERAGE       0x809E
#define GL_SAMPLE_ALPHA_TO_ONE            0x809F
#define GL_SAMPLE_COVERAGE                0x80A0
#define GL_SAMPLE_BUFFERS                 0x80A8
#define GL_SAMPLES                        0x80A9
#define GL_SAMPLE_COVERAGE_VALUE          0x80AA
#define GL_SAMPLE_COVERAGE_INVERT         0x80AB
#define GL_TEXTURE_CUBE_MAP               0x8513
#define GL_TEXTURE_BINDING_CUBE_MAP       0x8514
#define GL_TEXTURE_CUBE_MAP_POSITIVE_X    0x8515
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X    0x8516
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y    0x8517
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y    0x8518
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z    0x8519
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z    0x851A
#define GL_PROXY_TEXTURE_CUBE_MAP         0x851B
#define GL_MAX_CUBE_MAP_TEXTURE_SIZE      0x851C
#define GL_COMPRESSED_RGB                 0x84ED
#define GL_COMPRESSED_RGBA                0x84EE
#define GL_TEXTURE_COMPRESSION_HINT       0x84EF
#define GL_TEXTURE_COMPRESSED_IMAGE_SIZE  0x86A0
#define GL_TEXTURE_COMPRESSED             0x86A1
#define GL_NUM_COMPRESSED_TEXTURE_FORMATS 0x86A2
#define GL_COMPRESSED_TEXTURE_FORMATS     0x86A3
#define GL_CLAMP_TO_BORDER                0x812D
	typedef void (APIENTRYP PFNGLACTIVETEXTUREPROC) (GLenum texture);
	typedef void (APIENTRYP PFNGLSAMPLECOVERAGEPROC) (GLfloat value, GLboolean invert);
	typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE3DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void* data);
	typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void* data);
	typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE1DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void* data);
	typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* data);
	typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* data);
	typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void* data);
	typedef void (APIENTRYP PFNGLGETCOMPRESSEDTEXIMAGEPROC) (GLenum target, GLint level, void* img);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glActiveTexture(GLenum texture);
	GLAPI void APIENTRY glSampleCoverage(GLfloat value, GLboolean invert);
	GLAPI void APIENTRY glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void* data);
	GLAPI void APIENTRY glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void* data);
	GLAPI void APIENTRY glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void* data);
	GLAPI void APIENTRY glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* data);
	GLAPI void APIENTRY glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* data);
	GLAPI void APIENTRY glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void* data);
	GLAPI void APIENTRY glGetCompressedTexImage(GLenum target, GLint level, void* img);
#endif
#endif /* GL_VERSION_1_3 */

#ifndef GL_VERSION_1_4
#define GL_VERSION_1_4 1
#define GL_BLEND_DST_RGB                  0x80C8
#define GL_BLEND_SRC_RGB                  0x80C9
#define GL_BLEND_DST_ALPHA                0x80CA
#define GL_BLEND_SRC_ALPHA                0x80CB
#define GL_POINT_FADE_THRESHOLD_SIZE      0x8128
#define GL_DEPTH_COMPONENT16              0x81A5
#define GL_DEPTH_COMPONENT24              0x81A6
#define GL_DEPTH_COMPONENT32              0x81A7
#define GL_MIRRORED_REPEAT                0x8370
#define GL_MAX_TEXTURE_LOD_BIAS           0x84FD
#define GL_TEXTURE_LOD_BIAS               0x8501
#define GL_INCR_WRAP                      0x8507
#define GL_DECR_WRAP                      0x8508
#define GL_TEXTURE_DEPTH_SIZE             0x884A
#define GL_TEXTURE_COMPARE_MODE           0x884C
#define GL_TEXTURE_COMPARE_FUNC           0x884D
#define GL_BLEND_COLOR                    0x8005
#define GL_BLEND_EQUATION                 0x8009
#define GL_CONSTANT_COLOR                 0x8001
#define GL_ONE_MINUS_CONSTANT_COLOR       0x8002
#define GL_CONSTANT_ALPHA                 0x8003
#define GL_ONE_MINUS_CONSTANT_ALPHA       0x8004
#define GL_FUNC_ADD                       0x8006
#define GL_FUNC_REVERSE_SUBTRACT          0x800B
#define GL_FUNC_SUBTRACT                  0x800A
#define GL_MIN                            0x8007
#define GL_MAX                            0x8008
	typedef void (APIENTRYP PFNGLBLENDFUNCSEPARATEPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
	typedef void (APIENTRYP PFNGLMULTIDRAWARRAYSPROC) (GLenum mode, const GLint* first, const GLsizei* count, GLsizei drawcount);
	typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSPROC) (GLenum mode, const GLsizei* count, GLenum type, const void* const* indices, GLsizei drawcount);
	typedef void (APIENTRYP PFNGLPOINTPARAMETERFPROC) (GLenum pname, GLfloat param);
	typedef void (APIENTRYP PFNGLPOINTPARAMETERFVPROC) (GLenum pname, const GLfloat* params);
	typedef void (APIENTRYP PFNGLPOINTPARAMETERIPROC) (GLenum pname, GLint param);
	typedef void (APIENTRYP PFNGLPOINTPARAMETERIVPROC) (GLenum pname, const GLint* params);
	typedef void (APIENTRYP PFNGLBLENDCOLORPROC) (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
	typedef void (APIENTRYP PFNGLBLENDEQUATIONPROC) (GLenum mode);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glBlendFuncSeparate(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
	GLAPI void APIENTRY glMultiDrawArrays(GLenum mode, const GLint* first, const GLsizei* count, GLsizei drawcount);
	GLAPI void APIENTRY glMultiDrawElements(GLenum mode, const GLsizei* count, GLenum type, const void* const* indices, GLsizei drawcount);
	GLAPI void APIENTRY glPointParameterf(GLenum pname, GLfloat param);
	GLAPI void APIENTRY glPointParameterfv(GLenum pname, const GLfloat* params);
	GLAPI void APIENTRY glPointParameteri(GLenum pname, GLint param);
	GLAPI void APIENTRY glPointParameteriv(GLenum pname, const GLint* params);
	GLAPI void APIENTRY glBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
	GLAPI void APIENTRY glBlendEquation(GLenum mode);
#endif
#endif /* GL_VERSION_1_4 */

#ifndef GL_VERSION_1_5
#define GL_VERSION_1_5 1
	typedef khronos_ssize_t GLsizeiptr;
	typedef khronos_intptr_t GLintptr;
#define GL_BUFFER_SIZE                    0x8764
#define GL_BUFFER_USAGE                   0x8765
#define GL_QUERY_COUNTER_BITS             0x8864
#define GL_CURRENT_QUERY                  0x8865
#define GL_QUERY_RESULT                   0x8866
#define GL_QUERY_RESULT_AVAILABLE         0x8867
#define GL_ARRAY_BUFFER                   0x8892
#define GL_ELEMENT_ARRAY_BUFFER           0x8893
#define GL_ARRAY_BUFFER_BINDING           0x8894
#define GL_ELEMENT_ARRAY_BUFFER_BINDING   0x8895
#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING 0x889F
#define GL_READ_ONLY                      0x88B8
#define GL_WRITE_ONLY                     0x88B9
#define GL_READ_WRITE                     0x88BA
#define GL_BUFFER_ACCESS                  0x88BB
#define GL_BUFFER_MAPPED                  0x88BC
#define GL_BUFFER_MAP_POINTER             0x88BD
#define GL_STREAM_DRAW                    0x88E0
#define GL_STREAM_READ                    0x88E1
#define GL_STREAM_COPY                    0x88E2
#define GL_STATIC_DRAW                    0x88E4
#define GL_STATIC_READ                    0x88E5
#define GL_STATIC_COPY                    0x88E6
#define GL_DYNAMIC_DRAW                   0x88E8
#define GL_DYNAMIC_READ                   0x88E9
#define GL_DYNAMIC_COPY                   0x88EA
#define GL_SAMPLES_PASSED                 0x8914
#define GL_SRC1_ALPHA                     0x8589
	typedef void (APIENTRYP PFNGLGENQUERIESPROC) (GLsizei n, GLuint* ids);
	typedef void (APIENTRYP PFNGLDELETEQUERIESPROC) (GLsizei n, const GLuint* ids);
	typedef GLboolean(APIENTRYP PFNGLISQUERYPROC) (GLuint id);
	typedef void (APIENTRYP PFNGLBEGINQUERYPROC) (GLenum target, GLuint id);
	typedef void (APIENTRYP PFNGLENDQUERYPROC) (GLenum target);
	typedef void (APIENTRYP PFNGLGETQUERYIVPROC) (GLenum target, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLGETQUERYOBJECTIVPROC) (GLuint id, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLGETQUERYOBJECTUIVPROC) (GLuint id, GLenum pname, GLuint* params);
	typedef void (APIENTRYP PFNGLBINDBUFFERPROC) (GLenum target, GLuint buffer);
	typedef void (APIENTRYP PFNGLDELETEBUFFERSPROC) (GLsizei n, const GLuint* buffers);
	typedef void (APIENTRYP PFNGLGENBUFFERSPROC) (GLsizei n, GLuint* buffers);
	typedef GLboolean(APIENTRYP PFNGLISBUFFERPROC) (GLuint buffer);
	typedef void (APIENTRYP PFNGLBUFFERDATAPROC) (GLenum target, GLsizeiptr size, const void* data, GLenum usage);
	typedef void (APIENTRYP PFNGLBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, const void* data);
	typedef void (APIENTRYP PFNGLGETBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, void* data);
	typedef void* (APIENTRYP PFNGLMAPBUFFERPROC) (GLenum target, GLenum access);
	typedef GLboolean(APIENTRYP PFNGLUNMAPBUFFERPROC) (GLenum target);
	typedef void (APIENTRYP PFNGLGETBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLGETBUFFERPOINTERVPROC) (GLenum target, GLenum pname, void** params);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glGenQueries(GLsizei n, GLuint* ids);
	GLAPI void APIENTRY glDeleteQueries(GLsizei n, const GLuint* ids);
	GLAPI GLboolean APIENTRY glIsQuery(GLuint id);
	GLAPI void APIENTRY glBeginQuery(GLenum target, GLuint id);
	GLAPI void APIENTRY glEndQuery(GLenum target);
	GLAPI void APIENTRY glGetQueryiv(GLenum target, GLenum pname, GLint* params);
	GLAPI void APIENTRY glGetQueryObjectiv(GLuint id, GLenum pname, GLint* params);
	GLAPI void APIENTRY glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint* params);
	GLAPI void APIENTRY glBindBuffer(GLenum target, GLuint buffer);
	GLAPI void APIENTRY glDeleteBuffers(GLsizei n, const GLuint* buffers);
	GLAPI void APIENTRY glGenBuffers(GLsizei n, GLuint* buffers);
	GLAPI GLboolean APIENTRY glIsBuffer(GLuint buffer);
	GLAPI void APIENTRY glBufferData(GLenum target, GLsizeiptr size, const void* data, GLenum usage);
	GLAPI void APIENTRY glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const void* data);
	GLAPI void APIENTRY glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, void* data);
	GLAPI void* APIENTRY glMapBuffer(GLenum target, GLenum access);
	GLAPI GLboolean APIENTRY glUnmapBuffer(GLenum target);
	GLAPI void APIENTRY glGetBufferParameteriv(GLenum target, GLenum pname, GLint* params);
	GLAPI void APIENTRY glGetBufferPointerv(GLenum target, GLenum pname, void** params);
#endif
#endif /* GL_VERSION_1_5 */

#ifndef GL_VERSION_2_0
#define GL_VERSION_2_0 1
	typedef char GLchar;
	typedef khronos_int16_t GLshort;
	typedef khronos_int8_t GLbyte;
	typedef khronos_uint16_t GLushort;
#define GL_BLEND_EQUATION_RGB             0x8009
#define GL_VERTEX_ATTRIB_ARRAY_ENABLED    0x8622
#define GL_VERTEX_ATTRIB_ARRAY_SIZE       0x8623
#define GL_VERTEX_ATTRIB_ARRAY_STRIDE     0x8624
#define GL_VERTEX_ATTRIB_ARRAY_TYPE       0x8625
#define GL_CURRENT_VERTEX_ATTRIB          0x8626
#define GL_VERTEX_PROGRAM_POINT_SIZE      0x8642
#define GL_VERTEX_ATTRIB_ARRAY_POINTER    0x8645
#define GL_STENCIL_BACK_FUNC              0x8800
#define GL_STENCIL_BACK_FAIL              0x8801
#define GL_STENCIL_BACK_PASS_DEPTH_FAIL   0x8802
#define GL_STENCIL_BACK_PASS_DEPTH_PASS   0x8803
#define GL_MAX_DRAW_BUFFERS               0x8824
#define GL_DRAW_BUFFER0                   0x8825
#define GL_DRAW_BUFFER1                   0x8826
#define GL_DRAW_BUFFER2                   0x8827
#define GL_DRAW_BUFFER3                   0x8828
#define GL_DRAW_BUFFER4                   0x8829
#define GL_DRAW_BUFFER5                   0x882A
#define GL_DRAW_BUFFER6                   0x882B
#define GL_DRAW_BUFFER7                   0x882C
#define GL_DRAW_BUFFER8                   0x882D
#define GL_DRAW_BUFFER9                   0x882E
#define GL_DRAW_BUFFER10                  0x882F
#define GL_DRAW_BUFFER11                  0x8830
#define GL_DRAW_BUFFER12                  0x8831
#define GL_DRAW_BUFFER13                  0x8832
#define GL_DRAW_BUFFER14                  0x8833
#define GL_DRAW_BUFFER15                  0x8834
#define GL_BLEND_EQUATION_ALPHA           0x883D
#define GL_MAX_VERTEX_ATTRIBS             0x8869
#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED 0x886A
#define GL_MAX_TEXTURE_IMAGE_UNITS        0x8872
#define GL_FRAGMENT_SHADER                0x8B30
#define GL_VERTEX_SHADER                  0x8B31
#define GL_MAX_FRAGMENT_UNIFORM_COMPONENTS 0x8B49
#define GL_MAX_VERTEX_UNIFORM_COMPONENTS  0x8B4A
#define GL_MAX_VARYING_FLOATS             0x8B4B
#define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS 0x8B4C
#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS 0x8B4D
#define GL_SHADER_TYPE                    0x8B4F
#define GL_FLOAT_VEC2                     0x8B50
#define GL_FLOAT_VEC3                     0x8B51
#define GL_FLOAT_VEC4                     0x8B52
#define GL_INT_VEC2                       0x8B53
#define GL_INT_VEC3                       0x8B54
#define GL_INT_VEC4                       0x8B55
#define GL_BOOL                           0x8B56
#define GL_BOOL_VEC2                      0x8B57
#define GL_BOOL_VEC3                      0x8B58
#define GL_BOOL_VEC4                      0x8B59
#define GL_FLOAT_MAT2                     0x8B5A
#define GL_FLOAT_MAT3                     0x8B5B
#define GL_FLOAT_MAT4                     0x8B5C
#define GL_SAMPLER_1D                     0x8B5D
#define GL_SAMPLER_2D                     0x8B5E
#define GL_SAMPLER_3D                     0x8B5F
#define GL_SAMPLER_CUBE                   0x8B60
#define GL_SAMPLER_1D_SHADOW              0x8B61
#define GL_SAMPLER_2D_SHADOW              0x8B62
#define GL_DELETE_STATUS                  0x8B80
#define GL_COMPILE_STATUS                 0x8B81
#define GL_LINK_STATUS                    0x8B82
#define GL_VALIDATE_STATUS                0x8B83
#define GL_INFO_LOG_LENGTH                0x8B84
#define GL_ATTACHED_SHADERS               0x8B85
#define GL_ACTIVE_UNIFORMS                0x8B86
#define GL_ACTIVE_UNIFORM_MAX_LENGTH      0x8B87
#define GL_SHADER_SOURCE_LENGTH           0x8B88
#define GL_ACTIVE_ATTRIBUTES              0x8B89
#define GL_ACTIVE_ATTRIBUTE_MAX_LENGTH    0x8B8A
#define GL_FRAGMENT_SHADER_DERIVATIVE_HINT 0x8B8B
#define GL_SHADING_LANGUAGE_VERSION       0x8B8C
#define GL_CURRENT_PROGRAM                0x8B8D
#define GL_POINT_SPRITE_COORD_ORIGIN      0x8CA0
#define GL_LOWER_LEFT                     0x8CA1
#define GL_UPPER_LEFT                     0x8CA2
#define GL_STENCIL_BACK_REF               0x8CA3
#define GL_STENCIL_BACK_VALUE_MASK        0x8CA4
#define GL_STENCIL_BACK_WRITEMASK         0x8CA5
	typedef void (APIENTRYP PFNGLBLENDEQUATIONSEPARATEPROC) (GLenum modeRGB, GLenum modeAlpha);
	typedef void (APIENTRYP PFNGLDRAWBUFFERSPROC) (GLsizei n, const GLenum* bufs);
	typedef void (APIENTRYP PFNGLSTENCILOPSEPARATEPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
	typedef void (APIENTRYP PFNGLSTENCILFUNCSEPARATEPROC) (GLenum face, GLenum func, GLint ref, GLuint mask);
	typedef void (APIENTRYP PFNGLSTENCILMASKSEPARATEPROC) (GLenum face, GLuint mask);
	typedef void (APIENTRYP PFNGLATTACHSHADERPROC) (GLuint program, GLuint shader);
	typedef void (APIENTRYP PFNGLBINDATTRIBLOCATIONPROC) (GLuint program, GLuint index, const GLchar* name);
	typedef void (APIENTRYP PFNGLCOMPILESHADERPROC) (GLuint shader);
	typedef GLuint(APIENTRYP PFNGLCREATEPROGRAMPROC) (void);
	typedef GLuint(APIENTRYP PFNGLCREATESHADERPROC) (GLenum type);
	typedef void (APIENTRYP PFNGLDELETEPROGRAMPROC) (GLuint program);
	typedef void (APIENTRYP PFNGLDELETESHADERPROC) (GLuint shader);
	typedef void (APIENTRYP PFNGLDETACHSHADERPROC) (GLuint program, GLuint shader);
	typedef void (APIENTRYP PFNGLDISABLEVERTEXATTRIBARRAYPROC) (GLuint index);
	typedef void (APIENTRYP PFNGLENABLEVERTEXATTRIBARRAYPROC) (GLuint index);
	typedef void (APIENTRYP PFNGLGETACTIVEATTRIBPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
	typedef void (APIENTRYP PFNGLGETACTIVEUNIFORMPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
	typedef void (APIENTRYP PFNGLGETATTACHEDSHADERSPROC) (GLuint program, GLsizei maxCount, GLsizei* count, GLuint* shaders);
	typedef GLint(APIENTRYP PFNGLGETATTRIBLOCATIONPROC) (GLuint program, const GLchar* name);
	typedef void (APIENTRYP PFNGLGETPROGRAMIVPROC) (GLuint program, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLGETPROGRAMINFOLOGPROC) (GLuint program, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
	typedef void (APIENTRYP PFNGLGETSHADERIVPROC) (GLuint shader, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLGETSHADERINFOLOGPROC) (GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
	typedef void (APIENTRYP PFNGLGETSHADERSOURCEPROC) (GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* source);
	typedef GLint(APIENTRYP PFNGLGETUNIFORMLOCATIONPROC) (GLuint program, const GLchar* name);
	typedef void (APIENTRYP PFNGLGETUNIFORMFVPROC) (GLuint program, GLint location, GLfloat* params);
	typedef void (APIENTRYP PFNGLGETUNIFORMIVPROC) (GLuint program, GLint location, GLint* params);
	typedef void (APIENTRYP PFNGLGETVERTEXATTRIBDVPROC) (GLuint index, GLenum pname, GLdouble* params);
	typedef void (APIENTRYP PFNGLGETVERTEXATTRIBFVPROC) (GLuint index, GLenum pname, GLfloat* params);
	typedef void (APIENTRYP PFNGLGETVERTEXATTRIBIVPROC) (GLuint index, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLGETVERTEXATTRIBPOINTERVPROC) (GLuint index, GLenum pname, void** pointer);
	typedef GLboolean(APIENTRYP PFNGLISPROGRAMPROC) (GLuint program);
	typedef GLboolean(APIENTRYP PFNGLISSHADERPROC) (GLuint shader);
	typedef void (APIENTRYP PFNGLLINKPROGRAMPROC) (GLuint program);
	typedef void (APIENTRYP PFNGLSHADERSOURCEPROC) (GLuint shader, GLsizei count, const GLchar* const* string, const GLint* length);
	typedef void (APIENTRYP PFNGLUSEPROGRAMPROC) (GLuint program);
	typedef void (APIENTRYP PFNGLUNIFORM1FPROC) (GLint location, GLfloat v0);
	typedef void (APIENTRYP PFNGLUNIFORM2FPROC) (GLint location, GLfloat v0, GLfloat v1);
	typedef void (APIENTRYP PFNGLUNIFORM3FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
	typedef void (APIENTRYP PFNGLUNIFORM4FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
	typedef void (APIENTRYP PFNGLUNIFORM1IPROC) (GLint location, GLint v0);
	typedef void (APIENTRYP PFNGLUNIFORM2IPROC) (GLint location, GLint v0, GLint v1);
	typedef void (APIENTRYP PFNGLUNIFORM3IPROC) (GLint location, GLint v0, GLint v1, GLint v2);
	typedef void (APIENTRYP PFNGLUNIFORM4IPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
	typedef void (APIENTRYP PFNGLUNIFORM1FVPROC) (GLint location, GLsizei count, const GLfloat* value);
	typedef void (APIENTRYP PFNGLUNIFORM2FVPROC) (GLint location, GLsizei count, const GLfloat* value);
	typedef void (APIENTRYP PFNGLUNIFORM3FVPROC) (GLint location, GLsizei count, const GLfloat* value);
	typedef void (APIENTRYP PFNGLUNIFORM4FVPROC) (GLint location, GLsizei count, const GLfloat* value);
	typedef void (APIENTRYP PFNGLUNIFORM1IVPROC) (GLint location, GLsizei count, const GLint* value);
	typedef void (APIENTRYP PFNGLUNIFORM2IVPROC) (GLint location, GLsizei count, const GLint* value);
	typedef void (APIENTRYP PFNGLUNIFORM3IVPROC) (GLint location, GLsizei count, const GLint* value);
	typedef void (APIENTRYP PFNGLUNIFORM4IVPROC) (GLint location, GLsizei count, const GLint* value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	typedef void (APIENTRYP PFNGLVALIDATEPROGRAMPROC) (GLuint program);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB1DPROC) (GLuint index, GLdouble x);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB1DVPROC) (GLuint index, const GLdouble* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB1FPROC) (GLuint index, GLfloat x);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB1FVPROC) (GLuint index, const GLfloat* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB1SPROC) (GLuint index, GLshort x);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB1SVPROC) (GLuint index, const GLshort* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB2DPROC) (GLuint index, GLdouble x, GLdouble y);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB2DVPROC) (GLuint index, const GLdouble* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB2FPROC) (GLuint index, GLfloat x, GLfloat y);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB2FVPROC) (GLuint index, const GLfloat* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB2SPROC) (GLuint index, GLshort x, GLshort y);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB2SVPROC) (GLuint index, const GLshort* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB3DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB3DVPROC) (GLuint index, const GLdouble* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB3FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB3FVPROC) (GLuint index, const GLfloat* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB3SPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB3SVPROC) (GLuint index, const GLshort* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4NBVPROC) (GLuint index, const GLbyte* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4NIVPROC) (GLuint index, const GLint* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4NSVPROC) (GLuint index, const GLshort* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUBVPROC) (GLuint index, const GLubyte* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUIVPROC) (GLuint index, const GLuint* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUSVPROC) (GLuint index, const GLushort* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4BVPROC) (GLuint index, const GLbyte* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4DVPROC) (GLuint index, const GLdouble* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4FVPROC) (GLuint index, const GLfloat* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4IVPROC) (GLuint index, const GLint* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4SPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4SVPROC) (GLuint index, const GLshort* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4UBVPROC) (GLuint index, const GLubyte* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4UIVPROC) (GLuint index, const GLuint* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIB4USVPROC) (GLuint index, const GLushort* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBPOINTERPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void* pointer);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha);
	GLAPI void APIENTRY glDrawBuffers(GLsizei n, const GLenum* bufs);
	GLAPI void APIENTRY glStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
	GLAPI void APIENTRY glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask);
	GLAPI void APIENTRY glStencilMaskSeparate(GLenum face, GLuint mask);
	GLAPI void APIENTRY glAttachShader(GLuint program, GLuint shader);
	GLAPI void APIENTRY glBindAttribLocation(GLuint program, GLuint index, const GLchar* name);
	GLAPI void APIENTRY glCompileShader(GLuint shader);
	GLAPI GLuint APIENTRY glCreateProgram(void);
	GLAPI GLuint APIENTRY glCreateShader(GLenum type);
	GLAPI void APIENTRY glDeleteProgram(GLuint program);
	GLAPI void APIENTRY glDeleteShader(GLuint shader);
	GLAPI void APIENTRY glDetachShader(GLuint program, GLuint shader);
	GLAPI void APIENTRY glDisableVertexAttribArray(GLuint index);
	GLAPI void APIENTRY glEnableVertexAttribArray(GLuint index);
	GLAPI void APIENTRY glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
	GLAPI void APIENTRY glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
	GLAPI void APIENTRY glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei* count, GLuint* shaders);
	GLAPI GLint APIENTRY glGetAttribLocation(GLuint program, const GLchar* name);
	GLAPI void APIENTRY glGetProgramiv(GLuint program, GLenum pname, GLint* params);
	GLAPI void APIENTRY glGetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
	GLAPI void APIENTRY glGetShaderiv(GLuint shader, GLenum pname, GLint* params);
	GLAPI void APIENTRY glGetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
	GLAPI void APIENTRY glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* source);
	GLAPI GLint APIENTRY glGetUniformLocation(GLuint program, const GLchar* name);
	GLAPI void APIENTRY glGetUniformfv(GLuint program, GLint location, GLfloat* params);
	GLAPI void APIENTRY glGetUniformiv(GLuint program, GLint location, GLint* params);
	GLAPI void APIENTRY glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble* params);
	GLAPI void APIENTRY glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat* params);
	GLAPI void APIENTRY glGetVertexAttribiv(GLuint index, GLenum pname, GLint* params);
	GLAPI void APIENTRY glGetVertexAttribPointerv(GLuint index, GLenum pname, void** pointer);
	GLAPI GLboolean APIENTRY glIsProgram(GLuint program);
	GLAPI GLboolean APIENTRY glIsShader(GLuint shader);
	GLAPI void APIENTRY glLinkProgram(GLuint program);
	GLAPI void APIENTRY glShaderSource(GLuint shader, GLsizei count, const GLchar* const* string, const GLint* length);
	GLAPI void APIENTRY glUseProgram(GLuint program);
	GLAPI void APIENTRY glUniform1f(GLint location, GLfloat v0);
	GLAPI void APIENTRY glUniform2f(GLint location, GLfloat v0, GLfloat v1);
	GLAPI void APIENTRY glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
	GLAPI void APIENTRY glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
	GLAPI void APIENTRY glUniform1i(GLint location, GLint v0);
	GLAPI void APIENTRY glUniform2i(GLint location, GLint v0, GLint v1);
	GLAPI void APIENTRY glUniform3i(GLint location, GLint v0, GLint v1, GLint v2);
	GLAPI void APIENTRY glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
	GLAPI void APIENTRY glUniform1fv(GLint location, GLsizei count, const GLfloat* value);
	GLAPI void APIENTRY glUniform2fv(GLint location, GLsizei count, const GLfloat* value);
	GLAPI void APIENTRY glUniform3fv(GLint location, GLsizei count, const GLfloat* value);
	GLAPI void APIENTRY glUniform4fv(GLint location, GLsizei count, const GLfloat* value);
	GLAPI void APIENTRY glUniform1iv(GLint location, GLsizei count, const GLint* value);
	GLAPI void APIENTRY glUniform2iv(GLint location, GLsizei count, const GLint* value);
	GLAPI void APIENTRY glUniform3iv(GLint location, GLsizei count, const GLint* value);
	GLAPI void APIENTRY glUniform4iv(GLint location, GLsizei count, const GLint* value);
	GLAPI void APIENTRY glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	GLAPI void APIENTRY glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	GLAPI void APIENTRY glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	GLAPI void APIENTRY glValidateProgram(GLuint program);
	GLAPI void APIENTRY glVertexAttrib1d(GLuint index, GLdouble x);
	GLAPI void APIENTRY glVertexAttrib1dv(GLuint index, const GLdouble* v);
	GLAPI void APIENTRY glVertexAttrib1f(GLuint index, GLfloat x);
	GLAPI void APIENTRY glVertexAttrib1fv(GLuint index, const GLfloat* v);
	GLAPI void APIENTRY glVertexAttrib1s(GLuint index, GLshort x);
	GLAPI void APIENTRY glVertexAttrib1sv(GLuint index, const GLshort* v);
	GLAPI void APIENTRY glVertexAttrib2d(GLuint index, GLdouble x, GLdouble y);
	GLAPI void APIENTRY glVertexAttrib2dv(GLuint index, const GLdouble* v);
	GLAPI void APIENTRY glVertexAttrib2f(GLuint index, GLfloat x, GLfloat y);
	GLAPI void APIENTRY glVertexAttrib2fv(GLuint index, const GLfloat* v);
	GLAPI void APIENTRY glVertexAttrib2s(GLuint index, GLshort x, GLshort y);
	GLAPI void APIENTRY glVertexAttrib2sv(GLuint index, const GLshort* v);
	GLAPI void APIENTRY glVertexAttrib3d(GLuint index, GLdouble x, GLdouble y, GLdouble z);
	GLAPI void APIENTRY glVertexAttrib3dv(GLuint index, const GLdouble* v);
	GLAPI void APIENTRY glVertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z);
	GLAPI void APIENTRY glVertexAttrib3fv(GLuint index, const GLfloat* v);
	GLAPI void APIENTRY glVertexAttrib3s(GLuint index, GLshort x, GLshort y, GLshort z);
	GLAPI void APIENTRY glVertexAttrib3sv(GLuint index, const GLshort* v);
	GLAPI void APIENTRY glVertexAttrib4Nbv(GLuint index, const GLbyte* v);
	GLAPI void APIENTRY glVertexAttrib4Niv(GLuint index, const GLint* v);
	GLAPI void APIENTRY glVertexAttrib4Nsv(GLuint index, const GLshort* v);
	GLAPI void APIENTRY glVertexAttrib4Nub(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
	GLAPI void APIENTRY glVertexAttrib4Nubv(GLuint index, const GLubyte* v);
	GLAPI void APIENTRY glVertexAttrib4Nuiv(GLuint index, const GLuint* v);
	GLAPI void APIENTRY glVertexAttrib4Nusv(GLuint index, const GLushort* v);
	GLAPI void APIENTRY glVertexAttrib4bv(GLuint index, const GLbyte* v);
	GLAPI void APIENTRY glVertexAttrib4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
	GLAPI void APIENTRY glVertexAttrib4dv(GLuint index, const GLdouble* v);
	GLAPI void APIENTRY glVertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
	GLAPI void APIENTRY glVertexAttrib4fv(GLuint index, const GLfloat* v);
	GLAPI void APIENTRY glVertexAttrib4iv(GLuint index, const GLint* v);
	GLAPI void APIENTRY glVertexAttrib4s(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
	GLAPI void APIENTRY glVertexAttrib4sv(GLuint index, const GLshort* v);
	GLAPI void APIENTRY glVertexAttrib4ubv(GLuint index, const GLubyte* v);
	GLAPI void APIENTRY glVertexAttrib4uiv(GLuint index, const GLuint* v);
	GLAPI void APIENTRY glVertexAttrib4usv(GLuint index, const GLushort* v);
	GLAPI void APIENTRY glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void* pointer);
#endif
#endif /* GL_VERSION_2_0 */

#ifndef GL_VERSION_2_1
#define GL_VERSION_2_1 1
#define GL_PIXEL_PACK_BUFFER              0x88EB
#define GL_PIXEL_UNPACK_BUFFER            0x88EC
#define GL_PIXEL_PACK_BUFFER_BINDING      0x88ED
#define GL_PIXEL_UNPACK_BUFFER_BINDING    0x88EF
#define GL_FLOAT_MAT2x3                   0x8B65
#define GL_FLOAT_MAT2x4                   0x8B66
#define GL_FLOAT_MAT3x2                   0x8B67
#define GL_FLOAT_MAT3x4                   0x8B68
#define GL_FLOAT_MAT4x2                   0x8B69
#define GL_FLOAT_MAT4x3                   0x8B6A
#define GL_SRGB                           0x8C40
#define GL_SRGB8                          0x8C41
#define GL_SRGB_ALPHA                     0x8C42
#define GL_SRGB8_ALPHA8                   0x8C43
#define GL_COMPRESSED_SRGB                0x8C48
#define GL_COMPRESSED_SRGB_ALPHA          0x8C49
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX2X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX3X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX2X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX4X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX3X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX4X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	GLAPI void APIENTRY glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	GLAPI void APIENTRY glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	GLAPI void APIENTRY glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	GLAPI void APIENTRY glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	GLAPI void APIENTRY glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
#endif
#endif /* GL_VERSION_2_1 */

#ifndef GL_VERSION_3_0
#define GL_VERSION_3_0 1
	typedef khronos_uint16_t GLhalf;
#define GL_COMPARE_REF_TO_TEXTURE         0x884E
#define GL_CLIP_DISTANCE0                 0x3000
#define GL_CLIP_DISTANCE1                 0x3001
#define GL_CLIP_DISTANCE2                 0x3002
#define GL_CLIP_DISTANCE3                 0x3003
#define GL_CLIP_DISTANCE4                 0x3004
#define GL_CLIP_DISTANCE5                 0x3005
#define GL_CLIP_DISTANCE6                 0x3006
#define GL_CLIP_DISTANCE7                 0x3007
#define GL_MAX_CLIP_DISTANCES             0x0D32
#define GL_MAJOR_VERSION                  0x821B
#define GL_MINOR_VERSION                  0x821C
#define GL_NUM_EXTENSIONS                 0x821D
#define GL_CONTEXT_FLAGS                  0x821E
#define GL_COMPRESSED_RED                 0x8225
#define GL_COMPRESSED_RG                  0x8226
#define GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT 0x00000001
#define GL_RGBA32F                        0x8814
#define GL_RGB32F                         0x8815
#define GL_RGBA16F                        0x881A
#define GL_RGB16F                         0x881B
#define GL_VERTEX_ATTRIB_ARRAY_INTEGER    0x88FD
#define GL_MAX_ARRAY_TEXTURE_LAYERS       0x88FF
#define GL_MIN_PROGRAM_TEXEL_OFFSET       0x8904
#define GL_MAX_PROGRAM_TEXEL_OFFSET       0x8905
#define GL_CLAMP_READ_COLOR               0x891C
#define GL_FIXED_ONLY                     0x891D
#define GL_MAX_VARYING_COMPONENTS         0x8B4B
#define GL_TEXTURE_1D_ARRAY               0x8C18
#define GL_PROXY_TEXTURE_1D_ARRAY         0x8C19
#define GL_TEXTURE_2D_ARRAY               0x8C1A
#define GL_PROXY_TEXTURE_2D_ARRAY         0x8C1B
#define GL_TEXTURE_BINDING_1D_ARRAY       0x8C1C
#define GL_TEXTURE_BINDING_2D_ARRAY       0x8C1D
#define GL_R11F_G11F_B10F                 0x8C3A
#define GL_UNSIGNED_INT_10F_11F_11F_REV   0x8C3B
#define GL_RGB9_E5                        0x8C3D
#define GL_UNSIGNED_INT_5_9_9_9_REV       0x8C3E
#define GL_TEXTURE_SHARED_SIZE            0x8C3F
#define GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH 0x8C76
#define GL_TRANSFORM_FEEDBACK_BUFFER_MODE 0x8C7F
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS 0x8C80
#define GL_TRANSFORM_FEEDBACK_VARYINGS    0x8C83
#define GL_TRANSFORM_FEEDBACK_BUFFER_START 0x8C84
#define GL_TRANSFORM_FEEDBACK_BUFFER_SIZE 0x8C85
#define GL_PRIMITIVES_GENERATED           0x8C87
#define GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN 0x8C88
#define GL_RASTERIZER_DISCARD             0x8C89
#define GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS 0x8C8A
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS 0x8C8B
#define GL_INTERLEAVED_ATTRIBS            0x8C8C
#define GL_SEPARATE_ATTRIBS               0x8C8D
#define GL_TRANSFORM_FEEDBACK_BUFFER      0x8C8E
#define GL_TRANSFORM_FEEDBACK_BUFFER_BINDING 0x8C8F
#define GL_RGBA32UI                       0x8D70
#define GL_RGB32UI                        0x8D71
#define GL_RGBA16UI                       0x8D76
#define GL_RGB16UI                        0x8D77
#define GL_RGBA8UI                        0x8D7C
#define GL_RGB8UI                         0x8D7D
#define GL_RGBA32I                        0x8D82
#define GL_RGB32I                         0x8D83
#define GL_RGBA16I                        0x8D88
#define GL_RGB16I                         0x8D89
#define GL_RGBA8I                         0x8D8E
#define GL_RGB8I                          0x8D8F
#define GL_RED_INTEGER                    0x8D94
#define GL_GREEN_INTEGER                  0x8D95
#define GL_BLUE_INTEGER                   0x8D96
#define GL_RGB_INTEGER                    0x8D98
#define GL_RGBA_INTEGER                   0x8D99
#define GL_BGR_INTEGER                    0x8D9A
#define GL_BGRA_INTEGER                   0x8D9B
#define GL_SAMPLER_1D_ARRAY               0x8DC0
#define GL_SAMPLER_2D_ARRAY               0x8DC1
#define GL_SAMPLER_1D_ARRAY_SHADOW        0x8DC3
#define GL_SAMPLER_2D_ARRAY_SHADOW        0x8DC4
#define GL_SAMPLER_CUBE_SHADOW            0x8DC5
#define GL_UNSIGNED_INT_VEC2              0x8DC6
#define GL_UNSIGNED_INT_VEC3              0x8DC7
#define GL_UNSIGNED_INT_VEC4              0x8DC8
#define GL_INT_SAMPLER_1D                 0x8DC9
#define GL_INT_SAMPLER_2D                 0x8DCA
#define GL_INT_SAMPLER_3D                 0x8DCB
#define GL_INT_SAMPLER_CUBE               0x8DCC
#define GL_INT_SAMPLER_1D_ARRAY           0x8DCE
#define GL_INT_SAMPLER_2D_ARRAY           0x8DCF
#define GL_UNSIGNED_INT_SAMPLER_1D        0x8DD1
#define GL_UNSIGNED_INT_SAMPLER_2D        0x8DD2
#define GL_UNSIGNED_INT_SAMPLER_3D        0x8DD3
#define GL_UNSIGNED_INT_SAMPLER_CUBE      0x8DD4
#define GL_UNSIGNED_INT_SAMPLER_1D_ARRAY  0x8DD6
#define GL_UNSIGNED_INT_SAMPLER_2D_ARRAY  0x8DD7
#define GL_QUERY_WAIT                     0x8E13
#define GL_QUERY_NO_WAIT                  0x8E14
#define GL_QUERY_BY_REGION_WAIT           0x8E15
#define GL_QUERY_BY_REGION_NO_WAIT        0x8E16
#define GL_BUFFER_ACCESS_FLAGS            0x911F
#define GL_BUFFER_MAP_LENGTH              0x9120
#define GL_BUFFER_MAP_OFFSET              0x9121
#define GL_DEPTH_COMPONENT32F             0x8CAC
#define GL_DEPTH32F_STENCIL8              0x8CAD
#define GL_FLOAT_32_UNSIGNED_INT_24_8_REV 0x8DAD
#define GL_INVALID_FRAMEBUFFER_OPERATION  0x0506
#define GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING 0x8210
#define GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE 0x8211
#define GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE 0x8212
#define GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE 0x8213
#define GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE 0x8214
#define GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE 0x8215
#define GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE 0x8216
#define GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE 0x8217
#define GL_FRAMEBUFFER_DEFAULT            0x8218
#define GL_FRAMEBUFFER_UNDEFINED          0x8219
#define GL_DEPTH_STENCIL_ATTACHMENT       0x821A
#define GL_MAX_RENDERBUFFER_SIZE          0x84E8
#define GL_DEPTH_STENCIL                  0x84F9
#define GL_UNSIGNED_INT_24_8              0x84FA
#define GL_DEPTH24_STENCIL8               0x88F0
#define GL_TEXTURE_STENCIL_SIZE           0x88F1
#define GL_TEXTURE_RED_TYPE               0x8C10
#define GL_TEXTURE_GREEN_TYPE             0x8C11
#define GL_TEXTURE_BLUE_TYPE              0x8C12
#define GL_TEXTURE_ALPHA_TYPE             0x8C13
#define GL_TEXTURE_DEPTH_TYPE             0x8C16
#define GL_UNSIGNED_NORMALIZED            0x8C17
#define GL_FRAMEBUFFER_BINDING            0x8CA6
#define GL_DRAW_FRAMEBUFFER_BINDING       0x8CA6
#define GL_RENDERBUFFER_BINDING           0x8CA7
#define GL_READ_FRAMEBUFFER               0x8CA8
#define GL_DRAW_FRAMEBUFFER               0x8CA9
#define GL_READ_FRAMEBUFFER_BINDING       0x8CAA
#define GL_RENDERBUFFER_SAMPLES           0x8CAB
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE 0x8CD0
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME 0x8CD1
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL 0x8CD2
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE 0x8CD3
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER 0x8CD4
#define GL_FRAMEBUFFER_COMPLETE           0x8CD5
#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT 0x8CD6
#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT 0x8CD7
#define GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER 0x8CDB
#define GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER 0x8CDC
#define GL_FRAMEBUFFER_UNSUPPORTED        0x8CDD
#define GL_MAX_COLOR_ATTACHMENTS          0x8CDF
#define GL_COLOR_ATTACHMENT0              0x8CE0
#define GL_COLOR_ATTACHMENT1              0x8CE1
#define GL_COLOR_ATTACHMENT2              0x8CE2
#define GL_COLOR_ATTACHMENT3              0x8CE3
#define GL_COLOR_ATTACHMENT4              0x8CE4
#define GL_COLOR_ATTACHMENT5              0x8CE5
#define GL_COLOR_ATTACHMENT6              0x8CE6
#define GL_COLOR_ATTACHMENT7              0x8CE7
#define GL_COLOR_ATTACHMENT8              0x8CE8
#define GL_COLOR_ATTACHMENT9              0x8CE9
#define GL_COLOR_ATTACHMENT10             0x8CEA
#define GL_COLOR_ATTACHMENT11             0x8CEB
#define GL_COLOR_ATTACHMENT12             0x8CEC
#define GL_COLOR_ATTACHMENT13             0x8CED
#define GL_COLOR_ATTACHMENT14             0x8CEE
#define GL_COLOR_ATTACHMENT15             0x8CEF
#define GL_COLOR_ATTACHMENT16             0x8CF0
#define GL_COLOR_ATTACHMENT17             0x8CF1
#define GL_COLOR_ATTACHMENT18             0x8CF2
#define GL_COLOR_ATTACHMENT19             0x8CF3
#define GL_COLOR_ATTACHMENT20             0x8CF4
#define GL_COLOR_ATTACHMENT21             0x8CF5
#define GL_COLOR_ATTACHMENT22             0x8CF6
#define GL_COLOR_ATTACHMENT23             0x8CF7
#define GL_COLOR_ATTACHMENT24             0x8CF8
#define GL_COLOR_ATTACHMENT25             0x8CF9
#define GL_COLOR_ATTACHMENT26             0x8CFA
#define GL_COLOR_ATTACHMENT27             0x8CFB
#define GL_COLOR_ATTACHMENT28             0x8CFC
#define GL_COLOR_ATTACHMENT29             0x8CFD
#define GL_COLOR_ATTACHMENT30             0x8CFE
#define GL_COLOR_ATTACHMENT31             0x8CFF
#define GL_DEPTH_ATTACHMENT               0x8D00
#define GL_STENCIL_ATTACHMENT             0x8D20
#define GL_FRAMEBUFFER                    0x8D40
#define GL_RENDERBUFFER                   0x8D41
#define GL_RENDERBUFFER_WIDTH             0x8D42
#define GL_RENDERBUFFER_HEIGHT            0x8D43
#define GL_RENDERBUFFER_INTERNAL_FORMAT   0x8D44
#define GL_STENCIL_INDEX1                 0x8D46
#define GL_STENCIL_INDEX4                 0x8D47
#define GL_STENCIL_INDEX8                 0x8D48
#define GL_STENCIL_INDEX16                0x8D49
#define GL_RENDERBUFFER_RED_SIZE          0x8D50
#define GL_RENDERBUFFER_GREEN_SIZE        0x8D51
#define GL_RENDERBUFFER_BLUE_SIZE         0x8D52
#define GL_RENDERBUFFER_ALPHA_SIZE        0x8D53
#define GL_RENDERBUFFER_DEPTH_SIZE        0x8D54
#define GL_RENDERBUFFER_STENCIL_SIZE      0x8D55
#define GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE 0x8D56
#define GL_MAX_SAMPLES                    0x8D57
#define GL_FRAMEBUFFER_SRGB               0x8DB9
#define GL_HALF_FLOAT                     0x140B
#define GL_MAP_READ_BIT                   0x0001
#define GL_MAP_WRITE_BIT                  0x0002
#define GL_MAP_INVALIDATE_RANGE_BIT       0x0004
#define GL_MAP_INVALIDATE_BUFFER_BIT      0x0008
#define GL_MAP_FLUSH_EXPLICIT_BIT         0x0010
#define GL_MAP_UNSYNCHRONIZED_BIT         0x0020
#define GL_COMPRESSED_RED_RGTC1           0x8DBB
#define GL_COMPRESSED_SIGNED_RED_RGTC1    0x8DBC
#define GL_COMPRESSED_RG_RGTC2            0x8DBD
#define GL_COMPRESSED_SIGNED_RG_RGTC2     0x8DBE
#define GL_RG                             0x8227
#define GL_RG_INTEGER                     0x8228
#define GL_R8                             0x8229
#define GL_R16                            0x822A
#define GL_RG8                            0x822B
#define GL_RG16                           0x822C
#define GL_R16F                           0x822D
#define GL_R32F                           0x822E
#define GL_RG16F                          0x822F
#define GL_RG32F                          0x8230
#define GL_R8I                            0x8231
#define GL_R8UI                           0x8232
#define GL_R16I                           0x8233
#define GL_R16UI                          0x8234
#define GL_R32I                           0x8235
#define GL_R32UI                          0x8236
#define GL_RG8I                           0x8237
#define GL_RG8UI                          0x8238
#define GL_RG16I                          0x8239
#define GL_RG16UI                         0x823A
#define GL_RG32I                          0x823B
#define GL_RG32UI                         0x823C
#define GL_VERTEX_ARRAY_BINDING           0x85B5
	typedef void (APIENTRYP PFNGLCOLORMASKIPROC) (GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
	typedef void (APIENTRYP PFNGLGETBOOLEANI_VPROC) (GLenum target, GLuint index, GLboolean* data);
	typedef void (APIENTRYP PFNGLGETINTEGERI_VPROC) (GLenum target, GLuint index, GLint* data);
	typedef void (APIENTRYP PFNGLENABLEIPROC) (GLenum target, GLuint index);
	typedef void (APIENTRYP PFNGLDISABLEIPROC) (GLenum target, GLuint index);
	typedef GLboolean(APIENTRYP PFNGLISENABLEDIPROC) (GLenum target, GLuint index);
	typedef void (APIENTRYP PFNGLBEGINTRANSFORMFEEDBACKPROC) (GLenum primitiveMode);
	typedef void (APIENTRYP PFNGLENDTRANSFORMFEEDBACKPROC) (void);
	typedef void (APIENTRYP PFNGLBINDBUFFERRANGEPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
	typedef void (APIENTRYP PFNGLBINDBUFFERBASEPROC) (GLenum target, GLuint index, GLuint buffer);
	typedef void (APIENTRYP PFNGLTRANSFORMFEEDBACKVARYINGSPROC) (GLuint program, GLsizei count, const GLchar* const* varyings, GLenum bufferMode);
	typedef void (APIENTRYP PFNGLGETTRANSFORMFEEDBACKVARYINGPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei* size, GLenum* type, GLchar* name);
	typedef void (APIENTRYP PFNGLCLAMPCOLORPROC) (GLenum target, GLenum clamp);
	typedef void (APIENTRYP PFNGLBEGINCONDITIONALRENDERPROC) (GLuint id, GLenum mode);
	typedef void (APIENTRYP PFNGLENDCONDITIONALRENDERPROC) (void);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBIPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void* pointer);
	typedef void (APIENTRYP PFNGLGETVERTEXATTRIBIIVPROC) (GLuint index, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLGETVERTEXATTRIBIUIVPROC) (GLuint index, GLenum pname, GLuint* params);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI1IPROC) (GLuint index, GLint x);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI2IPROC) (GLuint index, GLint x, GLint y);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI3IPROC) (GLuint index, GLint x, GLint y, GLint z);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI4IPROC) (GLuint index, GLint x, GLint y, GLint z, GLint w);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI1UIPROC) (GLuint index, GLuint x);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI2UIPROC) (GLuint index, GLuint x, GLuint y);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI3UIPROC) (GLuint index, GLuint x, GLuint y, GLuint z);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI4UIPROC) (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI1IVPROC) (GLuint index, const GLint* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI2IVPROC) (GLuint index, const GLint* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI3IVPROC) (GLuint index, const GLint* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI4IVPROC) (GLuint index, const GLint* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI1UIVPROC) (GLuint index, const GLuint* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI2UIVPROC) (GLuint index, const GLuint* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI3UIVPROC) (GLuint index, const GLuint* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI4UIVPROC) (GLuint index, const GLuint* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI4BVPROC) (GLuint index, const GLbyte* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI4SVPROC) (GLuint index, const GLshort* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI4UBVPROC) (GLuint index, const GLubyte* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBI4USVPROC) (GLuint index, const GLushort* v);
	typedef void (APIENTRYP PFNGLGETUNIFORMUIVPROC) (GLuint program, GLint location, GLuint* params);
	typedef void (APIENTRYP PFNGLBINDFRAGDATALOCATIONPROC) (GLuint program, GLuint color, const GLchar* name);
	typedef GLint(APIENTRYP PFNGLGETFRAGDATALOCATIONPROC) (GLuint program, const GLchar* name);
	typedef void (APIENTRYP PFNGLUNIFORM1UIPROC) (GLint location, GLuint v0);
	typedef void (APIENTRYP PFNGLUNIFORM2UIPROC) (GLint location, GLuint v0, GLuint v1);
	typedef void (APIENTRYP PFNGLUNIFORM3UIPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2);
	typedef void (APIENTRYP PFNGLUNIFORM4UIPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
	typedef void (APIENTRYP PFNGLUNIFORM1UIVPROC) (GLint location, GLsizei count, const GLuint* value);
	typedef void (APIENTRYP PFNGLUNIFORM2UIVPROC) (GLint location, GLsizei count, const GLuint* value);
	typedef void (APIENTRYP PFNGLUNIFORM3UIVPROC) (GLint location, GLsizei count, const GLuint* value);
	typedef void (APIENTRYP PFNGLUNIFORM4UIVPROC) (GLint location, GLsizei count, const GLuint* value);
	typedef void (APIENTRYP PFNGLTEXPARAMETERIIVPROC) (GLenum target, GLenum pname, const GLint* params);
	typedef void (APIENTRYP PFNGLTEXPARAMETERIUIVPROC) (GLenum target, GLenum pname, const GLuint* params);
	typedef void (APIENTRYP PFNGLGETTEXPARAMETERIIVPROC) (GLenum target, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLGETTEXPARAMETERIUIVPROC) (GLenum target, GLenum pname, GLuint* params);
	typedef void (APIENTRYP PFNGLCLEARBUFFERIVPROC) (GLenum buffer, GLint drawbuffer, const GLint* value);
	typedef void (APIENTRYP PFNGLCLEARBUFFERUIVPROC) (GLenum buffer, GLint drawbuffer, const GLuint* value);
	typedef void (APIENTRYP PFNGLCLEARBUFFERFVPROC) (GLenum buffer, GLint drawbuffer, const GLfloat* value);
	typedef void (APIENTRYP PFNGLCLEARBUFFERFIPROC) (GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
	typedef const GLubyte* (APIENTRYP PFNGLGETSTRINGIPROC) (GLenum name, GLuint index);
	typedef GLboolean(APIENTRYP PFNGLISRENDERBUFFERPROC) (GLuint renderbuffer);
	typedef void (APIENTRYP PFNGLBINDRENDERBUFFERPROC) (GLenum target, GLuint renderbuffer);
	typedef void (APIENTRYP PFNGLDELETERENDERBUFFERSPROC) (GLsizei n, const GLuint* renderbuffers);
	typedef void (APIENTRYP PFNGLGENRENDERBUFFERSPROC) (GLsizei n, GLuint* renderbuffers);
	typedef void (APIENTRYP PFNGLRENDERBUFFERSTORAGEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLGETRENDERBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
	typedef GLboolean(APIENTRYP PFNGLISFRAMEBUFFERPROC) (GLuint framebuffer);
	typedef void (APIENTRYP PFNGLBINDFRAMEBUFFERPROC) (GLenum target, GLuint framebuffer);
	typedef void (APIENTRYP PFNGLDELETEFRAMEBUFFERSPROC) (GLsizei n, const GLuint* framebuffers);
	typedef void (APIENTRYP PFNGLGENFRAMEBUFFERSPROC) (GLsizei n, GLuint* framebuffers);
	typedef GLenum(APIENTRYP PFNGLCHECKFRAMEBUFFERSTATUSPROC) (GLenum target);
	typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTURE1DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
	typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTURE2DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
	typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTURE3DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
	typedef void (APIENTRYP PFNGLFRAMEBUFFERRENDERBUFFERPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
	typedef void (APIENTRYP PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC) (GLenum target, GLenum attachment, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLGENERATEMIPMAPPROC) (GLenum target);
	typedef void (APIENTRYP PFNGLBLITFRAMEBUFFERPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
	typedef void (APIENTRYP PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTURELAYERPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
	typedef void* (APIENTRYP PFNGLMAPBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
	typedef void (APIENTRYP PFNGLFLUSHMAPPEDBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length);
	typedef void (APIENTRYP PFNGLBINDVERTEXARRAYPROC) (GLuint array);
	typedef void (APIENTRYP PFNGLDELETEVERTEXARRAYSPROC) (GLsizei n, const GLuint* arrays);
	typedef void (APIENTRYP PFNGLGENVERTEXARRAYSPROC) (GLsizei n, GLuint* arrays);
	typedef GLboolean(APIENTRYP PFNGLISVERTEXARRAYPROC) (GLuint array);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glColorMaski(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
	GLAPI void APIENTRY glGetBooleani_v(GLenum target, GLuint index, GLboolean* data);
	GLAPI void APIENTRY glGetIntegeri_v(GLenum target, GLuint index, GLint* data);
	GLAPI void APIENTRY glEnablei(GLenum target, GLuint index);
	GLAPI void APIENTRY glDisablei(GLenum target, GLuint index);
	GLAPI GLboolean APIENTRY glIsEnabledi(GLenum target, GLuint index);
	GLAPI void APIENTRY glBeginTransformFeedback(GLenum primitiveMode);
	GLAPI void APIENTRY glEndTransformFeedback(void);
	GLAPI void APIENTRY glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
	GLAPI void APIENTRY glBindBufferBase(GLenum target, GLuint index, GLuint buffer);
	GLAPI void APIENTRY glTransformFeedbackVaryings(GLuint program, GLsizei count, const GLchar* const* varyings, GLenum bufferMode);
	GLAPI void APIENTRY glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei* size, GLenum* type, GLchar* name);
	GLAPI void APIENTRY glClampColor(GLenum target, GLenum clamp);
	GLAPI void APIENTRY glBeginConditionalRender(GLuint id, GLenum mode);
	GLAPI void APIENTRY glEndConditionalRender(void);
	GLAPI void APIENTRY glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void* pointer);
	GLAPI void APIENTRY glGetVertexAttribIiv(GLuint index, GLenum pname, GLint* params);
	GLAPI void APIENTRY glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint* params);
	GLAPI void APIENTRY glVertexAttribI1i(GLuint index, GLint x);
	GLAPI void APIENTRY glVertexAttribI2i(GLuint index, GLint x, GLint y);
	GLAPI void APIENTRY glVertexAttribI3i(GLuint index, GLint x, GLint y, GLint z);
	GLAPI void APIENTRY glVertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w);
	GLAPI void APIENTRY glVertexAttribI1ui(GLuint index, GLuint x);
	GLAPI void APIENTRY glVertexAttribI2ui(GLuint index, GLuint x, GLuint y);
	GLAPI void APIENTRY glVertexAttribI3ui(GLuint index, GLuint x, GLuint y, GLuint z);
	GLAPI void APIENTRY glVertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
	GLAPI void APIENTRY glVertexAttribI1iv(GLuint index, const GLint* v);
	GLAPI void APIENTRY glVertexAttribI2iv(GLuint index, const GLint* v);
	GLAPI void APIENTRY glVertexAttribI3iv(GLuint index, const GLint* v);
	GLAPI void APIENTRY glVertexAttribI4iv(GLuint index, const GLint* v);
	GLAPI void APIENTRY glVertexAttribI1uiv(GLuint index, const GLuint* v);
	GLAPI void APIENTRY glVertexAttribI2uiv(GLuint index, const GLuint* v);
	GLAPI void APIENTRY glVertexAttribI3uiv(GLuint index, const GLuint* v);
	GLAPI void APIENTRY glVertexAttribI4uiv(GLuint index, const GLuint* v);
	GLAPI void APIENTRY glVertexAttribI4bv(GLuint index, const GLbyte* v);
	GLAPI void APIENTRY glVertexAttribI4sv(GLuint index, const GLshort* v);
	GLAPI void APIENTRY glVertexAttribI4ubv(GLuint index, const GLubyte* v);
	GLAPI void APIENTRY glVertexAttribI4usv(GLuint index, const GLushort* v);
	GLAPI void APIENTRY glGetUniformuiv(GLuint program, GLint location, GLuint* params);
	GLAPI void APIENTRY glBindFragDataLocation(GLuint program, GLuint color, const GLchar* name);
	GLAPI GLint APIENTRY glGetFragDataLocation(GLuint program, const GLchar* name);
	GLAPI void APIENTRY glUniform1ui(GLint location, GLuint v0);
	GLAPI void APIENTRY glUniform2ui(GLint location, GLuint v0, GLuint v1);
	GLAPI void APIENTRY glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2);
	GLAPI void APIENTRY glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
	GLAPI void APIENTRY glUniform1uiv(GLint location, GLsizei count, const GLuint* value);
	GLAPI void APIENTRY glUniform2uiv(GLint location, GLsizei count, const GLuint* value);
	GLAPI void APIENTRY glUniform3uiv(GLint location, GLsizei count, const GLuint* value);
	GLAPI void APIENTRY glUniform4uiv(GLint location, GLsizei count, const GLuint* value);
	GLAPI void APIENTRY glTexParameterIiv(GLenum target, GLenum pname, const GLint* params);
	GLAPI void APIENTRY glTexParameterIuiv(GLenum target, GLenum pname, const GLuint* params);
	GLAPI void APIENTRY glGetTexParameterIiv(GLenum target, GLenum pname, GLint* params);
	GLAPI void APIENTRY glGetTexParameterIuiv(GLenum target, GLenum pname, GLuint* params);
	GLAPI void APIENTRY glClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint* value);
	GLAPI void APIENTRY glClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint* value);
	GLAPI void APIENTRY glClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat* value);
	GLAPI void APIENTRY glClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
	GLAPI const GLubyte* APIENTRY glGetStringi(GLenum name, GLuint index);
	GLAPI GLboolean APIENTRY glIsRenderbuffer(GLuint renderbuffer);
	GLAPI void APIENTRY glBindRenderbuffer(GLenum target, GLuint renderbuffer);
	GLAPI void APIENTRY glDeleteRenderbuffers(GLsizei n, const GLuint* renderbuffers);
	GLAPI void APIENTRY glGenRenderbuffers(GLsizei n, GLuint* renderbuffers);
	GLAPI void APIENTRY glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint* params);
	GLAPI GLboolean APIENTRY glIsFramebuffer(GLuint framebuffer);
	GLAPI void APIENTRY glBindFramebuffer(GLenum target, GLuint framebuffer);
	GLAPI void APIENTRY glDeleteFramebuffers(GLsizei n, const GLuint* framebuffers);
	GLAPI void APIENTRY glGenFramebuffers(GLsizei n, GLuint* framebuffers);
	GLAPI GLenum APIENTRY glCheckFramebufferStatus(GLenum target);
	GLAPI void APIENTRY glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
	GLAPI void APIENTRY glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
	GLAPI void APIENTRY glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
	GLAPI void APIENTRY glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
	GLAPI void APIENTRY glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint* params);
	GLAPI void APIENTRY glGenerateMipmap(GLenum target);
	GLAPI void APIENTRY glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
	GLAPI void APIENTRY glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
	GLAPI void* APIENTRY glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
	GLAPI void APIENTRY glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length);
	GLAPI void APIENTRY glBindVertexArray(GLuint array);
	GLAPI void APIENTRY glDeleteVertexArrays(GLsizei n, const GLuint* arrays);
	GLAPI void APIENTRY glGenVertexArrays(GLsizei n, GLuint* arrays);
	GLAPI GLboolean APIENTRY glIsVertexArray(GLuint array);
#endif
#endif /* GL_VERSION_3_0 */

#ifndef GL_VERSION_3_1
#define GL_VERSION_3_1 1
#define GL_SAMPLER_2D_RECT                0x8B63
#define GL_SAMPLER_2D_RECT_SHADOW         0x8B64
#define GL_SAMPLER_BUFFER                 0x8DC2
#define GL_INT_SAMPLER_2D_RECT            0x8DCD
#define GL_INT_SAMPLER_BUFFER             0x8DD0
#define GL_UNSIGNED_INT_SAMPLER_2D_RECT   0x8DD5
#define GL_UNSIGNED_INT_SAMPLER_BUFFER    0x8DD8
#define GL_TEXTURE_BUFFER                 0x8C2A
#define GL_MAX_TEXTURE_BUFFER_SIZE        0x8C2B
#define GL_TEXTURE_BINDING_BUFFER         0x8C2C
#define GL_TEXTURE_BUFFER_DATA_STORE_BINDING 0x8C2D
#define GL_TEXTURE_RECTANGLE              0x84F5
#define GL_TEXTURE_BINDING_RECTANGLE      0x84F6
#define GL_PROXY_TEXTURE_RECTANGLE        0x84F7
#define GL_MAX_RECTANGLE_TEXTURE_SIZE     0x84F8
#define GL_R8_SNORM                       0x8F94
#define GL_RG8_SNORM                      0x8F95
#define GL_RGB8_SNORM                     0x8F96
#define GL_RGBA8_SNORM                    0x8F97
#define GL_R16_SNORM                      0x8F98
#define GL_RG16_SNORM                     0x8F99
#define GL_RGB16_SNORM                    0x8F9A
#define GL_RGBA16_SNORM                   0x8F9B
#define GL_SIGNED_NORMALIZED              0x8F9C
#define GL_PRIMITIVE_RESTART              0x8F9D
#define GL_PRIMITIVE_RESTART_INDEX        0x8F9E
#define GL_COPY_READ_BUFFER               0x8F36
#define GL_COPY_WRITE_BUFFER              0x8F37
#define GL_UNIFORM_BUFFER                 0x8A11
#define GL_UNIFORM_BUFFER_BINDING         0x8A28
#define GL_UNIFORM_BUFFER_START           0x8A29
#define GL_UNIFORM_BUFFER_SIZE            0x8A2A
#define GL_MAX_VERTEX_UNIFORM_BLOCKS      0x8A2B
#define GL_MAX_GEOMETRY_UNIFORM_BLOCKS    0x8A2C
#define GL_MAX_FRAGMENT_UNIFORM_BLOCKS    0x8A2D
#define GL_MAX_COMBINED_UNIFORM_BLOCKS    0x8A2E
#define GL_MAX_UNIFORM_BUFFER_BINDINGS    0x8A2F
#define GL_MAX_UNIFORM_BLOCK_SIZE         0x8A30
#define GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS 0x8A31
#define GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS 0x8A32
#define GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS 0x8A33
#define GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT 0x8A34
#define GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH 0x8A35
#define GL_ACTIVE_UNIFORM_BLOCKS          0x8A36
#define GL_UNIFORM_TYPE                   0x8A37
#define GL_UNIFORM_SIZE                   0x8A38
#define GL_UNIFORM_NAME_LENGTH            0x8A39
#define GL_UNIFORM_BLOCK_INDEX            0x8A3A
#define GL_UNIFORM_OFFSET                 0x8A3B
#define GL_UNIFORM_ARRAY_STRIDE           0x8A3C
#define GL_UNIFORM_MATRIX_STRIDE          0x8A3D
#define GL_UNIFORM_IS_ROW_MAJOR           0x8A3E
#define GL_UNIFORM_BLOCK_BINDING          0x8A3F
#define GL_UNIFORM_BLOCK_DATA_SIZE        0x8A40
#define GL_UNIFORM_BLOCK_NAME_LENGTH      0x8A41
#define GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS  0x8A42
#define GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES 0x8A43
#define GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER 0x8A44
#define GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER 0x8A45
#define GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER 0x8A46
#define GL_INVALID_INDEX                  0xFFFFFFFFu
	typedef void (APIENTRYP PFNGLDRAWARRAYSINSTANCEDPROC) (GLenum mode, GLint first, GLsizei count, GLsizei instancecount);
	typedef void (APIENTRYP PFNGLDRAWELEMENTSINSTANCEDPROC) (GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount);
	typedef void (APIENTRYP PFNGLTEXBUFFERPROC) (GLenum target, GLenum internalformat, GLuint buffer);
	typedef void (APIENTRYP PFNGLPRIMITIVERESTARTINDEXPROC) (GLuint index);
	typedef void (APIENTRYP PFNGLCOPYBUFFERSUBDATAPROC) (GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
	typedef void (APIENTRYP PFNGLGETUNIFORMINDICESPROC) (GLuint program, GLsizei uniformCount, const GLchar* const* uniformNames, GLuint* uniformIndices);
	typedef void (APIENTRYP PFNGLGETACTIVEUNIFORMSIVPROC) (GLuint program, GLsizei uniformCount, const GLuint* uniformIndices, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLGETACTIVEUNIFORMNAMEPROC) (GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformName);
	typedef GLuint(APIENTRYP PFNGLGETUNIFORMBLOCKINDEXPROC) (GLuint program, const GLchar* uniformBlockName);
	typedef void (APIENTRYP PFNGLGETACTIVEUNIFORMBLOCKIVPROC) (GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC) (GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformBlockName);
	typedef void (APIENTRYP PFNGLUNIFORMBLOCKBINDINGPROC) (GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instancecount);
	GLAPI void APIENTRY glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount);
	GLAPI void APIENTRY glTexBuffer(GLenum target, GLenum internalformat, GLuint buffer);
	GLAPI void APIENTRY glPrimitiveRestartIndex(GLuint index);
	GLAPI void APIENTRY glCopyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
	GLAPI void APIENTRY glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar* const* uniformNames, GLuint* uniformIndices);
	GLAPI void APIENTRY glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint* uniformIndices, GLenum pname, GLint* params);
	GLAPI void APIENTRY glGetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformName);
	GLAPI GLuint APIENTRY glGetUniformBlockIndex(GLuint program, const GLchar* uniformBlockName);
	GLAPI void APIENTRY glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params);
	GLAPI void APIENTRY glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformBlockName);
	GLAPI void APIENTRY glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
#endif
#endif /* GL_VERSION_3_1 */

#ifndef GL_VERSION_3_2
#define GL_VERSION_3_2 1
	typedef struct __GLsync* GLsync;
	typedef khronos_uint64_t GLuint64;
	typedef khronos_int64_t GLint64;
#define GL_CONTEXT_CORE_PROFILE_BIT       0x00000001
#define GL_CONTEXT_COMPATIBILITY_PROFILE_BIT 0x00000002
#define GL_LINES_ADJACENCY                0x000A
#define GL_LINE_STRIP_ADJACENCY           0x000B
#define GL_TRIANGLES_ADJACENCY            0x000C
#define GL_TRIANGLE_STRIP_ADJACENCY       0x000D
#define GL_PROGRAM_POINT_SIZE             0x8642
#define GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS 0x8C29
#define GL_FRAMEBUFFER_ATTACHMENT_LAYERED 0x8DA7
#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS 0x8DA8
#define GL_GEOMETRY_SHADER                0x8DD9
#define GL_GEOMETRY_VERTICES_OUT          0x8916
#define GL_GEOMETRY_INPUT_TYPE            0x8917
#define GL_GEOMETRY_OUTPUT_TYPE           0x8918
#define GL_MAX_GEOMETRY_UNIFORM_COMPONENTS 0x8DDF
#define GL_MAX_GEOMETRY_OUTPUT_VERTICES   0x8DE0
#define GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS 0x8DE1
#define GL_MAX_VERTEX_OUTPUT_COMPONENTS   0x9122
#define GL_MAX_GEOMETRY_INPUT_COMPONENTS  0x9123
#define GL_MAX_GEOMETRY_OUTPUT_COMPONENTS 0x9124
#define GL_MAX_FRAGMENT_INPUT_COMPONENTS  0x9125
#define GL_CONTEXT_PROFILE_MASK           0x9126
#define GL_DEPTH_CLAMP                    0x864F
#define GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION 0x8E4C
#define GL_FIRST_VERTEX_CONVENTION        0x8E4D
#define GL_LAST_VERTEX_CONVENTION         0x8E4E
#define GL_PROVOKING_VERTEX               0x8E4F
#define GL_TEXTURE_CUBE_MAP_SEAMLESS      0x884F
#define GL_MAX_SERVER_WAIT_TIMEOUT        0x9111
#define GL_OBJECT_TYPE                    0x9112
#define GL_SYNC_CONDITION                 0x9113
#define GL_SYNC_STATUS                    0x9114
#define GL_SYNC_FLAGS                     0x9115
#define GL_SYNC_FENCE                     0x9116
#define GL_SYNC_GPU_COMMANDS_COMPLETE     0x9117
#define GL_UNSIGNALED                     0x9118
#define GL_SIGNALED                       0x9119
#define GL_ALREADY_SIGNALED               0x911A
#define GL_TIMEOUT_EXPIRED                0x911B
#define GL_CONDITION_SATISFIED            0x911C
#define GL_WAIT_FAILED                    0x911D
#define GL_TIMEOUT_IGNORED                0xFFFFFFFFFFFFFFFFull
#define GL_SYNC_FLUSH_COMMANDS_BIT        0x00000001
#define GL_SAMPLE_POSITION                0x8E50
#define GL_SAMPLE_MASK                    0x8E51
#define GL_SAMPLE_MASK_VALUE              0x8E52
#define GL_MAX_SAMPLE_MASK_WORDS          0x8E59
#define GL_TEXTURE_2D_MULTISAMPLE         0x9100
#define GL_PROXY_TEXTURE_2D_MULTISAMPLE   0x9101
#define GL_TEXTURE_2D_MULTISAMPLE_ARRAY   0x9102
#define GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY 0x9103
#define GL_TEXTURE_BINDING_2D_MULTISAMPLE 0x9104
#define GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY 0x9105
#define GL_TEXTURE_SAMPLES                0x9106
#define GL_TEXTURE_FIXED_SAMPLE_LOCATIONS 0x9107
#define GL_SAMPLER_2D_MULTISAMPLE         0x9108
#define GL_INT_SAMPLER_2D_MULTISAMPLE     0x9109
#define GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE 0x910A
#define GL_SAMPLER_2D_MULTISAMPLE_ARRAY   0x910B
#define GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910C
#define GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910D
#define GL_MAX_COLOR_TEXTURE_SAMPLES      0x910E
#define GL_MAX_DEPTH_TEXTURE_SAMPLES      0x910F
#define GL_MAX_INTEGER_SAMPLES            0x9110
	typedef void (APIENTRYP PFNGLDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, const void* indices, GLint basevertex);
	typedef void (APIENTRYP PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void* indices, GLint basevertex);
	typedef void (APIENTRYP PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount, GLint basevertex);
	typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, const GLsizei* count, GLenum type, const void* const* indices, GLsizei drawcount, const GLint* basevertex);
	typedef void (APIENTRYP PFNGLPROVOKINGVERTEXPROC) (GLenum mode);
	typedef GLsync(APIENTRYP PFNGLFENCESYNCPROC) (GLenum condition, GLbitfield flags);
	typedef GLboolean(APIENTRYP PFNGLISSYNCPROC) (GLsync sync);
	typedef void (APIENTRYP PFNGLDELETESYNCPROC) (GLsync sync);
	typedef GLenum(APIENTRYP PFNGLCLIENTWAITSYNCPROC) (GLsync sync, GLbitfield flags, GLuint64 timeout);
	typedef void (APIENTRYP PFNGLWAITSYNCPROC) (GLsync sync, GLbitfield flags, GLuint64 timeout);
	typedef void (APIENTRYP PFNGLGETINTEGER64VPROC) (GLenum pname, GLint64* data);
	typedef void (APIENTRYP PFNGLGETSYNCIVPROC) (GLsync sync, GLenum pname, GLsizei count, GLsizei* length, GLint* values);
	typedef void (APIENTRYP PFNGLGETINTEGER64I_VPROC) (GLenum target, GLuint index, GLint64* data);
	typedef void (APIENTRYP PFNGLGETBUFFERPARAMETERI64VPROC) (GLenum target, GLenum pname, GLint64* params);
	typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTUREPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
	typedef void (APIENTRYP PFNGLTEXIMAGE2DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
	typedef void (APIENTRYP PFNGLTEXIMAGE3DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
	typedef void (APIENTRYP PFNGLGETMULTISAMPLEFVPROC) (GLenum pname, GLuint index, GLfloat* val);
	typedef void (APIENTRYP PFNGLSAMPLEMASKIPROC) (GLuint maskNumber, GLbitfield mask);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, const void* indices, GLint basevertex);
	GLAPI void APIENTRY glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void* indices, GLint basevertex);
	GLAPI void APIENTRY glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount, GLint basevertex);
	GLAPI void APIENTRY glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei* count, GLenum type, const void* const* indices, GLsizei drawcount, const GLint* basevertex);
	GLAPI void APIENTRY glProvokingVertex(GLenum mode);
	GLAPI GLsync APIENTRY glFenceSync(GLenum condition, GLbitfield flags);
	GLAPI GLboolean APIENTRY glIsSync(GLsync sync);
	GLAPI void APIENTRY glDeleteSync(GLsync sync);
	GLAPI GLenum APIENTRY glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);
	GLAPI void APIENTRY glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);
	GLAPI void APIENTRY glGetInteger64v(GLenum pname, GLint64* data);
	GLAPI void APIENTRY glGetSynciv(GLsync sync, GLenum pname, GLsizei count, GLsizei* length, GLint* values);
	GLAPI void APIENTRY glGetInteger64i_v(GLenum target, GLuint index, GLint64* data);
	GLAPI void APIENTRY glGetBufferParameteri64v(GLenum target, GLenum pname, GLint64* params);
	GLAPI void APIENTRY glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level);
	GLAPI void APIENTRY glTexImage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
	GLAPI void APIENTRY glTexImage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
	GLAPI void APIENTRY glGetMultisamplefv(GLenum pname, GLuint index, GLfloat* val);
	GLAPI void APIENTRY glSampleMaski(GLuint maskNumber, GLbitfield mask);
#endif
#endif /* GL_VERSION_3_2 */

#ifndef GL_VERSION_3_3
#define GL_VERSION_3_3 1
#define GL_VERTEX_ATTRIB_ARRAY_DIVISOR    0x88FE
#define GL_SRC1_COLOR                     0x88F9
#define GL_ONE_MINUS_SRC1_COLOR           0x88FA
#define GL_ONE_MINUS_SRC1_ALPHA           0x88FB
#define GL_MAX_DUAL_SOURCE_DRAW_BUFFERS   0x88FC
#define GL_ANY_SAMPLES_PASSED             0x8C2F
#define GL_SAMPLER_BINDING                0x8919
#define GL_RGB10_A2UI                     0x906F
#define GL_TEXTURE_SWIZZLE_R              0x8E42
#define GL_TEXTURE_SWIZZLE_G              0x8E43
#define GL_TEXTURE_SWIZZLE_B              0x8E44
#define GL_TEXTURE_SWIZZLE_A              0x8E45
#define GL_TEXTURE_SWIZZLE_RGBA           0x8E46
#define GL_TIME_ELAPSED                   0x88BF
#define GL_TIMESTAMP                      0x8E28
#define GL_INT_2_10_10_10_REV             0x8D9F
	typedef void (APIENTRYP PFNGLBINDFRAGDATALOCATIONINDEXEDPROC) (GLuint program, GLuint colorNumber, GLuint index, const GLchar* name);
	typedef GLint(APIENTRYP PFNGLGETFRAGDATAINDEXPROC) (GLuint program, const GLchar* name);
	typedef void (APIENTRYP PFNGLGENSAMPLERSPROC) (GLsizei count, GLuint* samplers);
	typedef void (APIENTRYP PFNGLDELETESAMPLERSPROC) (GLsizei count, const GLuint* samplers);
	typedef GLboolean(APIENTRYP PFNGLISSAMPLERPROC) (GLuint sampler);
	typedef void (APIENTRYP PFNGLBINDSAMPLERPROC) (GLuint unit, GLuint sampler);
	typedef void (APIENTRYP PFNGLSAMPLERPARAMETERIPROC) (GLuint sampler, GLenum pname, GLint param);
	typedef void (APIENTRYP PFNGLSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, const GLint* param);
	typedef void (APIENTRYP PFNGLSAMPLERPARAMETERFPROC) (GLuint sampler, GLenum pname, GLfloat param);
	typedef void (APIENTRYP PFNGLSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, const GLfloat* param);
	typedef void (APIENTRYP PFNGLSAMPLERPARAMETERIIVPROC) (GLuint sampler, GLenum pname, const GLint* param);
	typedef void (APIENTRYP PFNGLSAMPLERPARAMETERIUIVPROC) (GLuint sampler, GLenum pname, const GLuint* param);
	typedef void (APIENTRYP PFNGLGETSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLGETSAMPLERPARAMETERIIVPROC) (GLuint sampler, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLGETSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, GLfloat* params);
	typedef void (APIENTRYP PFNGLGETSAMPLERPARAMETERIUIVPROC) (GLuint sampler, GLenum pname, GLuint* params);
	typedef void (APIENTRYP PFNGLQUERYCOUNTERPROC) (GLuint id, GLenum target);
	typedef void (APIENTRYP PFNGLGETQUERYOBJECTI64VPROC) (GLuint id, GLenum pname, GLint64* params);
	typedef void (APIENTRYP PFNGLGETQUERYOBJECTUI64VPROC) (GLuint id, GLenum pname, GLuint64* params);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBDIVISORPROC) (GLuint index, GLuint divisor);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBP1UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBP1UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBP2UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBP2UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBP3UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBP3UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBP4UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBP4UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glBindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const GLchar* name);
	GLAPI GLint APIENTRY glGetFragDataIndex(GLuint program, const GLchar* name);
	GLAPI void APIENTRY glGenSamplers(GLsizei count, GLuint* samplers);
	GLAPI void APIENTRY glDeleteSamplers(GLsizei count, const GLuint* samplers);
	GLAPI GLboolean APIENTRY glIsSampler(GLuint sampler);
	GLAPI void APIENTRY glBindSampler(GLuint unit, GLuint sampler);
	GLAPI void APIENTRY glSamplerParameteri(GLuint sampler, GLenum pname, GLint param);
	GLAPI void APIENTRY glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint* param);
	GLAPI void APIENTRY glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param);
	GLAPI void APIENTRY glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat* param);
	GLAPI void APIENTRY glSamplerParameterIiv(GLuint sampler, GLenum pname, const GLint* param);
	GLAPI void APIENTRY glSamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint* param);
	GLAPI void APIENTRY glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint* params);
	GLAPI void APIENTRY glGetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint* params);
	GLAPI void APIENTRY glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat* params);
	GLAPI void APIENTRY glGetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint* params);
	GLAPI void APIENTRY glQueryCounter(GLuint id, GLenum target);
	GLAPI void APIENTRY glGetQueryObjecti64v(GLuint id, GLenum pname, GLint64* params);
	GLAPI void APIENTRY glGetQueryObjectui64v(GLuint id, GLenum pname, GLuint64* params);
	GLAPI void APIENTRY glVertexAttribDivisor(GLuint index, GLuint divisor);
	GLAPI void APIENTRY glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
	GLAPI void APIENTRY glVertexAttribP1uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
	GLAPI void APIENTRY glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
	GLAPI void APIENTRY glVertexAttribP2uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
	GLAPI void APIENTRY glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
	GLAPI void APIENTRY glVertexAttribP3uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
	GLAPI void APIENTRY glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
	GLAPI void APIENTRY glVertexAttribP4uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
#endif
#endif /* GL_VERSION_3_3 */

#ifndef GL_VERSION_4_0
#define GL_VERSION_4_0 1
#define GL_SAMPLE_SHADING                 0x8C36
#define GL_MIN_SAMPLE_SHADING_VALUE       0x8C37
#define GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET 0x8E5E
#define GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET 0x8E5F
#define GL_TEXTURE_CUBE_MAP_ARRAY         0x9009
#define GL_TEXTURE_BINDING_CUBE_MAP_ARRAY 0x900A
#define GL_PROXY_TEXTURE_CUBE_MAP_ARRAY   0x900B
#define GL_SAMPLER_CUBE_MAP_ARRAY         0x900C
#define GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW  0x900D
#define GL_INT_SAMPLER_CUBE_MAP_ARRAY     0x900E
#define GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY 0x900F
#define GL_DRAW_INDIRECT_BUFFER           0x8F3F
#define GL_DRAW_INDIRECT_BUFFER_BINDING   0x8F43
#define GL_GEOMETRY_SHADER_INVOCATIONS    0x887F
#define GL_MAX_GEOMETRY_SHADER_INVOCATIONS 0x8E5A
#define GL_MIN_FRAGMENT_INTERPOLATION_OFFSET 0x8E5B
#define GL_MAX_FRAGMENT_INTERPOLATION_OFFSET 0x8E5C
#define GL_FRAGMENT_INTERPOLATION_OFFSET_BITS 0x8E5D
#define GL_MAX_VERTEX_STREAMS             0x8E71
#define GL_DOUBLE_VEC2                    0x8FFC
#define GL_DOUBLE_VEC3                    0x8FFD
#define GL_DOUBLE_VEC4                    0x8FFE
#define GL_DOUBLE_MAT2                    0x8F46
#define GL_DOUBLE_MAT3                    0x8F47
#define GL_DOUBLE_MAT4                    0x8F48
#define GL_DOUBLE_MAT2x3                  0x8F49
#define GL_DOUBLE_MAT2x4                  0x8F4A
#define GL_DOUBLE_MAT3x2                  0x8F4B
#define GL_DOUBLE_MAT3x4                  0x8F4C
#define GL_DOUBLE_MAT4x2                  0x8F4D
#define GL_DOUBLE_MAT4x3                  0x8F4E
#define GL_ACTIVE_SUBROUTINES             0x8DE5
#define GL_ACTIVE_SUBROUTINE_UNIFORMS     0x8DE6
#define GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS 0x8E47
#define GL_ACTIVE_SUBROUTINE_MAX_LENGTH   0x8E48
#define GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH 0x8E49
#define GL_MAX_SUBROUTINES                0x8DE7
#define GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS 0x8DE8
#define GL_NUM_COMPATIBLE_SUBROUTINES     0x8E4A
#define GL_COMPATIBLE_SUBROUTINES         0x8E4B
#define GL_PATCHES                        0x000E
#define GL_PATCH_VERTICES                 0x8E72
#define GL_PATCH_DEFAULT_INNER_LEVEL      0x8E73
#define GL_PATCH_DEFAULT_OUTER_LEVEL      0x8E74
#define GL_TESS_CONTROL_OUTPUT_VERTICES   0x8E75
#define GL_TESS_GEN_MODE                  0x8E76
#define GL_TESS_GEN_SPACING               0x8E77
#define GL_TESS_GEN_VERTEX_ORDER          0x8E78
#define GL_TESS_GEN_POINT_MODE            0x8E79
#define GL_ISOLINES                       0x8E7A
#define GL_FRACTIONAL_ODD                 0x8E7B
#define GL_FRACTIONAL_EVEN                0x8E7C
#define GL_MAX_PATCH_VERTICES             0x8E7D
#define GL_MAX_TESS_GEN_LEVEL             0x8E7E
#define GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS 0x8E7F
#define GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS 0x8E80
#define GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS 0x8E81
#define GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS 0x8E82
#define GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS 0x8E83
#define GL_MAX_TESS_PATCH_COMPONENTS      0x8E84
#define GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS 0x8E85
#define GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS 0x8E86
#define GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS 0x8E89
#define GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS 0x8E8A
#define GL_MAX_TESS_CONTROL_INPUT_COMPONENTS 0x886C
#define GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS 0x886D
#define GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS 0x8E1E
#define GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS 0x8E1F
#define GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER 0x84F0
#define GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER 0x84F1
#define GL_TESS_EVALUATION_SHADER         0x8E87
#define GL_TESS_CONTROL_SHADER            0x8E88
#define GL_TRANSFORM_FEEDBACK             0x8E22
#define GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED 0x8E23
#define GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE 0x8E24
#define GL_TRANSFORM_FEEDBACK_BINDING     0x8E25
#define GL_MAX_TRANSFORM_FEEDBACK_BUFFERS 0x8E70
	typedef void (APIENTRYP PFNGLMINSAMPLESHADINGPROC) (GLfloat value);
	typedef void (APIENTRYP PFNGLBLENDEQUATIONIPROC) (GLuint buf, GLenum mode);
	typedef void (APIENTRYP PFNGLBLENDEQUATIONSEPARATEIPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
	typedef void (APIENTRYP PFNGLBLENDFUNCIPROC) (GLuint buf, GLenum src, GLenum dst);
	typedef void (APIENTRYP PFNGLBLENDFUNCSEPARATEIPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
	typedef void (APIENTRYP PFNGLDRAWARRAYSINDIRECTPROC) (GLenum mode, const void* indirect);
	typedef void (APIENTRYP PFNGLDRAWELEMENTSINDIRECTPROC) (GLenum mode, GLenum type, const void* indirect);
	typedef void (APIENTRYP PFNGLUNIFORM1DPROC) (GLint location, GLdouble x);
	typedef void (APIENTRYP PFNGLUNIFORM2DPROC) (GLint location, GLdouble x, GLdouble y);
	typedef void (APIENTRYP PFNGLUNIFORM3DPROC) (GLint location, GLdouble x, GLdouble y, GLdouble z);
	typedef void (APIENTRYP PFNGLUNIFORM4DPROC) (GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
	typedef void (APIENTRYP PFNGLUNIFORM1DVPROC) (GLint location, GLsizei count, const GLdouble* value);
	typedef void (APIENTRYP PFNGLUNIFORM2DVPROC) (GLint location, GLsizei count, const GLdouble* value);
	typedef void (APIENTRYP PFNGLUNIFORM3DVPROC) (GLint location, GLsizei count, const GLdouble* value);
	typedef void (APIENTRYP PFNGLUNIFORM4DVPROC) (GLint location, GLsizei count, const GLdouble* value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX2X3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX2X4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX3X2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX3X4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX4X2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	typedef void (APIENTRYP PFNGLUNIFORMMATRIX4X3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	typedef void (APIENTRYP PFNGLGETUNIFORMDVPROC) (GLuint program, GLint location, GLdouble* params);
	typedef GLint(APIENTRYP PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC) (GLuint program, GLenum shadertype, const GLchar* name);
	typedef GLuint(APIENTRYP PFNGLGETSUBROUTINEINDEXPROC) (GLuint program, GLenum shadertype, const GLchar* name);
	typedef void (APIENTRYP PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC) (GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint* values);
	typedef void (APIENTRYP PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC) (GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei* length, GLchar* name);
	typedef void (APIENTRYP PFNGLGETACTIVESUBROUTINENAMEPROC) (GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei* length, GLchar* name);
	typedef void (APIENTRYP PFNGLUNIFORMSUBROUTINESUIVPROC) (GLenum shadertype, GLsizei count, const GLuint* indices);
	typedef void (APIENTRYP PFNGLGETUNIFORMSUBROUTINEUIVPROC) (GLenum shadertype, GLint location, GLuint* params);
	typedef void (APIENTRYP PFNGLGETPROGRAMSTAGEIVPROC) (GLuint program, GLenum shadertype, GLenum pname, GLint* values);
	typedef void (APIENTRYP PFNGLPATCHPARAMETERIPROC) (GLenum pname, GLint value);
	typedef void (APIENTRYP PFNGLPATCHPARAMETERFVPROC) (GLenum pname, const GLfloat* values);
	typedef void (APIENTRYP PFNGLBINDTRANSFORMFEEDBACKPROC) (GLenum target, GLuint id);
	typedef void (APIENTRYP PFNGLDELETETRANSFORMFEEDBACKSPROC) (GLsizei n, const GLuint* ids);
	typedef void (APIENTRYP PFNGLGENTRANSFORMFEEDBACKSPROC) (GLsizei n, GLuint* ids);
	typedef GLboolean(APIENTRYP PFNGLISTRANSFORMFEEDBACKPROC) (GLuint id);
	typedef void (APIENTRYP PFNGLPAUSETRANSFORMFEEDBACKPROC) (void);
	typedef void (APIENTRYP PFNGLRESUMETRANSFORMFEEDBACKPROC) (void);
	typedef void (APIENTRYP PFNGLDRAWTRANSFORMFEEDBACKPROC) (GLenum mode, GLuint id);
	typedef void (APIENTRYP PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC) (GLenum mode, GLuint id, GLuint stream);
	typedef void (APIENTRYP PFNGLBEGINQUERYINDEXEDPROC) (GLenum target, GLuint index, GLuint id);
	typedef void (APIENTRYP PFNGLENDQUERYINDEXEDPROC) (GLenum target, GLuint index);
	typedef void (APIENTRYP PFNGLGETQUERYINDEXEDIVPROC) (GLenum target, GLuint index, GLenum pname, GLint* params);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glMinSampleShading(GLfloat value);
	GLAPI void APIENTRY glBlendEquationi(GLuint buf, GLenum mode);
	GLAPI void APIENTRY glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
	GLAPI void APIENTRY glBlendFunci(GLuint buf, GLenum src, GLenum dst);
	GLAPI void APIENTRY glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
	GLAPI void APIENTRY glDrawArraysIndirect(GLenum mode, const void* indirect);
	GLAPI void APIENTRY glDrawElementsIndirect(GLenum mode, GLenum type, const void* indirect);
	GLAPI void APIENTRY glUniform1d(GLint location, GLdouble x);
	GLAPI void APIENTRY glUniform2d(GLint location, GLdouble x, GLdouble y);
	GLAPI void APIENTRY glUniform3d(GLint location, GLdouble x, GLdouble y, GLdouble z);
	GLAPI void APIENTRY glUniform4d(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
	GLAPI void APIENTRY glUniform1dv(GLint location, GLsizei count, const GLdouble* value);
	GLAPI void APIENTRY glUniform2dv(GLint location, GLsizei count, const GLdouble* value);
	GLAPI void APIENTRY glUniform3dv(GLint location, GLsizei count, const GLdouble* value);
	GLAPI void APIENTRY glUniform4dv(GLint location, GLsizei count, const GLdouble* value);
	GLAPI void APIENTRY glUniformMatrix2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	GLAPI void APIENTRY glUniformMatrix3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	GLAPI void APIENTRY glUniformMatrix4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	GLAPI void APIENTRY glUniformMatrix2x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	GLAPI void APIENTRY glUniformMatrix2x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	GLAPI void APIENTRY glUniformMatrix3x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	GLAPI void APIENTRY glUniformMatrix3x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	GLAPI void APIENTRY glUniformMatrix4x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	GLAPI void APIENTRY glUniformMatrix4x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	GLAPI void APIENTRY glGetUniformdv(GLuint program, GLint location, GLdouble* params);
	GLAPI GLint APIENTRY glGetSubroutineUniformLocation(GLuint program, GLenum shadertype, const GLchar* name);
	GLAPI GLuint APIENTRY glGetSubroutineIndex(GLuint program, GLenum shadertype, const GLchar* name);
	GLAPI void APIENTRY glGetActiveSubroutineUniformiv(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint* values);
	GLAPI void APIENTRY glGetActiveSubroutineUniformName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei* length, GLchar* name);
	GLAPI void APIENTRY glGetActiveSubroutineName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei* length, GLchar* name);
	GLAPI void APIENTRY glUniformSubroutinesuiv(GLenum shadertype, GLsizei count, const GLuint* indices);
	GLAPI void APIENTRY glGetUniformSubroutineuiv(GLenum shadertype, GLint location, GLuint* params);
	GLAPI void APIENTRY glGetProgramStageiv(GLuint program, GLenum shadertype, GLenum pname, GLint* values);
	GLAPI void APIENTRY glPatchParameteri(GLenum pname, GLint value);
	GLAPI void APIENTRY glPatchParameterfv(GLenum pname, const GLfloat* values);
	GLAPI void APIENTRY glBindTransformFeedback(GLenum target, GLuint id);
	GLAPI void APIENTRY glDeleteTransformFeedbacks(GLsizei n, const GLuint* ids);
	GLAPI void APIENTRY glGenTransformFeedbacks(GLsizei n, GLuint* ids);
	GLAPI GLboolean APIENTRY glIsTransformFeedback(GLuint id);
	GLAPI void APIENTRY glPauseTransformFeedback(void);
	GLAPI void APIENTRY glResumeTransformFeedback(void);
	GLAPI void APIENTRY glDrawTransformFeedback(GLenum mode, GLuint id);
	GLAPI void APIENTRY glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream);
	GLAPI void APIENTRY glBeginQueryIndexed(GLenum target, GLuint index, GLuint id);
	GLAPI void APIENTRY glEndQueryIndexed(GLenum target, GLuint index);
	GLAPI void APIENTRY glGetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint* params);
#endif
#endif /* GL_VERSION_4_0 */

#ifndef GL_VERSION_4_1
#define GL_VERSION_4_1 1
#define GL_FIXED                          0x140C
#define GL_IMPLEMENTATION_COLOR_READ_TYPE 0x8B9A
#define GL_IMPLEMENTATION_COLOR_READ_FORMAT 0x8B9B
#define GL_LOW_FLOAT                      0x8DF0
#define GL_MEDIUM_FLOAT                   0x8DF1
#define GL_HIGH_FLOAT                     0x8DF2
#define GL_LOW_INT                        0x8DF3
#define GL_MEDIUM_INT                     0x8DF4
#define GL_HIGH_INT                       0x8DF5
#define GL_SHADER_COMPILER                0x8DFA
#define GL_SHADER_BINARY_FORMATS          0x8DF8
#define GL_NUM_SHADER_BINARY_FORMATS      0x8DF9
#define GL_MAX_VERTEX_UNIFORM_VECTORS     0x8DFB
#define GL_MAX_VARYING_VECTORS            0x8DFC
#define GL_MAX_FRAGMENT_UNIFORM_VECTORS   0x8DFD
#define GL_RGB565                         0x8D62
#define GL_PROGRAM_BINARY_RETRIEVABLE_HINT 0x8257
#define GL_PROGRAM_BINARY_LENGTH          0x8741
#define GL_NUM_PROGRAM_BINARY_FORMATS     0x87FE
#define GL_PROGRAM_BINARY_FORMATS         0x87FF
#define GL_VERTEX_SHADER_BIT              0x00000001
#define GL_FRAGMENT_SHADER_BIT            0x00000002
#define GL_GEOMETRY_SHADER_BIT            0x00000004
#define GL_TESS_CONTROL_SHADER_BIT        0x00000008
#define GL_TESS_EVALUATION_SHADER_BIT     0x00000010
#define GL_ALL_SHADER_BITS                0xFFFFFFFF
#define GL_PROGRAM_SEPARABLE              0x8258
#define GL_ACTIVE_PROGRAM                 0x8259
#define GL_PROGRAM_PIPELINE_BINDING       0x825A
#define GL_MAX_VIEWPORTS                  0x825B
#define GL_VIEWPORT_SUBPIXEL_BITS         0x825C
#define GL_VIEWPORT_BOUNDS_RANGE          0x825D
#define GL_LAYER_PROVOKING_VERTEX         0x825E
#define GL_VIEWPORT_INDEX_PROVOKING_VERTEX 0x825F
#define GL_UNDEFINED_VERTEX               0x8260
	typedef void (APIENTRYP PFNGLRELEASESHADERCOMPILERPROC) (void);
	typedef void (APIENTRYP PFNGLSHADERBINARYPROC) (GLsizei count, const GLuint* shaders, GLenum binaryFormat, const void* binary, GLsizei length);
	typedef void (APIENTRYP PFNGLGETSHADERPRECISIONFORMATPROC) (GLenum shadertype, GLenum precisiontype, GLint* range, GLint* precision);
	typedef void (APIENTRYP PFNGLDEPTHRANGEFPROC) (GLfloat n, GLfloat f);
	typedef void (APIENTRYP PFNGLCLEARDEPTHFPROC) (GLfloat d);
	typedef void (APIENTRYP PFNGLGETPROGRAMBINARYPROC) (GLuint program, GLsizei bufSize, GLsizei* length, GLenum* binaryFormat, void* binary);
	typedef void (APIENTRYP PFNGLPROGRAMBINARYPROC) (GLuint program, GLenum binaryFormat, const void* binary, GLsizei length);
	typedef void (APIENTRYP PFNGLPROGRAMPARAMETERIPROC) (GLuint program, GLenum pname, GLint value);
	typedef void (APIENTRYP PFNGLUSEPROGRAMSTAGESPROC) (GLuint pipeline, GLbitfield stages, GLuint program);
	typedef void (APIENTRYP PFNGLACTIVESHADERPROGRAMPROC) (GLuint pipeline, GLuint program);
	typedef GLuint(APIENTRYP PFNGLCREATESHADERPROGRAMVPROC) (GLenum type, GLsizei count, const GLchar* const* strings);
	typedef void (APIENTRYP PFNGLBINDPROGRAMPIPELINEPROC) (GLuint pipeline);
	typedef void (APIENTRYP PFNGLDELETEPROGRAMPIPELINESPROC) (GLsizei n, const GLuint* pipelines);
	typedef void (APIENTRYP PFNGLGENPROGRAMPIPELINESPROC) (GLsizei n, GLuint* pipelines);
	typedef GLboolean(APIENTRYP PFNGLISPROGRAMPIPELINEPROC) (GLuint pipeline);
	typedef void (APIENTRYP PFNGLGETPROGRAMPIPELINEIVPROC) (GLuint pipeline, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1IPROC) (GLuint program, GLint location, GLint v0);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1FPROC) (GLuint program, GLint location, GLfloat v0);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1DPROC) (GLuint program, GLint location, GLdouble v0);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1UIPROC) (GLuint program, GLint location, GLuint v0);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2IPROC) (GLuint program, GLint location, GLint v0, GLint v1);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2FPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2DPROC) (GLuint program, GLint location, GLdouble v0, GLdouble v1);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2UIPROC) (GLuint program, GLint location, GLuint v0, GLuint v1);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3IPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3FPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3DPROC) (GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3UIPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4IPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4FPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4DPROC) (GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4UIPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	typedef void (APIENTRYP PFNGLVALIDATEPROGRAMPIPELINEPROC) (GLuint pipeline);
	typedef void (APIENTRYP PFNGLGETPROGRAMPIPELINEINFOLOGPROC) (GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL1DPROC) (GLuint index, GLdouble x);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL2DPROC) (GLuint index, GLdouble x, GLdouble y);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL3DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL4DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL1DVPROC) (GLuint index, const GLdouble* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL2DVPROC) (GLuint index, const GLdouble* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL3DVPROC) (GLuint index, const GLdouble* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL4DVPROC) (GLuint index, const GLdouble* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBLPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void* pointer);
	typedef void (APIENTRYP PFNGLGETVERTEXATTRIBLDVPROC) (GLuint index, GLenum pname, GLdouble* params);
	typedef void (APIENTRYP PFNGLVIEWPORTARRAYVPROC) (GLuint first, GLsizei count, const GLfloat* v);
	typedef void (APIENTRYP PFNGLVIEWPORTINDEXEDFPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
	typedef void (APIENTRYP PFNGLVIEWPORTINDEXEDFVPROC) (GLuint index, const GLfloat* v);
	typedef void (APIENTRYP PFNGLSCISSORARRAYVPROC) (GLuint first, GLsizei count, const GLint* v);
	typedef void (APIENTRYP PFNGLSCISSORINDEXEDPROC) (GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLSCISSORINDEXEDVPROC) (GLuint index, const GLint* v);
	typedef void (APIENTRYP PFNGLDEPTHRANGEARRAYVPROC) (GLuint first, GLsizei count, const GLdouble* v);
	typedef void (APIENTRYP PFNGLDEPTHRANGEINDEXEDPROC) (GLuint index, GLdouble n, GLdouble f);
	typedef void (APIENTRYP PFNGLGETFLOATI_VPROC) (GLenum target, GLuint index, GLfloat* data);
	typedef void (APIENTRYP PFNGLGETDOUBLEI_VPROC) (GLenum target, GLuint index, GLdouble* data);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glReleaseShaderCompiler(void);
	GLAPI void APIENTRY glShaderBinary(GLsizei count, const GLuint* shaders, GLenum binaryFormat, const void* binary, GLsizei length);
	GLAPI void APIENTRY glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint* range, GLint* precision);
	GLAPI void APIENTRY glDepthRangef(GLfloat n, GLfloat f);
	GLAPI void APIENTRY glClearDepthf(GLfloat d);
	GLAPI void APIENTRY glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei* length, GLenum* binaryFormat, void* binary);
	GLAPI void APIENTRY glProgramBinary(GLuint program, GLenum binaryFormat, const void* binary, GLsizei length);
	GLAPI void APIENTRY glProgramParameteri(GLuint program, GLenum pname, GLint value);
	GLAPI void APIENTRY glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program);
	GLAPI void APIENTRY glActiveShaderProgram(GLuint pipeline, GLuint program);
	GLAPI GLuint APIENTRY glCreateShaderProgramv(GLenum type, GLsizei count, const GLchar* const* strings);
	GLAPI void APIENTRY glBindProgramPipeline(GLuint pipeline);
	GLAPI void APIENTRY glDeleteProgramPipelines(GLsizei n, const GLuint* pipelines);
	GLAPI void APIENTRY glGenProgramPipelines(GLsizei n, GLuint* pipelines);
	GLAPI GLboolean APIENTRY glIsProgramPipeline(GLuint pipeline);
	GLAPI void APIENTRY glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint* params);
	GLAPI void APIENTRY glProgramUniform1i(GLuint program, GLint location, GLint v0);
	GLAPI void APIENTRY glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint* value);
	GLAPI void APIENTRY glProgramUniform1f(GLuint program, GLint location, GLfloat v0);
	GLAPI void APIENTRY glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat* value);
	GLAPI void APIENTRY glProgramUniform1d(GLuint program, GLint location, GLdouble v0);
	GLAPI void APIENTRY glProgramUniform1dv(GLuint program, GLint location, GLsizei count, const GLdouble* value);
	GLAPI void APIENTRY glProgramUniform1ui(GLuint program, GLint location, GLuint v0);
	GLAPI void APIENTRY glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint* value);
	GLAPI void APIENTRY glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1);
	GLAPI void APIENTRY glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint* value);
	GLAPI void APIENTRY glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1);
	GLAPI void APIENTRY glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat* value);
	GLAPI void APIENTRY glProgramUniform2d(GLuint program, GLint location, GLdouble v0, GLdouble v1);
	GLAPI void APIENTRY glProgramUniform2dv(GLuint program, GLint location, GLsizei count, const GLdouble* value);
	GLAPI void APIENTRY glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1);
	GLAPI void APIENTRY glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint* value);
	GLAPI void APIENTRY glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
	GLAPI void APIENTRY glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint* value);
	GLAPI void APIENTRY glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
	GLAPI void APIENTRY glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat* value);
	GLAPI void APIENTRY glProgramUniform3d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2);
	GLAPI void APIENTRY glProgramUniform3dv(GLuint program, GLint location, GLsizei count, const GLdouble* value);
	GLAPI void APIENTRY glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
	GLAPI void APIENTRY glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint* value);
	GLAPI void APIENTRY glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
	GLAPI void APIENTRY glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint* value);
	GLAPI void APIENTRY glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
	GLAPI void APIENTRY glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat* value);
	GLAPI void APIENTRY glProgramUniform4d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
	GLAPI void APIENTRY glProgramUniform4dv(GLuint program, GLint location, GLsizei count, const GLdouble* value);
	GLAPI void APIENTRY glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
	GLAPI void APIENTRY glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint* value);
	GLAPI void APIENTRY glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	GLAPI void APIENTRY glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	GLAPI void APIENTRY glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	GLAPI void APIENTRY glProgramUniformMatrix2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	GLAPI void APIENTRY glProgramUniformMatrix3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	GLAPI void APIENTRY glProgramUniformMatrix4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	GLAPI void APIENTRY glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	GLAPI void APIENTRY glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	GLAPI void APIENTRY glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	GLAPI void APIENTRY glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	GLAPI void APIENTRY glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	GLAPI void APIENTRY glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	GLAPI void APIENTRY glProgramUniformMatrix2x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	GLAPI void APIENTRY glProgramUniformMatrix3x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	GLAPI void APIENTRY glProgramUniformMatrix2x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	GLAPI void APIENTRY glProgramUniformMatrix4x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	GLAPI void APIENTRY glProgramUniformMatrix3x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	GLAPI void APIENTRY glProgramUniformMatrix4x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	GLAPI void APIENTRY glValidateProgramPipeline(GLuint pipeline);
	GLAPI void APIENTRY glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
	GLAPI void APIENTRY glVertexAttribL1d(GLuint index, GLdouble x);
	GLAPI void APIENTRY glVertexAttribL2d(GLuint index, GLdouble x, GLdouble y);
	GLAPI void APIENTRY glVertexAttribL3d(GLuint index, GLdouble x, GLdouble y, GLdouble z);
	GLAPI void APIENTRY glVertexAttribL4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
	GLAPI void APIENTRY glVertexAttribL1dv(GLuint index, const GLdouble* v);
	GLAPI void APIENTRY glVertexAttribL2dv(GLuint index, const GLdouble* v);
	GLAPI void APIENTRY glVertexAttribL3dv(GLuint index, const GLdouble* v);
	GLAPI void APIENTRY glVertexAttribL4dv(GLuint index, const GLdouble* v);
	GLAPI void APIENTRY glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void* pointer);
	GLAPI void APIENTRY glGetVertexAttribLdv(GLuint index, GLenum pname, GLdouble* params);
	GLAPI void APIENTRY glViewportArrayv(GLuint first, GLsizei count, const GLfloat* v);
	GLAPI void APIENTRY glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
	GLAPI void APIENTRY glViewportIndexedfv(GLuint index, const GLfloat* v);
	GLAPI void APIENTRY glScissorArrayv(GLuint first, GLsizei count, const GLint* v);
	GLAPI void APIENTRY glScissorIndexed(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glScissorIndexedv(GLuint index, const GLint* v);
	GLAPI void APIENTRY glDepthRangeArrayv(GLuint first, GLsizei count, const GLdouble* v);
	GLAPI void APIENTRY glDepthRangeIndexed(GLuint index, GLdouble n, GLdouble f);
	GLAPI void APIENTRY glGetFloati_v(GLenum target, GLuint index, GLfloat* data);
	GLAPI void APIENTRY glGetDoublei_v(GLenum target, GLuint index, GLdouble* data);
#endif
#endif /* GL_VERSION_4_1 */

#ifndef GL_VERSION_4_2
#define GL_VERSION_4_2 1
#define GL_COPY_READ_BUFFER_BINDING       0x8F36
#define GL_COPY_WRITE_BUFFER_BINDING      0x8F37
#define GL_TRANSFORM_FEEDBACK_ACTIVE      0x8E24
#define GL_TRANSFORM_FEEDBACK_PAUSED      0x8E23
#define GL_UNPACK_COMPRESSED_BLOCK_WIDTH  0x9127
#define GL_UNPACK_COMPRESSED_BLOCK_HEIGHT 0x9128
#define GL_UNPACK_COMPRESSED_BLOCK_DEPTH  0x9129
#define GL_UNPACK_COMPRESSED_BLOCK_SIZE   0x912A
#define GL_PACK_COMPRESSED_BLOCK_WIDTH    0x912B
#define GL_PACK_COMPRESSED_BLOCK_HEIGHT   0x912C
#define GL_PACK_COMPRESSED_BLOCK_DEPTH    0x912D
#define GL_PACK_COMPRESSED_BLOCK_SIZE     0x912E
#define GL_NUM_SAMPLE_COUNTS              0x9380
#define GL_MIN_MAP_BUFFER_ALIGNMENT       0x90BC
#define GL_ATOMIC_COUNTER_BUFFER          0x92C0
#define GL_ATOMIC_COUNTER_BUFFER_BINDING  0x92C1
#define GL_ATOMIC_COUNTER_BUFFER_START    0x92C2
#define GL_ATOMIC_COUNTER_BUFFER_SIZE     0x92C3
#define GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE 0x92C4
#define GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS 0x92C5
#define GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES 0x92C6
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER 0x92C7
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER 0x92C8
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER 0x92C9
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER 0x92CA
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER 0x92CB
#define GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS 0x92CC
#define GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS 0x92CD
#define GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS 0x92CE
#define GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS 0x92CF
#define GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS 0x92D0
#define GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS 0x92D1
#define GL_MAX_VERTEX_ATOMIC_COUNTERS     0x92D2
#define GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS 0x92D3
#define GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS 0x92D4
#define GL_MAX_GEOMETRY_ATOMIC_COUNTERS   0x92D5
#define GL_MAX_FRAGMENT_ATOMIC_COUNTERS   0x92D6
#define GL_MAX_COMBINED_ATOMIC_COUNTERS   0x92D7
#define GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE 0x92D8
#define GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS 0x92DC
#define GL_ACTIVE_ATOMIC_COUNTER_BUFFERS  0x92D9
#define GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX 0x92DA
#define GL_UNSIGNED_INT_ATOMIC_COUNTER    0x92DB
#define GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT 0x00000001
#define GL_ELEMENT_ARRAY_BARRIER_BIT      0x00000002
#define GL_UNIFORM_BARRIER_BIT            0x00000004
#define GL_TEXTURE_FETCH_BARRIER_BIT      0x00000008
#define GL_SHADER_IMAGE_ACCESS_BARRIER_BIT 0x00000020
#define GL_COMMAND_BARRIER_BIT            0x00000040
#define GL_PIXEL_BUFFER_BARRIER_BIT       0x00000080
#define GL_TEXTURE_UPDATE_BARRIER_BIT     0x00000100
#define GL_BUFFER_UPDATE_BARRIER_BIT      0x00000200
#define GL_FRAMEBUFFER_BARRIER_BIT        0x00000400
#define GL_TRANSFORM_FEEDBACK_BARRIER_BIT 0x00000800
#define GL_ATOMIC_COUNTER_BARRIER_BIT     0x00001000
#define GL_ALL_BARRIER_BITS               0xFFFFFFFF
#define GL_MAX_IMAGE_UNITS                0x8F38
#define GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS 0x8F39
#define GL_IMAGE_BINDING_NAME             0x8F3A
#define GL_IMAGE_BINDING_LEVEL            0x8F3B
#define GL_IMAGE_BINDING_LAYERED          0x8F3C
#define GL_IMAGE_BINDING_LAYER            0x8F3D
#define GL_IMAGE_BINDING_ACCESS           0x8F3E
#define GL_IMAGE_1D                       0x904C
#define GL_IMAGE_2D                       0x904D
#define GL_IMAGE_3D                       0x904E
#define GL_IMAGE_2D_RECT                  0x904F
#define GL_IMAGE_CUBE                     0x9050
#define GL_IMAGE_BUFFER                   0x9051
#define GL_IMAGE_1D_ARRAY                 0x9052
#define GL_IMAGE_2D_ARRAY                 0x9053
#define GL_IMAGE_CUBE_MAP_ARRAY           0x9054
#define GL_IMAGE_2D_MULTISAMPLE           0x9055
#define GL_IMAGE_2D_MULTISAMPLE_ARRAY     0x9056
#define GL_INT_IMAGE_1D                   0x9057
#define GL_INT_IMAGE_2D                   0x9058
#define GL_INT_IMAGE_3D                   0x9059
#define GL_INT_IMAGE_2D_RECT              0x905A
#define GL_INT_IMAGE_CUBE                 0x905B
#define GL_INT_IMAGE_BUFFER               0x905C
#define GL_INT_IMAGE_1D_ARRAY             0x905D
#define GL_INT_IMAGE_2D_ARRAY             0x905E
#define GL_INT_IMAGE_CUBE_MAP_ARRAY       0x905F
#define GL_INT_IMAGE_2D_MULTISAMPLE       0x9060
#define GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY 0x9061
#define GL_UNSIGNED_INT_IMAGE_1D          0x9062
#define GL_UNSIGNED_INT_IMAGE_2D          0x9063
#define GL_UNSIGNED_INT_IMAGE_3D          0x9064
#define GL_UNSIGNED_INT_IMAGE_2D_RECT     0x9065
#define GL_UNSIGNED_INT_IMAGE_CUBE        0x9066
#define GL_UNSIGNED_INT_IMAGE_BUFFER      0x9067
#define GL_UNSIGNED_INT_IMAGE_1D_ARRAY    0x9068
#define GL_UNSIGNED_INT_IMAGE_2D_ARRAY    0x9069
#define GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY 0x906A
#define GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE 0x906B
#define GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY 0x906C
#define GL_MAX_IMAGE_SAMPLES              0x906D
#define GL_IMAGE_BINDING_FORMAT           0x906E
#define GL_IMAGE_FORMAT_COMPATIBILITY_TYPE 0x90C7
#define GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE 0x90C8
#define GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS 0x90C9
#define GL_MAX_VERTEX_IMAGE_UNIFORMS      0x90CA
#define GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS 0x90CB
#define GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS 0x90CC
#define GL_MAX_GEOMETRY_IMAGE_UNIFORMS    0x90CD
#define GL_MAX_FRAGMENT_IMAGE_UNIFORMS    0x90CE
#define GL_MAX_COMBINED_IMAGE_UNIFORMS    0x90CF
#define GL_COMPRESSED_RGBA_BPTC_UNORM     0x8E8C
#define GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM 0x8E8D
#define GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT 0x8E8E
#define GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT 0x8E8F
#define GL_TEXTURE_IMMUTABLE_FORMAT       0x912F
	typedef void (APIENTRYP PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC) (GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance);
	typedef void (APIENTRYP PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC) (GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount, GLuint baseinstance);
	typedef void (APIENTRYP PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC) (GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance);
	typedef void (APIENTRYP PFNGLGETINTERNALFORMATIVPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint* params);
	typedef void (APIENTRYP PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC) (GLuint program, GLuint bufferIndex, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLBINDIMAGETEXTUREPROC) (GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
	typedef void (APIENTRYP PFNGLMEMORYBARRIERPROC) (GLbitfield barriers);
	typedef void (APIENTRYP PFNGLTEXSTORAGE1DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
	typedef void (APIENTRYP PFNGLTEXSTORAGE2DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLTEXSTORAGE3DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
	typedef void (APIENTRYP PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC) (GLenum mode, GLuint id, GLsizei instancecount);
	typedef void (APIENTRYP PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC) (GLenum mode, GLuint id, GLuint stream, GLsizei instancecount);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance);
	GLAPI void APIENTRY glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount, GLuint baseinstance);
	GLAPI void APIENTRY glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance);
	GLAPI void APIENTRY glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint* params);
	GLAPI void APIENTRY glGetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex, GLenum pname, GLint* params);
	GLAPI void APIENTRY glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
	GLAPI void APIENTRY glMemoryBarrier(GLbitfield barriers);
	GLAPI void APIENTRY glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
	GLAPI void APIENTRY glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
	GLAPI void APIENTRY glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei instancecount);
	GLAPI void APIENTRY glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount);
#endif
#endif /* GL_VERSION_4_2 */

#ifndef GL_VERSION_4_3
#define GL_VERSION_4_3 1
	typedef void (APIENTRY* GLDEBUGPROC)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam);
#define GL_NUM_SHADING_LANGUAGE_VERSIONS  0x82E9
#define GL_VERTEX_ATTRIB_ARRAY_LONG       0x874E
#define GL_COMPRESSED_RGB8_ETC2           0x9274
#define GL_COMPRESSED_SRGB8_ETC2          0x9275
#define GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 0x9276
#define GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 0x9277
#define GL_COMPRESSED_RGBA8_ETC2_EAC      0x9278
#define GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC 0x9279
#define GL_COMPRESSED_R11_EAC             0x9270
#define GL_COMPRESSED_SIGNED_R11_EAC      0x9271
#define GL_COMPRESSED_RG11_EAC            0x9272
#define GL_COMPRESSED_SIGNED_RG11_EAC     0x9273
#define GL_PRIMITIVE_RESTART_FIXED_INDEX  0x8D69
#define GL_ANY_SAMPLES_PASSED_CONSERVATIVE 0x8D6A
#define GL_MAX_ELEMENT_INDEX              0x8D6B
#define GL_COMPUTE_SHADER                 0x91B9
#define GL_MAX_COMPUTE_UNIFORM_BLOCKS     0x91BB
#define GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS 0x91BC
#define GL_MAX_COMPUTE_IMAGE_UNIFORMS     0x91BD
#define GL_MAX_COMPUTE_SHARED_MEMORY_SIZE 0x8262
#define GL_MAX_COMPUTE_UNIFORM_COMPONENTS 0x8263
#define GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS 0x8264
#define GL_MAX_COMPUTE_ATOMIC_COUNTERS    0x8265
#define GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS 0x8266
#define GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS 0x90EB
#define GL_MAX_COMPUTE_WORK_GROUP_COUNT   0x91BE
#define GL_MAX_COMPUTE_WORK_GROUP_SIZE    0x91BF
#define GL_COMPUTE_WORK_GROUP_SIZE        0x8267
#define GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER 0x90EC
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER 0x90ED
#define GL_DISPATCH_INDIRECT_BUFFER       0x90EE
#define GL_DISPATCH_INDIRECT_BUFFER_BINDING 0x90EF
#define GL_COMPUTE_SHADER_BIT             0x00000020
#define GL_DEBUG_OUTPUT_SYNCHRONOUS       0x8242
#define GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH 0x8243
#define GL_DEBUG_CALLBACK_FUNCTION        0x8244
#define GL_DEBUG_CALLBACK_USER_PARAM      0x8245
#define GL_DEBUG_SOURCE_API               0x8246
#define GL_DEBUG_SOURCE_WINDOW_SYSTEM     0x8247
#define GL_DEBUG_SOURCE_SHADER_COMPILER   0x8248
#define GL_DEBUG_SOURCE_THIRD_PARTY       0x8249
#define GL_DEBUG_SOURCE_APPLICATION       0x824A
#define GL_DEBUG_SOURCE_OTHER             0x824B
#define GL_DEBUG_TYPE_ERROR               0x824C
#define GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR 0x824D
#define GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR  0x824E
#define GL_DEBUG_TYPE_PORTABILITY         0x824F
#define GL_DEBUG_TYPE_PERFORMANCE         0x8250
#define GL_DEBUG_TYPE_OTHER               0x8251
#define GL_MAX_DEBUG_MESSAGE_LENGTH       0x9143
#define GL_MAX_DEBUG_LOGGED_MESSAGES      0x9144
#define GL_DEBUG_LOGGED_MESSAGES          0x9145
#define GL_DEBUG_SEVERITY_HIGH            0x9146
#define GL_DEBUG_SEVERITY_MEDIUM          0x9147
#define GL_DEBUG_SEVERITY_LOW             0x9148
#define GL_DEBUG_TYPE_MARKER              0x8268
#define GL_DEBUG_TYPE_PUSH_GROUP          0x8269
#define GL_DEBUG_TYPE_POP_GROUP           0x826A
#define GL_DEBUG_SEVERITY_NOTIFICATION    0x826B
#define GL_MAX_DEBUG_GROUP_STACK_DEPTH    0x826C
#define GL_DEBUG_GROUP_STACK_DEPTH        0x826D
#define GL_BUFFER                         0x82E0
#define GL_SHADER                         0x82E1
#define GL_PROGRAM                        0x82E2
#define GL_QUERY                          0x82E3
#define GL_PROGRAM_PIPELINE               0x82E4
#define GL_SAMPLER                        0x82E6
#define GL_MAX_LABEL_LENGTH               0x82E8
#define GL_DEBUG_OUTPUT                   0x92E0
#define GL_CONTEXT_FLAG_DEBUG_BIT         0x00000002
#define GL_MAX_UNIFORM_LOCATIONS          0x826E
#define GL_FRAMEBUFFER_DEFAULT_WIDTH      0x9310
#define GL_FRAMEBUFFER_DEFAULT_HEIGHT     0x9311
#define GL_FRAMEBUFFER_DEFAULT_LAYERS     0x9312
#define GL_FRAMEBUFFER_DEFAULT_SAMPLES    0x9313
#define GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS 0x9314
#define GL_MAX_FRAMEBUFFER_WIDTH          0x9315
#define GL_MAX_FRAMEBUFFER_HEIGHT         0x9316
#define GL_MAX_FRAMEBUFFER_LAYERS         0x9317
#define GL_MAX_FRAMEBUFFER_SAMPLES        0x9318
#define GL_INTERNALFORMAT_SUPPORTED       0x826F
#define GL_INTERNALFORMAT_PREFERRED       0x8270
#define GL_INTERNALFORMAT_RED_SIZE        0x8271
#define GL_INTERNALFORMAT_GREEN_SIZE      0x8272
#define GL_INTERNALFORMAT_BLUE_SIZE       0x8273
#define GL_INTERNALFORMAT_ALPHA_SIZE      0x8274
#define GL_INTERNALFORMAT_DEPTH_SIZE      0x8275
#define GL_INTERNALFORMAT_STENCIL_SIZE    0x8276
#define GL_INTERNALFORMAT_SHARED_SIZE     0x8277
#define GL_INTERNALFORMAT_RED_TYPE        0x8278
#define GL_INTERNALFORMAT_GREEN_TYPE      0x8279
#define GL_INTERNALFORMAT_BLUE_TYPE       0x827A
#define GL_INTERNALFORMAT_ALPHA_TYPE      0x827B
#define GL_INTERNALFORMAT_DEPTH_TYPE      0x827C
#define GL_INTERNALFORMAT_STENCIL_TYPE    0x827D
#define GL_MAX_WIDTH                      0x827E
#define GL_MAX_HEIGHT                     0x827F
#define GL_MAX_DEPTH                      0x8280
#define GL_MAX_LAYERS                     0x8281
#define GL_MAX_COMBINED_DIMENSIONS        0x8282
#define GL_COLOR_COMPONENTS               0x8283
#define GL_DEPTH_COMPONENTS               0x8284
#define GL_STENCIL_COMPONENTS             0x8285
#define GL_COLOR_RENDERABLE               0x8286
#define GL_DEPTH_RENDERABLE               0x8287
#define GL_STENCIL_RENDERABLE             0x8288
#define GL_FRAMEBUFFER_RENDERABLE         0x8289
#define GL_FRAMEBUFFER_RENDERABLE_LAYERED 0x828A
#define GL_FRAMEBUFFER_BLEND              0x828B
#define GL_READ_PIXELS                    0x828C
#define GL_READ_PIXELS_FORMAT             0x828D
#define GL_READ_PIXELS_TYPE               0x828E
#define GL_TEXTURE_IMAGE_FORMAT           0x828F
#define GL_TEXTURE_IMAGE_TYPE             0x8290
#define GL_GET_TEXTURE_IMAGE_FORMAT       0x8291
#define GL_GET_TEXTURE_IMAGE_TYPE         0x8292
#define GL_MIPMAP                         0x8293
#define GL_MANUAL_GENERATE_MIPMAP         0x8294
#define GL_AUTO_GENERATE_MIPMAP           0x8295
#define GL_COLOR_ENCODING                 0x8296
#define GL_SRGB_READ                      0x8297
#define GL_SRGB_WRITE                     0x8298
#define GL_FILTER                         0x829A
#define GL_VERTEX_TEXTURE                 0x829B
#define GL_TESS_CONTROL_TEXTURE           0x829C
#define GL_TESS_EVALUATION_TEXTURE        0x829D
#define GL_GEOMETRY_TEXTURE               0x829E
#define GL_FRAGMENT_TEXTURE               0x829F
#define GL_COMPUTE_TEXTURE                0x82A0
#define GL_TEXTURE_SHADOW                 0x82A1
#define GL_TEXTURE_GATHER                 0x82A2
#define GL_TEXTURE_GATHER_SHADOW          0x82A3
#define GL_SHADER_IMAGE_LOAD              0x82A4
#define GL_SHADER_IMAGE_STORE             0x82A5
#define GL_SHADER_IMAGE_ATOMIC            0x82A6
#define GL_IMAGE_TEXEL_SIZE               0x82A7
#define GL_IMAGE_COMPATIBILITY_CLASS      0x82A8
#define GL_IMAGE_PIXEL_FORMAT             0x82A9
#define GL_IMAGE_PIXEL_TYPE               0x82AA
#define GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST 0x82AC
#define GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST 0x82AD
#define GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE 0x82AE
#define GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE 0x82AF
#define GL_TEXTURE_COMPRESSED_BLOCK_WIDTH 0x82B1
#define GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT 0x82B2
#define GL_TEXTURE_COMPRESSED_BLOCK_SIZE  0x82B3
#define GL_CLEAR_BUFFER                   0x82B4
#define GL_TEXTURE_VIEW                   0x82B5
#define GL_VIEW_COMPATIBILITY_CLASS       0x82B6
#define GL_FULL_SUPPORT                   0x82B7
#define GL_CAVEAT_SUPPORT                 0x82B8
#define GL_IMAGE_CLASS_4_X_32             0x82B9
#define GL_IMAGE_CLASS_2_X_32             0x82BA
#define GL_IMAGE_CLASS_1_X_32             0x82BB
#define GL_IMAGE_CLASS_4_X_16             0x82BC
#define GL_IMAGE_CLASS_2_X_16             0x82BD
#define GL_IMAGE_CLASS_1_X_16             0x82BE
#define GL_IMAGE_CLASS_4_X_8              0x82BF
#define GL_IMAGE_CLASS_2_X_8              0x82C0
#define GL_IMAGE_CLASS_1_X_8              0x82C1
#define GL_IMAGE_CLASS_11_11_10           0x82C2
#define GL_IMAGE_CLASS_10_10_10_2         0x82C3
#define GL_VIEW_CLASS_128_BITS            0x82C4
#define GL_VIEW_CLASS_96_BITS             0x82C5
#define GL_VIEW_CLASS_64_BITS             0x82C6
#define GL_VIEW_CLASS_48_BITS             0x82C7
#define GL_VIEW_CLASS_32_BITS             0x82C8
#define GL_VIEW_CLASS_24_BITS             0x82C9
#define GL_VIEW_CLASS_16_BITS             0x82CA
#define GL_VIEW_CLASS_8_BITS              0x82CB
#define GL_VIEW_CLASS_S3TC_DXT1_RGB       0x82CC
#define GL_VIEW_CLASS_S3TC_DXT1_RGBA      0x82CD
#define GL_VIEW_CLASS_S3TC_DXT3_RGBA      0x82CE
#define GL_VIEW_CLASS_S3TC_DXT5_RGBA      0x82CF
#define GL_VIEW_CLASS_RGTC1_RED           0x82D0
#define GL_VIEW_CLASS_RGTC2_RG            0x82D1
#define GL_VIEW_CLASS_BPTC_UNORM          0x82D2
#define GL_VIEW_CLASS_BPTC_FLOAT          0x82D3
#define GL_UNIFORM                        0x92E1
#define GL_UNIFORM_BLOCK                  0x92E2
#define GL_PROGRAM_INPUT                  0x92E3
#define GL_PROGRAM_OUTPUT                 0x92E4
#define GL_BUFFER_VARIABLE                0x92E5
#define GL_SHADER_STORAGE_BLOCK           0x92E6
#define GL_VERTEX_SUBROUTINE              0x92E8
#define GL_TESS_CONTROL_SUBROUTINE        0x92E9
#define GL_TESS_EVALUATION_SUBROUTINE     0x92EA
#define GL_GEOMETRY_SUBROUTINE            0x92EB
#define GL_FRAGMENT_SUBROUTINE            0x92EC
#define GL_COMPUTE_SUBROUTINE             0x92ED
#define GL_VERTEX_SUBROUTINE_UNIFORM      0x92EE
#define GL_TESS_CONTROL_SUBROUTINE_UNIFORM 0x92EF
#define GL_TESS_EVALUATION_SUBROUTINE_UNIFORM 0x92F0
#define GL_GEOMETRY_SUBROUTINE_UNIFORM    0x92F1
#define GL_FRAGMENT_SUBROUTINE_UNIFORM    0x92F2
#define GL_COMPUTE_SUBROUTINE_UNIFORM     0x92F3
#define GL_TRANSFORM_FEEDBACK_VARYING     0x92F4
#define GL_ACTIVE_RESOURCES               0x92F5
#define GL_MAX_NAME_LENGTH                0x92F6
#define GL_MAX_NUM_ACTIVE_VARIABLES       0x92F7
#define GL_MAX_NUM_COMPATIBLE_SUBROUTINES 0x92F8
#define GL_NAME_LENGTH                    0x92F9
#define GL_TYPE                           0x92FA
#define GL_ARRAY_SIZE                     0x92FB
#define GL_OFFSET                         0x92FC
#define GL_BLOCK_INDEX                    0x92FD
#define GL_ARRAY_STRIDE                   0x92FE
#define GL_MATRIX_STRIDE                  0x92FF
#define GL_IS_ROW_MAJOR                   0x9300
#define GL_ATOMIC_COUNTER_BUFFER_INDEX    0x9301
#define GL_BUFFER_BINDING                 0x9302
#define GL_BUFFER_DATA_SIZE               0x9303
#define GL_NUM_ACTIVE_VARIABLES           0x9304
#define GL_ACTIVE_VARIABLES               0x9305
#define GL_REFERENCED_BY_VERTEX_SHADER    0x9306
#define GL_REFERENCED_BY_TESS_CONTROL_SHADER 0x9307
#define GL_REFERENCED_BY_TESS_EVALUATION_SHADER 0x9308
#define GL_REFERENCED_BY_GEOMETRY_SHADER  0x9309
#define GL_REFERENCED_BY_FRAGMENT_SHADER  0x930A
#define GL_REFERENCED_BY_COMPUTE_SHADER   0x930B
#define GL_TOP_LEVEL_ARRAY_SIZE           0x930C
#define GL_TOP_LEVEL_ARRAY_STRIDE         0x930D
#define GL_LOCATION                       0x930E
#define GL_LOCATION_INDEX                 0x930F
#define GL_IS_PER_PATCH                   0x92E7
#define GL_SHADER_STORAGE_BUFFER          0x90D2
#define GL_SHADER_STORAGE_BUFFER_BINDING  0x90D3
#define GL_SHADER_STORAGE_BUFFER_START    0x90D4
#define GL_SHADER_STORAGE_BUFFER_SIZE     0x90D5
#define GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS 0x90D6
#define GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS 0x90D7
#define GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS 0x90D8
#define GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS 0x90D9
#define GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS 0x90DA
#define GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS 0x90DB
#define GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS 0x90DC
#define GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS 0x90DD
#define GL_MAX_SHADER_STORAGE_BLOCK_SIZE  0x90DE
#define GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT 0x90DF
#define GL_SHADER_STORAGE_BARRIER_BIT     0x00002000
#define GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES 0x8F39
#define GL_DEPTH_STENCIL_TEXTURE_MODE     0x90EA
#define GL_TEXTURE_BUFFER_OFFSET          0x919D
#define GL_TEXTURE_BUFFER_SIZE            0x919E
#define GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT 0x919F
#define GL_TEXTURE_VIEW_MIN_LEVEL         0x82DB
#define GL_TEXTURE_VIEW_NUM_LEVELS        0x82DC
#define GL_TEXTURE_VIEW_MIN_LAYER         0x82DD
#define GL_TEXTURE_VIEW_NUM_LAYERS        0x82DE
#define GL_TEXTURE_IMMUTABLE_LEVELS       0x82DF
#define GL_VERTEX_ATTRIB_BINDING          0x82D4
#define GL_VERTEX_ATTRIB_RELATIVE_OFFSET  0x82D5
#define GL_VERTEX_BINDING_DIVISOR         0x82D6
#define GL_VERTEX_BINDING_OFFSET          0x82D7
#define GL_VERTEX_BINDING_STRIDE          0x82D8
#define GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET 0x82D9
#define GL_MAX_VERTEX_ATTRIB_BINDINGS     0x82DA
#define GL_VERTEX_BINDING_BUFFER          0x8F4F
	typedef void (APIENTRYP PFNGLCLEARBUFFERDATAPROC) (GLenum target, GLenum internalformat, GLenum format, GLenum type, const void* data);
	typedef void (APIENTRYP PFNGLCLEARBUFFERSUBDATAPROC) (GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void* data);
	typedef void (APIENTRYP PFNGLDISPATCHCOMPUTEPROC) (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
	typedef void (APIENTRYP PFNGLDISPATCHCOMPUTEINDIRECTPROC) (GLintptr indirect);
	typedef void (APIENTRYP PFNGLCOPYIMAGESUBDATAPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
	typedef void (APIENTRYP PFNGLFRAMEBUFFERPARAMETERIPROC) (GLenum target, GLenum pname, GLint param);
	typedef void (APIENTRYP PFNGLGETFRAMEBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLGETINTERNALFORMATI64VPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint64* params);
	typedef void (APIENTRYP PFNGLINVALIDATETEXSUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);
	typedef void (APIENTRYP PFNGLINVALIDATETEXIMAGEPROC) (GLuint texture, GLint level);
	typedef void (APIENTRYP PFNGLINVALIDATEBUFFERSUBDATAPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
	typedef void (APIENTRYP PFNGLINVALIDATEBUFFERDATAPROC) (GLuint buffer);
	typedef void (APIENTRYP PFNGLINVALIDATEFRAMEBUFFERPROC) (GLenum target, GLsizei numAttachments, const GLenum* attachments);
	typedef void (APIENTRYP PFNGLINVALIDATESUBFRAMEBUFFERPROC) (GLenum target, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLMULTIDRAWARRAYSINDIRECTPROC) (GLenum mode, const void* indirect, GLsizei drawcount, GLsizei stride);
	typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSINDIRECTPROC) (GLenum mode, GLenum type, const void* indirect, GLsizei drawcount, GLsizei stride);
	typedef void (APIENTRYP PFNGLGETPROGRAMINTERFACEIVPROC) (GLuint program, GLenum programInterface, GLenum pname, GLint* params);
	typedef GLuint(APIENTRYP PFNGLGETPROGRAMRESOURCEINDEXPROC) (GLuint program, GLenum programInterface, const GLchar* name);
	typedef void (APIENTRYP PFNGLGETPROGRAMRESOURCENAMEPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei* length, GLchar* name);
	typedef void (APIENTRYP PFNGLGETPROGRAMRESOURCEIVPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei count, GLsizei* length, GLint* params);
	typedef GLint(APIENTRYP PFNGLGETPROGRAMRESOURCELOCATIONPROC) (GLuint program, GLenum programInterface, const GLchar* name);
	typedef GLint(APIENTRYP PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC) (GLuint program, GLenum programInterface, const GLchar* name);
	typedef void (APIENTRYP PFNGLSHADERSTORAGEBLOCKBINDINGPROC) (GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);
	typedef void (APIENTRYP PFNGLTEXBUFFERRANGEPROC) (GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
	typedef void (APIENTRYP PFNGLTEXSTORAGE2DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
	typedef void (APIENTRYP PFNGLTEXSTORAGE3DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
	typedef void (APIENTRYP PFNGLTEXTUREVIEWPROC) (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
	typedef void (APIENTRYP PFNGLBINDVERTEXBUFFERPROC) (GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBIFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBLFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBBINDINGPROC) (GLuint attribindex, GLuint bindingindex);
	typedef void (APIENTRYP PFNGLVERTEXBINDINGDIVISORPROC) (GLuint bindingindex, GLuint divisor);
	typedef void (APIENTRYP PFNGLDEBUGMESSAGECONTROLPROC) (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
	typedef void (APIENTRYP PFNGLDEBUGMESSAGEINSERTPROC) (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf);
	typedef void (APIENTRYP PFNGLDEBUGMESSAGECALLBACKPROC) (GLDEBUGPROC callback, const void* userParam);
	typedef GLuint(APIENTRYP PFNGLGETDEBUGMESSAGELOGPROC) (GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog);
	typedef void (APIENTRYP PFNGLPUSHDEBUGGROUPPROC) (GLenum source, GLuint id, GLsizei length, const GLchar* message);
	typedef void (APIENTRYP PFNGLPOPDEBUGGROUPPROC) (void);
	typedef void (APIENTRYP PFNGLOBJECTLABELPROC) (GLenum identifier, GLuint name, GLsizei length, const GLchar* label);
	typedef void (APIENTRYP PFNGLGETOBJECTLABELPROC) (GLenum identifier, GLuint name, GLsizei bufSize, GLsizei* length, GLchar* label);
	typedef void (APIENTRYP PFNGLOBJECTPTRLABELPROC) (const void* ptr, GLsizei length, const GLchar* label);
	typedef void (APIENTRYP PFNGLGETOBJECTPTRLABELPROC) (const void* ptr, GLsizei bufSize, GLsizei* length, GLchar* label);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void* data);
	GLAPI void APIENTRY glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void* data);
	GLAPI void APIENTRY glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
	GLAPI void APIENTRY glDispatchComputeIndirect(GLintptr indirect);
	GLAPI void APIENTRY glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
	GLAPI void APIENTRY glFramebufferParameteri(GLenum target, GLenum pname, GLint param);
	GLAPI void APIENTRY glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint* params);
	GLAPI void APIENTRY glGetInternalformati64v(GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint64* params);
	GLAPI void APIENTRY glInvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);
	GLAPI void APIENTRY glInvalidateTexImage(GLuint texture, GLint level);
	GLAPI void APIENTRY glInvalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length);
	GLAPI void APIENTRY glInvalidateBufferData(GLuint buffer);
	GLAPI void APIENTRY glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum* attachments);
	GLAPI void APIENTRY glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glMultiDrawArraysIndirect(GLenum mode, const void* indirect, GLsizei drawcount, GLsizei stride);
	GLAPI void APIENTRY glMultiDrawElementsIndirect(GLenum mode, GLenum type, const void* indirect, GLsizei drawcount, GLsizei stride);
	GLAPI void APIENTRY glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint* params);
	GLAPI GLuint APIENTRY glGetProgramResourceIndex(GLuint program, GLenum programInterface, const GLchar* name);
	GLAPI void APIENTRY glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei* length, GLchar* name);
	GLAPI void APIENTRY glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei count, GLsizei* length, GLint* params);
	GLAPI GLint APIENTRY glGetProgramResourceLocation(GLuint program, GLenum programInterface, const GLchar* name);
	GLAPI GLint APIENTRY glGetProgramResourceLocationIndex(GLuint program, GLenum programInterface, const GLchar* name);
	GLAPI void APIENTRY glShaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);
	GLAPI void APIENTRY glTexBufferRange(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
	GLAPI void APIENTRY glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
	GLAPI void APIENTRY glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
	GLAPI void APIENTRY glTextureView(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
	GLAPI void APIENTRY glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
	GLAPI void APIENTRY glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
	GLAPI void APIENTRY glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
	GLAPI void APIENTRY glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
	GLAPI void APIENTRY glVertexAttribBinding(GLuint attribindex, GLuint bindingindex);
	GLAPI void APIENTRY glVertexBindingDivisor(GLuint bindingindex, GLuint divisor);
	GLAPI void APIENTRY glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
	GLAPI void APIENTRY glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf);
	GLAPI void APIENTRY glDebugMessageCallback(GLDEBUGPROC callback, const void* userParam);
	GLAPI GLuint APIENTRY glGetDebugMessageLog(GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog);
	GLAPI void APIENTRY glPushDebugGroup(GLenum source, GLuint id, GLsizei length, const GLchar* message);
	GLAPI void APIENTRY glPopDebugGroup(void);
	GLAPI void APIENTRY glObjectLabel(GLenum identifier, GLuint name, GLsizei length, const GLchar* label);
	GLAPI void APIENTRY glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei* length, GLchar* label);
	GLAPI void APIENTRY glObjectPtrLabel(const void* ptr, GLsizei length, const GLchar* label);
	GLAPI void APIENTRY glGetObjectPtrLabel(const void* ptr, GLsizei bufSize, GLsizei* length, GLchar* label);
#endif
#endif /* GL_VERSION_4_3 */

#ifndef GL_VERSION_4_4
#define GL_VERSION_4_4 1
#define GL_MAX_VERTEX_ATTRIB_STRIDE       0x82E5
#define GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED 0x8221
#define GL_TEXTURE_BUFFER_BINDING         0x8C2A
#define GL_MAP_PERSISTENT_BIT             0x0040
#define GL_MAP_COHERENT_BIT               0x0080
#define GL_DYNAMIC_STORAGE_BIT            0x0100
#define GL_CLIENT_STORAGE_BIT             0x0200
#define GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT 0x00004000
#define GL_BUFFER_IMMUTABLE_STORAGE       0x821F
#define GL_BUFFER_STORAGE_FLAGS           0x8220
#define GL_CLEAR_TEXTURE                  0x9365
#define GL_LOCATION_COMPONENT             0x934A
#define GL_TRANSFORM_FEEDBACK_BUFFER_INDEX 0x934B
#define GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE 0x934C
#define GL_QUERY_BUFFER                   0x9192
#define GL_QUERY_BUFFER_BARRIER_BIT       0x00008000
#define GL_QUERY_BUFFER_BINDING           0x9193
#define GL_QUERY_RESULT_NO_WAIT           0x9194
#define GL_MIRROR_CLAMP_TO_EDGE           0x8743
	typedef void (APIENTRYP PFNGLBUFFERSTORAGEPROC) (GLenum target, GLsizeiptr size, const void* data, GLbitfield flags);
	typedef void (APIENTRYP PFNGLCLEARTEXIMAGEPROC) (GLuint texture, GLint level, GLenum format, GLenum type, const void* data);
	typedef void (APIENTRYP PFNGLCLEARTEXSUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* data);
	typedef void (APIENTRYP PFNGLBINDBUFFERSBASEPROC) (GLenum target, GLuint first, GLsizei count, const GLuint* buffers);
	typedef void (APIENTRYP PFNGLBINDBUFFERSRANGEPROC) (GLenum target, GLuint first, GLsizei count, const GLuint* buffers, const GLintptr* offsets, const GLsizeiptr* sizes);
	typedef void (APIENTRYP PFNGLBINDTEXTURESPROC) (GLuint first, GLsizei count, const GLuint* textures);
	typedef void (APIENTRYP PFNGLBINDSAMPLERSPROC) (GLuint first, GLsizei count, const GLuint* samplers);
	typedef void (APIENTRYP PFNGLBINDIMAGETEXTURESPROC) (GLuint first, GLsizei count, const GLuint* textures);
	typedef void (APIENTRYP PFNGLBINDVERTEXBUFFERSPROC) (GLuint first, GLsizei count, const GLuint* buffers, const GLintptr* offsets, const GLsizei* strides);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glBufferStorage(GLenum target, GLsizeiptr size, const void* data, GLbitfield flags);
	GLAPI void APIENTRY glClearTexImage(GLuint texture, GLint level, GLenum format, GLenum type, const void* data);
	GLAPI void APIENTRY glClearTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* data);
	GLAPI void APIENTRY glBindBuffersBase(GLenum target, GLuint first, GLsizei count, const GLuint* buffers);
	GLAPI void APIENTRY glBindBuffersRange(GLenum target, GLuint first, GLsizei count, const GLuint* buffers, const GLintptr* offsets, const GLsizeiptr* sizes);
	GLAPI void APIENTRY glBindTextures(GLuint first, GLsizei count, const GLuint* textures);
	GLAPI void APIENTRY glBindSamplers(GLuint first, GLsizei count, const GLuint* samplers);
	GLAPI void APIENTRY glBindImageTextures(GLuint first, GLsizei count, const GLuint* textures);
	GLAPI void APIENTRY glBindVertexBuffers(GLuint first, GLsizei count, const GLuint* buffers, const GLintptr* offsets, const GLsizei* strides);
#endif
#endif /* GL_VERSION_4_4 */

#ifndef GL_VERSION_4_5
#define GL_VERSION_4_5 1
#define GL_CONTEXT_LOST                   0x0507
#define GL_NEGATIVE_ONE_TO_ONE            0x935E
#define GL_ZERO_TO_ONE                    0x935F
#define GL_CLIP_ORIGIN                    0x935C
#define GL_CLIP_DEPTH_MODE                0x935D
#define GL_QUERY_WAIT_INVERTED            0x8E17
#define GL_QUERY_NO_WAIT_INVERTED         0x8E18
#define GL_QUERY_BY_REGION_WAIT_INVERTED  0x8E19
#define GL_QUERY_BY_REGION_NO_WAIT_INVERTED 0x8E1A
#define GL_MAX_CULL_DISTANCES             0x82F9
#define GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES 0x82FA
#define GL_TEXTURE_TARGET                 0x1006
#define GL_QUERY_TARGET                   0x82EA
#define GL_GUILTY_CONTEXT_RESET           0x8253
#define GL_INNOCENT_CONTEXT_RESET         0x8254
#define GL_UNKNOWN_CONTEXT_RESET          0x8255
#define GL_RESET_NOTIFICATION_STRATEGY    0x8256
#define GL_LOSE_CONTEXT_ON_RESET          0x8252
#define GL_NO_RESET_NOTIFICATION          0x8261
#define GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT 0x00000004
#define GL_CONTEXT_RELEASE_BEHAVIOR       0x82FB
#define GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH 0x82FC
	typedef void (APIENTRYP PFNGLCLIPCONTROLPROC) (GLenum origin, GLenum depth);
	typedef void (APIENTRYP PFNGLCREATETRANSFORMFEEDBACKSPROC) (GLsizei n, GLuint* ids);
	typedef void (APIENTRYP PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC) (GLuint xfb, GLuint index, GLuint buffer);
	typedef void (APIENTRYP PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC) (GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
	typedef void (APIENTRYP PFNGLGETTRANSFORMFEEDBACKIVPROC) (GLuint xfb, GLenum pname, GLint* param);
	typedef void (APIENTRYP PFNGLGETTRANSFORMFEEDBACKI_VPROC) (GLuint xfb, GLenum pname, GLuint index, GLint* param);
	typedef void (APIENTRYP PFNGLGETTRANSFORMFEEDBACKI64_VPROC) (GLuint xfb, GLenum pname, GLuint index, GLint64* param);
	typedef void (APIENTRYP PFNGLCREATEBUFFERSPROC) (GLsizei n, GLuint* buffers);
	typedef void (APIENTRYP PFNGLNAMEDBUFFERSTORAGEPROC) (GLuint buffer, GLsizeiptr size, const void* data, GLbitfield flags);
	typedef void (APIENTRYP PFNGLNAMEDBUFFERDATAPROC) (GLuint buffer, GLsizeiptr size, const void* data, GLenum usage);
	typedef void (APIENTRYP PFNGLNAMEDBUFFERSUBDATAPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, const void* data);
	typedef void (APIENTRYP PFNGLCOPYNAMEDBUFFERSUBDATAPROC) (GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
	typedef void (APIENTRYP PFNGLCLEARNAMEDBUFFERDATAPROC) (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void* data);
	typedef void (APIENTRYP PFNGLCLEARNAMEDBUFFERSUBDATAPROC) (GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void* data);
	typedef void* (APIENTRYP PFNGLMAPNAMEDBUFFERPROC) (GLuint buffer, GLenum access);
	typedef void* (APIENTRYP PFNGLMAPNAMEDBUFFERRANGEPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
	typedef GLboolean(APIENTRYP PFNGLUNMAPNAMEDBUFFERPROC) (GLuint buffer);
	typedef void (APIENTRYP PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
	typedef void (APIENTRYP PFNGLGETNAMEDBUFFERPARAMETERIVPROC) (GLuint buffer, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLGETNAMEDBUFFERPARAMETERI64VPROC) (GLuint buffer, GLenum pname, GLint64* params);
	typedef void (APIENTRYP PFNGLGETNAMEDBUFFERPOINTERVPROC) (GLuint buffer, GLenum pname, void** params);
	typedef void (APIENTRYP PFNGLGETNAMEDBUFFERSUBDATAPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, void* data);
	typedef void (APIENTRYP PFNGLCREATEFRAMEBUFFERSPROC) (GLsizei n, GLuint* framebuffers);
	typedef void (APIENTRYP PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC) (GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
	typedef void (APIENTRYP PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC) (GLuint framebuffer, GLenum pname, GLint param);
	typedef void (APIENTRYP PFNGLNAMEDFRAMEBUFFERTEXTUREPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
	typedef void (APIENTRYP PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
	typedef void (APIENTRYP PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC) (GLuint framebuffer, GLenum buf);
	typedef void (APIENTRYP PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC) (GLuint framebuffer, GLsizei n, const GLenum* bufs);
	typedef void (APIENTRYP PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC) (GLuint framebuffer, GLenum src);
	typedef void (APIENTRYP PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC) (GLuint framebuffer, GLsizei numAttachments, const GLenum* attachments);
	typedef void (APIENTRYP PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC) (GLuint framebuffer, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLCLEARNAMEDFRAMEBUFFERIVPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint* value);
	typedef void (APIENTRYP PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint* value);
	typedef void (APIENTRYP PFNGLCLEARNAMEDFRAMEBUFFERFVPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat* value);
	typedef void (APIENTRYP PFNGLCLEARNAMEDFRAMEBUFFERFIPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
	typedef void (APIENTRYP PFNGLBLITNAMEDFRAMEBUFFERPROC) (GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
	typedef GLenum(APIENTRYP PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC) (GLuint framebuffer, GLenum target);
	typedef void (APIENTRYP PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC) (GLuint framebuffer, GLenum pname, GLint* param);
	typedef void (APIENTRYP PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC) (GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLCREATERENDERBUFFERSPROC) (GLsizei n, GLuint* renderbuffers);
	typedef void (APIENTRYP PFNGLNAMEDRENDERBUFFERSTORAGEPROC) (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC) (GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC) (GLuint renderbuffer, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLCREATETEXTURESPROC) (GLenum target, GLsizei n, GLuint* textures);
	typedef void (APIENTRYP PFNGLTEXTUREBUFFERPROC) (GLuint texture, GLenum internalformat, GLuint buffer);
	typedef void (APIENTRYP PFNGLTEXTUREBUFFERRANGEPROC) (GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
	typedef void (APIENTRYP PFNGLTEXTURESTORAGE1DPROC) (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width);
	typedef void (APIENTRYP PFNGLTEXTURESTORAGE2DPROC) (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLTEXTURESTORAGE3DPROC) (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
	typedef void (APIENTRYP PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC) (GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
	typedef void (APIENTRYP PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC) (GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
	typedef void (APIENTRYP PFNGLTEXTURESUBIMAGE1DPROC) (GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void* pixels);
	typedef void (APIENTRYP PFNGLTEXTURESUBIMAGE2DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels);
	typedef void (APIENTRYP PFNGLTEXTURESUBIMAGE3DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels);
	typedef void (APIENTRYP PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC) (GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void* data);
	typedef void (APIENTRYP PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* data);
	typedef void (APIENTRYP PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* data);
	typedef void (APIENTRYP PFNGLCOPYTEXTURESUBIMAGE1DPROC) (GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
	typedef void (APIENTRYP PFNGLCOPYTEXTURESUBIMAGE2DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLCOPYTEXTURESUBIMAGE3DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLTEXTUREPARAMETERFPROC) (GLuint texture, GLenum pname, GLfloat param);
	typedef void (APIENTRYP PFNGLTEXTUREPARAMETERFVPROC) (GLuint texture, GLenum pname, const GLfloat* param);
	typedef void (APIENTRYP PFNGLTEXTUREPARAMETERIPROC) (GLuint texture, GLenum pname, GLint param);
	typedef void (APIENTRYP PFNGLTEXTUREPARAMETERIIVPROC) (GLuint texture, GLenum pname, const GLint* params);
	typedef void (APIENTRYP PFNGLTEXTUREPARAMETERIUIVPROC) (GLuint texture, GLenum pname, const GLuint* params);
	typedef void (APIENTRYP PFNGLTEXTUREPARAMETERIVPROC) (GLuint texture, GLenum pname, const GLint* param);
	typedef void (APIENTRYP PFNGLGENERATETEXTUREMIPMAPPROC) (GLuint texture);
	typedef void (APIENTRYP PFNGLBINDTEXTUREUNITPROC) (GLuint unit, GLuint texture);
	typedef void (APIENTRYP PFNGLGETTEXTUREIMAGEPROC) (GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* pixels);
	typedef void (APIENTRYP PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC) (GLuint texture, GLint level, GLsizei bufSize, void* pixels);
	typedef void (APIENTRYP PFNGLGETTEXTURELEVELPARAMETERFVPROC) (GLuint texture, GLint level, GLenum pname, GLfloat* params);
	typedef void (APIENTRYP PFNGLGETTEXTURELEVELPARAMETERIVPROC) (GLuint texture, GLint level, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLGETTEXTUREPARAMETERFVPROC) (GLuint texture, GLenum pname, GLfloat* params);
	typedef void (APIENTRYP PFNGLGETTEXTUREPARAMETERIIVPROC) (GLuint texture, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLGETTEXTUREPARAMETERIUIVPROC) (GLuint texture, GLenum pname, GLuint* params);
	typedef void (APIENTRYP PFNGLGETTEXTUREPARAMETERIVPROC) (GLuint texture, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLCREATEVERTEXARRAYSPROC) (GLsizei n, GLuint* arrays);
	typedef void (APIENTRYP PFNGLDISABLEVERTEXARRAYATTRIBPROC) (GLuint vaobj, GLuint index);
	typedef void (APIENTRYP PFNGLENABLEVERTEXARRAYATTRIBPROC) (GLuint vaobj, GLuint index);
	typedef void (APIENTRYP PFNGLVERTEXARRAYELEMENTBUFFERPROC) (GLuint vaobj, GLuint buffer);
	typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXBUFFERPROC) (GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
	typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXBUFFERSPROC) (GLuint vaobj, GLuint first, GLsizei count, const GLuint* buffers, const GLintptr* offsets, const GLsizei* strides);
	typedef void (APIENTRYP PFNGLVERTEXARRAYATTRIBBINDINGPROC) (GLuint vaobj, GLuint attribindex, GLuint bindingindex);
	typedef void (APIENTRYP PFNGLVERTEXARRAYATTRIBFORMATPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
	typedef void (APIENTRYP PFNGLVERTEXARRAYATTRIBIFORMATPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
	typedef void (APIENTRYP PFNGLVERTEXARRAYATTRIBLFORMATPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
	typedef void (APIENTRYP PFNGLVERTEXARRAYBINDINGDIVISORPROC) (GLuint vaobj, GLuint bindingindex, GLuint divisor);
	typedef void (APIENTRYP PFNGLGETVERTEXARRAYIVPROC) (GLuint vaobj, GLenum pname, GLint* param);
	typedef void (APIENTRYP PFNGLGETVERTEXARRAYINDEXEDIVPROC) (GLuint vaobj, GLuint index, GLenum pname, GLint* param);
	typedef void (APIENTRYP PFNGLGETVERTEXARRAYINDEXED64IVPROC) (GLuint vaobj, GLuint index, GLenum pname, GLint64* param);
	typedef void (APIENTRYP PFNGLCREATESAMPLERSPROC) (GLsizei n, GLuint* samplers);
	typedef void (APIENTRYP PFNGLCREATEPROGRAMPIPELINESPROC) (GLsizei n, GLuint* pipelines);
	typedef void (APIENTRYP PFNGLCREATEQUERIESPROC) (GLenum target, GLsizei n, GLuint* ids);
	typedef void (APIENTRYP PFNGLGETQUERYBUFFEROBJECTI64VPROC) (GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
	typedef void (APIENTRYP PFNGLGETQUERYBUFFEROBJECTIVPROC) (GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
	typedef void (APIENTRYP PFNGLGETQUERYBUFFEROBJECTUI64VPROC) (GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
	typedef void (APIENTRYP PFNGLGETQUERYBUFFEROBJECTUIVPROC) (GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
	typedef void (APIENTRYP PFNGLMEMORYBARRIERBYREGIONPROC) (GLbitfield barriers);
	typedef void (APIENTRYP PFNGLGETTEXTURESUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void* pixels);
	typedef void (APIENTRYP PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void* pixels);
	typedef GLenum(APIENTRYP PFNGLGETGRAPHICSRESETSTATUSPROC) (void);
	typedef void (APIENTRYP PFNGLGETNCOMPRESSEDTEXIMAGEPROC) (GLenum target, GLint lod, GLsizei bufSize, void* pixels);
	typedef void (APIENTRYP PFNGLGETNTEXIMAGEPROC) (GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* pixels);
	typedef void (APIENTRYP PFNGLGETNUNIFORMDVPROC) (GLuint program, GLint location, GLsizei bufSize, GLdouble* params);
	typedef void (APIENTRYP PFNGLGETNUNIFORMFVPROC) (GLuint program, GLint location, GLsizei bufSize, GLfloat* params);
	typedef void (APIENTRYP PFNGLGETNUNIFORMIVPROC) (GLuint program, GLint location, GLsizei bufSize, GLint* params);
	typedef void (APIENTRYP PFNGLGETNUNIFORMUIVPROC) (GLuint program, GLint location, GLsizei bufSize, GLuint* params);
	typedef void (APIENTRYP PFNGLREADNPIXELSPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data);
	typedef void (APIENTRYP PFNGLTEXTUREBARRIERPROC) (void);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glClipControl(GLenum origin, GLenum depth);
	GLAPI void APIENTRY glCreateTransformFeedbacks(GLsizei n, GLuint* ids);
	GLAPI void APIENTRY glTransformFeedbackBufferBase(GLuint xfb, GLuint index, GLuint buffer);
	GLAPI void APIENTRY glTransformFeedbackBufferRange(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
	GLAPI void APIENTRY glGetTransformFeedbackiv(GLuint xfb, GLenum pname, GLint* param);
	GLAPI void APIENTRY glGetTransformFeedbacki_v(GLuint xfb, GLenum pname, GLuint index, GLint* param);
	GLAPI void APIENTRY glGetTransformFeedbacki64_v(GLuint xfb, GLenum pname, GLuint index, GLint64* param);
	GLAPI void APIENTRY glCreateBuffers(GLsizei n, GLuint* buffers);
	GLAPI void APIENTRY glNamedBufferStorage(GLuint buffer, GLsizeiptr size, const void* data, GLbitfield flags);
	GLAPI void APIENTRY glNamedBufferData(GLuint buffer, GLsizeiptr size, const void* data, GLenum usage);
	GLAPI void APIENTRY glNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, const void* data);
	GLAPI void APIENTRY glCopyNamedBufferSubData(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
	GLAPI void APIENTRY glClearNamedBufferData(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void* data);
	GLAPI void APIENTRY glClearNamedBufferSubData(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void* data);
	GLAPI void* APIENTRY glMapNamedBuffer(GLuint buffer, GLenum access);
	GLAPI void* APIENTRY glMapNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
	GLAPI GLboolean APIENTRY glUnmapNamedBuffer(GLuint buffer);
	GLAPI void APIENTRY glFlushMappedNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length);
	GLAPI void APIENTRY glGetNamedBufferParameteriv(GLuint buffer, GLenum pname, GLint* params);
	GLAPI void APIENTRY glGetNamedBufferParameteri64v(GLuint buffer, GLenum pname, GLint64* params);
	GLAPI void APIENTRY glGetNamedBufferPointerv(GLuint buffer, GLenum pname, void** params);
	GLAPI void APIENTRY glGetNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, void* data);
	GLAPI void APIENTRY glCreateFramebuffers(GLsizei n, GLuint* framebuffers);
	GLAPI void APIENTRY glNamedFramebufferRenderbuffer(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
	GLAPI void APIENTRY glNamedFramebufferParameteri(GLuint framebuffer, GLenum pname, GLint param);
	GLAPI void APIENTRY glNamedFramebufferTexture(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
	GLAPI void APIENTRY glNamedFramebufferTextureLayer(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
	GLAPI void APIENTRY glNamedFramebufferDrawBuffer(GLuint framebuffer, GLenum buf);
	GLAPI void APIENTRY glNamedFramebufferDrawBuffers(GLuint framebuffer, GLsizei n, const GLenum* bufs);
	GLAPI void APIENTRY glNamedFramebufferReadBuffer(GLuint framebuffer, GLenum src);
	GLAPI void APIENTRY glInvalidateNamedFramebufferData(GLuint framebuffer, GLsizei numAttachments, const GLenum* attachments);
	GLAPI void APIENTRY glInvalidateNamedFramebufferSubData(GLuint framebuffer, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glClearNamedFramebufferiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint* value);
	GLAPI void APIENTRY glClearNamedFramebufferuiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint* value);
	GLAPI void APIENTRY glClearNamedFramebufferfv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat* value);
	GLAPI void APIENTRY glClearNamedFramebufferfi(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
	GLAPI void APIENTRY glBlitNamedFramebuffer(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
	GLAPI GLenum APIENTRY glCheckNamedFramebufferStatus(GLuint framebuffer, GLenum target);
	GLAPI void APIENTRY glGetNamedFramebufferParameteriv(GLuint framebuffer, GLenum pname, GLint* param);
	GLAPI void APIENTRY glGetNamedFramebufferAttachmentParameteriv(GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params);
	GLAPI void APIENTRY glCreateRenderbuffers(GLsizei n, GLuint* renderbuffers);
	GLAPI void APIENTRY glNamedRenderbufferStorage(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glNamedRenderbufferStorageMultisample(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glGetNamedRenderbufferParameteriv(GLuint renderbuffer, GLenum pname, GLint* params);
	GLAPI void APIENTRY glCreateTextures(GLenum target, GLsizei n, GLuint* textures);
	GLAPI void APIENTRY glTextureBuffer(GLuint texture, GLenum internalformat, GLuint buffer);
	GLAPI void APIENTRY glTextureBufferRange(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
	GLAPI void APIENTRY glTextureStorage1D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width);
	GLAPI void APIENTRY glTextureStorage2D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glTextureStorage3D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
	GLAPI void APIENTRY glTextureStorage2DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
	GLAPI void APIENTRY glTextureStorage3DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
	GLAPI void APIENTRY glTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void* pixels);
	GLAPI void APIENTRY glTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels);
	GLAPI void APIENTRY glTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels);
	GLAPI void APIENTRY glCompressedTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void* data);
	GLAPI void APIENTRY glCompressedTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* data);
	GLAPI void APIENTRY glCompressedTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* data);
	GLAPI void APIENTRY glCopyTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
	GLAPI void APIENTRY glCopyTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glCopyTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glTextureParameterf(GLuint texture, GLenum pname, GLfloat param);
	GLAPI void APIENTRY glTextureParameterfv(GLuint texture, GLenum pname, const GLfloat* param);
	GLAPI void APIENTRY glTextureParameteri(GLuint texture, GLenum pname, GLint param);
	GLAPI void APIENTRY glTextureParameterIiv(GLuint texture, GLenum pname, const GLint* params);
	GLAPI void APIENTRY glTextureParameterIuiv(GLuint texture, GLenum pname, const GLuint* params);
	GLAPI void APIENTRY glTextureParameteriv(GLuint texture, GLenum pname, const GLint* param);
	GLAPI void APIENTRY glGenerateTextureMipmap(GLuint texture);
	GLAPI void APIENTRY glBindTextureUnit(GLuint unit, GLuint texture);
	GLAPI void APIENTRY glGetTextureImage(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* pixels);
	GLAPI void APIENTRY glGetCompressedTextureImage(GLuint texture, GLint level, GLsizei bufSize, void* pixels);
	GLAPI void APIENTRY glGetTextureLevelParameterfv(GLuint texture, GLint level, GLenum pname, GLfloat* params);
	GLAPI void APIENTRY glGetTextureLevelParameteriv(GLuint texture, GLint level, GLenum pname, GLint* params);
	GLAPI void APIENTRY glGetTextureParameterfv(GLuint texture, GLenum pname, GLfloat* params);
	GLAPI void APIENTRY glGetTextureParameterIiv(GLuint texture, GLenum pname, GLint* params);
	GLAPI void APIENTRY glGetTextureParameterIuiv(GLuint texture, GLenum pname, GLuint* params);
	GLAPI void APIENTRY glGetTextureParameteriv(GLuint texture, GLenum pname, GLint* params);
	GLAPI void APIENTRY glCreateVertexArrays(GLsizei n, GLuint* arrays);
	GLAPI void APIENTRY glDisableVertexArrayAttrib(GLuint vaobj, GLuint index);
	GLAPI void APIENTRY glEnableVertexArrayAttrib(GLuint vaobj, GLuint index);
	GLAPI void APIENTRY glVertexArrayElementBuffer(GLuint vaobj, GLuint buffer);
	GLAPI void APIENTRY glVertexArrayVertexBuffer(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
	GLAPI void APIENTRY glVertexArrayVertexBuffers(GLuint vaobj, GLuint first, GLsizei count, const GLuint* buffers, const GLintptr* offsets, const GLsizei* strides);
	GLAPI void APIENTRY glVertexArrayAttribBinding(GLuint vaobj, GLuint attribindex, GLuint bindingindex);
	GLAPI void APIENTRY glVertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
	GLAPI void APIENTRY glVertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
	GLAPI void APIENTRY glVertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
	GLAPI void APIENTRY glVertexArrayBindingDivisor(GLuint vaobj, GLuint bindingindex, GLuint divisor);
	GLAPI void APIENTRY glGetVertexArrayiv(GLuint vaobj, GLenum pname, GLint* param);
	GLAPI void APIENTRY glGetVertexArrayIndexediv(GLuint vaobj, GLuint index, GLenum pname, GLint* param);
	GLAPI void APIENTRY glGetVertexArrayIndexed64iv(GLuint vaobj, GLuint index, GLenum pname, GLint64* param);
	GLAPI void APIENTRY glCreateSamplers(GLsizei n, GLuint* samplers);
	GLAPI void APIENTRY glCreateProgramPipelines(GLsizei n, GLuint* pipelines);
	GLAPI void APIENTRY glCreateQueries(GLenum target, GLsizei n, GLuint* ids);
	GLAPI void APIENTRY glGetQueryBufferObjecti64v(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
	GLAPI void APIENTRY glGetQueryBufferObjectiv(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
	GLAPI void APIENTRY glGetQueryBufferObjectui64v(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
	GLAPI void APIENTRY glGetQueryBufferObjectuiv(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
	GLAPI void APIENTRY glMemoryBarrierByRegion(GLbitfield barriers);
	GLAPI void APIENTRY glGetTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void* pixels);
	GLAPI void APIENTRY glGetCompressedTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void* pixels);
	GLAPI GLenum APIENTRY glGetGraphicsResetStatus(void);
	GLAPI void APIENTRY glGetnCompressedTexImage(GLenum target, GLint lod, GLsizei bufSize, void* pixels);
	GLAPI void APIENTRY glGetnTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* pixels);
	GLAPI void APIENTRY glGetnUniformdv(GLuint program, GLint location, GLsizei bufSize, GLdouble* params);
	GLAPI void APIENTRY glGetnUniformfv(GLuint program, GLint location, GLsizei bufSize, GLfloat* params);
	GLAPI void APIENTRY glGetnUniformiv(GLuint program, GLint location, GLsizei bufSize, GLint* params);
	GLAPI void APIENTRY glGetnUniformuiv(GLuint program, GLint location, GLsizei bufSize, GLuint* params);
	GLAPI void APIENTRY glReadnPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data);
	GLAPI void APIENTRY glTextureBarrier(void);
#endif
#endif /* GL_VERSION_4_5 */

#ifndef GL_VERSION_4_6
#define GL_VERSION_4_6 1
#define GL_SHADER_BINARY_FORMAT_SPIR_V    0x9551
#define GL_SPIR_V_BINARY                  0x9552
#define GL_PARAMETER_BUFFER               0x80EE
#define GL_PARAMETER_BUFFER_BINDING       0x80EF
#define GL_CONTEXT_FLAG_NO_ERROR_BIT      0x00000008
#define GL_VERTICES_SUBMITTED             0x82EE
#define GL_PRIMITIVES_SUBMITTED           0x82EF
#define GL_VERTEX_SHADER_INVOCATIONS      0x82F0
#define GL_TESS_CONTROL_SHADER_PATCHES    0x82F1
#define GL_TESS_EVALUATION_SHADER_INVOCATIONS 0x82F2
#define GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED 0x82F3
#define GL_FRAGMENT_SHADER_INVOCATIONS    0x82F4
#define GL_COMPUTE_SHADER_INVOCATIONS     0x82F5
#define GL_CLIPPING_INPUT_PRIMITIVES      0x82F6
#define GL_CLIPPING_OUTPUT_PRIMITIVES     0x82F7
#define GL_POLYGON_OFFSET_CLAMP           0x8E1B
#define GL_SPIR_V_EXTENSIONS              0x9553
#define GL_NUM_SPIR_V_EXTENSIONS          0x9554
#define GL_TEXTURE_MAX_ANISOTROPY         0x84FE
#define GL_MAX_TEXTURE_MAX_ANISOTROPY     0x84FF
#define GL_TRANSFORM_FEEDBACK_OVERFLOW    0x82EC
#define GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW 0x82ED
	typedef void (APIENTRYP PFNGLSPECIALIZESHADERPROC) (GLuint shader, const GLchar* pEntryPoint, GLuint numSpecializationConstants, const GLuint* pConstantIndex, const GLuint* pConstantValue);
	typedef void (APIENTRYP PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC) (GLenum mode, const void* indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
	typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC) (GLenum mode, GLenum type, const void* indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
	typedef void (APIENTRYP PFNGLPOLYGONOFFSETCLAMPPROC) (GLfloat factor, GLfloat units, GLfloat clamp);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glSpecializeShader(GLuint shader, const GLchar* pEntryPoint, GLuint numSpecializationConstants, const GLuint* pConstantIndex, const GLuint* pConstantValue);
	GLAPI void APIENTRY glMultiDrawArraysIndirectCount(GLenum mode, const void* indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
	GLAPI void APIENTRY glMultiDrawElementsIndirectCount(GLenum mode, GLenum type, const void* indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
	GLAPI void APIENTRY glPolygonOffsetClamp(GLfloat factor, GLfloat units, GLfloat clamp);
#endif
#endif /* GL_VERSION_4_6 */

#ifndef GL_ARB_ES2_compatibility
#define GL_ARB_ES2_compatibility 1
#endif /* GL_ARB_ES2_compatibility */

#ifndef GL_ARB_ES3_1_compatibility
#define GL_ARB_ES3_1_compatibility 1
#endif /* GL_ARB_ES3_1_compatibility */

#ifndef GL_ARB_ES3_2_compatibility
#define GL_ARB_ES3_2_compatibility 1
#define GL_PRIMITIVE_BOUNDING_BOX_ARB     0x92BE
#define GL_MULTISAMPLE_LINE_WIDTH_RANGE_ARB 0x9381
#define GL_MULTISAMPLE_LINE_WIDTH_GRANULARITY_ARB 0x9382
	typedef void (APIENTRYP PFNGLPRIMITIVEBOUNDINGBOXARBPROC) (GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glPrimitiveBoundingBoxARB(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW);
#endif
#endif /* GL_ARB_ES3_2_compatibility */

#ifndef GL_ARB_ES3_compatibility
#define GL_ARB_ES3_compatibility 1
#endif /* GL_ARB_ES3_compatibility */

#ifndef GL_ARB_arrays_of_arrays
#define GL_ARB_arrays_of_arrays 1
#endif /* GL_ARB_arrays_of_arrays */

#ifndef GL_ARB_base_instance
#define GL_ARB_base_instance 1
#endif /* GL_ARB_base_instance */

#ifndef GL_ARB_bindless_texture
#define GL_ARB_bindless_texture 1
	typedef khronos_uint64_t GLuint64EXT;
#define GL_UNSIGNED_INT64_ARB             0x140F
	typedef GLuint64(APIENTRYP PFNGLGETTEXTUREHANDLEARBPROC) (GLuint texture);
	typedef GLuint64(APIENTRYP PFNGLGETTEXTURESAMPLERHANDLEARBPROC) (GLuint texture, GLuint sampler);
	typedef void (APIENTRYP PFNGLMAKETEXTUREHANDLERESIDENTARBPROC) (GLuint64 handle);
	typedef void (APIENTRYP PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC) (GLuint64 handle);
	typedef GLuint64(APIENTRYP PFNGLGETIMAGEHANDLEARBPROC) (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
	typedef void (APIENTRYP PFNGLMAKEIMAGEHANDLERESIDENTARBPROC) (GLuint64 handle, GLenum access);
	typedef void (APIENTRYP PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC) (GLuint64 handle);
	typedef void (APIENTRYP PFNGLUNIFORMHANDLEUI64ARBPROC) (GLint location, GLuint64 value);
	typedef void (APIENTRYP PFNGLUNIFORMHANDLEUI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC) (GLuint program, GLint location, GLuint64 value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* values);
	typedef GLboolean(APIENTRYP PFNGLISTEXTUREHANDLERESIDENTARBPROC) (GLuint64 handle);
	typedef GLboolean(APIENTRYP PFNGLISIMAGEHANDLERESIDENTARBPROC) (GLuint64 handle);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL1UI64ARBPROC) (GLuint index, GLuint64EXT x);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL1UI64VARBPROC) (GLuint index, const GLuint64EXT* v);
	typedef void (APIENTRYP PFNGLGETVERTEXATTRIBLUI64VARBPROC) (GLuint index, GLenum pname, GLuint64EXT* params);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI GLuint64 APIENTRY glGetTextureHandleARB(GLuint texture);
	GLAPI GLuint64 APIENTRY glGetTextureSamplerHandleARB(GLuint texture, GLuint sampler);
	GLAPI void APIENTRY glMakeTextureHandleResidentARB(GLuint64 handle);
	GLAPI void APIENTRY glMakeTextureHandleNonResidentARB(GLuint64 handle);
	GLAPI GLuint64 APIENTRY glGetImageHandleARB(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
	GLAPI void APIENTRY glMakeImageHandleResidentARB(GLuint64 handle, GLenum access);
	GLAPI void APIENTRY glMakeImageHandleNonResidentARB(GLuint64 handle);
	GLAPI void APIENTRY glUniformHandleui64ARB(GLint location, GLuint64 value);
	GLAPI void APIENTRY glUniformHandleui64vARB(GLint location, GLsizei count, const GLuint64* value);
	GLAPI void APIENTRY glProgramUniformHandleui64ARB(GLuint program, GLint location, GLuint64 value);
	GLAPI void APIENTRY glProgramUniformHandleui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64* values);
	GLAPI GLboolean APIENTRY glIsTextureHandleResidentARB(GLuint64 handle);
	GLAPI GLboolean APIENTRY glIsImageHandleResidentARB(GLuint64 handle);
	GLAPI void APIENTRY glVertexAttribL1ui64ARB(GLuint index, GLuint64EXT x);
	GLAPI void APIENTRY glVertexAttribL1ui64vARB(GLuint index, const GLuint64EXT* v);
	GLAPI void APIENTRY glGetVertexAttribLui64vARB(GLuint index, GLenum pname, GLuint64EXT* params);
#endif
#endif /* GL_ARB_bindless_texture */

#ifndef GL_ARB_blend_func_extended
#define GL_ARB_blend_func_extended 1
#endif /* GL_ARB_blend_func_extended */

#ifndef GL_ARB_buffer_storage
#define GL_ARB_buffer_storage 1
#endif /* GL_ARB_buffer_storage */

#ifndef GL_ARB_cl_event
#define GL_ARB_cl_event 1
	struct _cl_context;
	struct _cl_event;
#define GL_SYNC_CL_EVENT_ARB              0x8240
#define GL_SYNC_CL_EVENT_COMPLETE_ARB     0x8241
	typedef GLsync(APIENTRYP PFNGLCREATESYNCFROMCLEVENTARBPROC) (struct _cl_context* context, struct _cl_event* event, GLbitfield flags);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI GLsync APIENTRY glCreateSyncFromCLeventARB(struct _cl_context* context, struct _cl_event* event, GLbitfield flags);
#endif
#endif /* GL_ARB_cl_event */

#ifndef GL_ARB_clear_buffer_object
#define GL_ARB_clear_buffer_object 1
#endif /* GL_ARB_clear_buffer_object */

#ifndef GL_ARB_clear_texture
#define GL_ARB_clear_texture 1
#endif /* GL_ARB_clear_texture */

#ifndef GL_ARB_clip_control
#define GL_ARB_clip_control 1
#endif /* GL_ARB_clip_control */

#ifndef GL_ARB_compressed_texture_pixel_storage
#define GL_ARB_compressed_texture_pixel_storage 1
#endif /* GL_ARB_compressed_texture_pixel_storage */

#ifndef GL_ARB_compute_shader
#define GL_ARB_compute_shader 1
#endif /* GL_ARB_compute_shader */

#ifndef GL_ARB_compute_variable_group_size
#define GL_ARB_compute_variable_group_size 1
#define GL_MAX_COMPUTE_VARIABLE_GROUP_INVOCATIONS_ARB 0x9344
#define GL_MAX_COMPUTE_FIXED_GROUP_INVOCATIONS_ARB 0x90EB
#define GL_MAX_COMPUTE_VARIABLE_GROUP_SIZE_ARB 0x9345
#define GL_MAX_COMPUTE_FIXED_GROUP_SIZE_ARB 0x91BF
	typedef void (APIENTRYP PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC) (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glDispatchComputeGroupSizeARB(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z);
#endif
#endif /* GL_ARB_compute_variable_group_size */

#ifndef GL_ARB_conditional_render_inverted
#define GL_ARB_conditional_render_inverted 1
#endif /* GL_ARB_conditional_render_inverted */

#ifndef GL_ARB_conservative_depth
#define GL_ARB_conservative_depth 1
#endif /* GL_ARB_conservative_depth */

#ifndef GL_ARB_copy_buffer
#define GL_ARB_copy_buffer 1
#endif /* GL_ARB_copy_buffer */

#ifndef GL_ARB_copy_image
#define GL_ARB_copy_image 1
#endif /* GL_ARB_copy_image */

#ifndef GL_ARB_cull_distance
#define GL_ARB_cull_distance 1
#endif /* GL_ARB_cull_distance */

#ifndef GL_ARB_debug_output
#define GL_ARB_debug_output 1
	typedef void (APIENTRY* GLDEBUGPROCARB)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam);
#define GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB   0x8242
#define GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_ARB 0x8243
#define GL_DEBUG_CALLBACK_FUNCTION_ARB    0x8244
#define GL_DEBUG_CALLBACK_USER_PARAM_ARB  0x8245
#define GL_DEBUG_SOURCE_API_ARB           0x8246
#define GL_DEBUG_SOURCE_WINDOW_SYSTEM_ARB 0x8247
#define GL_DEBUG_SOURCE_SHADER_COMPILER_ARB 0x8248
#define GL_DEBUG_SOURCE_THIRD_PARTY_ARB   0x8249
#define GL_DEBUG_SOURCE_APPLICATION_ARB   0x824A
#define GL_DEBUG_SOURCE_OTHER_ARB         0x824B
#define GL_DEBUG_TYPE_ERROR_ARB           0x824C
#define GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB 0x824D
#define GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB 0x824E
#define GL_DEBUG_TYPE_PORTABILITY_ARB     0x824F
#define GL_DEBUG_TYPE_PERFORMANCE_ARB     0x8250
#define GL_DEBUG_TYPE_OTHER_ARB           0x8251
#define GL_MAX_DEBUG_MESSAGE_LENGTH_ARB   0x9143
#define GL_MAX_DEBUG_LOGGED_MESSAGES_ARB  0x9144
#define GL_DEBUG_LOGGED_MESSAGES_ARB      0x9145
#define GL_DEBUG_SEVERITY_HIGH_ARB        0x9146
#define GL_DEBUG_SEVERITY_MEDIUM_ARB      0x9147
#define GL_DEBUG_SEVERITY_LOW_ARB         0x9148
	typedef void (APIENTRYP PFNGLDEBUGMESSAGECONTROLARBPROC) (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
	typedef void (APIENTRYP PFNGLDEBUGMESSAGEINSERTARBPROC) (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf);
	typedef void (APIENTRYP PFNGLDEBUGMESSAGECALLBACKARBPROC) (GLDEBUGPROCARB callback, const void* userParam);
	typedef GLuint(APIENTRYP PFNGLGETDEBUGMESSAGELOGARBPROC) (GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glDebugMessageControlARB(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
	GLAPI void APIENTRY glDebugMessageInsertARB(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf);
	GLAPI void APIENTRY glDebugMessageCallbackARB(GLDEBUGPROCARB callback, const void* userParam);
	GLAPI GLuint APIENTRY glGetDebugMessageLogARB(GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog);
#endif
#endif /* GL_ARB_debug_output */

#ifndef GL_ARB_depth_buffer_float
#define GL_ARB_depth_buffer_float 1
#endif /* GL_ARB_depth_buffer_float */

#ifndef GL_ARB_depth_clamp
#define GL_ARB_depth_clamp 1
#endif /* GL_ARB_depth_clamp */

#ifndef GL_ARB_derivative_control
#define GL_ARB_derivative_control 1
#endif /* GL_ARB_derivative_control */

#ifndef GL_ARB_direct_state_access
#define GL_ARB_direct_state_access 1
#endif /* GL_ARB_direct_state_access */

#ifndef GL_ARB_draw_buffers_blend
#define GL_ARB_draw_buffers_blend 1
	typedef void (APIENTRYP PFNGLBLENDEQUATIONIARBPROC) (GLuint buf, GLenum mode);
	typedef void (APIENTRYP PFNGLBLENDEQUATIONSEPARATEIARBPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
	typedef void (APIENTRYP PFNGLBLENDFUNCIARBPROC) (GLuint buf, GLenum src, GLenum dst);
	typedef void (APIENTRYP PFNGLBLENDFUNCSEPARATEIARBPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glBlendEquationiARB(GLuint buf, GLenum mode);
	GLAPI void APIENTRY glBlendEquationSeparateiARB(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
	GLAPI void APIENTRY glBlendFunciARB(GLuint buf, GLenum src, GLenum dst);
	GLAPI void APIENTRY glBlendFuncSeparateiARB(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
#endif
#endif /* GL_ARB_draw_buffers_blend */

#ifndef GL_ARB_draw_elements_base_vertex
#define GL_ARB_draw_elements_base_vertex 1
#endif /* GL_ARB_draw_elements_base_vertex */

#ifndef GL_ARB_draw_indirect
#define GL_ARB_draw_indirect 1
#endif /* GL_ARB_draw_indirect */

#ifndef GL_ARB_draw_instanced
#define GL_ARB_draw_instanced 1
	typedef void (APIENTRYP PFNGLDRAWARRAYSINSTANCEDARBPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
	typedef void (APIENTRYP PFNGLDRAWELEMENTSINSTANCEDARBPROC) (GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glDrawArraysInstancedARB(GLenum mode, GLint first, GLsizei count, GLsizei primcount);
	GLAPI void APIENTRY glDrawElementsInstancedARB(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount);
#endif
#endif /* GL_ARB_draw_instanced */

#ifndef GL_ARB_enhanced_layouts
#define GL_ARB_enhanced_layouts 1
#endif /* GL_ARB_enhanced_layouts */

#ifndef GL_ARB_explicit_attrib_location
#define GL_ARB_explicit_attrib_location 1
#endif /* GL_ARB_explicit_attrib_location */

#ifndef GL_ARB_explicit_uniform_location
#define GL_ARB_explicit_uniform_location 1
#endif /* GL_ARB_explicit_uniform_location */

#ifndef GL_ARB_fragment_coord_conventions
#define GL_ARB_fragment_coord_conventions 1
#endif /* GL_ARB_fragment_coord_conventions */

#ifndef GL_ARB_fragment_layer_viewport
#define GL_ARB_fragment_layer_viewport 1
#endif /* GL_ARB_fragment_layer_viewport */

#ifndef GL_ARB_fragment_shader_interlock
#define GL_ARB_fragment_shader_interlock 1
#endif /* GL_ARB_fragment_shader_interlock */

#ifndef GL_ARB_framebuffer_no_attachments
#define GL_ARB_framebuffer_no_attachments 1
#endif /* GL_ARB_framebuffer_no_attachments */

#ifndef GL_ARB_framebuffer_object
#define GL_ARB_framebuffer_object 1
#endif /* GL_ARB_framebuffer_object */

#ifndef GL_ARB_framebuffer_sRGB
#define GL_ARB_framebuffer_sRGB 1
#endif /* GL_ARB_framebuffer_sRGB */

#ifndef GL_ARB_geometry_shader4
#define GL_ARB_geometry_shader4 1
#define GL_LINES_ADJACENCY_ARB            0x000A
#define GL_LINE_STRIP_ADJACENCY_ARB       0x000B
#define GL_TRIANGLES_ADJACENCY_ARB        0x000C
#define GL_TRIANGLE_STRIP_ADJACENCY_ARB   0x000D
#define GL_PROGRAM_POINT_SIZE_ARB         0x8642
#define GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_ARB 0x8C29
#define GL_FRAMEBUFFER_ATTACHMENT_LAYERED_ARB 0x8DA7
#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_ARB 0x8DA8
#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_ARB 0x8DA9
#define GL_GEOMETRY_SHADER_ARB            0x8DD9
#define GL_GEOMETRY_VERTICES_OUT_ARB      0x8DDA
#define GL_GEOMETRY_INPUT_TYPE_ARB        0x8DDB
#define GL_GEOMETRY_OUTPUT_TYPE_ARB       0x8DDC
#define GL_MAX_GEOMETRY_VARYING_COMPONENTS_ARB 0x8DDD
#define GL_MAX_VERTEX_VARYING_COMPONENTS_ARB 0x8DDE
#define GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_ARB 0x8DDF
#define GL_MAX_GEOMETRY_OUTPUT_VERTICES_ARB 0x8DE0
#define GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_ARB 0x8DE1
	typedef void (APIENTRYP PFNGLPROGRAMPARAMETERIARBPROC) (GLuint program, GLenum pname, GLint value);
	typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTUREARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
	typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTURELAYERARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
	typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTUREFACEARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glProgramParameteriARB(GLuint program, GLenum pname, GLint value);
	GLAPI void APIENTRY glFramebufferTextureARB(GLenum target, GLenum attachment, GLuint texture, GLint level);
	GLAPI void APIENTRY glFramebufferTextureLayerARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
	GLAPI void APIENTRY glFramebufferTextureFaceARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
#endif
#endif /* GL_ARB_geometry_shader4 */

#ifndef GL_ARB_get_program_binary
#define GL_ARB_get_program_binary 1
#endif /* GL_ARB_get_program_binary */

#ifndef GL_ARB_get_texture_sub_image
#define GL_ARB_get_texture_sub_image 1
#endif /* GL_ARB_get_texture_sub_image */

#ifndef GL_ARB_gl_spirv
#define GL_ARB_gl_spirv 1
#define GL_SHADER_BINARY_FORMAT_SPIR_V_ARB 0x9551
#define GL_SPIR_V_BINARY_ARB              0x9552
	typedef void (APIENTRYP PFNGLSPECIALIZESHADERARBPROC) (GLuint shader, const GLchar* pEntryPoint, GLuint numSpecializationConstants, const GLuint* pConstantIndex, const GLuint* pConstantValue);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glSpecializeShaderARB(GLuint shader, const GLchar* pEntryPoint, GLuint numSpecializationConstants, const GLuint* pConstantIndex, const GLuint* pConstantValue);
#endif
#endif /* GL_ARB_gl_spirv */

#ifndef GL_ARB_gpu_shader5
#define GL_ARB_gpu_shader5 1
#endif /* GL_ARB_gpu_shader5 */

#ifndef GL_ARB_gpu_shader_fp64
#define GL_ARB_gpu_shader_fp64 1
#endif /* GL_ARB_gpu_shader_fp64 */

#ifndef GL_ARB_gpu_shader_int64
#define GL_ARB_gpu_shader_int64 1
#define GL_INT64_ARB                      0x140E
#define GL_INT64_VEC2_ARB                 0x8FE9
#define GL_INT64_VEC3_ARB                 0x8FEA
#define GL_INT64_VEC4_ARB                 0x8FEB
#define GL_UNSIGNED_INT64_VEC2_ARB        0x8FF5
#define GL_UNSIGNED_INT64_VEC3_ARB        0x8FF6
#define GL_UNSIGNED_INT64_VEC4_ARB        0x8FF7
	typedef void (APIENTRYP PFNGLUNIFORM1I64ARBPROC) (GLint location, GLint64 x);
	typedef void (APIENTRYP PFNGLUNIFORM2I64ARBPROC) (GLint location, GLint64 x, GLint64 y);
	typedef void (APIENTRYP PFNGLUNIFORM3I64ARBPROC) (GLint location, GLint64 x, GLint64 y, GLint64 z);
	typedef void (APIENTRYP PFNGLUNIFORM4I64ARBPROC) (GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w);
	typedef void (APIENTRYP PFNGLUNIFORM1I64VARBPROC) (GLint location, GLsizei count, const GLint64* value);
	typedef void (APIENTRYP PFNGLUNIFORM2I64VARBPROC) (GLint location, GLsizei count, const GLint64* value);
	typedef void (APIENTRYP PFNGLUNIFORM3I64VARBPROC) (GLint location, GLsizei count, const GLint64* value);
	typedef void (APIENTRYP PFNGLUNIFORM4I64VARBPROC) (GLint location, GLsizei count, const GLint64* value);
	typedef void (APIENTRYP PFNGLUNIFORM1UI64ARBPROC) (GLint location, GLuint64 x);
	typedef void (APIENTRYP PFNGLUNIFORM2UI64ARBPROC) (GLint location, GLuint64 x, GLuint64 y);
	typedef void (APIENTRYP PFNGLUNIFORM3UI64ARBPROC) (GLint location, GLuint64 x, GLuint64 y, GLuint64 z);
	typedef void (APIENTRYP PFNGLUNIFORM4UI64ARBPROC) (GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w);
	typedef void (APIENTRYP PFNGLUNIFORM1UI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
	typedef void (APIENTRYP PFNGLUNIFORM2UI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
	typedef void (APIENTRYP PFNGLUNIFORM3UI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
	typedef void (APIENTRYP PFNGLUNIFORM4UI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
	typedef void (APIENTRYP PFNGLGETUNIFORMI64VARBPROC) (GLuint program, GLint location, GLint64* params);
	typedef void (APIENTRYP PFNGLGETUNIFORMUI64VARBPROC) (GLuint program, GLint location, GLuint64* params);
	typedef void (APIENTRYP PFNGLGETNUNIFORMI64VARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLint64* params);
	typedef void (APIENTRYP PFNGLGETNUNIFORMUI64VARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLuint64* params);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1I64ARBPROC) (GLuint program, GLint location, GLint64 x);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2I64ARBPROC) (GLuint program, GLint location, GLint64 x, GLint64 y);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3I64ARBPROC) (GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4I64ARBPROC) (GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1I64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLint64* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2I64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLint64* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3I64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLint64* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4I64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLint64* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1UI64ARBPROC) (GLuint program, GLint location, GLuint64 x);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2UI64ARBPROC) (GLuint program, GLint location, GLuint64 x, GLuint64 y);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3UI64ARBPROC) (GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4UI64ARBPROC) (GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1UI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2UI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3UI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4UI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* value);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glUniform1i64ARB(GLint location, GLint64 x);
	GLAPI void APIENTRY glUniform2i64ARB(GLint location, GLint64 x, GLint64 y);
	GLAPI void APIENTRY glUniform3i64ARB(GLint location, GLint64 x, GLint64 y, GLint64 z);
	GLAPI void APIENTRY glUniform4i64ARB(GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w);
	GLAPI void APIENTRY glUniform1i64vARB(GLint location, GLsizei count, const GLint64* value);
	GLAPI void APIENTRY glUniform2i64vARB(GLint location, GLsizei count, const GLint64* value);
	GLAPI void APIENTRY glUniform3i64vARB(GLint location, GLsizei count, const GLint64* value);
	GLAPI void APIENTRY glUniform4i64vARB(GLint location, GLsizei count, const GLint64* value);
	GLAPI void APIENTRY glUniform1ui64ARB(GLint location, GLuint64 x);
	GLAPI void APIENTRY glUniform2ui64ARB(GLint location, GLuint64 x, GLuint64 y);
	GLAPI void APIENTRY glUniform3ui64ARB(GLint location, GLuint64 x, GLuint64 y, GLuint64 z);
	GLAPI void APIENTRY glUniform4ui64ARB(GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w);
	GLAPI void APIENTRY glUniform1ui64vARB(GLint location, GLsizei count, const GLuint64* value);
	GLAPI void APIENTRY glUniform2ui64vARB(GLint location, GLsizei count, const GLuint64* value);
	GLAPI void APIENTRY glUniform3ui64vARB(GLint location, GLsizei count, const GLuint64* value);
	GLAPI void APIENTRY glUniform4ui64vARB(GLint location, GLsizei count, const GLuint64* value);
	GLAPI void APIENTRY glGetUniformi64vARB(GLuint program, GLint location, GLint64* params);
	GLAPI void APIENTRY glGetUniformui64vARB(GLuint program, GLint location, GLuint64* params);
	GLAPI void APIENTRY glGetnUniformi64vARB(GLuint program, GLint location, GLsizei bufSize, GLint64* params);
	GLAPI void APIENTRY glGetnUniformui64vARB(GLuint program, GLint location, GLsizei bufSize, GLuint64* params);
	GLAPI void APIENTRY glProgramUniform1i64ARB(GLuint program, GLint location, GLint64 x);
	GLAPI void APIENTRY glProgramUniform2i64ARB(GLuint program, GLint location, GLint64 x, GLint64 y);
	GLAPI void APIENTRY glProgramUniform3i64ARB(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z);
	GLAPI void APIENTRY glProgramUniform4i64ARB(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w);
	GLAPI void APIENTRY glProgramUniform1i64vARB(GLuint program, GLint location, GLsizei count, const GLint64* value);
	GLAPI void APIENTRY glProgramUniform2i64vARB(GLuint program, GLint location, GLsizei count, const GLint64* value);
	GLAPI void APIENTRY glProgramUniform3i64vARB(GLuint program, GLint location, GLsizei count, const GLint64* value);
	GLAPI void APIENTRY glProgramUniform4i64vARB(GLuint program, GLint location, GLsizei count, const GLint64* value);
	GLAPI void APIENTRY glProgramUniform1ui64ARB(GLuint program, GLint location, GLuint64 x);
	GLAPI void APIENTRY glProgramUniform2ui64ARB(GLuint program, GLint location, GLuint64 x, GLuint64 y);
	GLAPI void APIENTRY glProgramUniform3ui64ARB(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z);
	GLAPI void APIENTRY glProgramUniform4ui64ARB(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w);
	GLAPI void APIENTRY glProgramUniform1ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64* value);
	GLAPI void APIENTRY glProgramUniform2ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64* value);
	GLAPI void APIENTRY glProgramUniform3ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64* value);
	GLAPI void APIENTRY glProgramUniform4ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64* value);
#endif
#endif /* GL_ARB_gpu_shader_int64 */

#ifndef GL_ARB_half_float_vertex
#define GL_ARB_half_float_vertex 1
#endif /* GL_ARB_half_float_vertex */

#ifndef GL_ARB_imaging
#define GL_ARB_imaging 1
#endif /* GL_ARB_imaging */

#ifndef GL_ARB_indirect_parameters
#define GL_ARB_indirect_parameters 1
#define GL_PARAMETER_BUFFER_ARB           0x80EE
#define GL_PARAMETER_BUFFER_BINDING_ARB   0x80EF
	typedef void (APIENTRYP PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC) (GLenum mode, const void* indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
	typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC) (GLenum mode, GLenum type, const void* indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glMultiDrawArraysIndirectCountARB(GLenum mode, const void* indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
	GLAPI void APIENTRY glMultiDrawElementsIndirectCountARB(GLenum mode, GLenum type, const void* indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
#endif
#endif /* GL_ARB_indirect_parameters */

#ifndef GL_ARB_instanced_arrays
#define GL_ARB_instanced_arrays 1
#define GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ARB 0x88FE
	typedef void (APIENTRYP PFNGLVERTEXATTRIBDIVISORARBPROC) (GLuint index, GLuint divisor);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glVertexAttribDivisorARB(GLuint index, GLuint divisor);
#endif
#endif /* GL_ARB_instanced_arrays */

#ifndef GL_ARB_internalformat_query
#define GL_ARB_internalformat_query 1
#endif /* GL_ARB_internalformat_query */

#ifndef GL_ARB_internalformat_query2
#define GL_ARB_internalformat_query2 1
#define GL_SRGB_DECODE_ARB                0x8299
#define GL_VIEW_CLASS_EAC_R11             0x9383
#define GL_VIEW_CLASS_EAC_RG11            0x9384
#define GL_VIEW_CLASS_ETC2_RGB            0x9385
#define GL_VIEW_CLASS_ETC2_RGBA           0x9386
#define GL_VIEW_CLASS_ETC2_EAC_RGBA       0x9387
#define GL_VIEW_CLASS_ASTC_4x4_RGBA       0x9388
#define GL_VIEW_CLASS_ASTC_5x4_RGBA       0x9389
#define GL_VIEW_CLASS_ASTC_5x5_RGBA       0x938A
#define GL_VIEW_CLASS_ASTC_6x5_RGBA       0x938B
#define GL_VIEW_CLASS_ASTC_6x6_RGBA       0x938C
#define GL_VIEW_CLASS_ASTC_8x5_RGBA       0x938D
#define GL_VIEW_CLASS_ASTC_8x6_RGBA       0x938E
#define GL_VIEW_CLASS_ASTC_8x8_RGBA       0x938F
#define GL_VIEW_CLASS_ASTC_10x5_RGBA      0x9390
#define GL_VIEW_CLASS_ASTC_10x6_RGBA      0x9391
#define GL_VIEW_CLASS_ASTC_10x8_RGBA      0x9392
#define GL_VIEW_CLASS_ASTC_10x10_RGBA     0x9393
#define GL_VIEW_CLASS_ASTC_12x10_RGBA     0x9394
#define GL_VIEW_CLASS_ASTC_12x12_RGBA     0x9395
#endif /* GL_ARB_internalformat_query2 */

#ifndef GL_ARB_invalidate_subdata
#define GL_ARB_invalidate_subdata 1
#endif /* GL_ARB_invalidate_subdata */

#ifndef GL_ARB_map_buffer_alignment
#define GL_ARB_map_buffer_alignment 1
#endif /* GL_ARB_map_buffer_alignment */

#ifndef GL_ARB_map_buffer_range
#define GL_ARB_map_buffer_range 1
#endif /* GL_ARB_map_buffer_range */

#ifndef GL_ARB_multi_bind
#define GL_ARB_multi_bind 1
#endif /* GL_ARB_multi_bind */

#ifndef GL_ARB_multi_draw_indirect
#define GL_ARB_multi_draw_indirect 1
#endif /* GL_ARB_multi_draw_indirect */

#ifndef GL_ARB_occlusion_query2
#define GL_ARB_occlusion_query2 1
#endif /* GL_ARB_occlusion_query2 */

#ifndef GL_ARB_parallel_shader_compile
#define GL_ARB_parallel_shader_compile 1
#define GL_MAX_SHADER_COMPILER_THREADS_ARB 0x91B0
#define GL_COMPLETION_STATUS_ARB          0x91B1
	typedef void (APIENTRYP PFNGLMAXSHADERCOMPILERTHREADSARBPROC) (GLuint count);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glMaxShaderCompilerThreadsARB(GLuint count);
#endif
#endif /* GL_ARB_parallel_shader_compile */

#ifndef GL_ARB_pipeline_statistics_query
#define GL_ARB_pipeline_statistics_query 1
#define GL_VERTICES_SUBMITTED_ARB         0x82EE
#define GL_PRIMITIVES_SUBMITTED_ARB       0x82EF
#define GL_VERTEX_SHADER_INVOCATIONS_ARB  0x82F0
#define GL_TESS_CONTROL_SHADER_PATCHES_ARB 0x82F1
#define GL_TESS_EVALUATION_SHADER_INVOCATIONS_ARB 0x82F2
#define GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED_ARB 0x82F3
#define GL_FRAGMENT_SHADER_INVOCATIONS_ARB 0x82F4
#define GL_COMPUTE_SHADER_INVOCATIONS_ARB 0x82F5
#define GL_CLIPPING_INPUT_PRIMITIVES_ARB  0x82F6
#define GL_CLIPPING_OUTPUT_PRIMITIVES_ARB 0x82F7
#endif /* GL_ARB_pipeline_statistics_query */

#ifndef GL_ARB_pixel_buffer_object
#define GL_ARB_pixel_buffer_object 1
#define GL_PIXEL_PACK_BUFFER_ARB          0x88EB
#define GL_PIXEL_UNPACK_BUFFER_ARB        0x88EC
#define GL_PIXEL_PACK_BUFFER_BINDING_ARB  0x88ED
#define GL_PIXEL_UNPACK_BUFFER_BINDING_ARB 0x88EF
#endif /* GL_ARB_pixel_buffer_object */

#ifndef GL_ARB_polygon_offset_clamp
#define GL_ARB_polygon_offset_clamp 1
#endif /* GL_ARB_polygon_offset_clamp */

#ifndef GL_ARB_post_depth_coverage
#define GL_ARB_post_depth_coverage 1
#endif /* GL_ARB_post_depth_coverage */

#ifndef GL_ARB_program_interface_query
#define GL_ARB_program_interface_query 1
#endif /* GL_ARB_program_interface_query */

#ifndef GL_ARB_provoking_vertex
#define GL_ARB_provoking_vertex 1
#endif /* GL_ARB_provoking_vertex */

#ifndef GL_ARB_query_buffer_object
#define GL_ARB_query_buffer_object 1
#endif /* GL_ARB_query_buffer_object */

#ifndef GL_ARB_robust_buffer_access_behavior
#define GL_ARB_robust_buffer_access_behavior 1
#endif /* GL_ARB_robust_buffer_access_behavior */

#ifndef GL_ARB_robustness
#define GL_ARB_robustness 1
#define GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB 0x00000004
#define GL_LOSE_CONTEXT_ON_RESET_ARB      0x8252
#define GL_GUILTY_CONTEXT_RESET_ARB       0x8253
#define GL_INNOCENT_CONTEXT_RESET_ARB     0x8254
#define GL_UNKNOWN_CONTEXT_RESET_ARB      0x8255
#define GL_RESET_NOTIFICATION_STRATEGY_ARB 0x8256
#define GL_NO_RESET_NOTIFICATION_ARB      0x8261
	typedef GLenum(APIENTRYP PFNGLGETGRAPHICSRESETSTATUSARBPROC) (void);
	typedef void (APIENTRYP PFNGLGETNTEXIMAGEARBPROC) (GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* img);
	typedef void (APIENTRYP PFNGLREADNPIXELSARBPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data);
	typedef void (APIENTRYP PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint lod, GLsizei bufSize, void* img);
	typedef void (APIENTRYP PFNGLGETNUNIFORMFVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLfloat* params);
	typedef void (APIENTRYP PFNGLGETNUNIFORMIVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLint* params);
	typedef void (APIENTRYP PFNGLGETNUNIFORMUIVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLuint* params);
	typedef void (APIENTRYP PFNGLGETNUNIFORMDVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLdouble* params);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI GLenum APIENTRY glGetGraphicsResetStatusARB(void);
	GLAPI void APIENTRY glGetnTexImageARB(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* img);
	GLAPI void APIENTRY glReadnPixelsARB(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data);
	GLAPI void APIENTRY glGetnCompressedTexImageARB(GLenum target, GLint lod, GLsizei bufSize, void* img);
	GLAPI void APIENTRY glGetnUniformfvARB(GLuint program, GLint location, GLsizei bufSize, GLfloat* params);
	GLAPI void APIENTRY glGetnUniformivARB(GLuint program, GLint location, GLsizei bufSize, GLint* params);
	GLAPI void APIENTRY glGetnUniformuivARB(GLuint program, GLint location, GLsizei bufSize, GLuint* params);
	GLAPI void APIENTRY glGetnUniformdvARB(GLuint program, GLint location, GLsizei bufSize, GLdouble* params);
#endif
#endif /* GL_ARB_robustness */

#ifndef GL_ARB_robustness_isolation
#define GL_ARB_robustness_isolation 1
#endif /* GL_ARB_robustness_isolation */

#ifndef GL_ARB_sample_locations
#define GL_ARB_sample_locations 1
#define GL_SAMPLE_LOCATION_SUBPIXEL_BITS_ARB 0x933D
#define GL_SAMPLE_LOCATION_PIXEL_GRID_WIDTH_ARB 0x933E
#define GL_SAMPLE_LOCATION_PIXEL_GRID_HEIGHT_ARB 0x933F
#define GL_PROGRAMMABLE_SAMPLE_LOCATION_TABLE_SIZE_ARB 0x9340
#define GL_SAMPLE_LOCATION_ARB            0x8E50
#define GL_PROGRAMMABLE_SAMPLE_LOCATION_ARB 0x9341
#define GL_FRAMEBUFFER_PROGRAMMABLE_SAMPLE_LOCATIONS_ARB 0x9342
#define GL_FRAMEBUFFER_SAMPLE_LOCATION_PIXEL_GRID_ARB 0x9343
	typedef void (APIENTRYP PFNGLFRAMEBUFFERSAMPLELOCATIONSFVARBPROC) (GLenum target, GLuint start, GLsizei count, const GLfloat* v);
	typedef void (APIENTRYP PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARBPROC) (GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v);
	typedef void (APIENTRYP PFNGLEVALUATEDEPTHVALUESARBPROC) (void);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glFramebufferSampleLocationsfvARB(GLenum target, GLuint start, GLsizei count, const GLfloat* v);
	GLAPI void APIENTRY glNamedFramebufferSampleLocationsfvARB(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v);
	GLAPI void APIENTRY glEvaluateDepthValuesARB(void);
#endif
#endif /* GL_ARB_sample_locations */

#ifndef GL_ARB_sample_shading
#define GL_ARB_sample_shading 1
#define GL_SAMPLE_SHADING_ARB             0x8C36
#define GL_MIN_SAMPLE_SHADING_VALUE_ARB   0x8C37
	typedef void (APIENTRYP PFNGLMINSAMPLESHADINGARBPROC) (GLfloat value);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glMinSampleShadingARB(GLfloat value);
#endif
#endif /* GL_ARB_sample_shading */

#ifndef GL_ARB_sampler_objects
#define GL_ARB_sampler_objects 1
#endif /* GL_ARB_sampler_objects */

#ifndef GL_ARB_seamless_cube_map
#define GL_ARB_seamless_cube_map 1
#endif /* GL_ARB_seamless_cube_map */

#ifndef GL_ARB_seamless_cubemap_per_texture
#define GL_ARB_seamless_cubemap_per_texture 1
#endif /* GL_ARB_seamless_cubemap_per_texture */

#ifndef GL_ARB_separate_shader_objects
#define GL_ARB_separate_shader_objects 1
#endif /* GL_ARB_separate_shader_objects */

#ifndef GL_ARB_shader_atomic_counter_ops
#define GL_ARB_shader_atomic_counter_ops 1
#endif /* GL_ARB_shader_atomic_counter_ops */

#ifndef GL_ARB_shader_atomic_counters
#define GL_ARB_shader_atomic_counters 1
#endif /* GL_ARB_shader_atomic_counters */

#ifndef GL_ARB_shader_ballot
#define GL_ARB_shader_ballot 1
#endif /* GL_ARB_shader_ballot */

#ifndef GL_ARB_shader_bit_encoding
#define GL_ARB_shader_bit_encoding 1
#endif /* GL_ARB_shader_bit_encoding */

#ifndef GL_ARB_shader_clock
#define GL_ARB_shader_clock 1
#endif /* GL_ARB_shader_clock */

#ifndef GL_ARB_shader_draw_parameters
#define GL_ARB_shader_draw_parameters 1
#endif /* GL_ARB_shader_draw_parameters */

#ifndef GL_ARB_shader_group_vote
#define GL_ARB_shader_group_vote 1
#endif /* GL_ARB_shader_group_vote */

#ifndef GL_ARB_shader_image_load_store
#define GL_ARB_shader_image_load_store 1
#endif /* GL_ARB_shader_image_load_store */

#ifndef GL_ARB_shader_image_size
#define GL_ARB_shader_image_size 1
#endif /* GL_ARB_shader_image_size */

#ifndef GL_ARB_shader_precision
#define GL_ARB_shader_precision 1
#endif /* GL_ARB_shader_precision */

#ifndef GL_ARB_shader_stencil_export
#define GL_ARB_shader_stencil_export 1
#endif /* GL_ARB_shader_stencil_export */

#ifndef GL_ARB_shader_storage_buffer_object
#define GL_ARB_shader_storage_buffer_object 1
#endif /* GL_ARB_shader_storage_buffer_object */

#ifndef GL_ARB_shader_subroutine
#define GL_ARB_shader_subroutine 1
#endif /* GL_ARB_shader_subroutine */

#ifndef GL_ARB_shader_texture_image_samples
#define GL_ARB_shader_texture_image_samples 1
#endif /* GL_ARB_shader_texture_image_samples */

#ifndef GL_ARB_shader_viewport_layer_array
#define GL_ARB_shader_viewport_layer_array 1
#endif /* GL_ARB_shader_viewport_layer_array */

#ifndef GL_ARB_shading_language_420pack
#define GL_ARB_shading_language_420pack 1
#endif /* GL_ARB_shading_language_420pack */

#ifndef GL_ARB_shading_language_include
#define GL_ARB_shading_language_include 1
#define GL_SHADER_INCLUDE_ARB             0x8DAE
#define GL_NAMED_STRING_LENGTH_ARB        0x8DE9
#define GL_NAMED_STRING_TYPE_ARB          0x8DEA
	typedef void (APIENTRYP PFNGLNAMEDSTRINGARBPROC) (GLenum type, GLint namelen, const GLchar* name, GLint stringlen, const GLchar* string);
	typedef void (APIENTRYP PFNGLDELETENAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name);
	typedef void (APIENTRYP PFNGLCOMPILESHADERINCLUDEARBPROC) (GLuint shader, GLsizei count, const GLchar* const* path, const GLint* length);
	typedef GLboolean(APIENTRYP PFNGLISNAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name);
	typedef void (APIENTRYP PFNGLGETNAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name, GLsizei bufSize, GLint* stringlen, GLchar* string);
	typedef void (APIENTRYP PFNGLGETNAMEDSTRINGIVARBPROC) (GLint namelen, const GLchar* name, GLenum pname, GLint* params);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glNamedStringARB(GLenum type, GLint namelen, const GLchar* name, GLint stringlen, const GLchar* string);
	GLAPI void APIENTRY glDeleteNamedStringARB(GLint namelen, const GLchar* name);
	GLAPI void APIENTRY glCompileShaderIncludeARB(GLuint shader, GLsizei count, const GLchar* const* path, const GLint* length);
	GLAPI GLboolean APIENTRY glIsNamedStringARB(GLint namelen, const GLchar* name);
	GLAPI void APIENTRY glGetNamedStringARB(GLint namelen, const GLchar* name, GLsizei bufSize, GLint* stringlen, GLchar* string);
	GLAPI void APIENTRY glGetNamedStringivARB(GLint namelen, const GLchar* name, GLenum pname, GLint* params);
#endif
#endif /* GL_ARB_shading_language_include */

#ifndef GL_ARB_shading_language_packing
#define GL_ARB_shading_language_packing 1
#endif /* GL_ARB_shading_language_packing */

#ifndef GL_ARB_sparse_buffer
#define GL_ARB_sparse_buffer 1
#define GL_SPARSE_STORAGE_BIT_ARB         0x0400
#define GL_SPARSE_BUFFER_PAGE_SIZE_ARB    0x82F8
	typedef void (APIENTRYP PFNGLBUFFERPAGECOMMITMENTARBPROC) (GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit);
	typedef void (APIENTRYP PFNGLNAMEDBUFFERPAGECOMMITMENTEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit);
	typedef void (APIENTRYP PFNGLNAMEDBUFFERPAGECOMMITMENTARBPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glBufferPageCommitmentARB(GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit);
	GLAPI void APIENTRY glNamedBufferPageCommitmentEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit);
	GLAPI void APIENTRY glNamedBufferPageCommitmentARB(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit);
#endif
#endif /* GL_ARB_sparse_buffer */

#ifndef GL_ARB_sparse_texture
#define GL_ARB_sparse_texture 1
#define GL_TEXTURE_SPARSE_ARB             0x91A6
#define GL_VIRTUAL_PAGE_SIZE_INDEX_ARB    0x91A7
#define GL_NUM_SPARSE_LEVELS_ARB          0x91AA
#define GL_NUM_VIRTUAL_PAGE_SIZES_ARB     0x91A8
#define GL_VIRTUAL_PAGE_SIZE_X_ARB        0x9195
#define GL_VIRTUAL_PAGE_SIZE_Y_ARB        0x9196
#define GL_VIRTUAL_PAGE_SIZE_Z_ARB        0x9197
#define GL_MAX_SPARSE_TEXTURE_SIZE_ARB    0x9198
#define GL_MAX_SPARSE_3D_TEXTURE_SIZE_ARB 0x9199
#define GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS_ARB 0x919A
#define GL_SPARSE_TEXTURE_FULL_ARRAY_CUBE_MIPMAPS_ARB 0x91A9
	typedef void (APIENTRYP PFNGLTEXPAGECOMMITMENTARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glTexPageCommitmentARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);
#endif
#endif /* GL_ARB_sparse_texture */

#ifndef GL_ARB_sparse_texture2
#define GL_ARB_sparse_texture2 1
#endif /* GL_ARB_sparse_texture2 */

#ifndef GL_ARB_sparse_texture_clamp
#define GL_ARB_sparse_texture_clamp 1
#endif /* GL_ARB_sparse_texture_clamp */

#ifndef GL_ARB_spirv_extensions
#define GL_ARB_spirv_extensions 1
#endif /* GL_ARB_spirv_extensions */

#ifndef GL_ARB_stencil_texturing
#define GL_ARB_stencil_texturing 1
#endif /* GL_ARB_stencil_texturing */

#ifndef GL_ARB_sync
#define GL_ARB_sync 1
#endif /* GL_ARB_sync */

#ifndef GL_ARB_tessellation_shader
#define GL_ARB_tessellation_shader 1
#endif /* GL_ARB_tessellation_shader */

#ifndef GL_ARB_texture_barrier
#define GL_ARB_texture_barrier 1
#endif /* GL_ARB_texture_barrier */

#ifndef GL_ARB_texture_border_clamp
#define GL_ARB_texture_border_clamp 1
#define GL_CLAMP_TO_BORDER_ARB            0x812D
#endif /* GL_ARB_texture_border_clamp */

#ifndef GL_ARB_texture_buffer_object
#define GL_ARB_texture_buffer_object 1
#define GL_TEXTURE_BUFFER_ARB             0x8C2A
#define GL_MAX_TEXTURE_BUFFER_SIZE_ARB    0x8C2B
#define GL_TEXTURE_BINDING_BUFFER_ARB     0x8C2C
#define GL_TEXTURE_BUFFER_DATA_STORE_BINDING_ARB 0x8C2D
#define GL_TEXTURE_BUFFER_FORMAT_ARB      0x8C2E
	typedef void (APIENTRYP PFNGLTEXBUFFERARBPROC) (GLenum target, GLenum internalformat, GLuint buffer);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glTexBufferARB(GLenum target, GLenum internalformat, GLuint buffer);
#endif
#endif /* GL_ARB_texture_buffer_object */

#ifndef GL_ARB_texture_buffer_object_rgb32
#define GL_ARB_texture_buffer_object_rgb32 1
#endif /* GL_ARB_texture_buffer_object_rgb32 */

#ifndef GL_ARB_texture_buffer_range
#define GL_ARB_texture_buffer_range 1
#endif /* GL_ARB_texture_buffer_range */

#ifndef GL_ARB_texture_compression_bptc
#define GL_ARB_texture_compression_bptc 1
#define GL_COMPRESSED_RGBA_BPTC_UNORM_ARB 0x8E8C
#define GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB 0x8E8D
#define GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB 0x8E8E
#define GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB 0x8E8F
#endif /* GL_ARB_texture_compression_bptc */

#ifndef GL_ARB_texture_compression_rgtc
#define GL_ARB_texture_compression_rgtc 1
#endif /* GL_ARB_texture_compression_rgtc */

#ifndef GL_ARB_texture_cube_map_array
#define GL_ARB_texture_cube_map_array 1
#define GL_TEXTURE_CUBE_MAP_ARRAY_ARB     0x9009
#define GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_ARB 0x900A
#define GL_PROXY_TEXTURE_CUBE_MAP_ARRAY_ARB 0x900B
#define GL_SAMPLER_CUBE_MAP_ARRAY_ARB     0x900C
#define GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_ARB 0x900D
#define GL_INT_SAMPLER_CUBE_MAP_ARRAY_ARB 0x900E
#define GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_ARB 0x900F
#endif /* GL_ARB_texture_cube_map_array */

#ifndef GL_ARB_texture_filter_anisotropic
#define GL_ARB_texture_filter_anisotropic 1
#endif /* GL_ARB_texture_filter_anisotropic */

#ifndef GL_ARB_texture_filter_minmax
#define GL_ARB_texture_filter_minmax 1
#define GL_TEXTURE_REDUCTION_MODE_ARB     0x9366
#define GL_WEIGHTED_AVERAGE_ARB           0x9367
#endif /* GL_ARB_texture_filter_minmax */

#ifndef GL_ARB_texture_gather
#define GL_ARB_texture_gather 1
#define GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET_ARB 0x8E5E
#define GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET_ARB 0x8E5F
#define GL_MAX_PROGRAM_TEXTURE_GATHER_COMPONENTS_ARB 0x8F9F
#endif /* GL_ARB_texture_gather */

#ifndef GL_ARB_texture_mirror_clamp_to_edge
#define GL_ARB_texture_mirror_clamp_to_edge 1
#endif /* GL_ARB_texture_mirror_clamp_to_edge */

#ifndef GL_ARB_texture_mirrored_repeat
#define GL_ARB_texture_mirrored_repeat 1
#define GL_MIRRORED_REPEAT_ARB            0x8370
#endif /* GL_ARB_texture_mirrored_repeat */

#ifndef GL_ARB_texture_multisample
#define GL_ARB_texture_multisample 1
#endif /* GL_ARB_texture_multisample */

#ifndef GL_ARB_texture_non_power_of_two
#define GL_ARB_texture_non_power_of_two 1
#endif /* GL_ARB_texture_non_power_of_two */

#ifndef GL_ARB_texture_query_levels
#define GL_ARB_texture_query_levels 1
#endif /* GL_ARB_texture_query_levels */

#ifndef GL_ARB_texture_query_lod
#define GL_ARB_texture_query_lod 1
#endif /* GL_ARB_texture_query_lod */

#ifndef GL_ARB_texture_rg
#define GL_ARB_texture_rg 1
#endif /* GL_ARB_texture_rg */

#ifndef GL_ARB_texture_rgb10_a2ui
#define GL_ARB_texture_rgb10_a2ui 1
#endif /* GL_ARB_texture_rgb10_a2ui */

#ifndef GL_ARB_texture_stencil8
#define GL_ARB_texture_stencil8 1
#endif /* GL_ARB_texture_stencil8 */

#ifndef GL_ARB_texture_storage
#define GL_ARB_texture_storage 1
#endif /* GL_ARB_texture_storage */

#ifndef GL_ARB_texture_storage_multisample
#define GL_ARB_texture_storage_multisample 1
#endif /* GL_ARB_texture_storage_multisample */

#ifndef GL_ARB_texture_swizzle
#define GL_ARB_texture_swizzle 1
#endif /* GL_ARB_texture_swizzle */

#ifndef GL_ARB_texture_view
#define GL_ARB_texture_view 1
#endif /* GL_ARB_texture_view */

#ifndef GL_ARB_timer_query
#define GL_ARB_timer_query 1
#endif /* GL_ARB_timer_query */

#ifndef GL_ARB_transform_feedback2
#define GL_ARB_transform_feedback2 1
#endif /* GL_ARB_transform_feedback2 */

#ifndef GL_ARB_transform_feedback3
#define GL_ARB_transform_feedback3 1
#endif /* GL_ARB_transform_feedback3 */

#ifndef GL_ARB_transform_feedback_instanced
#define GL_ARB_transform_feedback_instanced 1
#endif /* GL_ARB_transform_feedback_instanced */

#ifndef GL_ARB_transform_feedback_overflow_query
#define GL_ARB_transform_feedback_overflow_query 1
#define GL_TRANSFORM_FEEDBACK_OVERFLOW_ARB 0x82EC
#define GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW_ARB 0x82ED
#endif /* GL_ARB_transform_feedback_overflow_query */

#ifndef GL_ARB_uniform_buffer_object
#define GL_ARB_uniform_buffer_object 1
#endif /* GL_ARB_uniform_buffer_object */

#ifndef GL_ARB_vertex_array_bgra
#define GL_ARB_vertex_array_bgra 1
#endif /* GL_ARB_vertex_array_bgra */

#ifndef GL_ARB_vertex_array_object
#define GL_ARB_vertex_array_object 1
#endif /* GL_ARB_vertex_array_object */

#ifndef GL_ARB_vertex_attrib_64bit
#define GL_ARB_vertex_attrib_64bit 1
#endif /* GL_ARB_vertex_attrib_64bit */

#ifndef GL_ARB_vertex_attrib_binding
#define GL_ARB_vertex_attrib_binding 1
#endif /* GL_ARB_vertex_attrib_binding */

#ifndef GL_ARB_vertex_type_10f_11f_11f_rev
#define GL_ARB_vertex_type_10f_11f_11f_rev 1
#endif /* GL_ARB_vertex_type_10f_11f_11f_rev */

#ifndef GL_ARB_vertex_type_2_10_10_10_rev
#define GL_ARB_vertex_type_2_10_10_10_rev 1
#endif /* GL_ARB_vertex_type_2_10_10_10_rev */

#ifndef GL_ARB_viewport_array
#define GL_ARB_viewport_array 1
	typedef void (APIENTRYP PFNGLDEPTHRANGEARRAYDVNVPROC) (GLuint first, GLsizei count, const GLdouble* v);
	typedef void (APIENTRYP PFNGLDEPTHRANGEINDEXEDDNVPROC) (GLuint index, GLdouble n, GLdouble f);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glDepthRangeArraydvNV(GLuint first, GLsizei count, const GLdouble* v);
	GLAPI void APIENTRY glDepthRangeIndexeddNV(GLuint index, GLdouble n, GLdouble f);
#endif
#endif /* GL_ARB_viewport_array */

#ifndef GL_KHR_blend_equation_advanced
#define GL_KHR_blend_equation_advanced 1
#define GL_MULTIPLY_KHR                   0x9294
#define GL_SCREEN_KHR                     0x9295
#define GL_OVERLAY_KHR                    0x9296
#define GL_DARKEN_KHR                     0x9297
#define GL_LIGHTEN_KHR                    0x9298
#define GL_COLORDODGE_KHR                 0x9299
#define GL_COLORBURN_KHR                  0x929A
#define GL_HARDLIGHT_KHR                  0x929B
#define GL_SOFTLIGHT_KHR                  0x929C
#define GL_DIFFERENCE_KHR                 0x929E
#define GL_EXCLUSION_KHR                  0x92A0
#define GL_HSL_HUE_KHR                    0x92AD
#define GL_HSL_SATURATION_KHR             0x92AE
#define GL_HSL_COLOR_KHR                  0x92AF
#define GL_HSL_LUMINOSITY_KHR             0x92B0
	typedef void (APIENTRYP PFNGLBLENDBARRIERKHRPROC) (void);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glBlendBarrierKHR(void);
#endif
#endif /* GL_KHR_blend_equation_advanced */

#ifndef GL_KHR_blend_equation_advanced_coherent
#define GL_KHR_blend_equation_advanced_coherent 1
#define GL_BLEND_ADVANCED_COHERENT_KHR    0x9285
#endif /* GL_KHR_blend_equation_advanced_coherent */

#ifndef GL_KHR_context_flush_control
#define GL_KHR_context_flush_control 1
#endif /* GL_KHR_context_flush_control */

#ifndef GL_KHR_debug
#define GL_KHR_debug 1
#endif /* GL_KHR_debug */

#ifndef GL_KHR_no_error
#define GL_KHR_no_error 1
#define GL_CONTEXT_FLAG_NO_ERROR_BIT_KHR  0x00000008
#endif /* GL_KHR_no_error */

#ifndef GL_KHR_parallel_shader_compile
#define GL_KHR_parallel_shader_compile 1
#define GL_MAX_SHADER_COMPILER_THREADS_KHR 0x91B0
#define GL_COMPLETION_STATUS_KHR          0x91B1
	typedef void (APIENTRYP PFNGLMAXSHADERCOMPILERTHREADSKHRPROC) (GLuint count);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glMaxShaderCompilerThreadsKHR(GLuint count);
#endif
#endif /* GL_KHR_parallel_shader_compile */

#ifndef GL_KHR_robust_buffer_access_behavior
#define GL_KHR_robust_buffer_access_behavior 1
#endif /* GL_KHR_robust_buffer_access_behavior */

#ifndef GL_KHR_robustness
#define GL_KHR_robustness 1
#define GL_CONTEXT_ROBUST_ACCESS          0x90F3
#endif /* GL_KHR_robustness */

#ifndef GL_KHR_shader_subgroup
#define GL_KHR_shader_subgroup 1
#define GL_SUBGROUP_SIZE_KHR              0x9532
#define GL_SUBGROUP_SUPPORTED_STAGES_KHR  0x9533
#define GL_SUBGROUP_SUPPORTED_FEATURES_KHR 0x9534
#define GL_SUBGROUP_QUAD_ALL_STAGES_KHR   0x9535
#define GL_SUBGROUP_FEATURE_BASIC_BIT_KHR 0x00000001
#define GL_SUBGROUP_FEATURE_VOTE_BIT_KHR  0x00000002
#define GL_SUBGROUP_FEATURE_ARITHMETIC_BIT_KHR 0x00000004
#define GL_SUBGROUP_FEATURE_BALLOT_BIT_KHR 0x00000008
#define GL_SUBGROUP_FEATURE_SHUFFLE_BIT_KHR 0x00000010
#define GL_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT_KHR 0x00000020
#define GL_SUBGROUP_FEATURE_CLUSTERED_BIT_KHR 0x00000040
#define GL_SUBGROUP_FEATURE_QUAD_BIT_KHR  0x00000080
#endif /* GL_KHR_shader_subgroup */

#ifndef GL_KHR_texture_compression_astc_hdr
#define GL_KHR_texture_compression_astc_hdr 1
#define GL_COMPRESSED_RGBA_ASTC_4x4_KHR   0x93B0
#define GL_COMPRESSED_RGBA_ASTC_5x4_KHR   0x93B1
#define GL_COMPRESSED_RGBA_ASTC_5x5_KHR   0x93B2
#define GL_COMPRESSED_RGBA_ASTC_6x5_KHR   0x93B3
#define GL_COMPRESSED_RGBA_ASTC_6x6_KHR   0x93B4
#define GL_COMPRESSED_RGBA_ASTC_8x5_KHR   0x93B5
#define GL_COMPRESSED_RGBA_ASTC_8x6_KHR   0x93B6
#define GL_COMPRESSED_RGBA_ASTC_8x8_KHR   0x93B7
#define GL_COMPRESSED_RGBA_ASTC_10x5_KHR  0x93B8
#define GL_COMPRESSED_RGBA_ASTC_10x6_KHR  0x93B9
#define GL_COMPRESSED_RGBA_ASTC_10x8_KHR  0x93BA
#define GL_COMPRESSED_RGBA_ASTC_10x10_KHR 0x93BB
#define GL_COMPRESSED_RGBA_ASTC_12x10_KHR 0x93BC
#define GL_COMPRESSED_RGBA_ASTC_12x12_KHR 0x93BD
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR 0x93D0
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR 0x93D1
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR 0x93D2
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR 0x93D3
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR 0x93D4
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR 0x93D5
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR 0x93D6
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR 0x93D7
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR 0x93D8
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR 0x93D9
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR 0x93DA
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR 0x93DB
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR 0x93DC
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR 0x93DD
#endif /* GL_KHR_texture_compression_astc_hdr */

#ifndef GL_KHR_texture_compression_astc_ldr
#define GL_KHR_texture_compression_astc_ldr 1
#endif /* GL_KHR_texture_compression_astc_ldr */

#ifndef GL_KHR_texture_compression_astc_sliced_3d
#define GL_KHR_texture_compression_astc_sliced_3d 1
#endif /* GL_KHR_texture_compression_astc_sliced_3d */

#ifndef GL_AMD_framebuffer_multisample_advanced
#define GL_AMD_framebuffer_multisample_advanced 1
#define GL_RENDERBUFFER_STORAGE_SAMPLES_AMD 0x91B2
#define GL_MAX_COLOR_FRAMEBUFFER_SAMPLES_AMD 0x91B3
#define GL_MAX_COLOR_FRAMEBUFFER_STORAGE_SAMPLES_AMD 0x91B4
#define GL_MAX_DEPTH_STENCIL_FRAMEBUFFER_SAMPLES_AMD 0x91B5
#define GL_NUM_SUPPORTED_MULTISAMPLE_MODES_AMD 0x91B6
#define GL_SUPPORTED_MULTISAMPLE_MODES_AMD 0x91B7
	typedef void (APIENTRYP PFNGLRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMDPROC) (GLenum target, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMDPROC) (GLuint renderbuffer, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glRenderbufferStorageMultisampleAdvancedAMD(GLenum target, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glNamedRenderbufferStorageMultisampleAdvancedAMD(GLuint renderbuffer, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height);
#endif
#endif /* GL_AMD_framebuffer_multisample_advanced */

#ifndef GL_AMD_performance_monitor
#define GL_AMD_performance_monitor 1
#define GL_COUNTER_TYPE_AMD               0x8BC0
#define GL_COUNTER_RANGE_AMD              0x8BC1
#define GL_UNSIGNED_INT64_AMD             0x8BC2
#define GL_PERCENTAGE_AMD                 0x8BC3
#define GL_PERFMON_RESULT_AVAILABLE_AMD   0x8BC4
#define GL_PERFMON_RESULT_SIZE_AMD        0x8BC5
#define GL_PERFMON_RESULT_AMD             0x8BC6
	typedef void (APIENTRYP PFNGLGETPERFMONITORGROUPSAMDPROC) (GLint* numGroups, GLsizei groupsSize, GLuint* groups);
	typedef void (APIENTRYP PFNGLGETPERFMONITORCOUNTERSAMDPROC) (GLuint group, GLint* numCounters, GLint* maxActiveCounters, GLsizei counterSize, GLuint* counters);
	typedef void (APIENTRYP PFNGLGETPERFMONITORGROUPSTRINGAMDPROC) (GLuint group, GLsizei bufSize, GLsizei* length, GLchar* groupString);
	typedef void (APIENTRYP PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC) (GLuint group, GLuint counter, GLsizei bufSize, GLsizei* length, GLchar* counterString);
	typedef void (APIENTRYP PFNGLGETPERFMONITORCOUNTERINFOAMDPROC) (GLuint group, GLuint counter, GLenum pname, void* data);
	typedef void (APIENTRYP PFNGLGENPERFMONITORSAMDPROC) (GLsizei n, GLuint* monitors);
	typedef void (APIENTRYP PFNGLDELETEPERFMONITORSAMDPROC) (GLsizei n, GLuint* monitors);
	typedef void (APIENTRYP PFNGLSELECTPERFMONITORCOUNTERSAMDPROC) (GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint* counterList);
	typedef void (APIENTRYP PFNGLBEGINPERFMONITORAMDPROC) (GLuint monitor);
	typedef void (APIENTRYP PFNGLENDPERFMONITORAMDPROC) (GLuint monitor);
	typedef void (APIENTRYP PFNGLGETPERFMONITORCOUNTERDATAAMDPROC) (GLuint monitor, GLenum pname, GLsizei dataSize, GLuint* data, GLint* bytesWritten);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glGetPerfMonitorGroupsAMD(GLint* numGroups, GLsizei groupsSize, GLuint* groups);
	GLAPI void APIENTRY glGetPerfMonitorCountersAMD(GLuint group, GLint* numCounters, GLint* maxActiveCounters, GLsizei counterSize, GLuint* counters);
	GLAPI void APIENTRY glGetPerfMonitorGroupStringAMD(GLuint group, GLsizei bufSize, GLsizei* length, GLchar* groupString);
	GLAPI void APIENTRY glGetPerfMonitorCounterStringAMD(GLuint group, GLuint counter, GLsizei bufSize, GLsizei* length, GLchar* counterString);
	GLAPI void APIENTRY glGetPerfMonitorCounterInfoAMD(GLuint group, GLuint counter, GLenum pname, void* data);
	GLAPI void APIENTRY glGenPerfMonitorsAMD(GLsizei n, GLuint* monitors);
	GLAPI void APIENTRY glDeletePerfMonitorsAMD(GLsizei n, GLuint* monitors);
	GLAPI void APIENTRY glSelectPerfMonitorCountersAMD(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint* counterList);
	GLAPI void APIENTRY glBeginPerfMonitorAMD(GLuint monitor);
	GLAPI void APIENTRY glEndPerfMonitorAMD(GLuint monitor);
	GLAPI void APIENTRY glGetPerfMonitorCounterDataAMD(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint* data, GLint* bytesWritten);
#endif
#endif /* GL_AMD_performance_monitor */

#ifndef GL_APPLE_rgb_422
#define GL_APPLE_rgb_422 1
#define GL_RGB_422_APPLE                  0x8A1F
#define GL_UNSIGNED_SHORT_8_8_APPLE       0x85BA
#define GL_UNSIGNED_SHORT_8_8_REV_APPLE   0x85BB
#define GL_RGB_RAW_422_APPLE              0x8A51
#endif /* GL_APPLE_rgb_422 */

#ifndef GL_EXT_EGL_image_storage
#define GL_EXT_EGL_image_storage 1
	typedef void* GLeglImageOES;
	typedef void (APIENTRYP PFNGLEGLIMAGETARGETTEXSTORAGEEXTPROC) (GLenum target, GLeglImageOES image, const GLint* attrib_list);
	typedef void (APIENTRYP PFNGLEGLIMAGETARGETTEXTURESTORAGEEXTPROC) (GLuint texture, GLeglImageOES image, const GLint* attrib_list);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glEGLImageTargetTexStorageEXT(GLenum target, GLeglImageOES image, const GLint* attrib_list);
	GLAPI void APIENTRY glEGLImageTargetTextureStorageEXT(GLuint texture, GLeglImageOES image, const GLint* attrib_list);
#endif
#endif /* GL_EXT_EGL_image_storage */

#ifndef GL_EXT_EGL_sync
#define GL_EXT_EGL_sync 1
#endif /* GL_EXT_EGL_sync */

#ifndef GL_EXT_debug_label
#define GL_EXT_debug_label 1
#define GL_PROGRAM_PIPELINE_OBJECT_EXT    0x8A4F
#define GL_PROGRAM_OBJECT_EXT             0x8B40
#define GL_SHADER_OBJECT_EXT              0x8B48
#define GL_BUFFER_OBJECT_EXT              0x9151
#define GL_QUERY_OBJECT_EXT               0x9153
#define GL_VERTEX_ARRAY_OBJECT_EXT        0x9154
	typedef void (APIENTRYP PFNGLLABELOBJECTEXTPROC) (GLenum type, GLuint object, GLsizei length, const GLchar* label);
	typedef void (APIENTRYP PFNGLGETOBJECTLABELEXTPROC) (GLenum type, GLuint object, GLsizei bufSize, GLsizei* length, GLchar* label);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glLabelObjectEXT(GLenum type, GLuint object, GLsizei length, const GLchar* label);
	GLAPI void APIENTRY glGetObjectLabelEXT(GLenum type, GLuint object, GLsizei bufSize, GLsizei* length, GLchar* label);
#endif
#endif /* GL_EXT_debug_label */

#ifndef GL_EXT_debug_marker
#define GL_EXT_debug_marker 1
	typedef void (APIENTRYP PFNGLINSERTEVENTMARKEREXTPROC) (GLsizei length, const GLchar* marker);
	typedef void (APIENTRYP PFNGLPUSHGROUPMARKEREXTPROC) (GLsizei length, const GLchar* marker);
	typedef void (APIENTRYP PFNGLPOPGROUPMARKEREXTPROC) (void);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glInsertEventMarkerEXT(GLsizei length, const GLchar* marker);
	GLAPI void APIENTRY glPushGroupMarkerEXT(GLsizei length, const GLchar* marker);
	GLAPI void APIENTRY glPopGroupMarkerEXT(void);
#endif
#endif /* GL_EXT_debug_marker */

#ifndef GL_EXT_direct_state_access
#define GL_EXT_direct_state_access 1
#define GL_PROGRAM_MATRIX_EXT             0x8E2D
#define GL_TRANSPOSE_PROGRAM_MATRIX_EXT   0x8E2E
#define GL_PROGRAM_MATRIX_STACK_DEPTH_EXT 0x8E2F
	typedef void (APIENTRYP PFNGLMATRIXLOADFEXTPROC) (GLenum mode, const GLfloat* m);
	typedef void (APIENTRYP PFNGLMATRIXLOADDEXTPROC) (GLenum mode, const GLdouble* m);
	typedef void (APIENTRYP PFNGLMATRIXMULTFEXTPROC) (GLenum mode, const GLfloat* m);
	typedef void (APIENTRYP PFNGLMATRIXMULTDEXTPROC) (GLenum mode, const GLdouble* m);
	typedef void (APIENTRYP PFNGLMATRIXLOADIDENTITYEXTPROC) (GLenum mode);
	typedef void (APIENTRYP PFNGLMATRIXROTATEFEXTPROC) (GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
	typedef void (APIENTRYP PFNGLMATRIXROTATEDEXTPROC) (GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
	typedef void (APIENTRYP PFNGLMATRIXSCALEFEXTPROC) (GLenum mode, GLfloat x, GLfloat y, GLfloat z);
	typedef void (APIENTRYP PFNGLMATRIXSCALEDEXTPROC) (GLenum mode, GLdouble x, GLdouble y, GLdouble z);
	typedef void (APIENTRYP PFNGLMATRIXTRANSLATEFEXTPROC) (GLenum mode, GLfloat x, GLfloat y, GLfloat z);
	typedef void (APIENTRYP PFNGLMATRIXTRANSLATEDEXTPROC) (GLenum mode, GLdouble x, GLdouble y, GLdouble z);
	typedef void (APIENTRYP PFNGLMATRIXFRUSTUMEXTPROC) (GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
	typedef void (APIENTRYP PFNGLMATRIXORTHOEXTPROC) (GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
	typedef void (APIENTRYP PFNGLMATRIXPOPEXTPROC) (GLenum mode);
	typedef void (APIENTRYP PFNGLMATRIXPUSHEXTPROC) (GLenum mode);
	typedef void (APIENTRYP PFNGLCLIENTATTRIBDEFAULTEXTPROC) (GLbitfield mask);
	typedef void (APIENTRYP PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC) (GLbitfield mask);
	typedef void (APIENTRYP PFNGLTEXTUREPARAMETERFEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLfloat param);
	typedef void (APIENTRYP PFNGLTEXTUREPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLfloat* params);
	typedef void (APIENTRYP PFNGLTEXTUREPARAMETERIEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint param);
	typedef void (APIENTRYP PFNGLTEXTUREPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLint* params);
	typedef void (APIENTRYP PFNGLTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void* pixels);
	typedef void (APIENTRYP PFNGLTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void* pixels);
	typedef void (APIENTRYP PFNGLTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void* pixels);
	typedef void (APIENTRYP PFNGLTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels);
	typedef void (APIENTRYP PFNGLCOPYTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
	typedef void (APIENTRYP PFNGLCOPYTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
	typedef void (APIENTRYP PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
	typedef void (APIENTRYP PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLGETTEXTUREIMAGEEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, void* pixels);
	typedef void (APIENTRYP PFNGLGETTEXTUREPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLfloat* params);
	typedef void (APIENTRYP PFNGLGETTEXTUREPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat* params);
	typedef void (APIENTRYP PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLTEXTUREIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void* pixels);
	typedef void (APIENTRYP PFNGLTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels);
	typedef void (APIENTRYP PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLBINDMULTITEXTUREEXTPROC) (GLenum texunit, GLenum target, GLuint texture);
	typedef void (APIENTRYP PFNGLMULTITEXCOORDPOINTEREXTPROC) (GLenum texunit, GLint size, GLenum type, GLsizei stride, const void* pointer);
	typedef void (APIENTRYP PFNGLMULTITEXENVFEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
	typedef void (APIENTRYP PFNGLMULTITEXENVFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLfloat* params);
	typedef void (APIENTRYP PFNGLMULTITEXENVIEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint param);
	typedef void (APIENTRYP PFNGLMULTITEXENVIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* params);
	typedef void (APIENTRYP PFNGLMULTITEXGENDEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLdouble param);
	typedef void (APIENTRYP PFNGLMULTITEXGENDVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLdouble* params);
	typedef void (APIENTRYP PFNGLMULTITEXGENFEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLfloat param);
	typedef void (APIENTRYP PFNGLMULTITEXGENFVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLfloat* params);
	typedef void (APIENTRYP PFNGLMULTITEXGENIEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLint param);
	typedef void (APIENTRYP PFNGLMULTITEXGENIVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLint* params);
	typedef void (APIENTRYP PFNGLGETMULTITEXENVFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat* params);
	typedef void (APIENTRYP PFNGLGETMULTITEXENVIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLGETMULTITEXGENDVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLdouble* params);
	typedef void (APIENTRYP PFNGLGETMULTITEXGENFVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLfloat* params);
	typedef void (APIENTRYP PFNGLGETMULTITEXGENIVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLMULTITEXPARAMETERIEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint param);
	typedef void (APIENTRYP PFNGLMULTITEXPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* params);
	typedef void (APIENTRYP PFNGLMULTITEXPARAMETERFEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
	typedef void (APIENTRYP PFNGLMULTITEXPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLfloat* params);
	typedef void (APIENTRYP PFNGLMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void* pixels);
	typedef void (APIENTRYP PFNGLMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void* pixels);
	typedef void (APIENTRYP PFNGLMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void* pixels);
	typedef void (APIENTRYP PFNGLMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels);
	typedef void (APIENTRYP PFNGLCOPYMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
	typedef void (APIENTRYP PFNGLCOPYMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
	typedef void (APIENTRYP PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
	typedef void (APIENTRYP PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLGETMULTITEXIMAGEEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, void* pixels);
	typedef void (APIENTRYP PFNGLGETMULTITEXPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat* params);
	typedef void (APIENTRYP PFNGLGETMULTITEXPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat* params);
	typedef void (APIENTRYP PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLMULTITEXIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void* pixels);
	typedef void (APIENTRYP PFNGLMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels);
	typedef void (APIENTRYP PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLENABLECLIENTSTATEINDEXEDEXTPROC) (GLenum array, GLuint index);
	typedef void (APIENTRYP PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC) (GLenum array, GLuint index);
	typedef void (APIENTRYP PFNGLGETFLOATINDEXEDVEXTPROC) (GLenum target, GLuint index, GLfloat* data);
	typedef void (APIENTRYP PFNGLGETDOUBLEINDEXEDVEXTPROC) (GLenum target, GLuint index, GLdouble* data);
	typedef void (APIENTRYP PFNGLGETPOINTERINDEXEDVEXTPROC) (GLenum target, GLuint index, void** data);
	typedef void (APIENTRYP PFNGLENABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
	typedef void (APIENTRYP PFNGLDISABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
	typedef GLboolean(APIENTRYP PFNGLISENABLEDINDEXEDEXTPROC) (GLenum target, GLuint index);
	typedef void (APIENTRYP PFNGLGETINTEGERINDEXEDVEXTPROC) (GLenum target, GLuint index, GLint* data);
	typedef void (APIENTRYP PFNGLGETBOOLEANINDEXEDVEXTPROC) (GLenum target, GLuint index, GLboolean* data);
	typedef void (APIENTRYP PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void* bits);
	typedef void (APIENTRYP PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void* bits);
	typedef void (APIENTRYP PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void* bits);
	typedef void (APIENTRYP PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* bits);
	typedef void (APIENTRYP PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* bits);
	typedef void (APIENTRYP PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void* bits);
	typedef void (APIENTRYP PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC) (GLuint texture, GLenum target, GLint lod, void* img);
	typedef void (APIENTRYP PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void* bits);
	typedef void (APIENTRYP PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void* bits);
	typedef void (APIENTRYP PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void* bits);
	typedef void (APIENTRYP PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* bits);
	typedef void (APIENTRYP PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* bits);
	typedef void (APIENTRYP PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void* bits);
	typedef void (APIENTRYP PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC) (GLenum texunit, GLenum target, GLint lod, void* img);
	typedef void (APIENTRYP PFNGLMATRIXLOADTRANSPOSEFEXTPROC) (GLenum mode, const GLfloat* m);
	typedef void (APIENTRYP PFNGLMATRIXLOADTRANSPOSEDEXTPROC) (GLenum mode, const GLdouble* m);
	typedef void (APIENTRYP PFNGLMATRIXMULTTRANSPOSEFEXTPROC) (GLenum mode, const GLfloat* m);
	typedef void (APIENTRYP PFNGLMATRIXMULTTRANSPOSEDEXTPROC) (GLenum mode, const GLdouble* m);
	typedef void (APIENTRYP PFNGLNAMEDBUFFERDATAEXTPROC) (GLuint buffer, GLsizeiptr size, const void* data, GLenum usage);
	typedef void (APIENTRYP PFNGLNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, const void* data);
	typedef void* (APIENTRYP PFNGLMAPNAMEDBUFFEREXTPROC) (GLuint buffer, GLenum access);
	typedef GLboolean(APIENTRYP PFNGLUNMAPNAMEDBUFFEREXTPROC) (GLuint buffer);
	typedef void (APIENTRYP PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC) (GLuint buffer, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLGETNAMEDBUFFERPOINTERVEXTPROC) (GLuint buffer, GLenum pname, void** params);
	typedef void (APIENTRYP PFNGLGETNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, void* data);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1FEXTPROC) (GLuint program, GLint location, GLfloat v0);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1IEXTPROC) (GLuint program, GLint location, GLint v0);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	typedef void (APIENTRYP PFNGLTEXTUREBUFFEREXTPROC) (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer);
	typedef void (APIENTRYP PFNGLMULTITEXBUFFEREXTPROC) (GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer);
	typedef void (APIENTRYP PFNGLTEXTUREPARAMETERIIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLint* params);
	typedef void (APIENTRYP PFNGLTEXTUREPARAMETERIUIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLuint* params);
	typedef void (APIENTRYP PFNGLGETTEXTUREPARAMETERIIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLGETTEXTUREPARAMETERIUIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLuint* params);
	typedef void (APIENTRYP PFNGLMULTITEXPARAMETERIIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* params);
	typedef void (APIENTRYP PFNGLMULTITEXPARAMETERIUIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLuint* params);
	typedef void (APIENTRYP PFNGLGETMULTITEXPARAMETERIIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLGETMULTITEXPARAMETERIUIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLuint* params);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1UIEXTPROC) (GLuint program, GLint location, GLuint v0);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
	typedef void (APIENTRYP PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat* params);
	typedef void (APIENTRYP PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC) (GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
	typedef void (APIENTRYP PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLint* params);
	typedef void (APIENTRYP PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLint* params);
	typedef void (APIENTRYP PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC) (GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
	typedef void (APIENTRYP PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLuint* params);
	typedef void (APIENTRYP PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint* params);
	typedef void (APIENTRYP PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLint* params);
	typedef void (APIENTRYP PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLuint* params);
	typedef void (APIENTRYP PFNGLENABLECLIENTSTATEIEXTPROC) (GLenum array, GLuint index);
	typedef void (APIENTRYP PFNGLDISABLECLIENTSTATEIEXTPROC) (GLenum array, GLuint index);
	typedef void (APIENTRYP PFNGLGETFLOATI_VEXTPROC) (GLenum pname, GLuint index, GLfloat* params);
	typedef void (APIENTRYP PFNGLGETDOUBLEI_VEXTPROC) (GLenum pname, GLuint index, GLdouble* params);
	typedef void (APIENTRYP PFNGLGETPOINTERI_VEXTPROC) (GLenum pname, GLuint index, void** params);
	typedef void (APIENTRYP PFNGLNAMEDPROGRAMSTRINGEXTPROC) (GLuint program, GLenum target, GLenum format, GLsizei len, const void* string);
	typedef void (APIENTRYP PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC) (GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
	typedef void (APIENTRYP PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLdouble* params);
	typedef void (APIENTRYP PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC) (GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
	typedef void (APIENTRYP PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLfloat* params);
	typedef void (APIENTRYP PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC) (GLuint program, GLenum target, GLuint index, GLdouble* params);
	typedef void (APIENTRYP PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC) (GLuint program, GLenum target, GLuint index, GLfloat* params);
	typedef void (APIENTRYP PFNGLGETNAMEDPROGRAMIVEXTPROC) (GLuint program, GLenum target, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLGETNAMEDPROGRAMSTRINGEXTPROC) (GLuint program, GLenum target, GLenum pname, void* string);
	typedef void (APIENTRYP PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC) (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC) (GLuint renderbuffer, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) (GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC) (GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
	typedef GLenum(APIENTRYP PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC) (GLuint framebuffer, GLenum target);
	typedef void (APIENTRYP PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
	typedef void (APIENTRYP PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
	typedef void (APIENTRYP PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
	typedef void (APIENTRYP PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC) (GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
	typedef void (APIENTRYP PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLGENERATETEXTUREMIPMAPEXTPROC) (GLuint texture, GLenum target);
	typedef void (APIENTRYP PFNGLGENERATEMULTITEXMIPMAPEXTPROC) (GLenum texunit, GLenum target);
	typedef void (APIENTRYP PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC) (GLuint framebuffer, GLenum mode);
	typedef void (APIENTRYP PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC) (GLuint framebuffer, GLsizei n, const GLenum* bufs);
	typedef void (APIENTRYP PFNGLFRAMEBUFFERREADBUFFEREXTPROC) (GLuint framebuffer, GLenum mode);
	typedef void (APIENTRYP PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC) (GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
	typedef void (APIENTRYP PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
	typedef void (APIENTRYP PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
	typedef void (APIENTRYP PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face);
	typedef void (APIENTRYP PFNGLTEXTURERENDERBUFFEREXTPROC) (GLuint texture, GLenum target, GLuint renderbuffer);
	typedef void (APIENTRYP PFNGLMULTITEXRENDERBUFFEREXTPROC) (GLenum texunit, GLenum target, GLuint renderbuffer);
	typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
	typedef void (APIENTRYP PFNGLVERTEXARRAYCOLOROFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
	typedef void (APIENTRYP PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset);
	typedef void (APIENTRYP PFNGLVERTEXARRAYINDEXOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
	typedef void (APIENTRYP PFNGLVERTEXARRAYNORMALOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
	typedef void (APIENTRYP PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
	typedef void (APIENTRYP PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset);
	typedef void (APIENTRYP PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
	typedef void (APIENTRYP PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
	typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset);
	typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
	typedef void (APIENTRYP PFNGLENABLEVERTEXARRAYEXTPROC) (GLuint vaobj, GLenum array);
	typedef void (APIENTRYP PFNGLDISABLEVERTEXARRAYEXTPROC) (GLuint vaobj, GLenum array);
	typedef void (APIENTRYP PFNGLENABLEVERTEXARRAYATTRIBEXTPROC) (GLuint vaobj, GLuint index);
	typedef void (APIENTRYP PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC) (GLuint vaobj, GLuint index);
	typedef void (APIENTRYP PFNGLGETVERTEXARRAYINTEGERVEXTPROC) (GLuint vaobj, GLenum pname, GLint* param);
	typedef void (APIENTRYP PFNGLGETVERTEXARRAYPOINTERVEXTPROC) (GLuint vaobj, GLenum pname, void** param);
	typedef void (APIENTRYP PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC) (GLuint vaobj, GLuint index, GLenum pname, GLint* param);
	typedef void (APIENTRYP PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC) (GLuint vaobj, GLuint index, GLenum pname, void** param);
	typedef void* (APIENTRYP PFNGLMAPNAMEDBUFFERRANGEEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
	typedef void (APIENTRYP PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
	typedef void (APIENTRYP PFNGLNAMEDBUFFERSTORAGEEXTPROC) (GLuint buffer, GLsizeiptr size, const void* data, GLbitfield flags);
	typedef void (APIENTRYP PFNGLCLEARNAMEDBUFFERDATAEXTPROC) (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void* data);
	typedef void (APIENTRYP PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLenum internalformat, GLsizeiptr offset, GLsizeiptr size, GLenum format, GLenum type, const void* data);
	typedef void (APIENTRYP PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC) (GLuint framebuffer, GLenum pname, GLint param);
	typedef void (APIENTRYP PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum pname, GLint* params);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1DEXTPROC) (GLuint program, GLint location, GLdouble x);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2DEXTPROC) (GLuint program, GLint location, GLdouble x, GLdouble y);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3DEXTPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4DEXTPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1DVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2DVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3DVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4DVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2X3DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2X4DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3X2DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3X4DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4X2DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4X3DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	typedef void (APIENTRYP PFNGLTEXTUREBUFFERRANGEEXTPROC) (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
	typedef void (APIENTRYP PFNGLTEXTURESTORAGE1DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
	typedef void (APIENTRYP PFNGLTEXTURESTORAGE2DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLTEXTURESTORAGE3DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
	typedef void (APIENTRYP PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC) (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
	typedef void (APIENTRYP PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC) (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
	typedef void (APIENTRYP PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC) (GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
	typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
	typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
	typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
	typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC) (GLuint vaobj, GLuint attribindex, GLuint bindingindex);
	typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC) (GLuint vaobj, GLuint bindingindex, GLuint divisor);
	typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
	typedef void (APIENTRYP PFNGLTEXTUREPAGECOMMITMENTEXTPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);
	typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXATTRIBDIVISOREXTPROC) (GLuint vaobj, GLuint index, GLuint divisor);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glMatrixLoadfEXT(GLenum mode, const GLfloat* m);
	GLAPI void APIENTRY glMatrixLoaddEXT(GLenum mode, const GLdouble* m);
	GLAPI void APIENTRY glMatrixMultfEXT(GLenum mode, const GLfloat* m);
	GLAPI void APIENTRY glMatrixMultdEXT(GLenum mode, const GLdouble* m);
	GLAPI void APIENTRY glMatrixLoadIdentityEXT(GLenum mode);
	GLAPI void APIENTRY glMatrixRotatefEXT(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
	GLAPI void APIENTRY glMatrixRotatedEXT(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
	GLAPI void APIENTRY glMatrixScalefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z);
	GLAPI void APIENTRY glMatrixScaledEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z);
	GLAPI void APIENTRY glMatrixTranslatefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z);
	GLAPI void APIENTRY glMatrixTranslatedEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z);
	GLAPI void APIENTRY glMatrixFrustumEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
	GLAPI void APIENTRY glMatrixOrthoEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
	GLAPI void APIENTRY glMatrixPopEXT(GLenum mode);
	GLAPI void APIENTRY glMatrixPushEXT(GLenum mode);
	GLAPI void APIENTRY glClientAttribDefaultEXT(GLbitfield mask);
	GLAPI void APIENTRY glPushClientAttribDefaultEXT(GLbitfield mask);
	GLAPI void APIENTRY glTextureParameterfEXT(GLuint texture, GLenum target, GLenum pname, GLfloat param);
	GLAPI void APIENTRY glTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, const GLfloat* params);
	GLAPI void APIENTRY glTextureParameteriEXT(GLuint texture, GLenum target, GLenum pname, GLint param);
	GLAPI void APIENTRY glTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, const GLint* params);
	GLAPI void APIENTRY glTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void* pixels);
	GLAPI void APIENTRY glTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void* pixels);
	GLAPI void APIENTRY glTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void* pixels);
	GLAPI void APIENTRY glTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels);
	GLAPI void APIENTRY glCopyTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
	GLAPI void APIENTRY glCopyTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
	GLAPI void APIENTRY glCopyTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
	GLAPI void APIENTRY glCopyTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glGetTextureImageEXT(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, void* pixels);
	GLAPI void APIENTRY glGetTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, GLfloat* params);
	GLAPI void APIENTRY glGetTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, GLint* params);
	GLAPI void APIENTRY glGetTextureLevelParameterfvEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat* params);
	GLAPI void APIENTRY glGetTextureLevelParameterivEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLint* params);
	GLAPI void APIENTRY glTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void* pixels);
	GLAPI void APIENTRY glTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels);
	GLAPI void APIENTRY glCopyTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glBindMultiTextureEXT(GLenum texunit, GLenum target, GLuint texture);
	GLAPI void APIENTRY glMultiTexCoordPointerEXT(GLenum texunit, GLint size, GLenum type, GLsizei stride, const void* pointer);
	GLAPI void APIENTRY glMultiTexEnvfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param);
	GLAPI void APIENTRY glMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat* params);
	GLAPI void APIENTRY glMultiTexEnviEXT(GLenum texunit, GLenum target, GLenum pname, GLint param);
	GLAPI void APIENTRY glMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint* params);
	GLAPI void APIENTRY glMultiTexGendEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble param);
	GLAPI void APIENTRY glMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLdouble* params);
	GLAPI void APIENTRY glMultiTexGenfEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat param);
	GLAPI void APIENTRY glMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLfloat* params);
	GLAPI void APIENTRY glMultiTexGeniEXT(GLenum texunit, GLenum coord, GLenum pname, GLint param);
	GLAPI void APIENTRY glMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, const GLint* params);
	GLAPI void APIENTRY glGetMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat* params);
	GLAPI void APIENTRY glGetMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, GLint* params);
	GLAPI void APIENTRY glGetMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble* params);
	GLAPI void APIENTRY glGetMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat* params);
	GLAPI void APIENTRY glGetMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, GLint* params);
	GLAPI void APIENTRY glMultiTexParameteriEXT(GLenum texunit, GLenum target, GLenum pname, GLint param);
	GLAPI void APIENTRY glMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint* params);
	GLAPI void APIENTRY glMultiTexParameterfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param);
	GLAPI void APIENTRY glMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat* params);
	GLAPI void APIENTRY glMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void* pixels);
	GLAPI void APIENTRY glMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void* pixels);
	GLAPI void APIENTRY glMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void* pixels);
	GLAPI void APIENTRY glMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels);
	GLAPI void APIENTRY glCopyMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
	GLAPI void APIENTRY glCopyMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
	GLAPI void APIENTRY glCopyMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
	GLAPI void APIENTRY glCopyMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glGetMultiTexImageEXT(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, void* pixels);
	GLAPI void APIENTRY glGetMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat* params);
	GLAPI void APIENTRY glGetMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, GLint* params);
	GLAPI void APIENTRY glGetMultiTexLevelParameterfvEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat* params);
	GLAPI void APIENTRY glGetMultiTexLevelParameterivEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint* params);
	GLAPI void APIENTRY glMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void* pixels);
	GLAPI void APIENTRY glMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels);
	GLAPI void APIENTRY glCopyMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glEnableClientStateIndexedEXT(GLenum array, GLuint index);
	GLAPI void APIENTRY glDisableClientStateIndexedEXT(GLenum array, GLuint index);
	GLAPI void APIENTRY glGetFloatIndexedvEXT(GLenum target, GLuint index, GLfloat* data);
	GLAPI void APIENTRY glGetDoubleIndexedvEXT(GLenum target, GLuint index, GLdouble* data);
	GLAPI void APIENTRY glGetPointerIndexedvEXT(GLenum target, GLuint index, void** data);
	GLAPI void APIENTRY glEnableIndexedEXT(GLenum target, GLuint index);
	GLAPI void APIENTRY glDisableIndexedEXT(GLenum target, GLuint index);
	GLAPI GLboolean APIENTRY glIsEnabledIndexedEXT(GLenum target, GLuint index);
	GLAPI void APIENTRY glGetIntegerIndexedvEXT(GLenum target, GLuint index, GLint* data);
	GLAPI void APIENTRY glGetBooleanIndexedvEXT(GLenum target, GLuint index, GLboolean* data);
	GLAPI void APIENTRY glCompressedTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void* bits);
	GLAPI void APIENTRY glCompressedTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void* bits);
	GLAPI void APIENTRY glCompressedTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void* bits);
	GLAPI void APIENTRY glCompressedTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* bits);
	GLAPI void APIENTRY glCompressedTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* bits);
	GLAPI void APIENTRY glCompressedTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void* bits);
	GLAPI void APIENTRY glGetCompressedTextureImageEXT(GLuint texture, GLenum target, GLint lod, void* img);
	GLAPI void APIENTRY glCompressedMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void* bits);
	GLAPI void APIENTRY glCompressedMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void* bits);
	GLAPI void APIENTRY glCompressedMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void* bits);
	GLAPI void APIENTRY glCompressedMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* bits);
	GLAPI void APIENTRY glCompressedMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* bits);
	GLAPI void APIENTRY glCompressedMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void* bits);
	GLAPI void APIENTRY glGetCompressedMultiTexImageEXT(GLenum texunit, GLenum target, GLint lod, void* img);
	GLAPI void APIENTRY glMatrixLoadTransposefEXT(GLenum mode, const GLfloat* m);
	GLAPI void APIENTRY glMatrixLoadTransposedEXT(GLenum mode, const GLdouble* m);
	GLAPI void APIENTRY glMatrixMultTransposefEXT(GLenum mode, const GLfloat* m);
	GLAPI void APIENTRY glMatrixMultTransposedEXT(GLenum mode, const GLdouble* m);
	GLAPI void APIENTRY glNamedBufferDataEXT(GLuint buffer, GLsizeiptr size, const void* data, GLenum usage);
	GLAPI void APIENTRY glNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, const void* data);
	GLAPI void* APIENTRY glMapNamedBufferEXT(GLuint buffer, GLenum access);
	GLAPI GLboolean APIENTRY glUnmapNamedBufferEXT(GLuint buffer);
	GLAPI void APIENTRY glGetNamedBufferParameterivEXT(GLuint buffer, GLenum pname, GLint* params);
	GLAPI void APIENTRY glGetNamedBufferPointervEXT(GLuint buffer, GLenum pname, void** params);
	GLAPI void APIENTRY glGetNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, void* data);
	GLAPI void APIENTRY glProgramUniform1fEXT(GLuint program, GLint location, GLfloat v0);
	GLAPI void APIENTRY glProgramUniform2fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1);
	GLAPI void APIENTRY glProgramUniform3fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
	GLAPI void APIENTRY glProgramUniform4fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
	GLAPI void APIENTRY glProgramUniform1iEXT(GLuint program, GLint location, GLint v0);
	GLAPI void APIENTRY glProgramUniform2iEXT(GLuint program, GLint location, GLint v0, GLint v1);
	GLAPI void APIENTRY glProgramUniform3iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
	GLAPI void APIENTRY glProgramUniform4iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
	GLAPI void APIENTRY glProgramUniform1fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat* value);
	GLAPI void APIENTRY glProgramUniform2fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat* value);
	GLAPI void APIENTRY glProgramUniform3fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat* value);
	GLAPI void APIENTRY glProgramUniform4fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat* value);
	GLAPI void APIENTRY glProgramUniform1ivEXT(GLuint program, GLint location, GLsizei count, const GLint* value);
	GLAPI void APIENTRY glProgramUniform2ivEXT(GLuint program, GLint location, GLsizei count, const GLint* value);
	GLAPI void APIENTRY glProgramUniform3ivEXT(GLuint program, GLint location, GLsizei count, const GLint* value);
	GLAPI void APIENTRY glProgramUniform4ivEXT(GLuint program, GLint location, GLsizei count, const GLint* value);
	GLAPI void APIENTRY glProgramUniformMatrix2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	GLAPI void APIENTRY glProgramUniformMatrix3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	GLAPI void APIENTRY glProgramUniformMatrix4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	GLAPI void APIENTRY glProgramUniformMatrix2x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	GLAPI void APIENTRY glProgramUniformMatrix3x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	GLAPI void APIENTRY glProgramUniformMatrix2x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	GLAPI void APIENTRY glProgramUniformMatrix4x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	GLAPI void APIENTRY glProgramUniformMatrix3x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	GLAPI void APIENTRY glProgramUniformMatrix4x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	GLAPI void APIENTRY glTextureBufferEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer);
	GLAPI void APIENTRY glMultiTexBufferEXT(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer);
	GLAPI void APIENTRY glTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, const GLint* params);
	GLAPI void APIENTRY glTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, const GLuint* params);
	GLAPI void APIENTRY glGetTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, GLint* params);
	GLAPI void APIENTRY glGetTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, GLuint* params);
	GLAPI void APIENTRY glMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint* params);
	GLAPI void APIENTRY glMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, const GLuint* params);
	GLAPI void APIENTRY glGetMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, GLint* params);
	GLAPI void APIENTRY glGetMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, GLuint* params);
	GLAPI void APIENTRY glProgramUniform1uiEXT(GLuint program, GLint location, GLuint v0);
	GLAPI void APIENTRY glProgramUniform2uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1);
	GLAPI void APIENTRY glProgramUniform3uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
	GLAPI void APIENTRY glProgramUniform4uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
	GLAPI void APIENTRY glProgramUniform1uivEXT(GLuint program, GLint location, GLsizei count, const GLuint* value);
	GLAPI void APIENTRY glProgramUniform2uivEXT(GLuint program, GLint location, GLsizei count, const GLuint* value);
	GLAPI void APIENTRY glProgramUniform3uivEXT(GLuint program, GLint location, GLsizei count, const GLuint* value);
	GLAPI void APIENTRY glProgramUniform4uivEXT(GLuint program, GLint location, GLsizei count, const GLuint* value);
	GLAPI void APIENTRY glNamedProgramLocalParameters4fvEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat* params);
	GLAPI void APIENTRY glNamedProgramLocalParameterI4iEXT(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
	GLAPI void APIENTRY glNamedProgramLocalParameterI4ivEXT(GLuint program, GLenum target, GLuint index, const GLint* params);
	GLAPI void APIENTRY glNamedProgramLocalParametersI4ivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint* params);
	GLAPI void APIENTRY glNamedProgramLocalParameterI4uiEXT(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
	GLAPI void APIENTRY glNamedProgramLocalParameterI4uivEXT(GLuint program, GLenum target, GLuint index, const GLuint* params);
	GLAPI void APIENTRY glNamedProgramLocalParametersI4uivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint* params);
	GLAPI void APIENTRY glGetNamedProgramLocalParameterIivEXT(GLuint program, GLenum target, GLuint index, GLint* params);
	GLAPI void APIENTRY glGetNamedProgramLocalParameterIuivEXT(GLuint program, GLenum target, GLuint index, GLuint* params);
	GLAPI void APIENTRY glEnableClientStateiEXT(GLenum array, GLuint index);
	GLAPI void APIENTRY glDisableClientStateiEXT(GLenum array, GLuint index);
	GLAPI void APIENTRY glGetFloati_vEXT(GLenum pname, GLuint index, GLfloat* params);
	GLAPI void APIENTRY glGetDoublei_vEXT(GLenum pname, GLuint index, GLdouble* params);
	GLAPI void APIENTRY glGetPointeri_vEXT(GLenum pname, GLuint index, void** params);
	GLAPI void APIENTRY glNamedProgramStringEXT(GLuint program, GLenum target, GLenum format, GLsizei len, const void* string);
	GLAPI void APIENTRY glNamedProgramLocalParameter4dEXT(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
	GLAPI void APIENTRY glNamedProgramLocalParameter4dvEXT(GLuint program, GLenum target, GLuint index, const GLdouble* params);
	GLAPI void APIENTRY glNamedProgramLocalParameter4fEXT(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
	GLAPI void APIENTRY glNamedProgramLocalParameter4fvEXT(GLuint program, GLenum target, GLuint index, const GLfloat* params);
	GLAPI void APIENTRY glGetNamedProgramLocalParameterdvEXT(GLuint program, GLenum target, GLuint index, GLdouble* params);
	GLAPI void APIENTRY glGetNamedProgramLocalParameterfvEXT(GLuint program, GLenum target, GLuint index, GLfloat* params);
	GLAPI void APIENTRY glGetNamedProgramivEXT(GLuint program, GLenum target, GLenum pname, GLint* params);
	GLAPI void APIENTRY glGetNamedProgramStringEXT(GLuint program, GLenum target, GLenum pname, void* string);
	GLAPI void APIENTRY glNamedRenderbufferStorageEXT(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glGetNamedRenderbufferParameterivEXT(GLuint renderbuffer, GLenum pname, GLint* params);
	GLAPI void APIENTRY glNamedRenderbufferStorageMultisampleEXT(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glNamedRenderbufferStorageMultisampleCoverageEXT(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
	GLAPI GLenum APIENTRY glCheckNamedFramebufferStatusEXT(GLuint framebuffer, GLenum target);
	GLAPI void APIENTRY glNamedFramebufferTexture1DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
	GLAPI void APIENTRY glNamedFramebufferTexture2DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
	GLAPI void APIENTRY glNamedFramebufferTexture3DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
	GLAPI void APIENTRY glNamedFramebufferRenderbufferEXT(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
	GLAPI void APIENTRY glGetNamedFramebufferAttachmentParameterivEXT(GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params);
	GLAPI void APIENTRY glGenerateTextureMipmapEXT(GLuint texture, GLenum target);
	GLAPI void APIENTRY glGenerateMultiTexMipmapEXT(GLenum texunit, GLenum target);
	GLAPI void APIENTRY glFramebufferDrawBufferEXT(GLuint framebuffer, GLenum mode);
	GLAPI void APIENTRY glFramebufferDrawBuffersEXT(GLuint framebuffer, GLsizei n, const GLenum* bufs);
	GLAPI void APIENTRY glFramebufferReadBufferEXT(GLuint framebuffer, GLenum mode);
	GLAPI void APIENTRY glGetFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint* params);
	GLAPI void APIENTRY glNamedCopyBufferSubDataEXT(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
	GLAPI void APIENTRY glNamedFramebufferTextureEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
	GLAPI void APIENTRY glNamedFramebufferTextureLayerEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
	GLAPI void APIENTRY glNamedFramebufferTextureFaceEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face);
	GLAPI void APIENTRY glTextureRenderbufferEXT(GLuint texture, GLenum target, GLuint renderbuffer);
	GLAPI void APIENTRY glMultiTexRenderbufferEXT(GLenum texunit, GLenum target, GLuint renderbuffer);
	GLAPI void APIENTRY glVertexArrayVertexOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
	GLAPI void APIENTRY glVertexArrayColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
	GLAPI void APIENTRY glVertexArrayEdgeFlagOffsetEXT(GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset);
	GLAPI void APIENTRY glVertexArrayIndexOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
	GLAPI void APIENTRY glVertexArrayNormalOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
	GLAPI void APIENTRY glVertexArrayTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
	GLAPI void APIENTRY glVertexArrayMultiTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset);
	GLAPI void APIENTRY glVertexArrayFogCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
	GLAPI void APIENTRY glVertexArraySecondaryColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
	GLAPI void APIENTRY glVertexArrayVertexAttribOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset);
	GLAPI void APIENTRY glVertexArrayVertexAttribIOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
	GLAPI void APIENTRY glEnableVertexArrayEXT(GLuint vaobj, GLenum array);
	GLAPI void APIENTRY glDisableVertexArrayEXT(GLuint vaobj, GLenum array);
	GLAPI void APIENTRY glEnableVertexArrayAttribEXT(GLuint vaobj, GLuint index);
	GLAPI void APIENTRY glDisableVertexArrayAttribEXT(GLuint vaobj, GLuint index);
	GLAPI void APIENTRY glGetVertexArrayIntegervEXT(GLuint vaobj, GLenum pname, GLint* param);
	GLAPI void APIENTRY glGetVertexArrayPointervEXT(GLuint vaobj, GLenum pname, void** param);
	GLAPI void APIENTRY glGetVertexArrayIntegeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, GLint* param);
	GLAPI void APIENTRY glGetVertexArrayPointeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, void** param);
	GLAPI void* APIENTRY glMapNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
	GLAPI void APIENTRY glFlushMappedNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length);
	GLAPI void APIENTRY glNamedBufferStorageEXT(GLuint buffer, GLsizeiptr size, const void* data, GLbitfield flags);
	GLAPI void APIENTRY glClearNamedBufferDataEXT(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void* data);
	GLAPI void APIENTRY glClearNamedBufferSubDataEXT(GLuint buffer, GLenum internalformat, GLsizeiptr offset, GLsizeiptr size, GLenum format, GLenum type, const void* data);
	GLAPI void APIENTRY glNamedFramebufferParameteriEXT(GLuint framebuffer, GLenum pname, GLint param);
	GLAPI void APIENTRY glGetNamedFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint* params);
	GLAPI void APIENTRY glProgramUniform1dEXT(GLuint program, GLint location, GLdouble x);
	GLAPI void APIENTRY glProgramUniform2dEXT(GLuint program, GLint location, GLdouble x, GLdouble y);
	GLAPI void APIENTRY glProgramUniform3dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z);
	GLAPI void APIENTRY glProgramUniform4dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
	GLAPI void APIENTRY glProgramUniform1dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble* value);
	GLAPI void APIENTRY glProgramUniform2dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble* value);
	GLAPI void APIENTRY glProgramUniform3dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble* value);
	GLAPI void APIENTRY glProgramUniform4dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble* value);
	GLAPI void APIENTRY glProgramUniformMatrix2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	GLAPI void APIENTRY glProgramUniformMatrix3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	GLAPI void APIENTRY glProgramUniformMatrix4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	GLAPI void APIENTRY glProgramUniformMatrix2x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	GLAPI void APIENTRY glProgramUniformMatrix2x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	GLAPI void APIENTRY glProgramUniformMatrix3x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	GLAPI void APIENTRY glProgramUniformMatrix3x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	GLAPI void APIENTRY glProgramUniformMatrix4x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	GLAPI void APIENTRY glProgramUniformMatrix4x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
	GLAPI void APIENTRY glTextureBufferRangeEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
	GLAPI void APIENTRY glTextureStorage1DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
	GLAPI void APIENTRY glTextureStorage2DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glTextureStorage3DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
	GLAPI void APIENTRY glTextureStorage2DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
	GLAPI void APIENTRY glTextureStorage3DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
	GLAPI void APIENTRY glVertexArrayBindVertexBufferEXT(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
	GLAPI void APIENTRY glVertexArrayVertexAttribFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
	GLAPI void APIENTRY glVertexArrayVertexAttribIFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
	GLAPI void APIENTRY glVertexArrayVertexAttribLFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
	GLAPI void APIENTRY glVertexArrayVertexAttribBindingEXT(GLuint vaobj, GLuint attribindex, GLuint bindingindex);
	GLAPI void APIENTRY glVertexArrayVertexBindingDivisorEXT(GLuint vaobj, GLuint bindingindex, GLuint divisor);
	GLAPI void APIENTRY glVertexArrayVertexAttribLOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
	GLAPI void APIENTRY glTexturePageCommitmentEXT(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);
	GLAPI void APIENTRY glVertexArrayVertexAttribDivisorEXT(GLuint vaobj, GLuint index, GLuint divisor);
#endif
#endif /* GL_EXT_direct_state_access */

#ifndef GL_EXT_draw_instanced
#define GL_EXT_draw_instanced 1
	typedef void (APIENTRYP PFNGLDRAWARRAYSINSTANCEDEXTPROC) (GLenum mode, GLint start, GLsizei count, GLsizei primcount);
	typedef void (APIENTRYP PFNGLDRAWELEMENTSINSTANCEDEXTPROC) (GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glDrawArraysInstancedEXT(GLenum mode, GLint start, GLsizei count, GLsizei primcount);
	GLAPI void APIENTRY glDrawElementsInstancedEXT(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount);
#endif
#endif /* GL_EXT_draw_instanced */

#ifndef GL_EXT_multiview_tessellation_geometry_shader
#define GL_EXT_multiview_tessellation_geometry_shader 1
#endif /* GL_EXT_multiview_tessellation_geometry_shader */

#ifndef GL_EXT_multiview_texture_multisample
#define GL_EXT_multiview_texture_multisample 1
#endif /* GL_EXT_multiview_texture_multisample */

#ifndef GL_EXT_multiview_timer_query
#define GL_EXT_multiview_timer_query 1
#endif /* GL_EXT_multiview_timer_query */

#ifndef GL_EXT_polygon_offset_clamp
#define GL_EXT_polygon_offset_clamp 1
#define GL_POLYGON_OFFSET_CLAMP_EXT       0x8E1B
	typedef void (APIENTRYP PFNGLPOLYGONOFFSETCLAMPEXTPROC) (GLfloat factor, GLfloat units, GLfloat clamp);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glPolygonOffsetClampEXT(GLfloat factor, GLfloat units, GLfloat clamp);
#endif
#endif /* GL_EXT_polygon_offset_clamp */

#ifndef GL_EXT_post_depth_coverage
#define GL_EXT_post_depth_coverage 1
#endif /* GL_EXT_post_depth_coverage */

#ifndef GL_EXT_raster_multisample
#define GL_EXT_raster_multisample 1
#define GL_RASTER_MULTISAMPLE_EXT         0x9327
#define GL_RASTER_SAMPLES_EXT             0x9328
#define GL_MAX_RASTER_SAMPLES_EXT         0x9329
#define GL_RASTER_FIXED_SAMPLE_LOCATIONS_EXT 0x932A
#define GL_MULTISAMPLE_RASTERIZATION_ALLOWED_EXT 0x932B
#define GL_EFFECTIVE_RASTER_SAMPLES_EXT   0x932C
	typedef void (APIENTRYP PFNGLRASTERSAMPLESEXTPROC) (GLuint samples, GLboolean fixedsamplelocations);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glRasterSamplesEXT(GLuint samples, GLboolean fixedsamplelocations);
#endif
#endif /* GL_EXT_raster_multisample */

#ifndef GL_EXT_separate_shader_objects
#define GL_EXT_separate_shader_objects 1
#define GL_ACTIVE_PROGRAM_EXT             0x8B8D
	typedef void (APIENTRYP PFNGLUSESHADERPROGRAMEXTPROC) (GLenum type, GLuint program);
	typedef void (APIENTRYP PFNGLACTIVEPROGRAMEXTPROC) (GLuint program);
	typedef GLuint(APIENTRYP PFNGLCREATESHADERPROGRAMEXTPROC) (GLenum type, const GLchar* string);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glUseShaderProgramEXT(GLenum type, GLuint program);
	GLAPI void APIENTRY glActiveProgramEXT(GLuint program);
	GLAPI GLuint APIENTRY glCreateShaderProgramEXT(GLenum type, const GLchar* string);
#endif
#endif /* GL_EXT_separate_shader_objects */

#ifndef GL_EXT_shader_framebuffer_fetch
#define GL_EXT_shader_framebuffer_fetch 1
#define GL_FRAGMENT_SHADER_DISCARDS_SAMPLES_EXT 0x8A52
#endif /* GL_EXT_shader_framebuffer_fetch */

#ifndef GL_EXT_shader_framebuffer_fetch_non_coherent
#define GL_EXT_shader_framebuffer_fetch_non_coherent 1
	typedef void (APIENTRYP PFNGLFRAMEBUFFERFETCHBARRIEREXTPROC) (void);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glFramebufferFetchBarrierEXT(void);
#endif
#endif /* GL_EXT_shader_framebuffer_fetch_non_coherent */

#ifndef GL_EXT_shader_integer_mix
#define GL_EXT_shader_integer_mix 1
#endif /* GL_EXT_shader_integer_mix */

#ifndef GL_EXT_texture_compression_s3tc
#define GL_EXT_texture_compression_s3tc 1
#define GL_COMPRESSED_RGB_S3TC_DXT1_EXT   0x83F0
#define GL_COMPRESSED_RGBA_S3TC_DXT1_EXT  0x83F1
#define GL_COMPRESSED_RGBA_S3TC_DXT3_EXT  0x83F2
#define GL_COMPRESSED_RGBA_S3TC_DXT5_EXT  0x83F3
#endif /* GL_EXT_texture_compression_s3tc */

#ifndef GL_EXT_texture_filter_minmax
#define GL_EXT_texture_filter_minmax 1
#define GL_TEXTURE_REDUCTION_MODE_EXT     0x9366
#define GL_WEIGHTED_AVERAGE_EXT           0x9367
#endif /* GL_EXT_texture_filter_minmax */

#ifndef GL_EXT_texture_sRGB_R8
#define GL_EXT_texture_sRGB_R8 1
#define GL_SR8_EXT                        0x8FBD
#endif /* GL_EXT_texture_sRGB_R8 */

#ifndef GL_EXT_texture_sRGB_RG8
#define GL_EXT_texture_sRGB_RG8 1
#define GL_SRG8_EXT                       0x8FBE
#endif /* GL_EXT_texture_sRGB_RG8 */

#ifndef GL_EXT_texture_sRGB_decode
#define GL_EXT_texture_sRGB_decode 1
#define GL_TEXTURE_SRGB_DECODE_EXT        0x8A48
#define GL_DECODE_EXT                     0x8A49
#define GL_SKIP_DECODE_EXT                0x8A4A
#endif /* GL_EXT_texture_sRGB_decode */

#ifndef GL_EXT_texture_shadow_lod
#define GL_EXT_texture_shadow_lod 1
#endif /* GL_EXT_texture_shadow_lod */

#ifndef GL_EXT_window_rectangles
#define GL_EXT_window_rectangles 1
#define GL_INCLUSIVE_EXT                  0x8F10
#define GL_EXCLUSIVE_EXT                  0x8F11
#define GL_WINDOW_RECTANGLE_EXT           0x8F12
#define GL_WINDOW_RECTANGLE_MODE_EXT      0x8F13
#define GL_MAX_WINDOW_RECTANGLES_EXT      0x8F14
#define GL_NUM_WINDOW_RECTANGLES_EXT      0x8F15
	typedef void (APIENTRYP PFNGLWINDOWRECTANGLESEXTPROC) (GLenum mode, GLsizei count, const GLint* box);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glWindowRectanglesEXT(GLenum mode, GLsizei count, const GLint* box);
#endif
#endif /* GL_EXT_window_rectangles */

#ifndef GL_INTEL_blackhole_render
#define GL_INTEL_blackhole_render 1
#define GL_BLACKHOLE_RENDER_INTEL         0x83FC
#endif /* GL_INTEL_blackhole_render */

#ifndef GL_INTEL_conservative_rasterization
#define GL_INTEL_conservative_rasterization 1
#define GL_CONSERVATIVE_RASTERIZATION_INTEL 0x83FE
#endif /* GL_INTEL_conservative_rasterization */

#ifndef GL_INTEL_framebuffer_CMAA
#define GL_INTEL_framebuffer_CMAA 1
	typedef void (APIENTRYP PFNGLAPPLYFRAMEBUFFERATTACHMENTCMAAINTELPROC) (void);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glApplyFramebufferAttachmentCMAAINTEL(void);
#endif
#endif /* GL_INTEL_framebuffer_CMAA */

#ifndef GL_INTEL_performance_query
#define GL_INTEL_performance_query 1
#define GL_PERFQUERY_SINGLE_CONTEXT_INTEL 0x00000000
#define GL_PERFQUERY_GLOBAL_CONTEXT_INTEL 0x00000001
#define GL_PERFQUERY_WAIT_INTEL           0x83FB
#define GL_PERFQUERY_FLUSH_INTEL          0x83FA
#define GL_PERFQUERY_DONOT_FLUSH_INTEL    0x83F9
#define GL_PERFQUERY_COUNTER_EVENT_INTEL  0x94F0
#define GL_PERFQUERY_COUNTER_DURATION_NORM_INTEL 0x94F1
#define GL_PERFQUERY_COUNTER_DURATION_RAW_INTEL 0x94F2
#define GL_PERFQUERY_COUNTER_THROUGHPUT_INTEL 0x94F3
#define GL_PERFQUERY_COUNTER_RAW_INTEL    0x94F4
#define GL_PERFQUERY_COUNTER_TIMESTAMP_INTEL 0x94F5
#define GL_PERFQUERY_COUNTER_DATA_UINT32_INTEL 0x94F8
#define GL_PERFQUERY_COUNTER_DATA_UINT64_INTEL 0x94F9
#define GL_PERFQUERY_COUNTER_DATA_FLOAT_INTEL 0x94FA
#define GL_PERFQUERY_COUNTER_DATA_DOUBLE_INTEL 0x94FB
#define GL_PERFQUERY_COUNTER_DATA_BOOL32_INTEL 0x94FC
#define GL_PERFQUERY_QUERY_NAME_LENGTH_MAX_INTEL 0x94FD
#define GL_PERFQUERY_COUNTER_NAME_LENGTH_MAX_INTEL 0x94FE
#define GL_PERFQUERY_COUNTER_DESC_LENGTH_MAX_INTEL 0x94FF
#define GL_PERFQUERY_GPA_EXTENDED_COUNTERS_INTEL 0x9500
	typedef void (APIENTRYP PFNGLBEGINPERFQUERYINTELPROC) (GLuint queryHandle);
	typedef void (APIENTRYP PFNGLCREATEPERFQUERYINTELPROC) (GLuint queryId, GLuint* queryHandle);
	typedef void (APIENTRYP PFNGLDELETEPERFQUERYINTELPROC) (GLuint queryHandle);
	typedef void (APIENTRYP PFNGLENDPERFQUERYINTELPROC) (GLuint queryHandle);
	typedef void (APIENTRYP PFNGLGETFIRSTPERFQUERYIDINTELPROC) (GLuint* queryId);
	typedef void (APIENTRYP PFNGLGETNEXTPERFQUERYIDINTELPROC) (GLuint queryId, GLuint* nextQueryId);
	typedef void (APIENTRYP PFNGLGETPERFCOUNTERINFOINTELPROC) (GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar* counterName, GLuint counterDescLength, GLchar* counterDesc, GLuint* counterOffset, GLuint* counterDataSize, GLuint* counterTypeEnum, GLuint* counterDataTypeEnum, GLuint64* rawCounterMaxValue);
	typedef void (APIENTRYP PFNGLGETPERFQUERYDATAINTELPROC) (GLuint queryHandle, GLuint flags, GLsizei dataSize, void* data, GLuint* bytesWritten);
	typedef void (APIENTRYP PFNGLGETPERFQUERYIDBYNAMEINTELPROC) (GLchar* queryName, GLuint* queryId);
	typedef void (APIENTRYP PFNGLGETPERFQUERYINFOINTELPROC) (GLuint queryId, GLuint queryNameLength, GLchar* queryName, GLuint* dataSize, GLuint* noCounters, GLuint* noInstances, GLuint* capsMask);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glBeginPerfQueryINTEL(GLuint queryHandle);
	GLAPI void APIENTRY glCreatePerfQueryINTEL(GLuint queryId, GLuint* queryHandle);
	GLAPI void APIENTRY glDeletePerfQueryINTEL(GLuint queryHandle);
	GLAPI void APIENTRY glEndPerfQueryINTEL(GLuint queryHandle);
	GLAPI void APIENTRY glGetFirstPerfQueryIdINTEL(GLuint* queryId);
	GLAPI void APIENTRY glGetNextPerfQueryIdINTEL(GLuint queryId, GLuint* nextQueryId);
	GLAPI void APIENTRY glGetPerfCounterInfoINTEL(GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar* counterName, GLuint counterDescLength, GLchar* counterDesc, GLuint* counterOffset, GLuint* counterDataSize, GLuint* counterTypeEnum, GLuint* counterDataTypeEnum, GLuint64* rawCounterMaxValue);
	GLAPI void APIENTRY glGetPerfQueryDataINTEL(GLuint queryHandle, GLuint flags, GLsizei dataSize, void* data, GLuint* bytesWritten);
	GLAPI void APIENTRY glGetPerfQueryIdByNameINTEL(GLchar* queryName, GLuint* queryId);
	GLAPI void APIENTRY glGetPerfQueryInfoINTEL(GLuint queryId, GLuint queryNameLength, GLchar* queryName, GLuint* dataSize, GLuint* noCounters, GLuint* noInstances, GLuint* capsMask);
#endif
#endif /* GL_INTEL_performance_query */

#ifndef GL_MESA_framebuffer_flip_x
#define GL_MESA_framebuffer_flip_x 1
#define GL_FRAMEBUFFER_FLIP_X_MESA        0x8BBC
#endif /* GL_MESA_framebuffer_flip_x */

#ifndef GL_MESA_framebuffer_flip_y
#define GL_MESA_framebuffer_flip_y 1
#define GL_FRAMEBUFFER_FLIP_Y_MESA        0x8BBB
	typedef void (APIENTRYP PFNGLFRAMEBUFFERPARAMETERIMESAPROC) (GLenum target, GLenum pname, GLint param);
	typedef void (APIENTRYP PFNGLGETFRAMEBUFFERPARAMETERIVMESAPROC) (GLenum target, GLenum pname, GLint* params);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glFramebufferParameteriMESA(GLenum target, GLenum pname, GLint param);
	GLAPI void APIENTRY glGetFramebufferParameterivMESA(GLenum target, GLenum pname, GLint* params);
#endif
#endif /* GL_MESA_framebuffer_flip_y */

#ifndef GL_MESA_framebuffer_swap_xy
#define GL_MESA_framebuffer_swap_xy 1
#define GL_FRAMEBUFFER_SWAP_XY_MESA       0x8BBD
#endif /* GL_MESA_framebuffer_swap_xy */

#ifndef GL_NV_bindless_multi_draw_indirect
#define GL_NV_bindless_multi_draw_indirect 1
	typedef void (APIENTRYP PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC) (GLenum mode, const void* indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);
	typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC) (GLenum mode, GLenum type, const void* indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glMultiDrawArraysIndirectBindlessNV(GLenum mode, const void* indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);
	GLAPI void APIENTRY glMultiDrawElementsIndirectBindlessNV(GLenum mode, GLenum type, const void* indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);
#endif
#endif /* GL_NV_bindless_multi_draw_indirect */

#ifndef GL_NV_bindless_multi_draw_indirect_count
#define GL_NV_bindless_multi_draw_indirect_count 1
	typedef void (APIENTRYP PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSCOUNTNVPROC) (GLenum mode, const void* indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount);
	typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSCOUNTNVPROC) (GLenum mode, GLenum type, const void* indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glMultiDrawArraysIndirectBindlessCountNV(GLenum mode, const void* indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount);
	GLAPI void APIENTRY glMultiDrawElementsIndirectBindlessCountNV(GLenum mode, GLenum type, const void* indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount);
#endif
#endif /* GL_NV_bindless_multi_draw_indirect_count */

#ifndef GL_NV_bindless_texture
#define GL_NV_bindless_texture 1
	typedef GLuint64(APIENTRYP PFNGLGETTEXTUREHANDLENVPROC) (GLuint texture);
	typedef GLuint64(APIENTRYP PFNGLGETTEXTURESAMPLERHANDLENVPROC) (GLuint texture, GLuint sampler);
	typedef void (APIENTRYP PFNGLMAKETEXTUREHANDLERESIDENTNVPROC) (GLuint64 handle);
	typedef void (APIENTRYP PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC) (GLuint64 handle);
	typedef GLuint64(APIENTRYP PFNGLGETIMAGEHANDLENVPROC) (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
	typedef void (APIENTRYP PFNGLMAKEIMAGEHANDLERESIDENTNVPROC) (GLuint64 handle, GLenum access);
	typedef void (APIENTRYP PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC) (GLuint64 handle);
	typedef void (APIENTRYP PFNGLUNIFORMHANDLEUI64NVPROC) (GLint location, GLuint64 value);
	typedef void (APIENTRYP PFNGLUNIFORMHANDLEUI64VNVPROC) (GLint location, GLsizei count, const GLuint64* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC) (GLuint program, GLint location, GLuint64 value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* values);
	typedef GLboolean(APIENTRYP PFNGLISTEXTUREHANDLERESIDENTNVPROC) (GLuint64 handle);
	typedef GLboolean(APIENTRYP PFNGLISIMAGEHANDLERESIDENTNVPROC) (GLuint64 handle);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI GLuint64 APIENTRY glGetTextureHandleNV(GLuint texture);
	GLAPI GLuint64 APIENTRY glGetTextureSamplerHandleNV(GLuint texture, GLuint sampler);
	GLAPI void APIENTRY glMakeTextureHandleResidentNV(GLuint64 handle);
	GLAPI void APIENTRY glMakeTextureHandleNonResidentNV(GLuint64 handle);
	GLAPI GLuint64 APIENTRY glGetImageHandleNV(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
	GLAPI void APIENTRY glMakeImageHandleResidentNV(GLuint64 handle, GLenum access);
	GLAPI void APIENTRY glMakeImageHandleNonResidentNV(GLuint64 handle);
	GLAPI void APIENTRY glUniformHandleui64NV(GLint location, GLuint64 value);
	GLAPI void APIENTRY glUniformHandleui64vNV(GLint location, GLsizei count, const GLuint64* value);
	GLAPI void APIENTRY glProgramUniformHandleui64NV(GLuint program, GLint location, GLuint64 value);
	GLAPI void APIENTRY glProgramUniformHandleui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64* values);
	GLAPI GLboolean APIENTRY glIsTextureHandleResidentNV(GLuint64 handle);
	GLAPI GLboolean APIENTRY glIsImageHandleResidentNV(GLuint64 handle);
#endif
#endif /* GL_NV_bindless_texture */

#ifndef GL_NV_blend_equation_advanced
#define GL_NV_blend_equation_advanced 1
#define GL_BLEND_OVERLAP_NV               0x9281
#define GL_BLEND_PREMULTIPLIED_SRC_NV     0x9280
#define GL_BLUE_NV                        0x1905
#define GL_COLORBURN_NV                   0x929A
#define GL_COLORDODGE_NV                  0x9299
#define GL_CONJOINT_NV                    0x9284
#define GL_CONTRAST_NV                    0x92A1
#define GL_DARKEN_NV                      0x9297
#define GL_DIFFERENCE_NV                  0x929E
#define GL_DISJOINT_NV                    0x9283
#define GL_DST_ATOP_NV                    0x928F
#define GL_DST_IN_NV                      0x928B
#define GL_DST_NV                         0x9287
#define GL_DST_OUT_NV                     0x928D
#define GL_DST_OVER_NV                    0x9289
#define GL_EXCLUSION_NV                   0x92A0
#define GL_GREEN_NV                       0x1904
#define GL_HARDLIGHT_NV                   0x929B
#define GL_HARDMIX_NV                     0x92A9
#define GL_HSL_COLOR_NV                   0x92AF
#define GL_HSL_HUE_NV                     0x92AD
#define GL_HSL_LUMINOSITY_NV              0x92B0
#define GL_HSL_SATURATION_NV              0x92AE
#define GL_INVERT_OVG_NV                  0x92B4
#define GL_INVERT_RGB_NV                  0x92A3
#define GL_LIGHTEN_NV                     0x9298
#define GL_LINEARBURN_NV                  0x92A5
#define GL_LINEARDODGE_NV                 0x92A4
#define GL_LINEARLIGHT_NV                 0x92A7
#define GL_MINUS_CLAMPED_NV               0x92B3
#define GL_MINUS_NV                       0x929F
#define GL_MULTIPLY_NV                    0x9294
#define GL_OVERLAY_NV                     0x9296
#define GL_PINLIGHT_NV                    0x92A8
#define GL_PLUS_CLAMPED_ALPHA_NV          0x92B2
#define GL_PLUS_CLAMPED_NV                0x92B1
#define GL_PLUS_DARKER_NV                 0x9292
#define GL_PLUS_NV                        0x9291
#define GL_RED_NV                         0x1903
#define GL_SCREEN_NV                      0x9295
#define GL_SOFTLIGHT_NV                   0x929C
#define GL_SRC_ATOP_NV                    0x928E
#define GL_SRC_IN_NV                      0x928A
#define GL_SRC_NV                         0x9286
#define GL_SRC_OUT_NV                     0x928C
#define GL_SRC_OVER_NV                    0x9288
#define GL_UNCORRELATED_NV                0x9282
#define GL_VIVIDLIGHT_NV                  0x92A6
#define GL_XOR_NV                         0x1506
	typedef void (APIENTRYP PFNGLBLENDPARAMETERINVPROC) (GLenum pname, GLint value);
	typedef void (APIENTRYP PFNGLBLENDBARRIERNVPROC) (void);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glBlendParameteriNV(GLenum pname, GLint value);
	GLAPI void APIENTRY glBlendBarrierNV(void);
#endif
#endif /* GL_NV_blend_equation_advanced */

#ifndef GL_NV_blend_equation_advanced_coherent
#define GL_NV_blend_equation_advanced_coherent 1
#define GL_BLEND_ADVANCED_COHERENT_NV     0x9285
#endif /* GL_NV_blend_equation_advanced_coherent */

#ifndef GL_NV_blend_minmax_factor
#define GL_NV_blend_minmax_factor 1
#define GL_FACTOR_MIN_AMD                 0x901C
#define GL_FACTOR_MAX_AMD                 0x901D
#endif /* GL_NV_blend_minmax_factor */

#ifndef GL_NV_clip_space_w_scaling
#define GL_NV_clip_space_w_scaling 1
#define GL_VIEWPORT_POSITION_W_SCALE_NV   0x937C
#define GL_VIEWPORT_POSITION_W_SCALE_X_COEFF_NV 0x937D
#define GL_VIEWPORT_POSITION_W_SCALE_Y_COEFF_NV 0x937E
	typedef void (APIENTRYP PFNGLVIEWPORTPOSITIONWSCALENVPROC) (GLuint index, GLfloat xcoeff, GLfloat ycoeff);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glViewportPositionWScaleNV(GLuint index, GLfloat xcoeff, GLfloat ycoeff);
#endif
#endif /* GL_NV_clip_space_w_scaling */

#ifndef GL_NV_command_list
#define GL_NV_command_list 1
#define GL_TERMINATE_SEQUENCE_COMMAND_NV  0x0000
#define GL_NOP_COMMAND_NV                 0x0001
#define GL_DRAW_ELEMENTS_COMMAND_NV       0x0002
#define GL_DRAW_ARRAYS_COMMAND_NV         0x0003
#define GL_DRAW_ELEMENTS_STRIP_COMMAND_NV 0x0004
#define GL_DRAW_ARRAYS_STRIP_COMMAND_NV   0x0005
#define GL_DRAW_ELEMENTS_INSTANCED_COMMAND_NV 0x0006
#define GL_DRAW_ARRAYS_INSTANCED_COMMAND_NV 0x0007
#define GL_ELEMENT_ADDRESS_COMMAND_NV     0x0008
#define GL_ATTRIBUTE_ADDRESS_COMMAND_NV   0x0009
#define GL_UNIFORM_ADDRESS_COMMAND_NV     0x000A
#define GL_BLEND_COLOR_COMMAND_NV         0x000B
#define GL_STENCIL_REF_COMMAND_NV         0x000C
#define GL_LINE_WIDTH_COMMAND_NV          0x000D
#define GL_POLYGON_OFFSET_COMMAND_NV      0x000E
#define GL_ALPHA_REF_COMMAND_NV           0x000F
#define GL_VIEWPORT_COMMAND_NV            0x0010
#define GL_SCISSOR_COMMAND_NV             0x0011
#define GL_FRONT_FACE_COMMAND_NV          0x0012
	typedef void (APIENTRYP PFNGLCREATESTATESNVPROC) (GLsizei n, GLuint* states);
	typedef void (APIENTRYP PFNGLDELETESTATESNVPROC) (GLsizei n, const GLuint* states);
	typedef GLboolean(APIENTRYP PFNGLISSTATENVPROC) (GLuint state);
	typedef void (APIENTRYP PFNGLSTATECAPTURENVPROC) (GLuint state, GLenum mode);
	typedef GLuint(APIENTRYP PFNGLGETCOMMANDHEADERNVPROC) (GLenum tokenID, GLuint size);
	typedef GLushort(APIENTRYP PFNGLGETSTAGEINDEXNVPROC) (GLenum shadertype);
	typedef void (APIENTRYP PFNGLDRAWCOMMANDSNVPROC) (GLenum primitiveMode, GLuint buffer, const GLintptr* indirects, const GLsizei* sizes, GLuint count);
	typedef void (APIENTRYP PFNGLDRAWCOMMANDSADDRESSNVPROC) (GLenum primitiveMode, const GLuint64* indirects, const GLsizei* sizes, GLuint count);
	typedef void (APIENTRYP PFNGLDRAWCOMMANDSSTATESNVPROC) (GLuint buffer, const GLintptr* indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count);
	typedef void (APIENTRYP PFNGLDRAWCOMMANDSSTATESADDRESSNVPROC) (const GLuint64* indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count);
	typedef void (APIENTRYP PFNGLCREATECOMMANDLISTSNVPROC) (GLsizei n, GLuint* lists);
	typedef void (APIENTRYP PFNGLDELETECOMMANDLISTSNVPROC) (GLsizei n, const GLuint* lists);
	typedef GLboolean(APIENTRYP PFNGLISCOMMANDLISTNVPROC) (GLuint list);
	typedef void (APIENTRYP PFNGLLISTDRAWCOMMANDSSTATESCLIENTNVPROC) (GLuint list, GLuint segment, const void** indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count);
	typedef void (APIENTRYP PFNGLCOMMANDLISTSEGMENTSNVPROC) (GLuint list, GLuint segments);
	typedef void (APIENTRYP PFNGLCOMPILECOMMANDLISTNVPROC) (GLuint list);
	typedef void (APIENTRYP PFNGLCALLCOMMANDLISTNVPROC) (GLuint list);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glCreateStatesNV(GLsizei n, GLuint* states);
	GLAPI void APIENTRY glDeleteStatesNV(GLsizei n, const GLuint* states);
	GLAPI GLboolean APIENTRY glIsStateNV(GLuint state);
	GLAPI void APIENTRY glStateCaptureNV(GLuint state, GLenum mode);
	GLAPI GLuint APIENTRY glGetCommandHeaderNV(GLenum tokenID, GLuint size);
	GLAPI GLushort APIENTRY glGetStageIndexNV(GLenum shadertype);
	GLAPI void APIENTRY glDrawCommandsNV(GLenum primitiveMode, GLuint buffer, const GLintptr* indirects, const GLsizei* sizes, GLuint count);
	GLAPI void APIENTRY glDrawCommandsAddressNV(GLenum primitiveMode, const GLuint64* indirects, const GLsizei* sizes, GLuint count);
	GLAPI void APIENTRY glDrawCommandsStatesNV(GLuint buffer, const GLintptr* indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count);
	GLAPI void APIENTRY glDrawCommandsStatesAddressNV(const GLuint64* indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count);
	GLAPI void APIENTRY glCreateCommandListsNV(GLsizei n, GLuint* lists);
	GLAPI void APIENTRY glDeleteCommandListsNV(GLsizei n, const GLuint* lists);
	GLAPI GLboolean APIENTRY glIsCommandListNV(GLuint list);
	GLAPI void APIENTRY glListDrawCommandsStatesClientNV(GLuint list, GLuint segment, const void** indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count);
	GLAPI void APIENTRY glCommandListSegmentsNV(GLuint list, GLuint segments);
	GLAPI void APIENTRY glCompileCommandListNV(GLuint list);
	GLAPI void APIENTRY glCallCommandListNV(GLuint list);
#endif
#endif /* GL_NV_command_list */

#ifndef GL_NV_compute_shader_derivatives
#define GL_NV_compute_shader_derivatives 1
#endif /* GL_NV_compute_shader_derivatives */

#ifndef GL_NV_conditional_render
#define GL_NV_conditional_render 1
#define GL_QUERY_WAIT_NV                  0x8E13
#define GL_QUERY_NO_WAIT_NV               0x8E14
#define GL_QUERY_BY_REGION_WAIT_NV        0x8E15
#define GL_QUERY_BY_REGION_NO_WAIT_NV     0x8E16
	typedef void (APIENTRYP PFNGLBEGINCONDITIONALRENDERNVPROC) (GLuint id, GLenum mode);
	typedef void (APIENTRYP PFNGLENDCONDITIONALRENDERNVPROC) (void);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glBeginConditionalRenderNV(GLuint id, GLenum mode);
	GLAPI void APIENTRY glEndConditionalRenderNV(void);
#endif
#endif /* GL_NV_conditional_render */

#ifndef GL_NV_conservative_raster
#define GL_NV_conservative_raster 1
#define GL_CONSERVATIVE_RASTERIZATION_NV  0x9346
#define GL_SUBPIXEL_PRECISION_BIAS_X_BITS_NV 0x9347
#define GL_SUBPIXEL_PRECISION_BIAS_Y_BITS_NV 0x9348
#define GL_MAX_SUBPIXEL_PRECISION_BIAS_BITS_NV 0x9349
	typedef void (APIENTRYP PFNGLSUBPIXELPRECISIONBIASNVPROC) (GLuint xbits, GLuint ybits);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glSubpixelPrecisionBiasNV(GLuint xbits, GLuint ybits);
#endif
#endif /* GL_NV_conservative_raster */

#ifndef GL_NV_conservative_raster_dilate
#define GL_NV_conservative_raster_dilate 1
#define GL_CONSERVATIVE_RASTER_DILATE_NV  0x9379
#define GL_CONSERVATIVE_RASTER_DILATE_RANGE_NV 0x937A
#define GL_CONSERVATIVE_RASTER_DILATE_GRANULARITY_NV 0x937B
	typedef void (APIENTRYP PFNGLCONSERVATIVERASTERPARAMETERFNVPROC) (GLenum pname, GLfloat value);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glConservativeRasterParameterfNV(GLenum pname, GLfloat value);
#endif
#endif /* GL_NV_conservative_raster_dilate */

#ifndef GL_NV_conservative_raster_pre_snap
#define GL_NV_conservative_raster_pre_snap 1
#define GL_CONSERVATIVE_RASTER_MODE_PRE_SNAP_NV 0x9550
#endif /* GL_NV_conservative_raster_pre_snap */

#ifndef GL_NV_conservative_raster_pre_snap_triangles
#define GL_NV_conservative_raster_pre_snap_triangles 1
#define GL_CONSERVATIVE_RASTER_MODE_NV    0x954D
#define GL_CONSERVATIVE_RASTER_MODE_POST_SNAP_NV 0x954E
#define GL_CONSERVATIVE_RASTER_MODE_PRE_SNAP_TRIANGLES_NV 0x954F
	typedef void (APIENTRYP PFNGLCONSERVATIVERASTERPARAMETERINVPROC) (GLenum pname, GLint param);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glConservativeRasterParameteriNV(GLenum pname, GLint param);
#endif
#endif /* GL_NV_conservative_raster_pre_snap_triangles */

#ifndef GL_NV_conservative_raster_underestimation
#define GL_NV_conservative_raster_underestimation 1
#endif /* GL_NV_conservative_raster_underestimation */

#ifndef GL_NV_depth_buffer_float
#define GL_NV_depth_buffer_float 1
#define GL_DEPTH_COMPONENT32F_NV          0x8DAB
#define GL_DEPTH32F_STENCIL8_NV           0x8DAC
#define GL_FLOAT_32_UNSIGNED_INT_24_8_REV_NV 0x8DAD
#define GL_DEPTH_BUFFER_FLOAT_MODE_NV     0x8DAF
	typedef void (APIENTRYP PFNGLDEPTHRANGEDNVPROC) (GLdouble zNear, GLdouble zFar);
	typedef void (APIENTRYP PFNGLCLEARDEPTHDNVPROC) (GLdouble depth);
	typedef void (APIENTRYP PFNGLDEPTHBOUNDSDNVPROC) (GLdouble zmin, GLdouble zmax);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glDepthRangedNV(GLdouble zNear, GLdouble zFar);
	GLAPI void APIENTRY glClearDepthdNV(GLdouble depth);
	GLAPI void APIENTRY glDepthBoundsdNV(GLdouble zmin, GLdouble zmax);
#endif
#endif /* GL_NV_depth_buffer_float */

#ifndef GL_NV_draw_vulkan_image
#define GL_NV_draw_vulkan_image 1
	typedef void (APIENTRY* GLVULKANPROCNV)(void);
	typedef void (APIENTRYP PFNGLDRAWVKIMAGENVPROC) (GLuint64 vkImage, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);
	typedef GLVULKANPROCNV(APIENTRYP PFNGLGETVKPROCADDRNVPROC) (const GLchar* name);
	typedef void (APIENTRYP PFNGLWAITVKSEMAPHORENVPROC) (GLuint64 vkSemaphore);
	typedef void (APIENTRYP PFNGLSIGNALVKSEMAPHORENVPROC) (GLuint64 vkSemaphore);
	typedef void (APIENTRYP PFNGLSIGNALVKFENCENVPROC) (GLuint64 vkFence);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glDrawVkImageNV(GLuint64 vkImage, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);
	GLAPI GLVULKANPROCNV APIENTRY glGetVkProcAddrNV(const GLchar* name);
	GLAPI void APIENTRY glWaitVkSemaphoreNV(GLuint64 vkSemaphore);
	GLAPI void APIENTRY glSignalVkSemaphoreNV(GLuint64 vkSemaphore);
	GLAPI void APIENTRY glSignalVkFenceNV(GLuint64 vkFence);
#endif
#endif /* GL_NV_draw_vulkan_image */

#ifndef GL_NV_fill_rectangle
#define GL_NV_fill_rectangle 1
#define GL_FILL_RECTANGLE_NV              0x933C
#endif /* GL_NV_fill_rectangle */

#ifndef GL_NV_fragment_coverage_to_color
#define GL_NV_fragment_coverage_to_color 1
#define GL_FRAGMENT_COVERAGE_TO_COLOR_NV  0x92DD
#define GL_FRAGMENT_COVERAGE_COLOR_NV     0x92DE
	typedef void (APIENTRYP PFNGLFRAGMENTCOVERAGECOLORNVPROC) (GLuint color);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glFragmentCoverageColorNV(GLuint color);
#endif
#endif /* GL_NV_fragment_coverage_to_color */

#ifndef GL_NV_fragment_shader_barycentric
#define GL_NV_fragment_shader_barycentric 1
#endif /* GL_NV_fragment_shader_barycentric */

#ifndef GL_NV_fragment_shader_interlock
#define GL_NV_fragment_shader_interlock 1
#endif /* GL_NV_fragment_shader_interlock */

#ifndef GL_NV_framebuffer_mixed_samples
#define GL_NV_framebuffer_mixed_samples 1
#define GL_COVERAGE_MODULATION_TABLE_NV   0x9331
#define GL_COLOR_SAMPLES_NV               0x8E20
#define GL_DEPTH_SAMPLES_NV               0x932D
#define GL_STENCIL_SAMPLES_NV             0x932E
#define GL_MIXED_DEPTH_SAMPLES_SUPPORTED_NV 0x932F
#define GL_MIXED_STENCIL_SAMPLES_SUPPORTED_NV 0x9330
#define GL_COVERAGE_MODULATION_NV         0x9332
#define GL_COVERAGE_MODULATION_TABLE_SIZE_NV 0x9333
	typedef void (APIENTRYP PFNGLCOVERAGEMODULATIONTABLENVPROC) (GLsizei n, const GLfloat* v);
	typedef void (APIENTRYP PFNGLGETCOVERAGEMODULATIONTABLENVPROC) (GLsizei bufSize, GLfloat* v);
	typedef void (APIENTRYP PFNGLCOVERAGEMODULATIONNVPROC) (GLenum components);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glCoverageModulationTableNV(GLsizei n, const GLfloat* v);
	GLAPI void APIENTRY glGetCoverageModulationTableNV(GLsizei bufSize, GLfloat* v);
	GLAPI void APIENTRY glCoverageModulationNV(GLenum components);
#endif
#endif /* GL_NV_framebuffer_mixed_samples */

#ifndef GL_NV_framebuffer_multisample_coverage
#define GL_NV_framebuffer_multisample_coverage 1
#define GL_RENDERBUFFER_COVERAGE_SAMPLES_NV 0x8CAB
#define GL_RENDERBUFFER_COLOR_SAMPLES_NV  0x8E10
#define GL_MAX_MULTISAMPLE_COVERAGE_MODES_NV 0x8E11
#define GL_MULTISAMPLE_COVERAGE_MODES_NV  0x8E12
	typedef void (APIENTRYP PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glRenderbufferStorageMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
#endif
#endif /* GL_NV_framebuffer_multisample_coverage */

#ifndef GL_NV_geometry_shader_passthrough
#define GL_NV_geometry_shader_passthrough 1
#endif /* GL_NV_geometry_shader_passthrough */

#ifndef GL_NV_gpu_shader5
#define GL_NV_gpu_shader5 1
	typedef khronos_int64_t GLint64EXT;
#define GL_INT64_NV                       0x140E
#define GL_UNSIGNED_INT64_NV              0x140F
#define GL_INT8_NV                        0x8FE0
#define GL_INT8_VEC2_NV                   0x8FE1
#define GL_INT8_VEC3_NV                   0x8FE2
#define GL_INT8_VEC4_NV                   0x8FE3
#define GL_INT16_NV                       0x8FE4
#define GL_INT16_VEC2_NV                  0x8FE5
#define GL_INT16_VEC3_NV                  0x8FE6
#define GL_INT16_VEC4_NV                  0x8FE7
#define GL_INT64_VEC2_NV                  0x8FE9
#define GL_INT64_VEC3_NV                  0x8FEA
#define GL_INT64_VEC4_NV                  0x8FEB
#define GL_UNSIGNED_INT8_NV               0x8FEC
#define GL_UNSIGNED_INT8_VEC2_NV          0x8FED
#define GL_UNSIGNED_INT8_VEC3_NV          0x8FEE
#define GL_UNSIGNED_INT8_VEC4_NV          0x8FEF
#define GL_UNSIGNED_INT16_NV              0x8FF0
#define GL_UNSIGNED_INT16_VEC2_NV         0x8FF1
#define GL_UNSIGNED_INT16_VEC3_NV         0x8FF2
#define GL_UNSIGNED_INT16_VEC4_NV         0x8FF3
#define GL_UNSIGNED_INT64_VEC2_NV         0x8FF5
#define GL_UNSIGNED_INT64_VEC3_NV         0x8FF6
#define GL_UNSIGNED_INT64_VEC4_NV         0x8FF7
#define GL_FLOAT16_NV                     0x8FF8
#define GL_FLOAT16_VEC2_NV                0x8FF9
#define GL_FLOAT16_VEC3_NV                0x8FFA
#define GL_FLOAT16_VEC4_NV                0x8FFB
	typedef void (APIENTRYP PFNGLUNIFORM1I64NVPROC) (GLint location, GLint64EXT x);
	typedef void (APIENTRYP PFNGLUNIFORM2I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y);
	typedef void (APIENTRYP PFNGLUNIFORM3I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
	typedef void (APIENTRYP PFNGLUNIFORM4I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
	typedef void (APIENTRYP PFNGLUNIFORM1I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
	typedef void (APIENTRYP PFNGLUNIFORM2I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
	typedef void (APIENTRYP PFNGLUNIFORM3I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
	typedef void (APIENTRYP PFNGLUNIFORM4I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
	typedef void (APIENTRYP PFNGLUNIFORM1UI64NVPROC) (GLint location, GLuint64EXT x);
	typedef void (APIENTRYP PFNGLUNIFORM2UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y);
	typedef void (APIENTRYP PFNGLUNIFORM3UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
	typedef void (APIENTRYP PFNGLUNIFORM4UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
	typedef void (APIENTRYP PFNGLUNIFORM1UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
	typedef void (APIENTRYP PFNGLUNIFORM2UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
	typedef void (APIENTRYP PFNGLUNIFORM3UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
	typedef void (APIENTRYP PFNGLUNIFORM4UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
	typedef void (APIENTRYP PFNGLGETUNIFORMI64VNVPROC) (GLuint program, GLint location, GLint64EXT* params);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1I64NVPROC) (GLuint program, GLint location, GLint64EXT x);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glUniform1i64NV(GLint location, GLint64EXT x);
	GLAPI void APIENTRY glUniform2i64NV(GLint location, GLint64EXT x, GLint64EXT y);
	GLAPI void APIENTRY glUniform3i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
	GLAPI void APIENTRY glUniform4i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
	GLAPI void APIENTRY glUniform1i64vNV(GLint location, GLsizei count, const GLint64EXT* value);
	GLAPI void APIENTRY glUniform2i64vNV(GLint location, GLsizei count, const GLint64EXT* value);
	GLAPI void APIENTRY glUniform3i64vNV(GLint location, GLsizei count, const GLint64EXT* value);
	GLAPI void APIENTRY glUniform4i64vNV(GLint location, GLsizei count, const GLint64EXT* value);
	GLAPI void APIENTRY glUniform1ui64NV(GLint location, GLuint64EXT x);
	GLAPI void APIENTRY glUniform2ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y);
	GLAPI void APIENTRY glUniform3ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
	GLAPI void APIENTRY glUniform4ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
	GLAPI void APIENTRY glUniform1ui64vNV(GLint location, GLsizei count, const GLuint64EXT* value);
	GLAPI void APIENTRY glUniform2ui64vNV(GLint location, GLsizei count, const GLuint64EXT* value);
	GLAPI void APIENTRY glUniform3ui64vNV(GLint location, GLsizei count, const GLuint64EXT* value);
	GLAPI void APIENTRY glUniform4ui64vNV(GLint location, GLsizei count, const GLuint64EXT* value);
	GLAPI void APIENTRY glGetUniformi64vNV(GLuint program, GLint location, GLint64EXT* params);
	GLAPI void APIENTRY glProgramUniform1i64NV(GLuint program, GLint location, GLint64EXT x);
	GLAPI void APIENTRY glProgramUniform2i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y);
	GLAPI void APIENTRY glProgramUniform3i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
	GLAPI void APIENTRY glProgramUniform4i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
	GLAPI void APIENTRY glProgramUniform1i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
	GLAPI void APIENTRY glProgramUniform2i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
	GLAPI void APIENTRY glProgramUniform3i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
	GLAPI void APIENTRY glProgramUniform4i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
	GLAPI void APIENTRY glProgramUniform1ui64NV(GLuint program, GLint location, GLuint64EXT x);
	GLAPI void APIENTRY glProgramUniform2ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y);
	GLAPI void APIENTRY glProgramUniform3ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
	GLAPI void APIENTRY glProgramUniform4ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
	GLAPI void APIENTRY glProgramUniform1ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
	GLAPI void APIENTRY glProgramUniform2ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
	GLAPI void APIENTRY glProgramUniform3ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
	GLAPI void APIENTRY glProgramUniform4ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
#endif
#endif /* GL_NV_gpu_shader5 */

#ifndef GL_NV_internalformat_sample_query
#define GL_NV_internalformat_sample_query 1
#define GL_MULTISAMPLES_NV                0x9371
#define GL_SUPERSAMPLE_SCALE_X_NV         0x9372
#define GL_SUPERSAMPLE_SCALE_Y_NV         0x9373
#define GL_CONFORMANT_NV                  0x9374
	typedef void (APIENTRYP PFNGLGETINTERNALFORMATSAMPLEIVNVPROC) (GLenum target, GLenum internalformat, GLsizei samples, GLenum pname, GLsizei count, GLint* params);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glGetInternalformatSampleivNV(GLenum target, GLenum internalformat, GLsizei samples, GLenum pname, GLsizei count, GLint* params);
#endif
#endif /* GL_NV_internalformat_sample_query */

#ifndef GL_NV_memory_attachment
#define GL_NV_memory_attachment 1
#define GL_ATTACHED_MEMORY_OBJECT_NV      0x95A4
#define GL_ATTACHED_MEMORY_OFFSET_NV      0x95A5
#define GL_MEMORY_ATTACHABLE_ALIGNMENT_NV 0x95A6
#define GL_MEMORY_ATTACHABLE_SIZE_NV      0x95A7
#define GL_MEMORY_ATTACHABLE_NV           0x95A8
#define GL_DETACHED_MEMORY_INCARNATION_NV 0x95A9
#define GL_DETACHED_TEXTURES_NV           0x95AA
#define GL_DETACHED_BUFFERS_NV            0x95AB
#define GL_MAX_DETACHED_TEXTURES_NV       0x95AC
#define GL_MAX_DETACHED_BUFFERS_NV        0x95AD
	typedef void (APIENTRYP PFNGLGETMEMORYOBJECTDETACHEDRESOURCESUIVNVPROC) (GLuint memory, GLenum pname, GLint first, GLsizei count, GLuint* params);
	typedef void (APIENTRYP PFNGLRESETMEMORYOBJECTPARAMETERNVPROC) (GLuint memory, GLenum pname);
	typedef void (APIENTRYP PFNGLTEXATTACHMEMORYNVPROC) (GLenum target, GLuint memory, GLuint64 offset);
	typedef void (APIENTRYP PFNGLBUFFERATTACHMEMORYNVPROC) (GLenum target, GLuint memory, GLuint64 offset);
	typedef void (APIENTRYP PFNGLTEXTUREATTACHMEMORYNVPROC) (GLuint texture, GLuint memory, GLuint64 offset);
	typedef void (APIENTRYP PFNGLNAMEDBUFFERATTACHMEMORYNVPROC) (GLuint buffer, GLuint memory, GLuint64 offset);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glGetMemoryObjectDetachedResourcesuivNV(GLuint memory, GLenum pname, GLint first, GLsizei count, GLuint* params);
	GLAPI void APIENTRY glResetMemoryObjectParameterNV(GLuint memory, GLenum pname);
	GLAPI void APIENTRY glTexAttachMemoryNV(GLenum target, GLuint memory, GLuint64 offset);
	GLAPI void APIENTRY glBufferAttachMemoryNV(GLenum target, GLuint memory, GLuint64 offset);
	GLAPI void APIENTRY glTextureAttachMemoryNV(GLuint texture, GLuint memory, GLuint64 offset);
	GLAPI void APIENTRY glNamedBufferAttachMemoryNV(GLuint buffer, GLuint memory, GLuint64 offset);
#endif
#endif /* GL_NV_memory_attachment */

#ifndef GL_NV_memory_object_sparse
#define GL_NV_memory_object_sparse 1
	typedef void (APIENTRYP PFNGLBUFFERPAGECOMMITMENTMEMNVPROC) (GLenum target, GLintptr offset, GLsizeiptr size, GLuint memory, GLuint64 memOffset, GLboolean commit);
	typedef void (APIENTRYP PFNGLTEXPAGECOMMITMENTMEMNVPROC) (GLenum target, GLint layer, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset, GLboolean commit);
	typedef void (APIENTRYP PFNGLNAMEDBUFFERPAGECOMMITMENTMEMNVPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, GLuint memory, GLuint64 memOffset, GLboolean commit);
	typedef void (APIENTRYP PFNGLTEXTUREPAGECOMMITMENTMEMNVPROC) (GLuint texture, GLint layer, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset, GLboolean commit);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glBufferPageCommitmentMemNV(GLenum target, GLintptr offset, GLsizeiptr size, GLuint memory, GLuint64 memOffset, GLboolean commit);
	GLAPI void APIENTRY glTexPageCommitmentMemNV(GLenum target, GLint layer, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset, GLboolean commit);
	GLAPI void APIENTRY glNamedBufferPageCommitmentMemNV(GLuint buffer, GLintptr offset, GLsizeiptr size, GLuint memory, GLuint64 memOffset, GLboolean commit);
	GLAPI void APIENTRY glTexturePageCommitmentMemNV(GLuint texture, GLint layer, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset, GLboolean commit);
#endif
#endif /* GL_NV_memory_object_sparse */

#ifndef GL_NV_mesh_shader
#define GL_NV_mesh_shader 1
#define GL_MESH_SHADER_NV                 0x9559
#define GL_TASK_SHADER_NV                 0x955A
#define GL_MAX_MESH_UNIFORM_BLOCKS_NV     0x8E60
#define GL_MAX_MESH_TEXTURE_IMAGE_UNITS_NV 0x8E61
#define GL_MAX_MESH_IMAGE_UNIFORMS_NV     0x8E62
#define GL_MAX_MESH_UNIFORM_COMPONENTS_NV 0x8E63
#define GL_MAX_MESH_ATOMIC_COUNTER_BUFFERS_NV 0x8E64
#define GL_MAX_MESH_ATOMIC_COUNTERS_NV    0x8E65
#define GL_MAX_MESH_SHADER_STORAGE_BLOCKS_NV 0x8E66
#define GL_MAX_COMBINED_MESH_UNIFORM_COMPONENTS_NV 0x8E67
#define GL_MAX_TASK_UNIFORM_BLOCKS_NV     0x8E68
#define GL_MAX_TASK_TEXTURE_IMAGE_UNITS_NV 0x8E69
#define GL_MAX_TASK_IMAGE_UNIFORMS_NV     0x8E6A
#define GL_MAX_TASK_UNIFORM_COMPONENTS_NV 0x8E6B
#define GL_MAX_TASK_ATOMIC_COUNTER_BUFFERS_NV 0x8E6C
#define GL_MAX_TASK_ATOMIC_COUNTERS_NV    0x8E6D
#define GL_MAX_TASK_SHADER_STORAGE_BLOCKS_NV 0x8E6E
#define GL_MAX_COMBINED_TASK_UNIFORM_COMPONENTS_NV 0x8E6F
#define GL_MAX_MESH_WORK_GROUP_INVOCATIONS_NV 0x95A2
#define GL_MAX_TASK_WORK_GROUP_INVOCATIONS_NV 0x95A3
#define GL_MAX_MESH_TOTAL_MEMORY_SIZE_NV  0x9536
#define GL_MAX_TASK_TOTAL_MEMORY_SIZE_NV  0x9537
#define GL_MAX_MESH_OUTPUT_VERTICES_NV    0x9538
#define GL_MAX_MESH_OUTPUT_PRIMITIVES_NV  0x9539
#define GL_MAX_TASK_OUTPUT_COUNT_NV       0x953A
#define GL_MAX_DRAW_MESH_TASKS_COUNT_NV   0x953D
#define GL_MAX_MESH_VIEWS_NV              0x9557
#define GL_MESH_OUTPUT_PER_VERTEX_GRANULARITY_NV 0x92DF
#define GL_MESH_OUTPUT_PER_PRIMITIVE_GRANULARITY_NV 0x9543
#define GL_MAX_MESH_WORK_GROUP_SIZE_NV    0x953B
#define GL_MAX_TASK_WORK_GROUP_SIZE_NV    0x953C
#define GL_MESH_WORK_GROUP_SIZE_NV        0x953E
#define GL_TASK_WORK_GROUP_SIZE_NV        0x953F
#define GL_MESH_VERTICES_OUT_NV           0x9579
#define GL_MESH_PRIMITIVES_OUT_NV         0x957A
#define GL_MESH_OUTPUT_TYPE_NV            0x957B
#define GL_UNIFORM_BLOCK_REFERENCED_BY_MESH_SHADER_NV 0x959C
#define GL_UNIFORM_BLOCK_REFERENCED_BY_TASK_SHADER_NV 0x959D
#define GL_REFERENCED_BY_MESH_SHADER_NV   0x95A0
#define GL_REFERENCED_BY_TASK_SHADER_NV   0x95A1
#define GL_MESH_SHADER_BIT_NV             0x00000040
#define GL_TASK_SHADER_BIT_NV             0x00000080
#define GL_MESH_SUBROUTINE_NV             0x957C
#define GL_TASK_SUBROUTINE_NV             0x957D
#define GL_MESH_SUBROUTINE_UNIFORM_NV     0x957E
#define GL_TASK_SUBROUTINE_UNIFORM_NV     0x957F
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_MESH_SHADER_NV 0x959E
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TASK_SHADER_NV 0x959F
	typedef void (APIENTRYP PFNGLDRAWMESHTASKSNVPROC) (GLuint first, GLuint count);
	typedef void (APIENTRYP PFNGLDRAWMESHTASKSINDIRECTNVPROC) (GLintptr indirect);
	typedef void (APIENTRYP PFNGLMULTIDRAWMESHTASKSINDIRECTNVPROC) (GLintptr indirect, GLsizei drawcount, GLsizei stride);
	typedef void (APIENTRYP PFNGLMULTIDRAWMESHTASKSINDIRECTCOUNTNVPROC) (GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glDrawMeshTasksNV(GLuint first, GLuint count);
	GLAPI void APIENTRY glDrawMeshTasksIndirectNV(GLintptr indirect);
	GLAPI void APIENTRY glMultiDrawMeshTasksIndirectNV(GLintptr indirect, GLsizei drawcount, GLsizei stride);
	GLAPI void APIENTRY glMultiDrawMeshTasksIndirectCountNV(GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
#endif
#endif /* GL_NV_mesh_shader */

#ifndef GL_NV_path_rendering
#define GL_NV_path_rendering 1
#define GL_PATH_FORMAT_SVG_NV             0x9070
#define GL_PATH_FORMAT_PS_NV              0x9071
#define GL_STANDARD_FONT_NAME_NV          0x9072
#define GL_SYSTEM_FONT_NAME_NV            0x9073
#define GL_FILE_NAME_NV                   0x9074
#define GL_PATH_STROKE_WIDTH_NV           0x9075
#define GL_PATH_END_CAPS_NV               0x9076
#define GL_PATH_INITIAL_END_CAP_NV        0x9077
#define GL_PATH_TERMINAL_END_CAP_NV       0x9078
#define GL_PATH_JOIN_STYLE_NV             0x9079
#define GL_PATH_MITER_LIMIT_NV            0x907A
#define GL_PATH_DASH_CAPS_NV              0x907B
#define GL_PATH_INITIAL_DASH_CAP_NV       0x907C
#define GL_PATH_TERMINAL_DASH_CAP_NV      0x907D
#define GL_PATH_DASH_OFFSET_NV            0x907E
#define GL_PATH_CLIENT_LENGTH_NV          0x907F
#define GL_PATH_FILL_MODE_NV              0x9080
#define GL_PATH_FILL_MASK_NV              0x9081
#define GL_PATH_FILL_COVER_MODE_NV        0x9082
#define GL_PATH_STROKE_COVER_MODE_NV      0x9083
#define GL_PATH_STROKE_MASK_NV            0x9084
#define GL_COUNT_UP_NV                    0x9088
#define GL_COUNT_DOWN_NV                  0x9089
#define GL_PATH_OBJECT_BOUNDING_BOX_NV    0x908A
#define GL_CONVEX_HULL_NV                 0x908B
#define GL_BOUNDING_BOX_NV                0x908D
#define GL_TRANSLATE_X_NV                 0x908E
#define GL_TRANSLATE_Y_NV                 0x908F
#define GL_TRANSLATE_2D_NV                0x9090
#define GL_TRANSLATE_3D_NV                0x9091
#define GL_AFFINE_2D_NV                   0x9092
#define GL_AFFINE_3D_NV                   0x9094
#define GL_TRANSPOSE_AFFINE_2D_NV         0x9096
#define GL_TRANSPOSE_AFFINE_3D_NV         0x9098
#define GL_UTF8_NV                        0x909A
#define GL_UTF16_NV                       0x909B
#define GL_BOUNDING_BOX_OF_BOUNDING_BOXES_NV 0x909C
#define GL_PATH_COMMAND_COUNT_NV          0x909D
#define GL_PATH_COORD_COUNT_NV            0x909E
#define GL_PATH_DASH_ARRAY_COUNT_NV       0x909F
#define GL_PATH_COMPUTED_LENGTH_NV        0x90A0
#define GL_PATH_FILL_BOUNDING_BOX_NV      0x90A1
#define GL_PATH_STROKE_BOUNDING_BOX_NV    0x90A2
#define GL_SQUARE_NV                      0x90A3
#define GL_ROUND_NV                       0x90A4
#define GL_TRIANGULAR_NV                  0x90A5
#define GL_BEVEL_NV                       0x90A6
#define GL_MITER_REVERT_NV                0x90A7
#define GL_MITER_TRUNCATE_NV              0x90A8
#define GL_SKIP_MISSING_GLYPH_NV          0x90A9
#define GL_USE_MISSING_GLYPH_NV           0x90AA
#define GL_PATH_ERROR_POSITION_NV         0x90AB
#define GL_ACCUM_ADJACENT_PAIRS_NV        0x90AD
#define GL_ADJACENT_PAIRS_NV              0x90AE
#define GL_FIRST_TO_REST_NV               0x90AF
#define GL_PATH_GEN_MODE_NV               0x90B0
#define GL_PATH_GEN_COEFF_NV              0x90B1
#define GL_PATH_GEN_COMPONENTS_NV         0x90B3
#define GL_PATH_STENCIL_FUNC_NV           0x90B7
#define GL_PATH_STENCIL_REF_NV            0x90B8
#define GL_PATH_STENCIL_VALUE_MASK_NV     0x90B9
#define GL_PATH_STENCIL_DEPTH_OFFSET_FACTOR_NV 0x90BD
#define GL_PATH_STENCIL_DEPTH_OFFSET_UNITS_NV 0x90BE
#define GL_PATH_COVER_DEPTH_FUNC_NV       0x90BF
#define GL_PATH_DASH_OFFSET_RESET_NV      0x90B4
#define GL_MOVE_TO_RESETS_NV              0x90B5
#define GL_MOVE_TO_CONTINUES_NV           0x90B6
#define GL_CLOSE_PATH_NV                  0x00
#define GL_MOVE_TO_NV                     0x02
#define GL_RELATIVE_MOVE_TO_NV            0x03
#define GL_LINE_TO_NV                     0x04
#define GL_RELATIVE_LINE_TO_NV            0x05
#define GL_HORIZONTAL_LINE_TO_NV          0x06
#define GL_RELATIVE_HORIZONTAL_LINE_TO_NV 0x07
#define GL_VERTICAL_LINE_TO_NV            0x08
#define GL_RELATIVE_VERTICAL_LINE_TO_NV   0x09
#define GL_QUADRATIC_CURVE_TO_NV          0x0A
#define GL_RELATIVE_QUADRATIC_CURVE_TO_NV 0x0B
#define GL_CUBIC_CURVE_TO_NV              0x0C
#define GL_RELATIVE_CUBIC_CURVE_TO_NV     0x0D
#define GL_SMOOTH_QUADRATIC_CURVE_TO_NV   0x0E
#define GL_RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV 0x0F
#define GL_SMOOTH_CUBIC_CURVE_TO_NV       0x10
#define GL_RELATIVE_SMOOTH_CUBIC_CURVE_TO_NV 0x11
#define GL_SMALL_CCW_ARC_TO_NV            0x12
#define GL_RELATIVE_SMALL_CCW_ARC_TO_NV   0x13
#define GL_SMALL_CW_ARC_TO_NV             0x14
#define GL_RELATIVE_SMALL_CW_ARC_TO_NV    0x15
#define GL_LARGE_CCW_ARC_TO_NV            0x16
#define GL_RELATIVE_LARGE_CCW_ARC_TO_NV   0x17
#define GL_LARGE_CW_ARC_TO_NV             0x18
#define GL_RELATIVE_LARGE_CW_ARC_TO_NV    0x19
#define GL_RESTART_PATH_NV                0xF0
#define GL_DUP_FIRST_CUBIC_CURVE_TO_NV    0xF2
#define GL_DUP_LAST_CUBIC_CURVE_TO_NV     0xF4
#define GL_RECT_NV                        0xF6
#define GL_CIRCULAR_CCW_ARC_TO_NV         0xF8
#define GL_CIRCULAR_CW_ARC_TO_NV          0xFA
#define GL_CIRCULAR_TANGENT_ARC_TO_NV     0xFC
#define GL_ARC_TO_NV                      0xFE
#define GL_RELATIVE_ARC_TO_NV             0xFF
#define GL_BOLD_BIT_NV                    0x01
#define GL_ITALIC_BIT_NV                  0x02
#define GL_GLYPH_WIDTH_BIT_NV             0x01
#define GL_GLYPH_HEIGHT_BIT_NV            0x02
#define GL_GLYPH_HORIZONTAL_BEARING_X_BIT_NV 0x04
#define GL_GLYPH_HORIZONTAL_BEARING_Y_BIT_NV 0x08
#define GL_GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV 0x10
#define GL_GLYPH_VERTICAL_BEARING_X_BIT_NV 0x20
#define GL_GLYPH_VERTICAL_BEARING_Y_BIT_NV 0x40
#define GL_GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV 0x80
#define GL_GLYPH_HAS_KERNING_BIT_NV       0x100
#define GL_FONT_X_MIN_BOUNDS_BIT_NV       0x00010000
#define GL_FONT_Y_MIN_BOUNDS_BIT_NV       0x00020000
#define GL_FONT_X_MAX_BOUNDS_BIT_NV       0x00040000
#define GL_FONT_Y_MAX_BOUNDS_BIT_NV       0x00080000
#define GL_FONT_UNITS_PER_EM_BIT_NV       0x00100000
#define GL_FONT_ASCENDER_BIT_NV           0x00200000
#define GL_FONT_DESCENDER_BIT_NV          0x00400000
#define GL_FONT_HEIGHT_BIT_NV             0x00800000
#define GL_FONT_MAX_ADVANCE_WIDTH_BIT_NV  0x01000000
#define GL_FONT_MAX_ADVANCE_HEIGHT_BIT_NV 0x02000000
#define GL_FONT_UNDERLINE_POSITION_BIT_NV 0x04000000
#define GL_FONT_UNDERLINE_THICKNESS_BIT_NV 0x08000000
#define GL_FONT_HAS_KERNING_BIT_NV        0x10000000
#define GL_ROUNDED_RECT_NV                0xE8
#define GL_RELATIVE_ROUNDED_RECT_NV       0xE9
#define GL_ROUNDED_RECT2_NV               0xEA
#define GL_RELATIVE_ROUNDED_RECT2_NV      0xEB
#define GL_ROUNDED_RECT4_NV               0xEC
#define GL_RELATIVE_ROUNDED_RECT4_NV      0xED
#define GL_ROUNDED_RECT8_NV               0xEE
#define GL_RELATIVE_ROUNDED_RECT8_NV      0xEF
#define GL_RELATIVE_RECT_NV               0xF7
#define GL_FONT_GLYPHS_AVAILABLE_NV       0x9368
#define GL_FONT_TARGET_UNAVAILABLE_NV     0x9369
#define GL_FONT_UNAVAILABLE_NV            0x936A
#define GL_FONT_UNINTELLIGIBLE_NV         0x936B
#define GL_CONIC_CURVE_TO_NV              0x1A
#define GL_RELATIVE_CONIC_CURVE_TO_NV     0x1B
#define GL_FONT_NUM_GLYPH_INDICES_BIT_NV  0x20000000
#define GL_STANDARD_FONT_FORMAT_NV        0x936C
#define GL_PATH_PROJECTION_NV             0x1701
#define GL_PATH_MODELVIEW_NV              0x1700
#define GL_PATH_MODELVIEW_STACK_DEPTH_NV  0x0BA3
#define GL_PATH_MODELVIEW_MATRIX_NV       0x0BA6
#define GL_PATH_MAX_MODELVIEW_STACK_DEPTH_NV 0x0D36
#define GL_PATH_TRANSPOSE_MODELVIEW_MATRIX_NV 0x84E3
#define GL_PATH_PROJECTION_STACK_DEPTH_NV 0x0BA4
#define GL_PATH_PROJECTION_MATRIX_NV      0x0BA7
#define GL_PATH_MAX_PROJECTION_STACK_DEPTH_NV 0x0D38
#define GL_PATH_TRANSPOSE_PROJECTION_MATRIX_NV 0x84E4
#define GL_FRAGMENT_INPUT_NV              0x936D
	typedef GLuint(APIENTRYP PFNGLGENPATHSNVPROC) (GLsizei range);
	typedef void (APIENTRYP PFNGLDELETEPATHSNVPROC) (GLuint path, GLsizei range);
	typedef GLboolean(APIENTRYP PFNGLISPATHNVPROC) (GLuint path);
	typedef void (APIENTRYP PFNGLPATHCOMMANDSNVPROC) (GLuint path, GLsizei numCommands, const GLubyte* commands, GLsizei numCoords, GLenum coordType, const void* coords);
	typedef void (APIENTRYP PFNGLPATHCOORDSNVPROC) (GLuint path, GLsizei numCoords, GLenum coordType, const void* coords);
	typedef void (APIENTRYP PFNGLPATHSUBCOMMANDSNVPROC) (GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte* commands, GLsizei numCoords, GLenum coordType, const void* coords);
	typedef void (APIENTRYP PFNGLPATHSUBCOORDSNVPROC) (GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void* coords);
	typedef void (APIENTRYP PFNGLPATHSTRINGNVPROC) (GLuint path, GLenum format, GLsizei length, const void* pathString);
	typedef void (APIENTRYP PFNGLPATHGLYPHSNVPROC) (GLuint firstPathName, GLenum fontTarget, const void* fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const void* charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
	typedef void (APIENTRYP PFNGLPATHGLYPHRANGENVPROC) (GLuint firstPathName, GLenum fontTarget, const void* fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
	typedef void (APIENTRYP PFNGLWEIGHTPATHSNVPROC) (GLuint resultPath, GLsizei numPaths, const GLuint* paths, const GLfloat* weights);
	typedef void (APIENTRYP PFNGLCOPYPATHNVPROC) (GLuint resultPath, GLuint srcPath);
	typedef void (APIENTRYP PFNGLINTERPOLATEPATHSNVPROC) (GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight);
	typedef void (APIENTRYP PFNGLTRANSFORMPATHNVPROC) (GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat* transformValues);
	typedef void (APIENTRYP PFNGLPATHPARAMETERIVNVPROC) (GLuint path, GLenum pname, const GLint* value);
	typedef void (APIENTRYP PFNGLPATHPARAMETERINVPROC) (GLuint path, GLenum pname, GLint value);
	typedef void (APIENTRYP PFNGLPATHPARAMETERFVNVPROC) (GLuint path, GLenum pname, const GLfloat* value);
	typedef void (APIENTRYP PFNGLPATHPARAMETERFNVPROC) (GLuint path, GLenum pname, GLfloat value);
	typedef void (APIENTRYP PFNGLPATHDASHARRAYNVPROC) (GLuint path, GLsizei dashCount, const GLfloat* dashArray);
	typedef void (APIENTRYP PFNGLPATHSTENCILFUNCNVPROC) (GLenum func, GLint ref, GLuint mask);
	typedef void (APIENTRYP PFNGLPATHSTENCILDEPTHOFFSETNVPROC) (GLfloat factor, GLfloat units);
	typedef void (APIENTRYP PFNGLSTENCILFILLPATHNVPROC) (GLuint path, GLenum fillMode, GLuint mask);
	typedef void (APIENTRYP PFNGLSTENCILSTROKEPATHNVPROC) (GLuint path, GLint reference, GLuint mask);
	typedef void (APIENTRYP PFNGLSTENCILFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat* transformValues);
	typedef void (APIENTRYP PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat* transformValues);
	typedef void (APIENTRYP PFNGLPATHCOVERDEPTHFUNCNVPROC) (GLenum func);
	typedef void (APIENTRYP PFNGLCOVERFILLPATHNVPROC) (GLuint path, GLenum coverMode);
	typedef void (APIENTRYP PFNGLCOVERSTROKEPATHNVPROC) (GLuint path, GLenum coverMode);
	typedef void (APIENTRYP PFNGLCOVERFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat* transformValues);
	typedef void (APIENTRYP PFNGLCOVERSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat* transformValues);
	typedef void (APIENTRYP PFNGLGETPATHPARAMETERIVNVPROC) (GLuint path, GLenum pname, GLint* value);
	typedef void (APIENTRYP PFNGLGETPATHPARAMETERFVNVPROC) (GLuint path, GLenum pname, GLfloat* value);
	typedef void (APIENTRYP PFNGLGETPATHCOMMANDSNVPROC) (GLuint path, GLubyte* commands);
	typedef void (APIENTRYP PFNGLGETPATHCOORDSNVPROC) (GLuint path, GLfloat* coords);
	typedef void (APIENTRYP PFNGLGETPATHDASHARRAYNVPROC) (GLuint path, GLfloat* dashArray);
	typedef void (APIENTRYP PFNGLGETPATHMETRICSNVPROC) (GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLsizei stride, GLfloat* metrics);
	typedef void (APIENTRYP PFNGLGETPATHMETRICRANGENVPROC) (GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat* metrics);
	typedef void (APIENTRYP PFNGLGETPATHSPACINGNVPROC) (GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat* returnedSpacing);
	typedef GLboolean(APIENTRYP PFNGLISPOINTINFILLPATHNVPROC) (GLuint path, GLuint mask, GLfloat x, GLfloat y);
	typedef GLboolean(APIENTRYP PFNGLISPOINTINSTROKEPATHNVPROC) (GLuint path, GLfloat x, GLfloat y);
	typedef GLfloat(APIENTRYP PFNGLGETPATHLENGTHNVPROC) (GLuint path, GLsizei startSegment, GLsizei numSegments);
	typedef GLboolean(APIENTRYP PFNGLPOINTALONGPATHNVPROC) (GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat* x, GLfloat* y, GLfloat* tangentX, GLfloat* tangentY);
	typedef void (APIENTRYP PFNGLMATRIXLOAD3X2FNVPROC) (GLenum matrixMode, const GLfloat* m);
	typedef void (APIENTRYP PFNGLMATRIXLOAD3X3FNVPROC) (GLenum matrixMode, const GLfloat* m);
	typedef void (APIENTRYP PFNGLMATRIXLOADTRANSPOSE3X3FNVPROC) (GLenum matrixMode, const GLfloat* m);
	typedef void (APIENTRYP PFNGLMATRIXMULT3X2FNVPROC) (GLenum matrixMode, const GLfloat* m);
	typedef void (APIENTRYP PFNGLMATRIXMULT3X3FNVPROC) (GLenum matrixMode, const GLfloat* m);
	typedef void (APIENTRYP PFNGLMATRIXMULTTRANSPOSE3X3FNVPROC) (GLenum matrixMode, const GLfloat* m);
	typedef void (APIENTRYP PFNGLSTENCILTHENCOVERFILLPATHNVPROC) (GLuint path, GLenum fillMode, GLuint mask, GLenum coverMode);
	typedef void (APIENTRYP PFNGLSTENCILTHENCOVERSTROKEPATHNVPROC) (GLuint path, GLint reference, GLuint mask, GLenum coverMode);
	typedef void (APIENTRYP PFNGLSTENCILTHENCOVERFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat* transformValues);
	typedef void (APIENTRYP PFNGLSTENCILTHENCOVERSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLint reference, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat* transformValues);
	typedef GLenum(APIENTRYP PFNGLPATHGLYPHINDEXRANGENVPROC) (GLenum fontTarget, const void* fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint baseAndCount[2]);
	typedef GLenum(APIENTRYP PFNGLPATHGLYPHINDEXARRAYNVPROC) (GLuint firstPathName, GLenum fontTarget, const void* fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
	typedef GLenum(APIENTRYP PFNGLPATHMEMORYGLYPHINDEXARRAYNVPROC) (GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void* fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
	typedef void (APIENTRYP PFNGLPROGRAMPATHFRAGMENTINPUTGENNVPROC) (GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat* coeffs);
	typedef void (APIENTRYP PFNGLGETPROGRAMRESOURCEFVNVPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei count, GLsizei* length, GLfloat* params);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI GLuint APIENTRY glGenPathsNV(GLsizei range);
	GLAPI void APIENTRY glDeletePathsNV(GLuint path, GLsizei range);
	GLAPI GLboolean APIENTRY glIsPathNV(GLuint path);
	GLAPI void APIENTRY glPathCommandsNV(GLuint path, GLsizei numCommands, const GLubyte* commands, GLsizei numCoords, GLenum coordType, const void* coords);
	GLAPI void APIENTRY glPathCoordsNV(GLuint path, GLsizei numCoords, GLenum coordType, const void* coords);
	GLAPI void APIENTRY glPathSubCommandsNV(GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte* commands, GLsizei numCoords, GLenum coordType, const void* coords);
	GLAPI void APIENTRY glPathSubCoordsNV(GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void* coords);
	GLAPI void APIENTRY glPathStringNV(GLuint path, GLenum format, GLsizei length, const void* pathString);
	GLAPI void APIENTRY glPathGlyphsNV(GLuint firstPathName, GLenum fontTarget, const void* fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const void* charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
	GLAPI void APIENTRY glPathGlyphRangeNV(GLuint firstPathName, GLenum fontTarget, const void* fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
	GLAPI void APIENTRY glWeightPathsNV(GLuint resultPath, GLsizei numPaths, const GLuint* paths, const GLfloat* weights);
	GLAPI void APIENTRY glCopyPathNV(GLuint resultPath, GLuint srcPath);
	GLAPI void APIENTRY glInterpolatePathsNV(GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight);
	GLAPI void APIENTRY glTransformPathNV(GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat* transformValues);
	GLAPI void APIENTRY glPathParameterivNV(GLuint path, GLenum pname, const GLint* value);
	GLAPI void APIENTRY glPathParameteriNV(GLuint path, GLenum pname, GLint value);
	GLAPI void APIENTRY glPathParameterfvNV(GLuint path, GLenum pname, const GLfloat* value);
	GLAPI void APIENTRY glPathParameterfNV(GLuint path, GLenum pname, GLfloat value);
	GLAPI void APIENTRY glPathDashArrayNV(GLuint path, GLsizei dashCount, const GLfloat* dashArray);
	GLAPI void APIENTRY glPathStencilFuncNV(GLenum func, GLint ref, GLuint mask);
	GLAPI void APIENTRY glPathStencilDepthOffsetNV(GLfloat factor, GLfloat units);
	GLAPI void APIENTRY glStencilFillPathNV(GLuint path, GLenum fillMode, GLuint mask);
	GLAPI void APIENTRY glStencilStrokePathNV(GLuint path, GLint reference, GLuint mask);
	GLAPI void APIENTRY glStencilFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat* transformValues);
	GLAPI void APIENTRY glStencilStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat* transformValues);
	GLAPI void APIENTRY glPathCoverDepthFuncNV(GLenum func);
	GLAPI void APIENTRY glCoverFillPathNV(GLuint path, GLenum coverMode);
	GLAPI void APIENTRY glCoverStrokePathNV(GLuint path, GLenum coverMode);
	GLAPI void APIENTRY glCoverFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat* transformValues);
	GLAPI void APIENTRY glCoverStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat* transformValues);
	GLAPI void APIENTRY glGetPathParameterivNV(GLuint path, GLenum pname, GLint* value);
	GLAPI void APIENTRY glGetPathParameterfvNV(GLuint path, GLenum pname, GLfloat* value);
	GLAPI void APIENTRY glGetPathCommandsNV(GLuint path, GLubyte* commands);
	GLAPI void APIENTRY glGetPathCoordsNV(GLuint path, GLfloat* coords);
	GLAPI void APIENTRY glGetPathDashArrayNV(GLuint path, GLfloat* dashArray);
	GLAPI void APIENTRY glGetPathMetricsNV(GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLsizei stride, GLfloat* metrics);
	GLAPI void APIENTRY glGetPathMetricRangeNV(GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat* metrics);
	GLAPI void APIENTRY glGetPathSpacingNV(GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat* returnedSpacing);
	GLAPI GLboolean APIENTRY glIsPointInFillPathNV(GLuint path, GLuint mask, GLfloat x, GLfloat y);
	GLAPI GLboolean APIENTRY glIsPointInStrokePathNV(GLuint path, GLfloat x, GLfloat y);
	GLAPI GLfloat APIENTRY glGetPathLengthNV(GLuint path, GLsizei startSegment, GLsizei numSegments);
	GLAPI GLboolean APIENTRY glPointAlongPathNV(GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat* x, GLfloat* y, GLfloat* tangentX, GLfloat* tangentY);
	GLAPI void APIENTRY glMatrixLoad3x2fNV(GLenum matrixMode, const GLfloat* m);
	GLAPI void APIENTRY glMatrixLoad3x3fNV(GLenum matrixMode, const GLfloat* m);
	GLAPI void APIENTRY glMatrixLoadTranspose3x3fNV(GLenum matrixMode, const GLfloat* m);
	GLAPI void APIENTRY glMatrixMult3x2fNV(GLenum matrixMode, const GLfloat* m);
	GLAPI void APIENTRY glMatrixMult3x3fNV(GLenum matrixMode, const GLfloat* m);
	GLAPI void APIENTRY glMatrixMultTranspose3x3fNV(GLenum matrixMode, const GLfloat* m);
	GLAPI void APIENTRY glStencilThenCoverFillPathNV(GLuint path, GLenum fillMode, GLuint mask, GLenum coverMode);
	GLAPI void APIENTRY glStencilThenCoverStrokePathNV(GLuint path, GLint reference, GLuint mask, GLenum coverMode);
	GLAPI void APIENTRY glStencilThenCoverFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat* transformValues);
	GLAPI void APIENTRY glStencilThenCoverStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLint reference, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat* transformValues);
	GLAPI GLenum APIENTRY glPathGlyphIndexRangeNV(GLenum fontTarget, const void* fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint baseAndCount[2]);
	GLAPI GLenum APIENTRY glPathGlyphIndexArrayNV(GLuint firstPathName, GLenum fontTarget, const void* fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
	GLAPI GLenum APIENTRY glPathMemoryGlyphIndexArrayNV(GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void* fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
	GLAPI void APIENTRY glProgramPathFragmentInputGenNV(GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat* coeffs);
	GLAPI void APIENTRY glGetProgramResourcefvNV(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei count, GLsizei* length, GLfloat* params);
#endif
#endif /* GL_NV_path_rendering */

#ifndef GL_NV_path_rendering_shared_edge
#define GL_NV_path_rendering_shared_edge 1
#define GL_SHARED_EDGE_NV                 0xC0
#endif /* GL_NV_path_rendering_shared_edge */

#ifndef GL_NV_primitive_shading_rate
#define GL_NV_primitive_shading_rate 1
#define GL_SHADING_RATE_IMAGE_PER_PRIMITIVE_NV 0x95B1
#define GL_SHADING_RATE_IMAGE_PALETTE_COUNT_NV 0x95B2
#endif /* GL_NV_primitive_shading_rate */

#ifndef GL_NV_representative_fragment_test
#define GL_NV_representative_fragment_test 1
#define GL_REPRESENTATIVE_FRAGMENT_TEST_NV 0x937F
#endif /* GL_NV_representative_fragment_test */

#ifndef GL_NV_sample_locations
#define GL_NV_sample_locations 1
#define GL_SAMPLE_LOCATION_SUBPIXEL_BITS_NV 0x933D
#define GL_SAMPLE_LOCATION_PIXEL_GRID_WIDTH_NV 0x933E
#define GL_SAMPLE_LOCATION_PIXEL_GRID_HEIGHT_NV 0x933F
#define GL_PROGRAMMABLE_SAMPLE_LOCATION_TABLE_SIZE_NV 0x9340
#define GL_SAMPLE_LOCATION_NV             0x8E50
#define GL_PROGRAMMABLE_SAMPLE_LOCATION_NV 0x9341
#define GL_FRAMEBUFFER_PROGRAMMABLE_SAMPLE_LOCATIONS_NV 0x9342
#define GL_FRAMEBUFFER_SAMPLE_LOCATION_PIXEL_GRID_NV 0x9343
	typedef void (APIENTRYP PFNGLFRAMEBUFFERSAMPLELOCATIONSFVNVPROC) (GLenum target, GLuint start, GLsizei count, const GLfloat* v);
	typedef void (APIENTRYP PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVNVPROC) (GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v);
	typedef void (APIENTRYP PFNGLRESOLVEDEPTHVALUESNVPROC) (void);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glFramebufferSampleLocationsfvNV(GLenum target, GLuint start, GLsizei count, const GLfloat* v);
	GLAPI void APIENTRY glNamedFramebufferSampleLocationsfvNV(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v);
	GLAPI void APIENTRY glResolveDepthValuesNV(void);
#endif
#endif /* GL_NV_sample_locations */

#ifndef GL_NV_sample_mask_override_coverage
#define GL_NV_sample_mask_override_coverage 1
#endif /* GL_NV_sample_mask_override_coverage */

#ifndef GL_NV_scissor_exclusive
#define GL_NV_scissor_exclusive 1
#define GL_SCISSOR_TEST_EXCLUSIVE_NV      0x9555
#define GL_SCISSOR_BOX_EXCLUSIVE_NV       0x9556
	typedef void (APIENTRYP PFNGLSCISSOREXCLUSIVENVPROC) (GLint x, GLint y, GLsizei width, GLsizei height);
	typedef void (APIENTRYP PFNGLSCISSOREXCLUSIVEARRAYVNVPROC) (GLuint first, GLsizei count, const GLint* v);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glScissorExclusiveNV(GLint x, GLint y, GLsizei width, GLsizei height);
	GLAPI void APIENTRY glScissorExclusiveArrayvNV(GLuint first, GLsizei count, const GLint* v);
#endif
#endif /* GL_NV_scissor_exclusive */

#ifndef GL_NV_shader_atomic_counters
#define GL_NV_shader_atomic_counters 1
#endif /* GL_NV_shader_atomic_counters */

#ifndef GL_NV_shader_atomic_float
#define GL_NV_shader_atomic_float 1
#endif /* GL_NV_shader_atomic_float */

#ifndef GL_NV_shader_atomic_float64
#define GL_NV_shader_atomic_float64 1
#endif /* GL_NV_shader_atomic_float64 */

#ifndef GL_NV_shader_atomic_fp16_vector
#define GL_NV_shader_atomic_fp16_vector 1
#endif /* GL_NV_shader_atomic_fp16_vector */

#ifndef GL_NV_shader_atomic_int64
#define GL_NV_shader_atomic_int64 1
#endif /* GL_NV_shader_atomic_int64 */

#ifndef GL_NV_shader_buffer_load
#define GL_NV_shader_buffer_load 1
#define GL_BUFFER_GPU_ADDRESS_NV          0x8F1D
#define GL_GPU_ADDRESS_NV                 0x8F34
#define GL_MAX_SHADER_BUFFER_ADDRESS_NV   0x8F35
	typedef void (APIENTRYP PFNGLMAKEBUFFERRESIDENTNVPROC) (GLenum target, GLenum access);
	typedef void (APIENTRYP PFNGLMAKEBUFFERNONRESIDENTNVPROC) (GLenum target);
	typedef GLboolean(APIENTRYP PFNGLISBUFFERRESIDENTNVPROC) (GLenum target);
	typedef void (APIENTRYP PFNGLMAKENAMEDBUFFERRESIDENTNVPROC) (GLuint buffer, GLenum access);
	typedef void (APIENTRYP PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC) (GLuint buffer);
	typedef GLboolean(APIENTRYP PFNGLISNAMEDBUFFERRESIDENTNVPROC) (GLuint buffer);
	typedef void (APIENTRYP PFNGLGETBUFFERPARAMETERUI64VNVPROC) (GLenum target, GLenum pname, GLuint64EXT* params);
	typedef void (APIENTRYP PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC) (GLuint buffer, GLenum pname, GLuint64EXT* params);
	typedef void (APIENTRYP PFNGLGETINTEGERUI64VNVPROC) (GLenum value, GLuint64EXT* result);
	typedef void (APIENTRYP PFNGLUNIFORMUI64NVPROC) (GLint location, GLuint64EXT value);
	typedef void (APIENTRYP PFNGLUNIFORMUI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
	typedef void (APIENTRYP PFNGLGETUNIFORMUI64VNVPROC) (GLuint program, GLint location, GLuint64EXT* params);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMUI64NVPROC) (GLuint program, GLint location, GLuint64EXT value);
	typedef void (APIENTRYP PFNGLPROGRAMUNIFORMUI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glMakeBufferResidentNV(GLenum target, GLenum access);
	GLAPI void APIENTRY glMakeBufferNonResidentNV(GLenum target);
	GLAPI GLboolean APIENTRY glIsBufferResidentNV(GLenum target);
	GLAPI void APIENTRY glMakeNamedBufferResidentNV(GLuint buffer, GLenum access);
	GLAPI void APIENTRY glMakeNamedBufferNonResidentNV(GLuint buffer);
	GLAPI GLboolean APIENTRY glIsNamedBufferResidentNV(GLuint buffer);
	GLAPI void APIENTRY glGetBufferParameterui64vNV(GLenum target, GLenum pname, GLuint64EXT* params);
	GLAPI void APIENTRY glGetNamedBufferParameterui64vNV(GLuint buffer, GLenum pname, GLuint64EXT* params);
	GLAPI void APIENTRY glGetIntegerui64vNV(GLenum value, GLuint64EXT* result);
	GLAPI void APIENTRY glUniformui64NV(GLint location, GLuint64EXT value);
	GLAPI void APIENTRY glUniformui64vNV(GLint location, GLsizei count, const GLuint64EXT* value);
	GLAPI void APIENTRY glGetUniformui64vNV(GLuint program, GLint location, GLuint64EXT* params);
	GLAPI void APIENTRY glProgramUniformui64NV(GLuint program, GLint location, GLuint64EXT value);
	GLAPI void APIENTRY glProgramUniformui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
#endif
#endif /* GL_NV_shader_buffer_load */

#ifndef GL_NV_shader_buffer_store
#define GL_NV_shader_buffer_store 1
#define GL_SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV 0x00000010
#endif /* GL_NV_shader_buffer_store */

#ifndef GL_NV_shader_subgroup_partitioned
#define GL_NV_shader_subgroup_partitioned 1
#define GL_SUBGROUP_FEATURE_PARTITIONED_BIT_NV 0x00000100
#endif /* GL_NV_shader_subgroup_partitioned */

#ifndef GL_NV_shader_texture_footprint
#define GL_NV_shader_texture_footprint 1
#endif /* GL_NV_shader_texture_footprint */

#ifndef GL_NV_shader_thread_group
#define GL_NV_shader_thread_group 1
#define GL_WARP_SIZE_NV                   0x9339
#define GL_WARPS_PER_SM_NV                0x933A
#define GL_SM_COUNT_NV                    0x933B
#endif /* GL_NV_shader_thread_group */

#ifndef GL_NV_shader_thread_shuffle
#define GL_NV_shader_thread_shuffle 1
#endif /* GL_NV_shader_thread_shuffle */

#ifndef GL_NV_shading_rate_image
#define GL_NV_shading_rate_image 1
#define GL_SHADING_RATE_IMAGE_NV          0x9563
#define GL_SHADING_RATE_NO_INVOCATIONS_NV 0x9564
#define GL_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV 0x9565
#define GL_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV 0x9566
#define GL_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV 0x9567
#define GL_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV 0x9568
#define GL_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV 0x9569
#define GL_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV 0x956A
#define GL_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV 0x956B
#define GL_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV 0x956C
#define GL_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV 0x956D
#define GL_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV 0x956E
#define GL_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV 0x956F
#define GL_SHADING_RATE_IMAGE_BINDING_NV  0x955B
#define GL_SHADING_RATE_IMAGE_TEXEL_WIDTH_NV 0x955C
#define GL_SHADING_RATE_IMAGE_TEXEL_HEIGHT_NV 0x955D
#define GL_SHADING_RATE_IMAGE_PALETTE_SIZE_NV 0x955E
#define GL_MAX_COARSE_FRAGMENT_SAMPLES_NV 0x955F
#define GL_SHADING_RATE_SAMPLE_ORDER_DEFAULT_NV 0x95AE
#define GL_SHADING_RATE_SAMPLE_ORDER_PIXEL_MAJOR_NV 0x95AF
#define GL_SHADING_RATE_SAMPLE_ORDER_SAMPLE_MAJOR_NV 0x95B0
	typedef void (APIENTRYP PFNGLBINDSHADINGRATEIMAGENVPROC) (GLuint texture);
	typedef void (APIENTRYP PFNGLGETSHADINGRATEIMAGEPALETTENVPROC) (GLuint viewport, GLuint entry, GLenum* rate);
	typedef void (APIENTRYP PFNGLGETSHADINGRATESAMPLELOCATIONIVNVPROC) (GLenum rate, GLuint samples, GLuint index, GLint* location);
	typedef void (APIENTRYP PFNGLSHADINGRATEIMAGEBARRIERNVPROC) (GLboolean synchronize);
	typedef void (APIENTRYP PFNGLSHADINGRATEIMAGEPALETTENVPROC) (GLuint viewport, GLuint first, GLsizei count, const GLenum* rates);
	typedef void (APIENTRYP PFNGLSHADINGRATESAMPLEORDERNVPROC) (GLenum order);
	typedef void (APIENTRYP PFNGLSHADINGRATESAMPLEORDERCUSTOMNVPROC) (GLenum rate, GLuint samples, const GLint* locations);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glBindShadingRateImageNV(GLuint texture);
	GLAPI void APIENTRY glGetShadingRateImagePaletteNV(GLuint viewport, GLuint entry, GLenum* rate);
	GLAPI void APIENTRY glGetShadingRateSampleLocationivNV(GLenum rate, GLuint samples, GLuint index, GLint* location);
	GLAPI void APIENTRY glShadingRateImageBarrierNV(GLboolean synchronize);
	GLAPI void APIENTRY glShadingRateImagePaletteNV(GLuint viewport, GLuint first, GLsizei count, const GLenum* rates);
	GLAPI void APIENTRY glShadingRateSampleOrderNV(GLenum order);
	GLAPI void APIENTRY glShadingRateSampleOrderCustomNV(GLenum rate, GLuint samples, const GLint* locations);
#endif
#endif /* GL_NV_shading_rate_image */

#ifndef GL_NV_stereo_view_rendering
#define GL_NV_stereo_view_rendering 1
#endif /* GL_NV_stereo_view_rendering */

#ifndef GL_NV_texture_barrier
#define GL_NV_texture_barrier 1
	typedef void (APIENTRYP PFNGLTEXTUREBARRIERNVPROC) (void);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glTextureBarrierNV(void);
#endif
#endif /* GL_NV_texture_barrier */

#ifndef GL_NV_texture_rectangle_compressed
#define GL_NV_texture_rectangle_compressed 1
#endif /* GL_NV_texture_rectangle_compressed */

#ifndef GL_NV_uniform_buffer_unified_memory
#define GL_NV_uniform_buffer_unified_memory 1
#define GL_UNIFORM_BUFFER_UNIFIED_NV      0x936E
#define GL_UNIFORM_BUFFER_ADDRESS_NV      0x936F
#define GL_UNIFORM_BUFFER_LENGTH_NV       0x9370
#endif /* GL_NV_uniform_buffer_unified_memory */

#ifndef GL_NV_vertex_attrib_integer_64bit
#define GL_NV_vertex_attrib_integer_64bit 1
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL1I64NVPROC) (GLuint index, GLint64EXT x);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL2I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL3I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL4I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL1I64VNVPROC) (GLuint index, const GLint64EXT* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL2I64VNVPROC) (GLuint index, const GLint64EXT* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL3I64VNVPROC) (GLuint index, const GLint64EXT* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL4I64VNVPROC) (GLuint index, const GLint64EXT* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL1UI64NVPROC) (GLuint index, GLuint64EXT x);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL2UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL3UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL4UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL1UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL2UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL3UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBL4UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
	typedef void (APIENTRYP PFNGLGETVERTEXATTRIBLI64VNVPROC) (GLuint index, GLenum pname, GLint64EXT* params);
	typedef void (APIENTRYP PFNGLGETVERTEXATTRIBLUI64VNVPROC) (GLuint index, GLenum pname, GLuint64EXT* params);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBLFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glVertexAttribL1i64NV(GLuint index, GLint64EXT x);
	GLAPI void APIENTRY glVertexAttribL2i64NV(GLuint index, GLint64EXT x, GLint64EXT y);
	GLAPI void APIENTRY glVertexAttribL3i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z);
	GLAPI void APIENTRY glVertexAttribL4i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
	GLAPI void APIENTRY glVertexAttribL1i64vNV(GLuint index, const GLint64EXT* v);
	GLAPI void APIENTRY glVertexAttribL2i64vNV(GLuint index, const GLint64EXT* v);
	GLAPI void APIENTRY glVertexAttribL3i64vNV(GLuint index, const GLint64EXT* v);
	GLAPI void APIENTRY glVertexAttribL4i64vNV(GLuint index, const GLint64EXT* v);
	GLAPI void APIENTRY glVertexAttribL1ui64NV(GLuint index, GLuint64EXT x);
	GLAPI void APIENTRY glVertexAttribL2ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y);
	GLAPI void APIENTRY glVertexAttribL3ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
	GLAPI void APIENTRY glVertexAttribL4ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
	GLAPI void APIENTRY glVertexAttribL1ui64vNV(GLuint index, const GLuint64EXT* v);
	GLAPI void APIENTRY glVertexAttribL2ui64vNV(GLuint index, const GLuint64EXT* v);
	GLAPI void APIENTRY glVertexAttribL3ui64vNV(GLuint index, const GLuint64EXT* v);
	GLAPI void APIENTRY glVertexAttribL4ui64vNV(GLuint index, const GLuint64EXT* v);
	GLAPI void APIENTRY glGetVertexAttribLi64vNV(GLuint index, GLenum pname, GLint64EXT* params);
	GLAPI void APIENTRY glGetVertexAttribLui64vNV(GLuint index, GLenum pname, GLuint64EXT* params);
	GLAPI void APIENTRY glVertexAttribLFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride);
#endif
#endif /* GL_NV_vertex_attrib_integer_64bit */

#ifndef GL_NV_vertex_buffer_unified_memory
#define GL_NV_vertex_buffer_unified_memory 1
#define GL_VERTEX_ATTRIB_ARRAY_UNIFIED_NV 0x8F1E
#define GL_ELEMENT_ARRAY_UNIFIED_NV       0x8F1F
#define GL_VERTEX_ATTRIB_ARRAY_ADDRESS_NV 0x8F20
#define GL_VERTEX_ARRAY_ADDRESS_NV        0x8F21
#define GL_NORMAL_ARRAY_ADDRESS_NV        0x8F22
#define GL_COLOR_ARRAY_ADDRESS_NV         0x8F23
#define GL_INDEX_ARRAY_ADDRESS_NV         0x8F24
#define GL_TEXTURE_COORD_ARRAY_ADDRESS_NV 0x8F25
#define GL_EDGE_FLAG_ARRAY_ADDRESS_NV     0x8F26
#define GL_SECONDARY_COLOR_ARRAY_ADDRESS_NV 0x8F27
#define GL_FOG_COORD_ARRAY_ADDRESS_NV     0x8F28
#define GL_ELEMENT_ARRAY_ADDRESS_NV       0x8F29
#define GL_VERTEX_ATTRIB_ARRAY_LENGTH_NV  0x8F2A
#define GL_VERTEX_ARRAY_LENGTH_NV         0x8F2B
#define GL_NORMAL_ARRAY_LENGTH_NV         0x8F2C
#define GL_COLOR_ARRAY_LENGTH_NV          0x8F2D
#define GL_INDEX_ARRAY_LENGTH_NV          0x8F2E
#define GL_TEXTURE_COORD_ARRAY_LENGTH_NV  0x8F2F
#define GL_EDGE_FLAG_ARRAY_LENGTH_NV      0x8F30
#define GL_SECONDARY_COLOR_ARRAY_LENGTH_NV 0x8F31
#define GL_FOG_COORD_ARRAY_LENGTH_NV      0x8F32
#define GL_ELEMENT_ARRAY_LENGTH_NV        0x8F33
#define GL_DRAW_INDIRECT_UNIFIED_NV       0x8F40
#define GL_DRAW_INDIRECT_ADDRESS_NV       0x8F41
#define GL_DRAW_INDIRECT_LENGTH_NV        0x8F42
	typedef void (APIENTRYP PFNGLBUFFERADDRESSRANGENVPROC) (GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length);
	typedef void (APIENTRYP PFNGLVERTEXFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
	typedef void (APIENTRYP PFNGLNORMALFORMATNVPROC) (GLenum type, GLsizei stride);
	typedef void (APIENTRYP PFNGLCOLORFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
	typedef void (APIENTRYP PFNGLINDEXFORMATNVPROC) (GLenum type, GLsizei stride);
	typedef void (APIENTRYP PFNGLTEXCOORDFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
	typedef void (APIENTRYP PFNGLEDGEFLAGFORMATNVPROC) (GLsizei stride);
	typedef void (APIENTRYP PFNGLSECONDARYCOLORFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
	typedef void (APIENTRYP PFNGLFOGCOORDFORMATNVPROC) (GLenum type, GLsizei stride);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride);
	typedef void (APIENTRYP PFNGLVERTEXATTRIBIFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride);
	typedef void (APIENTRYP PFNGLGETINTEGERUI64I_VNVPROC) (GLenum value, GLuint index, GLuint64EXT* result);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glBufferAddressRangeNV(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length);
	GLAPI void APIENTRY glVertexFormatNV(GLint size, GLenum type, GLsizei stride);
	GLAPI void APIENTRY glNormalFormatNV(GLenum type, GLsizei stride);
	GLAPI void APIENTRY glColorFormatNV(GLint size, GLenum type, GLsizei stride);
	GLAPI void APIENTRY glIndexFormatNV(GLenum type, GLsizei stride);
	GLAPI void APIENTRY glTexCoordFormatNV(GLint size, GLenum type, GLsizei stride);
	GLAPI void APIENTRY glEdgeFlagFormatNV(GLsizei stride);
	GLAPI void APIENTRY glSecondaryColorFormatNV(GLint size, GLenum type, GLsizei stride);
	GLAPI void APIENTRY glFogCoordFormatNV(GLenum type, GLsizei stride);
	GLAPI void APIENTRY glVertexAttribFormatNV(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride);
	GLAPI void APIENTRY glVertexAttribIFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride);
	GLAPI void APIENTRY glGetIntegerui64i_vNV(GLenum value, GLuint index, GLuint64EXT* result);
#endif
#endif /* GL_NV_vertex_buffer_unified_memory */

#ifndef GL_NV_viewport_array2
#define GL_NV_viewport_array2 1
#endif /* GL_NV_viewport_array2 */

#ifndef GL_NV_viewport_swizzle
#define GL_NV_viewport_swizzle 1
#define GL_VIEWPORT_SWIZZLE_POSITIVE_X_NV 0x9350
#define GL_VIEWPORT_SWIZZLE_NEGATIVE_X_NV 0x9351
#define GL_VIEWPORT_SWIZZLE_POSITIVE_Y_NV 0x9352
#define GL_VIEWPORT_SWIZZLE_NEGATIVE_Y_NV 0x9353
#define GL_VIEWPORT_SWIZZLE_POSITIVE_Z_NV 0x9354
#define GL_VIEWPORT_SWIZZLE_NEGATIVE_Z_NV 0x9355
#define GL_VIEWPORT_SWIZZLE_POSITIVE_W_NV 0x9356
#define GL_VIEWPORT_SWIZZLE_NEGATIVE_W_NV 0x9357
#define GL_VIEWPORT_SWIZZLE_X_NV          0x9358
#define GL_VIEWPORT_SWIZZLE_Y_NV          0x9359
#define GL_VIEWPORT_SWIZZLE_Z_NV          0x935A
#define GL_VIEWPORT_SWIZZLE_W_NV          0x935B
	typedef void (APIENTRYP PFNGLVIEWPORTSWIZZLENVPROC) (GLuint index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glViewportSwizzleNV(GLuint index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew);
#endif
#endif /* GL_NV_viewport_swizzle */

#ifndef GL_OVR_multiview
#define GL_OVR_multiview 1
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_OVR 0x9630
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_OVR 0x9632
#define GL_MAX_VIEWS_OVR                  0x9631
#define GL_FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR 0x9633
	typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews);
#ifdef GL_GLEXT_PROTOTYPES
	GLAPI void APIENTRY glFramebufferTextureMultiviewOVR(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews);
#endif
#endif /* GL_OVR_multiview */

#ifndef GL_OVR_multiview2
#define GL_OVR_multiview2 1
#endif /* GL_OVR_multiview2 */

#ifdef __cplusplus
}
#endif

#endif

#else
	#ifndef __gl3_h_
#define __gl3_h_ 1

#ifdef __cplusplus
extern "C" {
#endif

/*
** Copyright (c) 2013-2017 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/
/*
** This header is generated from the Khronos OpenGL / OpenGL ES XML
** API Registry. The current version of the Registry, generator scripts
** used to make the header, and the header can be found at
**   https://github.com/KhronosGroup/OpenGL-Registry
*/

#ifndef __gl3platform_h_
#define __gl3platform_h_

/*
** Copyright (c) 2017 The Khronos Group Inc.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
*/

/* Platform-specific types and definitions for OpenGL ES 3.X  gl3.h
 *
 * Adopters may modify khrplatform.h and this file to suit their platform.
 * Please contribute modifications back to Khronos as pull requests on the
 * public github repository:
 *      https://github.com/KhronosGroup/OpenGL-Registry
 */

#ifndef __khrplatform_h_
#define __khrplatform_h_

/*
** Copyright (c) 2008-2009 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

/* Khronos platform-specific types and definitions.
*
* $Revision: 32517 $ on $Date: 2016-03-11 02:41:19 -0800 (Fri, 11 Mar 2016) $
*
* Adopters may modify this file to suit their platform. Adopters are
* encouraged to submit platform specific modifications to the Khronos
* group so that they can be included in future versions of this file.
* Please submit changes by sending them to the public Khronos Bugzilla
* (http://khronos.org/bugzilla) by filing a bug against product
* "Khronos (general)" component "Registry".
*
* A predefined template which fills in some of the bug fields can be
* reached using http://tinyurl.com/khrplatform-h-bugreport, but you
* must create a Bugzilla login first.
*
*
* See the Implementer's Guidelines for information about where this file
* should be located on your system and for more details of its use:
*    http://www.khronos.org/registry/implementers_guide.pdf
*
* This file should be included as
*        #include <KHR/khrplatform.h>
* by Khronos client API header files that use its types and defines.
*
* The types in khrplatform.h should only be used to define API-specific types.
*
* Types defined in khrplatform.h:
*    khronos_int8_t              signed   8  bit
*    khronos_uint8_t             unsigned 8  bit
*    khronos_int16_t             signed   16 bit
*    khronos_uint16_t            unsigned 16 bit
*    khronos_int32_t             signed   32 bit
*    khronos_uint32_t            unsigned 32 bit
*    khronos_int64_t             signed   64 bit
*    khronos_uint64_t            unsigned 64 bit
*    khronos_intptr_t            signed   same number of bits as a pointer
*    khronos_uintptr_t           unsigned same number of bits as a pointer
*    khronos_ssize_t             signed   size
*    khronos_usize_t             unsigned size
*    khronos_float_t             signed   32 bit floating point
*    khronos_time_ns_t           unsigned 64 bit time in nanoseconds
*    khronos_utime_nanoseconds_t unsigned time interval or absolute time in
*                                         nanoseconds
*    khronos_stime_nanoseconds_t signed time interval in nanoseconds
*    khronos_boolean_enum_t      enumerated boolean type. This should
*      only be used as a base type when a client API's boolean type is
*      an enum. Client APIs which use an integer or other type for
*      booleans cannot use this as the base type for their boolean.
*
* Tokens defined in khrplatform.h:
*
*    KHRONOS_FALSE, KHRONOS_TRUE Enumerated boolean false/true values.
*
*    KHRONOS_SUPPORT_INT64 is 1 if 64 bit integers are supported; otherwise 0.
*    KHRONOS_SUPPORT_FLOAT is 1 if floats are supported; otherwise 0.
*
* Calling convention macros defined in this file:
*    KHRONOS_APICALL
*    KHRONOS_APIENTRY
*    KHRONOS_APIATTRIBUTES
*
* These may be used in function prototypes as:
*
*      KHRONOS_APICALL void KHRONOS_APIENTRY funcname(
*                                  int arg1,
*                                  int arg2) KHRONOS_APIATTRIBUTES;
*/

/*-------------------------------------------------------------------------
* Definition of KHRONOS_APICALL
*-------------------------------------------------------------------------
* This precedes the return type of the function in the function prototype.
*/
#if defined(_WIN32) && !defined(__SCITECH_SNAP__)
#   define KHRONOS_APICALL __declspec(dllimport)
#elif defined (__SYMBIAN32__)
#   define KHRONOS_APICALL IMPORT_C
#elif defined(__ANDROID__)
#   define KHRONOS_APICALL __attribute__((visibility("default")))
#else
#   define KHRONOS_APICALL
#endif

/*-------------------------------------------------------------------------
* Definition of KHRONOS_APIENTRY
*-------------------------------------------------------------------------
* This follows the return type of the function  and precedes the function
* name in the function prototype.
*/
#if defined(_WIN32) && !defined(_WIN32_WCE) && !defined(__SCITECH_SNAP__)
/* Win32 but not WinCE */
#   define KHRONOS_APIENTRY __stdcall
#else
#   define KHRONOS_APIENTRY
#endif

/*-------------------------------------------------------------------------
* Definition of KHRONOS_APIATTRIBUTES
*-------------------------------------------------------------------------
* This follows the closing parenthesis of the function prototype arguments.
*/
#if defined (__ARMCC_2__)
#define KHRONOS_APIATTRIBUTES __softfp
#else
#define KHRONOS_APIATTRIBUTES
#endif

/*-------------------------------------------------------------------------
* basic type definitions
*-----------------------------------------------------------------------*/
#if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || defined(__GNUC__) || defined(__SCO__) || defined(__USLC__)


/*
* Using <stdint.h>
*/
#include <stdint.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(__VMS ) || defined(__sgi)

/*
* Using <inttypes.h>
*/
#include <inttypes.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(_WIN32) && !defined(__SCITECH_SNAP__)

/*
* Win32
*/
typedef __int32                 khronos_int32_t;
typedef unsigned __int32        khronos_uint32_t;
typedef __int64                 khronos_int64_t;
typedef unsigned __int64        khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(__sun__) || defined(__digital__)

/*
* Sun or Digital
*/
typedef int                     khronos_int32_t;
typedef unsigned int            khronos_uint32_t;
#if defined(__arch64__) || defined(_LP64)
typedef long int                khronos_int64_t;
typedef unsigned long int       khronos_uint64_t;
#else
typedef long long int           khronos_int64_t;
typedef unsigned long long int  khronos_uint64_t;
#endif /* __arch64__ */
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif 0

/*
* Hypothetical platform with no float or int64 support
*/
typedef int                     khronos_int32_t;
typedef unsigned int            khronos_uint32_t;
#define KHRONOS_SUPPORT_INT64   0
#define KHRONOS_SUPPORT_FLOAT   0

#else

/*
* Generic fallback
*/
#include <stdint.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#endif


/*
* Types that are (so far) the same on all platforms
*/
typedef signed   char          khronos_int8_t;
typedef unsigned char          khronos_uint8_t;
typedef signed   short int     khronos_int16_t;
typedef unsigned short int     khronos_uint16_t;

/*
* Types that differ between LLP64 and LP64 architectures - in LLP64,
* pointers are 64 bits, but 'long' is still 32 bits. Win64 appears
* to be the only LLP64 architecture in current use.
*/
#ifdef _WIN64
typedef signed   long long int khronos_intptr_t;
typedef unsigned long long int khronos_uintptr_t;
typedef signed   long long int khronos_ssize_t;
typedef unsigned long long int khronos_usize_t;
#else
typedef signed   long  int     khronos_intptr_t;
typedef unsigned long  int     khronos_uintptr_t;
typedef signed   long  int     khronos_ssize_t;
typedef unsigned long  int     khronos_usize_t;
#endif

#if KHRONOS_SUPPORT_FLOAT
/*
* Float type
*/
typedef          float         khronos_float_t;
#endif

#if KHRONOS_SUPPORT_INT64
/* Time types
*
* These types can be used to represent a time interval in nanoseconds or
* an absolute Unadjusted System Time.  Unadjusted System Time is the number
* of nanoseconds since some arbitrary system event (e.g. since the last
* time the system booted).  The Unadjusted System Time is an unsigned
* 64 bit value that wraps back to 0 every 584 years.  Time intervals
* may be either signed or unsigned.
*/
typedef khronos_uint64_t       khronos_utime_nanoseconds_t;
typedef khronos_int64_t        khronos_stime_nanoseconds_t;
#endif

/*
* Dummy value used to pad enum types to 32 bits.
*/
#ifndef KHRONOS_MAX_ENUM
#define KHRONOS_MAX_ENUM 0x7FFFFFFF
#endif

/*
* Enumerated boolean type
*
* Values other than zero should be considered to be true.  Therefore
* comparisons should not be made against KHRONOS_TRUE.
*/
typedef enum {
	KHRONOS_FALSE = 0,
	KHRONOS_TRUE = 1,
	KHRONOS_BOOLEAN_ENUM_FORCE_SIZE = KHRONOS_MAX_ENUM
} khronos_boolean_enum_t;

#endif /* __khrplatform_h_ */


#ifndef GL_APICALL
#define GL_APICALL  KHRONOS_APICALL
#endif

#ifndef GL_APIENTRY
#define GL_APIENTRY KHRONOS_APIENTRY
#endif

#endif /* __gl3platform_h_ */



#ifndef GL_APIENTRYP
#define GL_APIENTRYP GL_APIENTRY*
#endif

#ifndef GL_GLES_PROTOTYPES
#define GL_GLES_PROTOTYPES 1
#endif

/* Generated on date 20170926 */

/* Generated C header for:
 * API: gles2
 * Profile: common
 * Versions considered: 2\.[0-9]|3\.0
 * Versions emitted: .*
 * Default extensions included: None
 * Additional extensions included: _nomatch_^
 * Extensions removed: _nomatch_^
 */

#ifndef GL_ES_VERSION_2_0
#define GL_ES_VERSION_2_0 1
#ifndef __khrplatform_h_
#define __khrplatform_h_

/*
** Copyright (c) 2008-2009 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

/* Khronos platform-specific types and definitions.
*
* $Revision: 32517 $ on $Date: 2016-03-11 02:41:19 -0800 (Fri, 11 Mar 2016) $
*
* Adopters may modify this file to suit their platform. Adopters are
* encouraged to submit platform specific modifications to the Khronos
* group so that they can be included in future versions of this file.
* Please submit changes by sending them to the public Khronos Bugzilla
* (http://khronos.org/bugzilla) by filing a bug against product
* "Khronos (general)" component "Registry".
*
* A predefined template which fills in some of the bug fields can be
* reached using http://tinyurl.com/khrplatform-h-bugreport, but you
* must create a Bugzilla login first.
*
*
* See the Implementer's Guidelines for information about where this file
* should be located on your system and for more details of its use:
*    http://www.khronos.org/registry/implementers_guide.pdf
*
* This file should be included as
*        #include <KHR/khrplatform.h>
* by Khronos client API header files that use its types and defines.
*
* The types in khrplatform.h should only be used to define API-specific types.
*
* Types defined in khrplatform.h:
*    khronos_int8_t              signed   8  bit
*    khronos_uint8_t             unsigned 8  bit
*    khronos_int16_t             signed   16 bit
*    khronos_uint16_t            unsigned 16 bit
*    khronos_int32_t             signed   32 bit
*    khronos_uint32_t            unsigned 32 bit
*    khronos_int64_t             signed   64 bit
*    khronos_uint64_t            unsigned 64 bit
*    khronos_intptr_t            signed   same number of bits as a pointer
*    khronos_uintptr_t           unsigned same number of bits as a pointer
*    khronos_ssize_t             signed   size
*    khronos_usize_t             unsigned size
*    khronos_float_t             signed   32 bit floating point
*    khronos_time_ns_t           unsigned 64 bit time in nanoseconds
*    khronos_utime_nanoseconds_t unsigned time interval or absolute time in
*                                         nanoseconds
*    khronos_stime_nanoseconds_t signed time interval in nanoseconds
*    khronos_boolean_enum_t      enumerated boolean type. This should
*      only be used as a base type when a client API's boolean type is
*      an enum. Client APIs which use an integer or other type for
*      booleans cannot use this as the base type for their boolean.
*
* Tokens defined in khrplatform.h:
*
*    KHRONOS_FALSE, KHRONOS_TRUE Enumerated boolean false/true values.
*
*    KHRONOS_SUPPORT_INT64 is 1 if 64 bit integers are supported; otherwise 0.
*    KHRONOS_SUPPORT_FLOAT is 1 if floats are supported; otherwise 0.
*
* Calling convention macros defined in this file:
*    KHRONOS_APICALL
*    KHRONOS_APIENTRY
*    KHRONOS_APIATTRIBUTES
*
* These may be used in function prototypes as:
*
*      KHRONOS_APICALL void KHRONOS_APIENTRY funcname(
*                                  int arg1,
*                                  int arg2) KHRONOS_APIATTRIBUTES;
*/

/*-------------------------------------------------------------------------
* Definition of KHRONOS_APICALL
*-------------------------------------------------------------------------
* This precedes the return type of the function in the function prototype.
*/
#if defined(_WIN32) && !defined(__SCITECH_SNAP__)
#   define KHRONOS_APICALL __declspec(dllimport)
#elif defined (__SYMBIAN32__)
#   define KHRONOS_APICALL IMPORT_C
#elif defined(__ANDROID__)
#   define KHRONOS_APICALL __attribute__((visibility("default")))
#else
#   define KHRONOS_APICALL
#endif

/*-------------------------------------------------------------------------
* Definition of KHRONOS_APIENTRY
*-------------------------------------------------------------------------
* This follows the return type of the function  and precedes the function
* name in the function prototype.
*/
#if defined(_WIN32) && !defined(_WIN32_WCE) && !defined(__SCITECH_SNAP__)
/* Win32 but not WinCE */
#   define KHRONOS_APIENTRY __stdcall
#else
#   define KHRONOS_APIENTRY
#endif

/*-------------------------------------------------------------------------
* Definition of KHRONOS_APIATTRIBUTES
*-------------------------------------------------------------------------
* This follows the closing parenthesis of the function prototype arguments.
*/
#if defined (__ARMCC_2__)
#define KHRONOS_APIATTRIBUTES __softfp
#else
#define KHRONOS_APIATTRIBUTES
#endif

/*-------------------------------------------------------------------------
* basic type definitions
*-----------------------------------------------------------------------*/
#if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || defined(__GNUC__) || defined(__SCO__) || defined(__USLC__)


/*
* Using <stdint.h>
*/
#include <stdint.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(__VMS ) || defined(__sgi)

/*
* Using <inttypes.h>
*/
#include <inttypes.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(_WIN32) && !defined(__SCITECH_SNAP__)

/*
* Win32
*/
typedef __int32                 khronos_int32_t;
typedef unsigned __int32        khronos_uint32_t;
typedef __int64                 khronos_int64_t;
typedef unsigned __int64        khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(__sun__) || defined(__digital__)

/*
* Sun or Digital
*/
typedef int                     khronos_int32_t;
typedef unsigned int            khronos_uint32_t;
#if defined(__arch64__) || defined(_LP64)
typedef long int                khronos_int64_t;
typedef unsigned long int       khronos_uint64_t;
#else
typedef long long int           khronos_int64_t;
typedef unsigned long long int  khronos_uint64_t;
#endif /* __arch64__ */
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif 0

/*
* Hypothetical platform with no float or int64 support
*/
typedef int                     khronos_int32_t;
typedef unsigned int            khronos_uint32_t;
#define KHRONOS_SUPPORT_INT64   0
#define KHRONOS_SUPPORT_FLOAT   0

#else

/*
* Generic fallback
*/
#include <stdint.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#endif


/*
* Types that are (so far) the same on all platforms
*/
typedef signed   char          khronos_int8_t;
typedef unsigned char          khronos_uint8_t;
typedef signed   short int     khronos_int16_t;
typedef unsigned short int     khronos_uint16_t;

/*
* Types that differ between LLP64 and LP64 architectures - in LLP64,
* pointers are 64 bits, but 'long' is still 32 bits. Win64 appears
* to be the only LLP64 architecture in current use.
*/
#ifdef _WIN64
typedef signed   long long int khronos_intptr_t;
typedef unsigned long long int khronos_uintptr_t;
typedef signed   long long int khronos_ssize_t;
typedef unsigned long long int khronos_usize_t;
#else
typedef signed   long  int     khronos_intptr_t;
typedef unsigned long  int     khronos_uintptr_t;
typedef signed   long  int     khronos_ssize_t;
typedef unsigned long  int     khronos_usize_t;
#endif

#if KHRONOS_SUPPORT_FLOAT
/*
* Float type
*/
typedef          float         khronos_float_t;
#endif

#if KHRONOS_SUPPORT_INT64
/* Time types
*
* These types can be used to represent a time interval in nanoseconds or
* an absolute Unadjusted System Time.  Unadjusted System Time is the number
* of nanoseconds since some arbitrary system event (e.g. since the last
* time the system booted).  The Unadjusted System Time is an unsigned
* 64 bit value that wraps back to 0 every 584 years.  Time intervals
* may be either signed or unsigned.
*/
typedef khronos_uint64_t       khronos_utime_nanoseconds_t;
typedef khronos_int64_t        khronos_stime_nanoseconds_t;
#endif

/*
* Dummy value used to pad enum types to 32 bits.
*/
#ifndef KHRONOS_MAX_ENUM
#define KHRONOS_MAX_ENUM 0x7FFFFFFF
#endif

/*
* Enumerated boolean type
*
* Values other than zero should be considered to be true.  Therefore
* comparisons should not be made against KHRONOS_TRUE.
*/
typedef enum {
	KHRONOS_FALSE = 0,
	KHRONOS_TRUE = 1,
	KHRONOS_BOOLEAN_ENUM_FORCE_SIZE = KHRONOS_MAX_ENUM
} khronos_boolean_enum_t;

#endif /* __khrplatform_h_ */

typedef khronos_int8_t GLbyte;
typedef khronos_float_t GLclampf;
typedef khronos_int32_t GLfixed;
typedef short GLshort;
typedef unsigned short GLushort;
typedef void GLvoid;
typedef struct __GLsync *GLsync;
typedef khronos_int64_t GLint64;
typedef khronos_uint64_t GLuint64;
typedef unsigned int GLenum;
typedef unsigned int GLuint;
typedef char GLchar;
typedef khronos_float_t GLfloat;
typedef khronos_ssize_t GLsizeiptr;
typedef khronos_intptr_t GLintptr;
typedef unsigned int GLbitfield;
typedef int GLint;
typedef unsigned char GLboolean;
typedef int GLsizei;
typedef khronos_uint8_t GLubyte;
#define GL_DEPTH_BUFFER_BIT               0x00000100
#define GL_STENCIL_BUFFER_BIT             0x00000400
#define GL_COLOR_BUFFER_BIT               0x00004000
#define GL_FALSE                          0
#define GL_TRUE                           1
#define GL_POINTS                         0x0000
#define GL_LINES                          0x0001
#define GL_LINE_LOOP                      0x0002
#define GL_LINE_STRIP                     0x0003
#define GL_TRIANGLES                      0x0004
#define GL_TRIANGLE_STRIP                 0x0005
#define GL_TRIANGLE_FAN                   0x0006
#define GL_ZERO                           0
#define GL_ONE                            1
#define GL_SRC_COLOR                      0x0300
#define GL_ONE_MINUS_SRC_COLOR            0x0301
#define GL_SRC_ALPHA                      0x0302
#define GL_ONE_MINUS_SRC_ALPHA            0x0303
#define GL_DST_ALPHA                      0x0304
#define GL_ONE_MINUS_DST_ALPHA            0x0305
#define GL_DST_COLOR                      0x0306
#define GL_ONE_MINUS_DST_COLOR            0x0307
#define GL_SRC_ALPHA_SATURATE             0x0308
#define GL_FUNC_ADD                       0x8006
#define GL_BLEND_EQUATION                 0x8009
#define GL_BLEND_EQUATION_RGB             0x8009
#define GL_BLEND_EQUATION_ALPHA           0x883D
#define GL_FUNC_SUBTRACT                  0x800A
#define GL_FUNC_REVERSE_SUBTRACT          0x800B
#define GL_BLEND_DST_RGB                  0x80C8
#define GL_BLEND_SRC_RGB                  0x80C9
#define GL_BLEND_DST_ALPHA                0x80CA
#define GL_BLEND_SRC_ALPHA                0x80CB
#define GL_CONSTANT_COLOR                 0x8001
#define GL_ONE_MINUS_CONSTANT_COLOR       0x8002
#define GL_CONSTANT_ALPHA                 0x8003
#define GL_ONE_MINUS_CONSTANT_ALPHA       0x8004
#define GL_BLEND_COLOR                    0x8005
#define GL_ARRAY_BUFFER                   0x8892
#define GL_ELEMENT_ARRAY_BUFFER           0x8893
#define GL_ARRAY_BUFFER_BINDING           0x8894
#define GL_ELEMENT_ARRAY_BUFFER_BINDING   0x8895
#define GL_STREAM_DRAW                    0x88E0
#define GL_STATIC_DRAW                    0x88E4
#define GL_DYNAMIC_DRAW                   0x88E8
#define GL_BUFFER_SIZE                    0x8764
#define GL_BUFFER_USAGE                   0x8765
#define GL_CURRENT_VERTEX_ATTRIB          0x8626
#define GL_FRONT                          0x0404
#define GL_BACK                           0x0405
#define GL_FRONT_AND_BACK                 0x0408
#define GL_TEXTURE_2D                     0x0DE1
#define GL_CULL_FACE                      0x0B44
#define GL_BLEND                          0x0BE2
#define GL_DITHER                         0x0BD0
#define GL_STENCIL_TEST                   0x0B90
#define GL_DEPTH_TEST                     0x0B71
#define GL_SCISSOR_TEST                   0x0C11
#define GL_POLYGON_OFFSET_FILL            0x8037
#define GL_SAMPLE_ALPHA_TO_COVERAGE       0x809E
#define GL_SAMPLE_COVERAGE                0x80A0
#define GL_NO_ERROR                       0
#define GL_INVALID_ENUM                   0x0500
#define GL_INVALID_VALUE                  0x0501
#define GL_INVALID_OPERATION              0x0502
#define GL_OUT_OF_MEMORY                  0x0505
#define GL_CW                             0x0900
#define GL_CCW                            0x0901
#define GL_LINE_WIDTH                     0x0B21
#define GL_ALIASED_POINT_SIZE_RANGE       0x846D
#define GL_ALIASED_LINE_WIDTH_RANGE       0x846E
#define GL_CULL_FACE_MODE                 0x0B45
#define GL_FRONT_FACE                     0x0B46
#define GL_DEPTH_RANGE                    0x0B70
#define GL_DEPTH_WRITEMASK                0x0B72
#define GL_DEPTH_CLEAR_VALUE              0x0B73
#define GL_DEPTH_FUNC                     0x0B74
#define GL_STENCIL_CLEAR_VALUE            0x0B91
#define GL_STENCIL_FUNC                   0x0B92
#define GL_STENCIL_FAIL                   0x0B94
#define GL_STENCIL_PASS_DEPTH_FAIL        0x0B95
#define GL_STENCIL_PASS_DEPTH_PASS        0x0B96
#define GL_STENCIL_REF                    0x0B97
#define GL_STENCIL_VALUE_MASK             0x0B93
#define GL_STENCIL_WRITEMASK              0x0B98
#define GL_STENCIL_BACK_FUNC              0x8800
#define GL_STENCIL_BACK_FAIL              0x8801
#define GL_STENCIL_BACK_PASS_DEPTH_FAIL   0x8802
#define GL_STENCIL_BACK_PASS_DEPTH_PASS   0x8803
#define GL_STENCIL_BACK_REF               0x8CA3
#define GL_STENCIL_BACK_VALUE_MASK        0x8CA4
#define GL_STENCIL_BACK_WRITEMASK         0x8CA5
#define GL_VIEWPORT                       0x0BA2
#define GL_SCISSOR_BOX                    0x0C10
#define GL_COLOR_CLEAR_VALUE              0x0C22
#define GL_COLOR_WRITEMASK                0x0C23
#define GL_UNPACK_ALIGNMENT               0x0CF5
#define GL_PACK_ALIGNMENT                 0x0D05
#define GL_MAX_TEXTURE_SIZE               0x0D33
#define GL_MAX_VIEWPORT_DIMS              0x0D3A
#define GL_SUBPIXEL_BITS                  0x0D50
#define GL_RED_BITS                       0x0D52
#define GL_GREEN_BITS                     0x0D53
#define GL_BLUE_BITS                      0x0D54
#define GL_ALPHA_BITS                     0x0D55
#define GL_DEPTH_BITS                     0x0D56
#define GL_STENCIL_BITS                   0x0D57
#define GL_POLYGON_OFFSET_UNITS           0x2A00
#define GL_POLYGON_OFFSET_FACTOR          0x8038
#define GL_TEXTURE_BINDING_2D             0x8069
#define GL_SAMPLE_BUFFERS                 0x80A8
#define GL_SAMPLES                        0x80A9
#define GL_SAMPLE_COVERAGE_VALUE          0x80AA
#define GL_SAMPLE_COVERAGE_INVERT         0x80AB
#define GL_NUM_COMPRESSED_TEXTURE_FORMATS 0x86A2
#define GL_COMPRESSED_TEXTURE_FORMATS     0x86A3
#define GL_DONT_CARE                      0x1100
#define GL_FASTEST                        0x1101
#define GL_NICEST                         0x1102
#define GL_GENERATE_MIPMAP_HINT           0x8192
#define GL_BYTE                           0x1400
#define GL_UNSIGNED_BYTE                  0x1401
#define GL_SHORT                          0x1402
#define GL_UNSIGNED_SHORT                 0x1403
#define GL_INT                            0x1404
#define GL_UNSIGNED_INT                   0x1405
#define GL_FLOAT                          0x1406
#define GL_FIXED                          0x140C
#define GL_DEPTH_COMPONENT                0x1902
#define GL_ALPHA                          0x1906
#define GL_RGB                            0x1907
#define GL_RGBA                           0x1908
#define GL_LUMINANCE                      0x1909
#define GL_LUMINANCE_ALPHA                0x190A
#define GL_UNSIGNED_SHORT_4_4_4_4         0x8033
#define GL_UNSIGNED_SHORT_5_5_5_1         0x8034
#define GL_UNSIGNED_SHORT_5_6_5           0x8363
#define GL_FRAGMENT_SHADER                0x8B30
#define GL_VERTEX_SHADER                  0x8B31
#define GL_MAX_VERTEX_ATTRIBS             0x8869
#define GL_MAX_VERTEX_UNIFORM_VECTORS     0x8DFB
#define GL_MAX_VARYING_VECTORS            0x8DFC
#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS 0x8B4D
#define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS 0x8B4C
#define GL_MAX_TEXTURE_IMAGE_UNITS        0x8872
#define GL_MAX_FRAGMENT_UNIFORM_VECTORS   0x8DFD
#define GL_SHADER_TYPE                    0x8B4F
#define GL_DELETE_STATUS                  0x8B80
#define GL_LINK_STATUS                    0x8B82
#define GL_VALIDATE_STATUS                0x8B83
#define GL_ATTACHED_SHADERS               0x8B85
#define GL_ACTIVE_UNIFORMS                0x8B86
#define GL_ACTIVE_UNIFORM_MAX_LENGTH      0x8B87
#define GL_ACTIVE_ATTRIBUTES              0x8B89
#define GL_ACTIVE_ATTRIBUTE_MAX_LENGTH    0x8B8A
#define GL_SHADING_LANGUAGE_VERSION       0x8B8C
#define GL_CURRENT_PROGRAM                0x8B8D
#define GL_NEVER                          0x0200
#define GL_LESS                           0x0201
#define GL_EQUAL                          0x0202
#define GL_LEQUAL                         0x0203
#define GL_GREATER                        0x0204
#define GL_NOTEQUAL                       0x0205
#define GL_GEQUAL                         0x0206
#define GL_ALWAYS                         0x0207
#define GL_KEEP                           0x1E00
#define GL_REPLACE                        0x1E01
#define GL_INCR                           0x1E02
#define GL_DECR                           0x1E03
#define GL_INVERT                         0x150A
#define GL_INCR_WRAP                      0x8507
#define GL_DECR_WRAP                      0x8508
#define GL_VENDOR                         0x1F00
#define GL_RENDERER                       0x1F01
#define GL_VERSION                        0x1F02
#define GL_EXTENSIONS                     0x1F03
#define GL_NEAREST                        0x2600
#define GL_LINEAR                         0x2601
#define GL_NEAREST_MIPMAP_NEAREST         0x2700
#define GL_LINEAR_MIPMAP_NEAREST          0x2701
#define GL_NEAREST_MIPMAP_LINEAR          0x2702
#define GL_LINEAR_MIPMAP_LINEAR           0x2703
#define GL_TEXTURE_MAG_FILTER             0x2800
#define GL_TEXTURE_MIN_FILTER             0x2801
#define GL_TEXTURE_WRAP_S                 0x2802
#define GL_TEXTURE_WRAP_T                 0x2803
#define GL_TEXTURE                        0x1702
#define GL_TEXTURE_CUBE_MAP               0x8513
#define GL_TEXTURE_BINDING_CUBE_MAP       0x8514
#define GL_TEXTURE_CUBE_MAP_POSITIVE_X    0x8515
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X    0x8516
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y    0x8517
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y    0x8518
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z    0x8519
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z    0x851A
#define GL_MAX_CUBE_MAP_TEXTURE_SIZE      0x851C
#define GL_TEXTURE0                       0x84C0
#define GL_TEXTURE1                       0x84C1
#define GL_TEXTURE2                       0x84C2
#define GL_TEXTURE3                       0x84C3
#define GL_TEXTURE4                       0x84C4
#define GL_TEXTURE5                       0x84C5
#define GL_TEXTURE6                       0x84C6
#define GL_TEXTURE7                       0x84C7
#define GL_TEXTURE8                       0x84C8
#define GL_TEXTURE9                       0x84C9
#define GL_TEXTURE10                      0x84CA
#define GL_TEXTURE11                      0x84CB
#define GL_TEXTURE12                      0x84CC
#define GL_TEXTURE13                      0x84CD
#define GL_TEXTURE14                      0x84CE
#define GL_TEXTURE15                      0x84CF
#define GL_TEXTURE16                      0x84D0
#define GL_TEXTURE17                      0x84D1
#define GL_TEXTURE18                      0x84D2
#define GL_TEXTURE19                      0x84D3
#define GL_TEXTURE20                      0x84D4
#define GL_TEXTURE21                      0x84D5
#define GL_TEXTURE22                      0x84D6
#define GL_TEXTURE23                      0x84D7
#define GL_TEXTURE24                      0x84D8
#define GL_TEXTURE25                      0x84D9
#define GL_TEXTURE26                      0x84DA
#define GL_TEXTURE27                      0x84DB
#define GL_TEXTURE28                      0x84DC
#define GL_TEXTURE29                      0x84DD
#define GL_TEXTURE30                      0x84DE
#define GL_TEXTURE31                      0x84DF
#define GL_ACTIVE_TEXTURE                 0x84E0
#define GL_REPEAT                         0x2901
#define GL_CLAMP_TO_EDGE                  0x812F
#define GL_MIRRORED_REPEAT                0x8370
#define GL_FLOAT_VEC2                     0x8B50
#define GL_FLOAT_VEC3                     0x8B51
#define GL_FLOAT_VEC4                     0x8B52
#define GL_INT_VEC2                       0x8B53
#define GL_INT_VEC3                       0x8B54
#define GL_INT_VEC4                       0x8B55
#define GL_BOOL                           0x8B56
#define GL_BOOL_VEC2                      0x8B57
#define GL_BOOL_VEC3                      0x8B58
#define GL_BOOL_VEC4                      0x8B59
#define GL_FLOAT_MAT2                     0x8B5A
#define GL_FLOAT_MAT3                     0x8B5B
#define GL_FLOAT_MAT4                     0x8B5C
#define GL_SAMPLER_2D                     0x8B5E
#define GL_SAMPLER_CUBE                   0x8B60
#define GL_VERTEX_ATTRIB_ARRAY_ENABLED    0x8622
#define GL_VERTEX_ATTRIB_ARRAY_SIZE       0x8623
#define GL_VERTEX_ATTRIB_ARRAY_STRIDE     0x8624
#define GL_VERTEX_ATTRIB_ARRAY_TYPE       0x8625
#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED 0x886A
#define GL_VERTEX_ATTRIB_ARRAY_POINTER    0x8645
#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING 0x889F
#define GL_IMPLEMENTATION_COLOR_READ_TYPE 0x8B9A
#define GL_IMPLEMENTATION_COLOR_READ_FORMAT 0x8B9B
#define GL_COMPILE_STATUS                 0x8B81
#define GL_INFO_LOG_LENGTH                0x8B84
#define GL_SHADER_SOURCE_LENGTH           0x8B88
#define GL_SHADER_COMPILER                0x8DFA
#define GL_SHADER_BINARY_FORMATS          0x8DF8
#define GL_NUM_SHADER_BINARY_FORMATS      0x8DF9
#define GL_LOW_FLOAT                      0x8DF0
#define GL_MEDIUM_FLOAT                   0x8DF1
#define GL_HIGH_FLOAT                     0x8DF2
#define GL_LOW_INT                        0x8DF3
#define GL_MEDIUM_INT                     0x8DF4
#define GL_HIGH_INT                       0x8DF5
#define GL_FRAMEBUFFER                    0x8D40
#define GL_RENDERBUFFER                   0x8D41
#define GL_RGBA4                          0x8056
#define GL_RGB5_A1                        0x8057
#define GL_RGB565                         0x8D62
#define GL_DEPTH_COMPONENT16              0x81A5
#define GL_STENCIL_INDEX8                 0x8D48
#define GL_RENDERBUFFER_WIDTH             0x8D42
#define GL_RENDERBUFFER_HEIGHT            0x8D43
#define GL_RENDERBUFFER_INTERNAL_FORMAT   0x8D44
#define GL_RENDERBUFFER_RED_SIZE          0x8D50
#define GL_RENDERBUFFER_GREEN_SIZE        0x8D51
#define GL_RENDERBUFFER_BLUE_SIZE         0x8D52
#define GL_RENDERBUFFER_ALPHA_SIZE        0x8D53
#define GL_RENDERBUFFER_DEPTH_SIZE        0x8D54
#define GL_RENDERBUFFER_STENCIL_SIZE      0x8D55
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE 0x8CD0
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME 0x8CD1
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL 0x8CD2
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE 0x8CD3
#define GL_COLOR_ATTACHMENT0              0x8CE0
#define GL_DEPTH_ATTACHMENT               0x8D00
#define GL_STENCIL_ATTACHMENT             0x8D20
#define GL_NONE                           0
#define GL_FRAMEBUFFER_COMPLETE           0x8CD5
#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT 0x8CD6
#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT 0x8CD7
#define GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS 0x8CD9
#define GL_FRAMEBUFFER_UNSUPPORTED        0x8CDD
#define GL_FRAMEBUFFER_BINDING            0x8CA6
#define GL_RENDERBUFFER_BINDING           0x8CA7
#define GL_MAX_RENDERBUFFER_SIZE          0x84E8
#define GL_INVALID_FRAMEBUFFER_OPERATION  0x0506
typedef void (GL_APIENTRYP PFNGLACTIVETEXTUREPROC) (GLenum texture);
typedef void (GL_APIENTRYP PFNGLATTACHSHADERPROC) (GLuint program, GLuint shader);
typedef void (GL_APIENTRYP PFNGLBINDATTRIBLOCATIONPROC) (GLuint program, GLuint index, const GLchar *name);
typedef void (GL_APIENTRYP PFNGLBINDBUFFERPROC) (GLenum target, GLuint buffer);
typedef void (GL_APIENTRYP PFNGLBINDFRAMEBUFFERPROC) (GLenum target, GLuint framebuffer);
typedef void (GL_APIENTRYP PFNGLBINDRENDERBUFFERPROC) (GLenum target, GLuint renderbuffer);
typedef void (GL_APIENTRYP PFNGLBINDTEXTUREPROC) (GLenum target, GLuint texture);
typedef void (GL_APIENTRYP PFNGLBLENDCOLORPROC) (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
typedef void (GL_APIENTRYP PFNGLBLENDEQUATIONPROC) (GLenum mode);
typedef void (GL_APIENTRYP PFNGLBLENDEQUATIONSEPARATEPROC) (GLenum modeRGB, GLenum modeAlpha);
typedef void (GL_APIENTRYP PFNGLBLENDFUNCPROC) (GLenum sfactor, GLenum dfactor);
typedef void (GL_APIENTRYP PFNGLBLENDFUNCSEPARATEPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
typedef void (GL_APIENTRYP PFNGLBUFFERDATAPROC) (GLenum target, GLsizeiptr size, const void *data, GLenum usage);
typedef void (GL_APIENTRYP PFNGLBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, const void *data);
typedef GLenum (GL_APIENTRYP PFNGLCHECKFRAMEBUFFERSTATUSPROC) (GLenum target);
typedef void (GL_APIENTRYP PFNGLCLEARPROC) (GLbitfield mask);
typedef void (GL_APIENTRYP PFNGLCLEARCOLORPROC) (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
typedef void (GL_APIENTRYP PFNGLCLEARDEPTHFPROC) (GLfloat d);
typedef void (GL_APIENTRYP PFNGLCLEARSTENCILPROC) (GLint s);
typedef void (GL_APIENTRYP PFNGLCOLORMASKPROC) (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
typedef void (GL_APIENTRYP PFNGLCOMPILESHADERPROC) (GLuint shader);
typedef void (GL_APIENTRYP PFNGLCOMPRESSEDTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
typedef void (GL_APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void (GL_APIENTRYP PFNGLCOPYTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void (GL_APIENTRYP PFNGLCOPYTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef GLuint (GL_APIENTRYP PFNGLCREATEPROGRAMPROC) (void);
typedef GLuint (GL_APIENTRYP PFNGLCREATESHADERPROC) (GLenum type);
typedef void (GL_APIENTRYP PFNGLCULLFACEPROC) (GLenum mode);
typedef void (GL_APIENTRYP PFNGLDELETEBUFFERSPROC) (GLsizei n, const GLuint *buffers);
typedef void (GL_APIENTRYP PFNGLDELETEFRAMEBUFFERSPROC) (GLsizei n, const GLuint *framebuffers);
typedef void (GL_APIENTRYP PFNGLDELETEPROGRAMPROC) (GLuint program);
typedef void (GL_APIENTRYP PFNGLDELETERENDERBUFFERSPROC) (GLsizei n, const GLuint *renderbuffers);
typedef void (GL_APIENTRYP PFNGLDELETESHADERPROC) (GLuint shader);
typedef void (GL_APIENTRYP PFNGLDELETETEXTURESPROC) (GLsizei n, const GLuint *textures);
typedef void (GL_APIENTRYP PFNGLDEPTHFUNCPROC) (GLenum func);
typedef void (GL_APIENTRYP PFNGLDEPTHMASKPROC) (GLboolean flag);
typedef void (GL_APIENTRYP PFNGLDEPTHRANGEFPROC) (GLfloat n, GLfloat f);
typedef void (GL_APIENTRYP PFNGLDETACHSHADERPROC) (GLuint program, GLuint shader);
typedef void (GL_APIENTRYP PFNGLDISABLEPROC) (GLenum cap);
typedef void (GL_APIENTRYP PFNGLDISABLEVERTEXATTRIBARRAYPROC) (GLuint index);
typedef void (GL_APIENTRYP PFNGLDRAWARRAYSPROC) (GLenum mode, GLint first, GLsizei count);
typedef void (GL_APIENTRYP PFNGLDRAWELEMENTSPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices);
typedef void (GL_APIENTRYP PFNGLENABLEPROC) (GLenum cap);
typedef void (GL_APIENTRYP PFNGLENABLEVERTEXATTRIBARRAYPROC) (GLuint index);
typedef void (GL_APIENTRYP PFNGLFINISHPROC) (void);
typedef void (GL_APIENTRYP PFNGLFLUSHPROC) (void);
typedef void (GL_APIENTRYP PFNGLFRAMEBUFFERRENDERBUFFERPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (GL_APIENTRYP PFNGLFRAMEBUFFERTEXTURE2DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (GL_APIENTRYP PFNGLFRONTFACEPROC) (GLenum mode);
typedef void (GL_APIENTRYP PFNGLGENBUFFERSPROC) (GLsizei n, GLuint *buffers);
typedef void (GL_APIENTRYP PFNGLGENERATEMIPMAPPROC) (GLenum target);
typedef void (GL_APIENTRYP PFNGLGENFRAMEBUFFERSPROC) (GLsizei n, GLuint *framebuffers);
typedef void (GL_APIENTRYP PFNGLGENRENDERBUFFERSPROC) (GLsizei n, GLuint *renderbuffers);
typedef void (GL_APIENTRYP PFNGLGENTEXTURESPROC) (GLsizei n, GLuint *textures);
typedef void (GL_APIENTRYP PFNGLGETACTIVEATTRIBPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
typedef void (GL_APIENTRYP PFNGLGETACTIVEUNIFORMPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
typedef void (GL_APIENTRYP PFNGLGETATTACHEDSHADERSPROC) (GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders);
typedef GLint (GL_APIENTRYP PFNGLGETATTRIBLOCATIONPROC) (GLuint program, const GLchar *name);
typedef void (GL_APIENTRYP PFNGLGETBOOLEANVPROC) (GLenum pname, GLboolean *data);
typedef void (GL_APIENTRYP PFNGLGETBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef GLenum (GL_APIENTRYP PFNGLGETERRORPROC) (void);
typedef void (GL_APIENTRYP PFNGLGETFLOATVPROC) (GLenum pname, GLfloat *data);
typedef void (GL_APIENTRYP PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC) (GLenum target, GLenum attachment, GLenum pname, GLint *params);
typedef void (GL_APIENTRYP PFNGLGETINTEGERVPROC) (GLenum pname, GLint *data);
typedef void (GL_APIENTRYP PFNGLGETPROGRAMIVPROC) (GLuint program, GLenum pname, GLint *params);
typedef void (GL_APIENTRYP PFNGLGETPROGRAMINFOLOGPROC) (GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
typedef void (GL_APIENTRYP PFNGLGETRENDERBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (GL_APIENTRYP PFNGLGETSHADERIVPROC) (GLuint shader, GLenum pname, GLint *params);
typedef void (GL_APIENTRYP PFNGLGETSHADERINFOLOGPROC) (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
typedef void (GL_APIENTRYP PFNGLGETSHADERPRECISIONFORMATPROC) (GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision);
typedef void (GL_APIENTRYP PFNGLGETSHADERSOURCEPROC) (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);
typedef const GLubyte *(GL_APIENTRYP PFNGLGETSTRINGPROC) (GLenum name);
typedef void (GL_APIENTRYP PFNGLGETTEXPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void (GL_APIENTRYP PFNGLGETTEXPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (GL_APIENTRYP PFNGLGETUNIFORMFVPROC) (GLuint program, GLint location, GLfloat *params);
typedef void (GL_APIENTRYP PFNGLGETUNIFORMIVPROC) (GLuint program, GLint location, GLint *params);
typedef GLint (GL_APIENTRYP PFNGLGETUNIFORMLOCATIONPROC) (GLuint program, const GLchar *name);
typedef void (GL_APIENTRYP PFNGLGETVERTEXATTRIBFVPROC) (GLuint index, GLenum pname, GLfloat *params);
typedef void (GL_APIENTRYP PFNGLGETVERTEXATTRIBIVPROC) (GLuint index, GLenum pname, GLint *params);
typedef void (GL_APIENTRYP PFNGLGETVERTEXATTRIBPOINTERVPROC) (GLuint index, GLenum pname, void **pointer);
typedef void (GL_APIENTRYP PFNGLHINTPROC) (GLenum target, GLenum mode);
typedef GLboolean (GL_APIENTRYP PFNGLISBUFFERPROC) (GLuint buffer);
typedef GLboolean (GL_APIENTRYP PFNGLISENABLEDPROC) (GLenum cap);
typedef GLboolean (GL_APIENTRYP PFNGLISFRAMEBUFFERPROC) (GLuint framebuffer);
typedef GLboolean (GL_APIENTRYP PFNGLISPROGRAMPROC) (GLuint program);
typedef GLboolean (GL_APIENTRYP PFNGLISRENDERBUFFERPROC) (GLuint renderbuffer);
typedef GLboolean (GL_APIENTRYP PFNGLISSHADERPROC) (GLuint shader);
typedef GLboolean (GL_APIENTRYP PFNGLISTEXTUREPROC) (GLuint texture);
typedef void (GL_APIENTRYP PFNGLLINEWIDTHPROC) (GLfloat width);
typedef void (GL_APIENTRYP PFNGLLINKPROGRAMPROC) (GLuint program);
typedef void (GL_APIENTRYP PFNGLPIXELSTOREIPROC) (GLenum pname, GLint param);
typedef void (GL_APIENTRYP PFNGLPOLYGONOFFSETPROC) (GLfloat factor, GLfloat units);
typedef void (GL_APIENTRYP PFNGLREADPIXELSPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void *pixels);
typedef void (GL_APIENTRYP PFNGLRELEASESHADERCOMPILERPROC) (void);
typedef void (GL_APIENTRYP PFNGLRENDERBUFFERSTORAGEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GL_APIENTRYP PFNGLSAMPLECOVERAGEPROC) (GLfloat value, GLboolean invert);
typedef void (GL_APIENTRYP PFNGLSCISSORPROC) (GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GL_APIENTRYP PFNGLSHADERBINARYPROC) (GLsizei count, const GLuint *shaders, GLenum binaryformat, const void *binary, GLsizei length);
typedef void (GL_APIENTRYP PFNGLSHADERSOURCEPROC) (GLuint shader, GLsizei count, const GLchar *const*string, const GLint *length);
typedef void (GL_APIENTRYP PFNGLSTENCILFUNCPROC) (GLenum func, GLint ref, GLuint mask);
typedef void (GL_APIENTRYP PFNGLSTENCILFUNCSEPARATEPROC) (GLenum face, GLenum func, GLint ref, GLuint mask);
typedef void (GL_APIENTRYP PFNGLSTENCILMASKPROC) (GLuint mask);
typedef void (GL_APIENTRYP PFNGLSTENCILMASKSEPARATEPROC) (GLenum face, GLuint mask);
typedef void (GL_APIENTRYP PFNGLSTENCILOPPROC) (GLenum fail, GLenum zfail, GLenum zpass);
typedef void (GL_APIENTRYP PFNGLSTENCILOPSEPARATEPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
typedef void (GL_APIENTRYP PFNGLTEXIMAGE2DPROC) (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (GL_APIENTRYP PFNGLTEXPARAMETERFPROC) (GLenum target, GLenum pname, GLfloat param);
typedef void (GL_APIENTRYP PFNGLTEXPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void (GL_APIENTRYP PFNGLTEXPARAMETERIPROC) (GLenum target, GLenum pname, GLint param);
typedef void (GL_APIENTRYP PFNGLTEXPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void (GL_APIENTRYP PFNGLTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
typedef void (GL_APIENTRYP PFNGLUNIFORM1FPROC) (GLint location, GLfloat v0);
typedef void (GL_APIENTRYP PFNGLUNIFORM1FVPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLUNIFORM1IPROC) (GLint location, GLint v0);
typedef void (GL_APIENTRYP PFNGLUNIFORM1IVPROC) (GLint location, GLsizei count, const GLint *value);
typedef void (GL_APIENTRYP PFNGLUNIFORM2FPROC) (GLint location, GLfloat v0, GLfloat v1);
typedef void (GL_APIENTRYP PFNGLUNIFORM2FVPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLUNIFORM2IPROC) (GLint location, GLint v0, GLint v1);
typedef void (GL_APIENTRYP PFNGLUNIFORM2IVPROC) (GLint location, GLsizei count, const GLint *value);
typedef void (GL_APIENTRYP PFNGLUNIFORM3FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (GL_APIENTRYP PFNGLUNIFORM3FVPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLUNIFORM3IPROC) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void (GL_APIENTRYP PFNGLUNIFORM3IVPROC) (GLint location, GLsizei count, const GLint *value);
typedef void (GL_APIENTRYP PFNGLUNIFORM4FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (GL_APIENTRYP PFNGLUNIFORM4FVPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLUNIFORM4IPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (GL_APIENTRYP PFNGLUNIFORM4IVPROC) (GLint location, GLsizei count, const GLint *value);
typedef void (GL_APIENTRYP PFNGLUNIFORMMATRIX2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLUNIFORMMATRIX3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLUNIFORMMATRIX4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLUSEPROGRAMPROC) (GLuint program);
typedef void (GL_APIENTRYP PFNGLVALIDATEPROGRAMPROC) (GLuint program);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIB1FPROC) (GLuint index, GLfloat x);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIB1FVPROC) (GLuint index, const GLfloat *v);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIB2FPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIB2FVPROC) (GLuint index, const GLfloat *v);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIB3FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIB3FVPROC) (GLuint index, const GLfloat *v);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIB4FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIB4FVPROC) (GLuint index, const GLfloat *v);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIBPOINTERPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer);
typedef void (GL_APIENTRYP PFNGLVIEWPORTPROC) (GLint x, GLint y, GLsizei width, GLsizei height);
#if GL_GLES_PROTOTYPES
GL_APICALL void GL_APIENTRY glActiveTexture (GLenum texture);
GL_APICALL void GL_APIENTRY glAttachShader (GLuint program, GLuint shader);
GL_APICALL void GL_APIENTRY glBindAttribLocation (GLuint program, GLuint index, const GLchar *name);
GL_APICALL void GL_APIENTRY glBindBuffer (GLenum target, GLuint buffer);
GL_APICALL void GL_APIENTRY glBindFramebuffer (GLenum target, GLuint framebuffer);
GL_APICALL void GL_APIENTRY glBindRenderbuffer (GLenum target, GLuint renderbuffer);
GL_APICALL void GL_APIENTRY glBindTexture (GLenum target, GLuint texture);
GL_APICALL void GL_APIENTRY glBlendColor (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
GL_APICALL void GL_APIENTRY glBlendEquation (GLenum mode);
GL_APICALL void GL_APIENTRY glBlendEquationSeparate (GLenum modeRGB, GLenum modeAlpha);
GL_APICALL void GL_APIENTRY glBlendFunc (GLenum sfactor, GLenum dfactor);
GL_APICALL void GL_APIENTRY glBlendFuncSeparate (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
GL_APICALL void GL_APIENTRY glBufferData (GLenum target, GLsizeiptr size, const void *data, GLenum usage);
GL_APICALL void GL_APIENTRY glBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, const void *data);
GL_APICALL GLenum GL_APIENTRY glCheckFramebufferStatus (GLenum target);
GL_APICALL void GL_APIENTRY glClear (GLbitfield mask);
GL_APICALL void GL_APIENTRY glClearColor (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
GL_APICALL void GL_APIENTRY glClearDepthf (GLfloat d);
GL_APICALL void GL_APIENTRY glClearStencil (GLint s);
GL_APICALL void GL_APIENTRY glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
GL_APICALL void GL_APIENTRY glCompileShader (GLuint shader);
GL_APICALL void GL_APIENTRY glCompressedTexImage2D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
GL_APICALL void GL_APIENTRY glCompressedTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
GL_APICALL void GL_APIENTRY glCopyTexImage2D (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
GL_APICALL void GL_APIENTRY glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
GL_APICALL GLuint GL_APIENTRY glCreateProgram (void);
GL_APICALL GLuint GL_APIENTRY glCreateShader (GLenum type);
GL_APICALL void GL_APIENTRY glCullFace (GLenum mode);
GL_APICALL void GL_APIENTRY glDeleteBuffers (GLsizei n, const GLuint *buffers);
GL_APICALL void GL_APIENTRY glDeleteFramebuffers (GLsizei n, const GLuint *framebuffers);
GL_APICALL void GL_APIENTRY glDeleteProgram (GLuint program);
GL_APICALL void GL_APIENTRY glDeleteRenderbuffers (GLsizei n, const GLuint *renderbuffers);
GL_APICALL void GL_APIENTRY glDeleteShader (GLuint shader);
GL_APICALL void GL_APIENTRY glDeleteTextures (GLsizei n, const GLuint *textures);
GL_APICALL void GL_APIENTRY glDepthFunc (GLenum func);
GL_APICALL void GL_APIENTRY glDepthMask (GLboolean flag);
GL_APICALL void GL_APIENTRY glDepthRangef (GLfloat n, GLfloat f);
GL_APICALL void GL_APIENTRY glDetachShader (GLuint program, GLuint shader);
GL_APICALL void GL_APIENTRY glDisable (GLenum cap);
GL_APICALL void GL_APIENTRY glDisableVertexAttribArray (GLuint index);
GL_APICALL void GL_APIENTRY glDrawArrays (GLenum mode, GLint first, GLsizei count);
GL_APICALL void GL_APIENTRY glDrawElements (GLenum mode, GLsizei count, GLenum type, const void *indices);
GL_APICALL void GL_APIENTRY glEnable (GLenum cap);
GL_APICALL void GL_APIENTRY glEnableVertexAttribArray (GLuint index);
GL_APICALL void GL_APIENTRY glFinish (void);
GL_APICALL void GL_APIENTRY glFlush (void);
GL_APICALL void GL_APIENTRY glFramebufferRenderbuffer (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
GL_APICALL void GL_APIENTRY glFramebufferTexture2D (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
GL_APICALL void GL_APIENTRY glFrontFace (GLenum mode);
GL_APICALL void GL_APIENTRY glGenBuffers (GLsizei n, GLuint *buffers);
GL_APICALL void GL_APIENTRY glGenerateMipmap (GLenum target);
GL_APICALL void GL_APIENTRY glGenFramebuffers (GLsizei n, GLuint *framebuffers);
GL_APICALL void GL_APIENTRY glGenRenderbuffers (GLsizei n, GLuint *renderbuffers);
GL_APICALL void GL_APIENTRY glGenTextures (GLsizei n, GLuint *textures);
GL_APICALL void GL_APIENTRY glGetActiveAttrib (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
GL_APICALL void GL_APIENTRY glGetActiveUniform (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
GL_APICALL void GL_APIENTRY glGetAttachedShaders (GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders);
GL_APICALL GLint GL_APIENTRY glGetAttribLocation (GLuint program, const GLchar *name);
GL_APICALL void GL_APIENTRY glGetBooleanv (GLenum pname, GLboolean *data);
GL_APICALL void GL_APIENTRY glGetBufferParameteriv (GLenum target, GLenum pname, GLint *params);
GL_APICALL GLenum GL_APIENTRY glGetError (void);
GL_APICALL void GL_APIENTRY glGetFloatv (GLenum pname, GLfloat *data);
GL_APICALL void GL_APIENTRY glGetFramebufferAttachmentParameteriv (GLenum target, GLenum attachment, GLenum pname, GLint *params);
GL_APICALL void GL_APIENTRY glGetIntegerv (GLenum pname, GLint *data);
GL_APICALL void GL_APIENTRY glGetProgramiv (GLuint program, GLenum pname, GLint *params);
GL_APICALL void GL_APIENTRY glGetProgramInfoLog (GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
GL_APICALL void GL_APIENTRY glGetRenderbufferParameteriv (GLenum target, GLenum pname, GLint *params);
GL_APICALL void GL_APIENTRY glGetShaderiv (GLuint shader, GLenum pname, GLint *params);
GL_APICALL void GL_APIENTRY glGetShaderInfoLog (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
GL_APICALL void GL_APIENTRY glGetShaderPrecisionFormat (GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision);
GL_APICALL void GL_APIENTRY glGetShaderSource (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);
GL_APICALL const GLubyte *GL_APIENTRY glGetString (GLenum name);
GL_APICALL void GL_APIENTRY glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
GL_APICALL void GL_APIENTRY glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
GL_APICALL void GL_APIENTRY glGetUniformfv (GLuint program, GLint location, GLfloat *params);
GL_APICALL void GL_APIENTRY glGetUniformiv (GLuint program, GLint location, GLint *params);
GL_APICALL GLint GL_APIENTRY glGetUniformLocation (GLuint program, const GLchar *name);
GL_APICALL void GL_APIENTRY glGetVertexAttribfv (GLuint index, GLenum pname, GLfloat *params);
GL_APICALL void GL_APIENTRY glGetVertexAttribiv (GLuint index, GLenum pname, GLint *params);
GL_APICALL void GL_APIENTRY glGetVertexAttribPointerv (GLuint index, GLenum pname, void **pointer);
GL_APICALL void GL_APIENTRY glHint (GLenum target, GLenum mode);
GL_APICALL GLboolean GL_APIENTRY glIsBuffer (GLuint buffer);
GL_APICALL GLboolean GL_APIENTRY glIsEnabled (GLenum cap);
GL_APICALL GLboolean GL_APIENTRY glIsFramebuffer (GLuint framebuffer);
GL_APICALL GLboolean GL_APIENTRY glIsProgram (GLuint program);
GL_APICALL GLboolean GL_APIENTRY glIsRenderbuffer (GLuint renderbuffer);
GL_APICALL GLboolean GL_APIENTRY glIsShader (GLuint shader);
GL_APICALL GLboolean GL_APIENTRY glIsTexture (GLuint texture);
GL_APICALL void GL_APIENTRY glLineWidth (GLfloat width);
GL_APICALL void GL_APIENTRY glLinkProgram (GLuint program);
GL_APICALL void GL_APIENTRY glPixelStorei (GLenum pname, GLint param);
GL_APICALL void GL_APIENTRY glPolygonOffset (GLfloat factor, GLfloat units);
GL_APICALL void GL_APIENTRY glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void *pixels);
GL_APICALL void GL_APIENTRY glReleaseShaderCompiler (void);
GL_APICALL void GL_APIENTRY glRenderbufferStorage (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
GL_APICALL void GL_APIENTRY glSampleCoverage (GLfloat value, GLboolean invert);
GL_APICALL void GL_APIENTRY glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
GL_APICALL void GL_APIENTRY glShaderBinary (GLsizei count, const GLuint *shaders, GLenum binaryformat, const void *binary, GLsizei length);
GL_APICALL void GL_APIENTRY glShaderSource (GLuint shader, GLsizei count, const GLchar *const*string, const GLint *length);
GL_APICALL void GL_APIENTRY glStencilFunc (GLenum func, GLint ref, GLuint mask);
GL_APICALL void GL_APIENTRY glStencilFuncSeparate (GLenum face, GLenum func, GLint ref, GLuint mask);
GL_APICALL void GL_APIENTRY glStencilMask (GLuint mask);
GL_APICALL void GL_APIENTRY glStencilMaskSeparate (GLenum face, GLuint mask);
GL_APICALL void GL_APIENTRY glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
GL_APICALL void GL_APIENTRY glStencilOpSeparate (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
GL_APICALL void GL_APIENTRY glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
GL_APICALL void GL_APIENTRY glTexParameterf (GLenum target, GLenum pname, GLfloat param);
GL_APICALL void GL_APIENTRY glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
GL_APICALL void GL_APIENTRY glTexParameteri (GLenum target, GLenum pname, GLint param);
GL_APICALL void GL_APIENTRY glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
GL_APICALL void GL_APIENTRY glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
GL_APICALL void GL_APIENTRY glUniform1f (GLint location, GLfloat v0);
GL_APICALL void GL_APIENTRY glUniform1fv (GLint location, GLsizei count, const GLfloat *value);
GL_APICALL void GL_APIENTRY glUniform1i (GLint location, GLint v0);
GL_APICALL void GL_APIENTRY glUniform1iv (GLint location, GLsizei count, const GLint *value);
GL_APICALL void GL_APIENTRY glUniform2f (GLint location, GLfloat v0, GLfloat v1);
GL_APICALL void GL_APIENTRY glUniform2fv (GLint location, GLsizei count, const GLfloat *value);
GL_APICALL void GL_APIENTRY glUniform2i (GLint location, GLint v0, GLint v1);
GL_APICALL void GL_APIENTRY glUniform2iv (GLint location, GLsizei count, const GLint *value);
GL_APICALL void GL_APIENTRY glUniform3f (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
GL_APICALL void GL_APIENTRY glUniform3fv (GLint location, GLsizei count, const GLfloat *value);
GL_APICALL void GL_APIENTRY glUniform3i (GLint location, GLint v0, GLint v1, GLint v2);
GL_APICALL void GL_APIENTRY glUniform3iv (GLint location, GLsizei count, const GLint *value);
GL_APICALL void GL_APIENTRY glUniform4f (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
GL_APICALL void GL_APIENTRY glUniform4fv (GLint location, GLsizei count, const GLfloat *value);
GL_APICALL void GL_APIENTRY glUniform4i (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
GL_APICALL void GL_APIENTRY glUniform4iv (GLint location, GLsizei count, const GLint *value);
GL_APICALL void GL_APIENTRY glUniformMatrix2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_APICALL void GL_APIENTRY glUniformMatrix3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_APICALL void GL_APIENTRY glUniformMatrix4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_APICALL void GL_APIENTRY glUseProgram (GLuint program);
GL_APICALL void GL_APIENTRY glValidateProgram (GLuint program);
GL_APICALL void GL_APIENTRY glVertexAttrib1f (GLuint index, GLfloat x);
GL_APICALL void GL_APIENTRY glVertexAttrib1fv (GLuint index, const GLfloat *v);
GL_APICALL void GL_APIENTRY glVertexAttrib2f (GLuint index, GLfloat x, GLfloat y);
GL_APICALL void GL_APIENTRY glVertexAttrib2fv (GLuint index, const GLfloat *v);
GL_APICALL void GL_APIENTRY glVertexAttrib3f (GLuint index, GLfloat x, GLfloat y, GLfloat z);
GL_APICALL void GL_APIENTRY glVertexAttrib3fv (GLuint index, const GLfloat *v);
GL_APICALL void GL_APIENTRY glVertexAttrib4f (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
GL_APICALL void GL_APIENTRY glVertexAttrib4fv (GLuint index, const GLfloat *v);
GL_APICALL void GL_APIENTRY glVertexAttribPointer (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer);
GL_APICALL void GL_APIENTRY glViewport (GLint x, GLint y, GLsizei width, GLsizei height);
#endif
#endif /* GL_ES_VERSION_2_0 */

#ifndef GL_ES_VERSION_3_0
#define GL_ES_VERSION_3_0 1
typedef unsigned short GLhalf;
#define GL_READ_BUFFER                    0x0C02
#define GL_UNPACK_ROW_LENGTH              0x0CF2
#define GL_UNPACK_SKIP_ROWS               0x0CF3
#define GL_UNPACK_SKIP_PIXELS             0x0CF4
#define GL_PACK_ROW_LENGTH                0x0D02
#define GL_PACK_SKIP_ROWS                 0x0D03
#define GL_PACK_SKIP_PIXELS               0x0D04
#define GL_COLOR                          0x1800
#define GL_DEPTH                          0x1801
#define GL_STENCIL                        0x1802
#define GL_RED                            0x1903
#define GL_RGB8                           0x8051
#define GL_RGBA8                          0x8058
#define GL_RGB10_A2                       0x8059
#define GL_TEXTURE_BINDING_3D             0x806A
#define GL_UNPACK_SKIP_IMAGES             0x806D
#define GL_UNPACK_IMAGE_HEIGHT            0x806E
#define GL_TEXTURE_3D                     0x806F
#define GL_TEXTURE_WRAP_R                 0x8072
#define GL_MAX_3D_TEXTURE_SIZE            0x8073
#define GL_UNSIGNED_INT_2_10_10_10_REV    0x8368
#define GL_MAX_ELEMENTS_VERTICES          0x80E8
#define GL_MAX_ELEMENTS_INDICES           0x80E9
#define GL_TEXTURE_MIN_LOD                0x813A
#define GL_TEXTURE_MAX_LOD                0x813B
#define GL_TEXTURE_BASE_LEVEL             0x813C
#define GL_TEXTURE_MAX_LEVEL              0x813D
#define GL_MIN                            0x8007
#define GL_MAX                            0x8008
#define GL_DEPTH_COMPONENT24              0x81A6
#define GL_MAX_TEXTURE_LOD_BIAS           0x84FD
#define GL_TEXTURE_COMPARE_MODE           0x884C
#define GL_TEXTURE_COMPARE_FUNC           0x884D
#define GL_CURRENT_QUERY                  0x8865
#define GL_QUERY_RESULT                   0x8866
#define GL_QUERY_RESULT_AVAILABLE         0x8867
#define GL_BUFFER_MAPPED                  0x88BC
#define GL_BUFFER_MAP_POINTER             0x88BD
#define GL_STREAM_READ                    0x88E1
#define GL_STREAM_COPY                    0x88E2
#define GL_STATIC_READ                    0x88E5
#define GL_STATIC_COPY                    0x88E6
#define GL_DYNAMIC_READ                   0x88E9
#define GL_DYNAMIC_COPY                   0x88EA
#define GL_MAX_DRAW_BUFFERS               0x8824
#define GL_DRAW_BUFFER0                   0x8825
#define GL_DRAW_BUFFER1                   0x8826
#define GL_DRAW_BUFFER2                   0x8827
#define GL_DRAW_BUFFER3                   0x8828
#define GL_DRAW_BUFFER4                   0x8829
#define GL_DRAW_BUFFER5                   0x882A
#define GL_DRAW_BUFFER6                   0x882B
#define GL_DRAW_BUFFER7                   0x882C
#define GL_DRAW_BUFFER8                   0x882D
#define GL_DRAW_BUFFER9                   0x882E
#define GL_DRAW_BUFFER10                  0x882F
#define GL_DRAW_BUFFER11                  0x8830
#define GL_DRAW_BUFFER12                  0x8831
#define GL_DRAW_BUFFER13                  0x8832
#define GL_DRAW_BUFFER14                  0x8833
#define GL_DRAW_BUFFER15                  0x8834
#define GL_MAX_FRAGMENT_UNIFORM_COMPONENTS 0x8B49
#define GL_MAX_VERTEX_UNIFORM_COMPONENTS  0x8B4A
#define GL_SAMPLER_3D                     0x8B5F
#define GL_SAMPLER_2D_SHADOW              0x8B62
#define GL_FRAGMENT_SHADER_DERIVATIVE_HINT 0x8B8B
#define GL_PIXEL_PACK_BUFFER              0x88EB
#define GL_PIXEL_UNPACK_BUFFER            0x88EC
#define GL_PIXEL_PACK_BUFFER_BINDING      0x88ED
#define GL_PIXEL_UNPACK_BUFFER_BINDING    0x88EF
#define GL_FLOAT_MAT2x3                   0x8B65
#define GL_FLOAT_MAT2x4                   0x8B66
#define GL_FLOAT_MAT3x2                   0x8B67
#define GL_FLOAT_MAT3x4                   0x8B68
#define GL_FLOAT_MAT4x2                   0x8B69
#define GL_FLOAT_MAT4x3                   0x8B6A
#define GL_SRGB                           0x8C40
#define GL_SRGB8                          0x8C41
#define GL_SRGB8_ALPHA8                   0x8C43
#define GL_COMPARE_REF_TO_TEXTURE         0x884E
#define GL_MAJOR_VERSION                  0x821B
#define GL_MINOR_VERSION                  0x821C
#define GL_NUM_EXTENSIONS                 0x821D
#define GL_RGBA32F                        0x8814
#define GL_RGB32F                         0x8815
#define GL_RGBA16F                        0x881A
#define GL_RGB16F                         0x881B
#define GL_VERTEX_ATTRIB_ARRAY_INTEGER    0x88FD
#define GL_MAX_ARRAY_TEXTURE_LAYERS       0x88FF
#define GL_MIN_PROGRAM_TEXEL_OFFSET       0x8904
#define GL_MAX_PROGRAM_TEXEL_OFFSET       0x8905
#define GL_MAX_VARYING_COMPONENTS         0x8B4B
#define GL_TEXTURE_2D_ARRAY               0x8C1A
#define GL_TEXTURE_BINDING_2D_ARRAY       0x8C1D
#define GL_R11F_G11F_B10F                 0x8C3A
#define GL_UNSIGNED_INT_10F_11F_11F_REV   0x8C3B
#define GL_RGB9_E5                        0x8C3D
#define GL_UNSIGNED_INT_5_9_9_9_REV       0x8C3E
#define GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH 0x8C76
#define GL_TRANSFORM_FEEDBACK_BUFFER_MODE 0x8C7F
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS 0x8C80
#define GL_TRANSFORM_FEEDBACK_VARYINGS    0x8C83
#define GL_TRANSFORM_FEEDBACK_BUFFER_START 0x8C84
#define GL_TRANSFORM_FEEDBACK_BUFFER_SIZE 0x8C85
#define GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN 0x8C88
#define GL_RASTERIZER_DISCARD             0x8C89
#define GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS 0x8C8A
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS 0x8C8B
#define GL_INTERLEAVED_ATTRIBS            0x8C8C
#define GL_SEPARATE_ATTRIBS               0x8C8D
#define GL_TRANSFORM_FEEDBACK_BUFFER      0x8C8E
#define GL_TRANSFORM_FEEDBACK_BUFFER_BINDING 0x8C8F
#define GL_RGBA32UI                       0x8D70
#define GL_RGB32UI                        0x8D71
#define GL_RGBA16UI                       0x8D76
#define GL_RGB16UI                        0x8D77
#define GL_RGBA8UI                        0x8D7C
#define GL_RGB8UI                         0x8D7D
#define GL_RGBA32I                        0x8D82
#define GL_RGB32I                         0x8D83
#define GL_RGBA16I                        0x8D88
#define GL_RGB16I                         0x8D89
#define GL_RGBA8I                         0x8D8E
#define GL_RGB8I                          0x8D8F
#define GL_RED_INTEGER                    0x8D94
#define GL_RGB_INTEGER                    0x8D98
#define GL_RGBA_INTEGER                   0x8D99
#define GL_SAMPLER_2D_ARRAY               0x8DC1
#define GL_SAMPLER_2D_ARRAY_SHADOW        0x8DC4
#define GL_SAMPLER_CUBE_SHADOW            0x8DC5
#define GL_UNSIGNED_INT_VEC2              0x8DC6
#define GL_UNSIGNED_INT_VEC3              0x8DC7
#define GL_UNSIGNED_INT_VEC4              0x8DC8
#define GL_INT_SAMPLER_2D                 0x8DCA
#define GL_INT_SAMPLER_3D                 0x8DCB
#define GL_INT_SAMPLER_CUBE               0x8DCC
#define GL_INT_SAMPLER_2D_ARRAY           0x8DCF
#define GL_UNSIGNED_INT_SAMPLER_2D        0x8DD2
#define GL_UNSIGNED_INT_SAMPLER_3D        0x8DD3
#define GL_UNSIGNED_INT_SAMPLER_CUBE      0x8DD4
#define GL_UNSIGNED_INT_SAMPLER_2D_ARRAY  0x8DD7
#define GL_BUFFER_ACCESS_FLAGS            0x911F
#define GL_BUFFER_MAP_LENGTH              0x9120
#define GL_BUFFER_MAP_OFFSET              0x9121
#define GL_DEPTH_COMPONENT32F             0x8CAC
#define GL_DEPTH32F_STENCIL8              0x8CAD
#define GL_FLOAT_32_UNSIGNED_INT_24_8_REV 0x8DAD
#define GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING 0x8210
#define GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE 0x8211
#define GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE 0x8212
#define GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE 0x8213
#define GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE 0x8214
#define GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE 0x8215
#define GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE 0x8216
#define GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE 0x8217
#define GL_FRAMEBUFFER_DEFAULT            0x8218
#define GL_FRAMEBUFFER_UNDEFINED          0x8219
#define GL_DEPTH_STENCIL_ATTACHMENT       0x821A
#define GL_DEPTH_STENCIL                  0x84F9
#define GL_UNSIGNED_INT_24_8              0x84FA
#define GL_DEPTH24_STENCIL8               0x88F0
#define GL_UNSIGNED_NORMALIZED            0x8C17
#define GL_DRAW_FRAMEBUFFER_BINDING       0x8CA6
#define GL_READ_FRAMEBUFFER               0x8CA8
#define GL_DRAW_FRAMEBUFFER               0x8CA9
#define GL_READ_FRAMEBUFFER_BINDING       0x8CAA
#define GL_RENDERBUFFER_SAMPLES           0x8CAB
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER 0x8CD4
#define GL_MAX_COLOR_ATTACHMENTS          0x8CDF
#define GL_COLOR_ATTACHMENT1              0x8CE1
#define GL_COLOR_ATTACHMENT2              0x8CE2
#define GL_COLOR_ATTACHMENT3              0x8CE3
#define GL_COLOR_ATTACHMENT4              0x8CE4
#define GL_COLOR_ATTACHMENT5              0x8CE5
#define GL_COLOR_ATTACHMENT6              0x8CE6
#define GL_COLOR_ATTACHMENT7              0x8CE7
#define GL_COLOR_ATTACHMENT8              0x8CE8
#define GL_COLOR_ATTACHMENT9              0x8CE9
#define GL_COLOR_ATTACHMENT10             0x8CEA
#define GL_COLOR_ATTACHMENT11             0x8CEB
#define GL_COLOR_ATTACHMENT12             0x8CEC
#define GL_COLOR_ATTACHMENT13             0x8CED
#define GL_COLOR_ATTACHMENT14             0x8CEE
#define GL_COLOR_ATTACHMENT15             0x8CEF
#define GL_COLOR_ATTACHMENT16             0x8CF0
#define GL_COLOR_ATTACHMENT17             0x8CF1
#define GL_COLOR_ATTACHMENT18             0x8CF2
#define GL_COLOR_ATTACHMENT19             0x8CF3
#define GL_COLOR_ATTACHMENT20             0x8CF4
#define GL_COLOR_ATTACHMENT21             0x8CF5
#define GL_COLOR_ATTACHMENT22             0x8CF6
#define GL_COLOR_ATTACHMENT23             0x8CF7
#define GL_COLOR_ATTACHMENT24             0x8CF8
#define GL_COLOR_ATTACHMENT25             0x8CF9
#define GL_COLOR_ATTACHMENT26             0x8CFA
#define GL_COLOR_ATTACHMENT27             0x8CFB
#define GL_COLOR_ATTACHMENT28             0x8CFC
#define GL_COLOR_ATTACHMENT29             0x8CFD
#define GL_COLOR_ATTACHMENT30             0x8CFE
#define GL_COLOR_ATTACHMENT31             0x8CFF
#define GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE 0x8D56
#define GL_MAX_SAMPLES                    0x8D57
#define GL_HALF_FLOAT                     0x140B
#define GL_MAP_READ_BIT                   0x0001
#define GL_MAP_WRITE_BIT                  0x0002
#define GL_MAP_INVALIDATE_RANGE_BIT       0x0004
#define GL_MAP_INVALIDATE_BUFFER_BIT      0x0008
#define GL_MAP_FLUSH_EXPLICIT_BIT         0x0010
#define GL_MAP_UNSYNCHRONIZED_BIT         0x0020
#define GL_RG                             0x8227
#define GL_RG_INTEGER                     0x8228
#define GL_R8                             0x8229
#define GL_RG8                            0x822B
#define GL_R16F                           0x822D
#define GL_R32F                           0x822E
#define GL_RG16F                          0x822F
#define GL_RG32F                          0x8230
#define GL_R8I                            0x8231
#define GL_R8UI                           0x8232
#define GL_R16I                           0x8233
#define GL_R16UI                          0x8234
#define GL_R32I                           0x8235
#define GL_R32UI                          0x8236
#define GL_RG8I                           0x8237
#define GL_RG8UI                          0x8238
#define GL_RG16I                          0x8239
#define GL_RG16UI                         0x823A
#define GL_RG32I                          0x823B
#define GL_RG32UI                         0x823C
#define GL_VERTEX_ARRAY_BINDING           0x85B5
#define GL_R8_SNORM                       0x8F94
#define GL_RG8_SNORM                      0x8F95
#define GL_RGB8_SNORM                     0x8F96
#define GL_RGBA8_SNORM                    0x8F97
#define GL_SIGNED_NORMALIZED              0x8F9C
#define GL_PRIMITIVE_RESTART_FIXED_INDEX  0x8D69
#define GL_COPY_READ_BUFFER               0x8F36
#define GL_COPY_WRITE_BUFFER              0x8F37
#define GL_COPY_READ_BUFFER_BINDING       0x8F36
#define GL_COPY_WRITE_BUFFER_BINDING      0x8F37
#define GL_UNIFORM_BUFFER                 0x8A11
#define GL_UNIFORM_BUFFER_BINDING         0x8A28
#define GL_UNIFORM_BUFFER_START           0x8A29
#define GL_UNIFORM_BUFFER_SIZE            0x8A2A
#define GL_MAX_VERTEX_UNIFORM_BLOCKS      0x8A2B
#define GL_MAX_FRAGMENT_UNIFORM_BLOCKS    0x8A2D
#define GL_MAX_COMBINED_UNIFORM_BLOCKS    0x8A2E
#define GL_MAX_UNIFORM_BUFFER_BINDINGS    0x8A2F
#define GL_MAX_UNIFORM_BLOCK_SIZE         0x8A30
#define GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS 0x8A31
#define GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS 0x8A33
#define GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT 0x8A34
#define GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH 0x8A35
#define GL_ACTIVE_UNIFORM_BLOCKS          0x8A36
#define GL_UNIFORM_TYPE                   0x8A37
#define GL_UNIFORM_SIZE                   0x8A38
#define GL_UNIFORM_NAME_LENGTH            0x8A39
#define GL_UNIFORM_BLOCK_INDEX            0x8A3A
#define GL_UNIFORM_OFFSET                 0x8A3B
#define GL_UNIFORM_ARRAY_STRIDE           0x8A3C
#define GL_UNIFORM_MATRIX_STRIDE          0x8A3D
#define GL_UNIFORM_IS_ROW_MAJOR           0x8A3E
#define GL_UNIFORM_BLOCK_BINDING          0x8A3F
#define GL_UNIFORM_BLOCK_DATA_SIZE        0x8A40
#define GL_UNIFORM_BLOCK_NAME_LENGTH      0x8A41
#define GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS  0x8A42
#define GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES 0x8A43
#define GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER 0x8A44
#define GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER 0x8A46
#define GL_INVALID_INDEX                  0xFFFFFFFFu
#define GL_MAX_VERTEX_OUTPUT_COMPONENTS   0x9122
#define GL_MAX_FRAGMENT_INPUT_COMPONENTS  0x9125
#define GL_MAX_SERVER_WAIT_TIMEOUT        0x9111
#define GL_OBJECT_TYPE                    0x9112
#define GL_SYNC_CONDITION                 0x9113
#define GL_SYNC_STATUS                    0x9114
#define GL_SYNC_FLAGS                     0x9115
#define GL_SYNC_FENCE                     0x9116
#define GL_SYNC_GPU_COMMANDS_COMPLETE     0x9117
#define GL_UNSIGNALED                     0x9118
#define GL_SIGNALED                       0x9119
#define GL_ALREADY_SIGNALED               0x911A
#define GL_TIMEOUT_EXPIRED                0x911B
#define GL_CONDITION_SATISFIED            0x911C
#define GL_WAIT_FAILED                    0x911D
#define GL_SYNC_FLUSH_COMMANDS_BIT        0x00000001
#define GL_TIMEOUT_IGNORED                0xFFFFFFFFFFFFFFFFull
#define GL_VERTEX_ATTRIB_ARRAY_DIVISOR    0x88FE
#define GL_ANY_SAMPLES_PASSED             0x8C2F
#define GL_ANY_SAMPLES_PASSED_CONSERVATIVE 0x8D6A
#define GL_SAMPLER_BINDING                0x8919
#define GL_RGB10_A2UI                     0x906F
#define GL_TEXTURE_SWIZZLE_R              0x8E42
#define GL_TEXTURE_SWIZZLE_G              0x8E43
#define GL_TEXTURE_SWIZZLE_B              0x8E44
#define GL_TEXTURE_SWIZZLE_A              0x8E45
#define GL_GREEN                          0x1904
#define GL_BLUE                           0x1905
#define GL_INT_2_10_10_10_REV             0x8D9F
#define GL_TRANSFORM_FEEDBACK             0x8E22
#define GL_TRANSFORM_FEEDBACK_PAUSED      0x8E23
#define GL_TRANSFORM_FEEDBACK_ACTIVE      0x8E24
#define GL_TRANSFORM_FEEDBACK_BINDING     0x8E25
#define GL_PROGRAM_BINARY_RETRIEVABLE_HINT 0x8257
#define GL_PROGRAM_BINARY_LENGTH          0x8741
#define GL_NUM_PROGRAM_BINARY_FORMATS     0x87FE
#define GL_PROGRAM_BINARY_FORMATS         0x87FF
#define GL_COMPRESSED_R11_EAC             0x9270
#define GL_COMPRESSED_SIGNED_R11_EAC      0x9271
#define GL_COMPRESSED_RG11_EAC            0x9272
#define GL_COMPRESSED_SIGNED_RG11_EAC     0x9273
#define GL_COMPRESSED_RGB8_ETC2           0x9274
#define GL_COMPRESSED_SRGB8_ETC2          0x9275
#define GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 0x9276
#define GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 0x9277
#define GL_COMPRESSED_RGBA8_ETC2_EAC      0x9278
#define GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC 0x9279
#define GL_TEXTURE_IMMUTABLE_FORMAT       0x912F
#define GL_MAX_ELEMENT_INDEX              0x8D6B
#define GL_NUM_SAMPLE_COUNTS              0x9380
#define GL_TEXTURE_IMMUTABLE_LEVELS       0x82DF
typedef void (GL_APIENTRYP PFNGLREADBUFFERPROC) (GLenum src);
typedef void (GL_APIENTRYP PFNGLDRAWRANGEELEMENTSPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices);
typedef void (GL_APIENTRYP PFNGLTEXIMAGE3DPROC) (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (GL_APIENTRYP PFNGLTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
typedef void (GL_APIENTRYP PFNGLCOPYTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GL_APIENTRYP PFNGLCOMPRESSEDTEXIMAGE3DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void (GL_APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void (GL_APIENTRYP PFNGLGENQUERIESPROC) (GLsizei n, GLuint *ids);
typedef void (GL_APIENTRYP PFNGLDELETEQUERIESPROC) (GLsizei n, const GLuint *ids);
typedef GLboolean (GL_APIENTRYP PFNGLISQUERYPROC) (GLuint id);
typedef void (GL_APIENTRYP PFNGLBEGINQUERYPROC) (GLenum target, GLuint id);
typedef void (GL_APIENTRYP PFNGLENDQUERYPROC) (GLenum target);
typedef void (GL_APIENTRYP PFNGLGETQUERYIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (GL_APIENTRYP PFNGLGETQUERYOBJECTUIVPROC) (GLuint id, GLenum pname, GLuint *params);
typedef GLboolean (GL_APIENTRYP PFNGLUNMAPBUFFERPROC) (GLenum target);
typedef void (GL_APIENTRYP PFNGLGETBUFFERPOINTERVPROC) (GLenum target, GLenum pname, void **params);
typedef void (GL_APIENTRYP PFNGLDRAWBUFFERSPROC) (GLsizei n, const GLenum *bufs);
typedef void (GL_APIENTRYP PFNGLUNIFORMMATRIX2X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLUNIFORMMATRIX3X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLUNIFORMMATRIX2X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLUNIFORMMATRIX4X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLUNIFORMMATRIX3X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLUNIFORMMATRIX4X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLBLITFRAMEBUFFERPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef void (GL_APIENTRYP PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GL_APIENTRYP PFNGLFRAMEBUFFERTEXTURELAYERPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void *(GL_APIENTRYP PFNGLMAPBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void (GL_APIENTRYP PFNGLFLUSHMAPPEDBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length);
typedef void (GL_APIENTRYP PFNGLBINDVERTEXARRAYPROC) (GLuint array);
typedef void (GL_APIENTRYP PFNGLDELETEVERTEXARRAYSPROC) (GLsizei n, const GLuint *arrays);
typedef void (GL_APIENTRYP PFNGLGENVERTEXARRAYSPROC) (GLsizei n, GLuint *arrays);
typedef GLboolean (GL_APIENTRYP PFNGLISVERTEXARRAYPROC) (GLuint array);
typedef void (GL_APIENTRYP PFNGLGETINTEGERI_VPROC) (GLenum target, GLuint index, GLint *data);
typedef void (GL_APIENTRYP PFNGLBEGINTRANSFORMFEEDBACKPROC) (GLenum primitiveMode);
typedef void (GL_APIENTRYP PFNGLENDTRANSFORMFEEDBACKPROC) (void);
typedef void (GL_APIENTRYP PFNGLBINDBUFFERRANGEPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (GL_APIENTRYP PFNGLBINDBUFFERBASEPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void (GL_APIENTRYP PFNGLTRANSFORMFEEDBACKVARYINGSPROC) (GLuint program, GLsizei count, const GLchar *const*varyings, GLenum bufferMode);
typedef void (GL_APIENTRYP PFNGLGETTRANSFORMFEEDBACKVARYINGPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIBIPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
typedef void (GL_APIENTRYP PFNGLGETVERTEXATTRIBIIVPROC) (GLuint index, GLenum pname, GLint *params);
typedef void (GL_APIENTRYP PFNGLGETVERTEXATTRIBIUIVPROC) (GLuint index, GLenum pname, GLuint *params);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIBI4IPROC) (GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIBI4UIPROC) (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIBI4IVPROC) (GLuint index, const GLint *v);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIBI4UIVPROC) (GLuint index, const GLuint *v);
typedef void (GL_APIENTRYP PFNGLGETUNIFORMUIVPROC) (GLuint program, GLint location, GLuint *params);
typedef GLint (GL_APIENTRYP PFNGLGETFRAGDATALOCATIONPROC) (GLuint program, const GLchar *name);
typedef void (GL_APIENTRYP PFNGLUNIFORM1UIPROC) (GLint location, GLuint v0);
typedef void (GL_APIENTRYP PFNGLUNIFORM2UIPROC) (GLint location, GLuint v0, GLuint v1);
typedef void (GL_APIENTRYP PFNGLUNIFORM3UIPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (GL_APIENTRYP PFNGLUNIFORM4UIPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (GL_APIENTRYP PFNGLUNIFORM1UIVPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (GL_APIENTRYP PFNGLUNIFORM2UIVPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (GL_APIENTRYP PFNGLUNIFORM3UIVPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (GL_APIENTRYP PFNGLUNIFORM4UIVPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (GL_APIENTRYP PFNGLCLEARBUFFERIVPROC) (GLenum buffer, GLint drawbuffer, const GLint *value);
typedef void (GL_APIENTRYP PFNGLCLEARBUFFERUIVPROC) (GLenum buffer, GLint drawbuffer, const GLuint *value);
typedef void (GL_APIENTRYP PFNGLCLEARBUFFERFVPROC) (GLenum buffer, GLint drawbuffer, const GLfloat *value);
typedef void (GL_APIENTRYP PFNGLCLEARBUFFERFIPROC) (GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
typedef const GLubyte *(GL_APIENTRYP PFNGLGETSTRINGIPROC) (GLenum name, GLuint index);
typedef void (GL_APIENTRYP PFNGLCOPYBUFFERSUBDATAPROC) (GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void (GL_APIENTRYP PFNGLGETUNIFORMINDICESPROC) (GLuint program, GLsizei uniformCount, const GLchar *const*uniformNames, GLuint *uniformIndices);
typedef void (GL_APIENTRYP PFNGLGETACTIVEUNIFORMSIVPROC) (GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params);
typedef GLuint (GL_APIENTRYP PFNGLGETUNIFORMBLOCKINDEXPROC) (GLuint program, const GLchar *uniformBlockName);
typedef void (GL_APIENTRYP PFNGLGETACTIVEUNIFORMBLOCKIVPROC) (GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params);
typedef void (GL_APIENTRYP PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC) (GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName);
typedef void (GL_APIENTRYP PFNGLUNIFORMBLOCKBINDINGPROC) (GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
typedef void (GL_APIENTRYP PFNGLDRAWARRAYSINSTANCEDPROC) (GLenum mode, GLint first, GLsizei count, GLsizei instancecount);
typedef void (GL_APIENTRYP PFNGLDRAWELEMENTSINSTANCEDPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount);
typedef GLsync (GL_APIENTRYP PFNGLFENCESYNCPROC) (GLenum condition, GLbitfield flags);
typedef GLboolean (GL_APIENTRYP PFNGLISSYNCPROC) (GLsync sync);
typedef void (GL_APIENTRYP PFNGLDELETESYNCPROC) (GLsync sync);
typedef GLenum (GL_APIENTRYP PFNGLCLIENTWAITSYNCPROC) (GLsync sync, GLbitfield flags, GLuint64 timeout);
typedef void (GL_APIENTRYP PFNGLWAITSYNCPROC) (GLsync sync, GLbitfield flags, GLuint64 timeout);
typedef void (GL_APIENTRYP PFNGLGETINTEGER64VPROC) (GLenum pname, GLint64 *data);
typedef void (GL_APIENTRYP PFNGLGETSYNCIVPROC) (GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);
typedef void (GL_APIENTRYP PFNGLGETINTEGER64I_VPROC) (GLenum target, GLuint index, GLint64 *data);
typedef void (GL_APIENTRYP PFNGLGETBUFFERPARAMETERI64VPROC) (GLenum target, GLenum pname, GLint64 *params);
typedef void (GL_APIENTRYP PFNGLGENSAMPLERSPROC) (GLsizei count, GLuint *samplers);
typedef void (GL_APIENTRYP PFNGLDELETESAMPLERSPROC) (GLsizei count, const GLuint *samplers);
typedef GLboolean (GL_APIENTRYP PFNGLISSAMPLERPROC) (GLuint sampler);
typedef void (GL_APIENTRYP PFNGLBINDSAMPLERPROC) (GLuint unit, GLuint sampler);
typedef void (GL_APIENTRYP PFNGLSAMPLERPARAMETERIPROC) (GLuint sampler, GLenum pname, GLint param);
typedef void (GL_APIENTRYP PFNGLSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, const GLint *param);
typedef void (GL_APIENTRYP PFNGLSAMPLERPARAMETERFPROC) (GLuint sampler, GLenum pname, GLfloat param);
typedef void (GL_APIENTRYP PFNGLSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, const GLfloat *param);
typedef void (GL_APIENTRYP PFNGLGETSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, GLint *params);
typedef void (GL_APIENTRYP PFNGLGETSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, GLfloat *params);
typedef void (GL_APIENTRYP PFNGLVERTEXATTRIBDIVISORPROC) (GLuint index, GLuint divisor);
typedef void (GL_APIENTRYP PFNGLBINDTRANSFORMFEEDBACKPROC) (GLenum target, GLuint id);
typedef void (GL_APIENTRYP PFNGLDELETETRANSFORMFEEDBACKSPROC) (GLsizei n, const GLuint *ids);
typedef void (GL_APIENTRYP PFNGLGENTRANSFORMFEEDBACKSPROC) (GLsizei n, GLuint *ids);
typedef GLboolean (GL_APIENTRYP PFNGLISTRANSFORMFEEDBACKPROC) (GLuint id);
typedef void (GL_APIENTRYP PFNGLPAUSETRANSFORMFEEDBACKPROC) (void);
typedef void (GL_APIENTRYP PFNGLRESUMETRANSFORMFEEDBACKPROC) (void);
typedef void (GL_APIENTRYP PFNGLGETPROGRAMBINARYPROC) (GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary);
typedef void (GL_APIENTRYP PFNGLPROGRAMBINARYPROC) (GLuint program, GLenum binaryFormat, const void *binary, GLsizei length);
typedef void (GL_APIENTRYP PFNGLPROGRAMPARAMETERIPROC) (GLuint program, GLenum pname, GLint value);
typedef void (GL_APIENTRYP PFNGLINVALIDATEFRAMEBUFFERPROC) (GLenum target, GLsizei numAttachments, const GLenum *attachments);
typedef void (GL_APIENTRYP PFNGLINVALIDATESUBFRAMEBUFFERPROC) (GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GL_APIENTRYP PFNGLTEXSTORAGE2DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GL_APIENTRYP PFNGLTEXSTORAGE3DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void (GL_APIENTRYP PFNGLGETINTERNALFORMATIVPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params);
#if GL_GLES_PROTOTYPES
GL_APICALL void GL_APIENTRY glReadBuffer (GLenum src);
GL_APICALL void GL_APIENTRY glDrawRangeElements (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices);
GL_APICALL void GL_APIENTRY glTexImage3D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
GL_APICALL void GL_APIENTRY glTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
GL_APICALL void GL_APIENTRY glCopyTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
GL_APICALL void GL_APIENTRY glCompressedTexImage3D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
GL_APICALL void GL_APIENTRY glCompressedTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
GL_APICALL void GL_APIENTRY glGenQueries (GLsizei n, GLuint *ids);
GL_APICALL void GL_APIENTRY glDeleteQueries (GLsizei n, const GLuint *ids);
GL_APICALL GLboolean GL_APIENTRY glIsQuery (GLuint id);
GL_APICALL void GL_APIENTRY glBeginQuery (GLenum target, GLuint id);
GL_APICALL void GL_APIENTRY glEndQuery (GLenum target);
GL_APICALL void GL_APIENTRY glGetQueryiv (GLenum target, GLenum pname, GLint *params);
GL_APICALL void GL_APIENTRY glGetQueryObjectuiv (GLuint id, GLenum pname, GLuint *params);
GL_APICALL GLboolean GL_APIENTRY glUnmapBuffer (GLenum target);
GL_APICALL void GL_APIENTRY glGetBufferPointerv (GLenum target, GLenum pname, void **params);
GL_APICALL void GL_APIENTRY glDrawBuffers (GLsizei n, const GLenum *bufs);
GL_APICALL void GL_APIENTRY glUniformMatrix2x3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_APICALL void GL_APIENTRY glUniformMatrix3x2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_APICALL void GL_APIENTRY glUniformMatrix2x4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_APICALL void GL_APIENTRY glUniformMatrix4x2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_APICALL void GL_APIENTRY glUniformMatrix3x4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_APICALL void GL_APIENTRY glUniformMatrix4x3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_APICALL void GL_APIENTRY glBlitFramebuffer (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
GL_APICALL void GL_APIENTRY glRenderbufferStorageMultisample (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
GL_APICALL void GL_APIENTRY glFramebufferTextureLayer (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
GL_APICALL void *GL_APIENTRY glMapBufferRange (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
GL_APICALL void GL_APIENTRY glFlushMappedBufferRange (GLenum target, GLintptr offset, GLsizeiptr length);
GL_APICALL void GL_APIENTRY glBindVertexArray (GLuint array);
GL_APICALL void GL_APIENTRY glDeleteVertexArrays (GLsizei n, const GLuint *arrays);
GL_APICALL void GL_APIENTRY glGenVertexArrays (GLsizei n, GLuint *arrays);
GL_APICALL GLboolean GL_APIENTRY glIsVertexArray (GLuint array);
GL_APICALL void GL_APIENTRY glGetIntegeri_v (GLenum target, GLuint index, GLint *data);
GL_APICALL void GL_APIENTRY glBeginTransformFeedback (GLenum primitiveMode);
GL_APICALL void GL_APIENTRY glEndTransformFeedback (void);
GL_APICALL void GL_APIENTRY glBindBufferRange (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
GL_APICALL void GL_APIENTRY glBindBufferBase (GLenum target, GLuint index, GLuint buffer);
GL_APICALL void GL_APIENTRY glTransformFeedbackVaryings (GLuint program, GLsizei count, const GLchar *const*varyings, GLenum bufferMode);
GL_APICALL void GL_APIENTRY glGetTransformFeedbackVarying (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
GL_APICALL void GL_APIENTRY glVertexAttribIPointer (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
GL_APICALL void GL_APIENTRY glGetVertexAttribIiv (GLuint index, GLenum pname, GLint *params);
GL_APICALL void GL_APIENTRY glGetVertexAttribIuiv (GLuint index, GLenum pname, GLuint *params);
GL_APICALL void GL_APIENTRY glVertexAttribI4i (GLuint index, GLint x, GLint y, GLint z, GLint w);
GL_APICALL void GL_APIENTRY glVertexAttribI4ui (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
GL_APICALL void GL_APIENTRY glVertexAttribI4iv (GLuint index, const GLint *v);
GL_APICALL void GL_APIENTRY glVertexAttribI4uiv (GLuint index, const GLuint *v);
GL_APICALL void GL_APIENTRY glGetUniformuiv (GLuint program, GLint location, GLuint *params);
GL_APICALL GLint GL_APIENTRY glGetFragDataLocation (GLuint program, const GLchar *name);
GL_APICALL void GL_APIENTRY glUniform1ui (GLint location, GLuint v0);
GL_APICALL void GL_APIENTRY glUniform2ui (GLint location, GLuint v0, GLuint v1);
GL_APICALL void GL_APIENTRY glUniform3ui (GLint location, GLuint v0, GLuint v1, GLuint v2);
GL_APICALL void GL_APIENTRY glUniform4ui (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
GL_APICALL void GL_APIENTRY glUniform1uiv (GLint location, GLsizei count, const GLuint *value);
GL_APICALL void GL_APIENTRY glUniform2uiv (GLint location, GLsizei count, const GLuint *value);
GL_APICALL void GL_APIENTRY glUniform3uiv (GLint location, GLsizei count, const GLuint *value);
GL_APICALL void GL_APIENTRY glUniform4uiv (GLint location, GLsizei count, const GLuint *value);
GL_APICALL void GL_APIENTRY glClearBufferiv (GLenum buffer, GLint drawbuffer, const GLint *value);
GL_APICALL void GL_APIENTRY glClearBufferuiv (GLenum buffer, GLint drawbuffer, const GLuint *value);
GL_APICALL void GL_APIENTRY glClearBufferfv (GLenum buffer, GLint drawbuffer, const GLfloat *value);
GL_APICALL void GL_APIENTRY glClearBufferfi (GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
GL_APICALL const GLubyte *GL_APIENTRY glGetStringi (GLenum name, GLuint index);
GL_APICALL void GL_APIENTRY glCopyBufferSubData (GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
GL_APICALL void GL_APIENTRY glGetUniformIndices (GLuint program, GLsizei uniformCount, const GLchar *const*uniformNames, GLuint *uniformIndices);
GL_APICALL void GL_APIENTRY glGetActiveUniformsiv (GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params);
GL_APICALL GLuint GL_APIENTRY glGetUniformBlockIndex (GLuint program, const GLchar *uniformBlockName);
GL_APICALL void GL_APIENTRY glGetActiveUniformBlockiv (GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params);
GL_APICALL void GL_APIENTRY glGetActiveUniformBlockName (GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName);
GL_APICALL void GL_APIENTRY glUniformBlockBinding (GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
GL_APICALL void GL_APIENTRY glDrawArraysInstanced (GLenum mode, GLint first, GLsizei count, GLsizei instancecount);
GL_APICALL void GL_APIENTRY glDrawElementsInstanced (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount);
GL_APICALL GLsync GL_APIENTRY glFenceSync (GLenum condition, GLbitfield flags);
GL_APICALL GLboolean GL_APIENTRY glIsSync (GLsync sync);
GL_APICALL void GL_APIENTRY glDeleteSync (GLsync sync);
GL_APICALL GLenum GL_APIENTRY glClientWaitSync (GLsync sync, GLbitfield flags, GLuint64 timeout);
GL_APICALL void GL_APIENTRY glWaitSync (GLsync sync, GLbitfield flags, GLuint64 timeout);
GL_APICALL void GL_APIENTRY glGetInteger64v (GLenum pname, GLint64 *data);
GL_APICALL void GL_APIENTRY glGetSynciv (GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);
GL_APICALL void GL_APIENTRY glGetInteger64i_v (GLenum target, GLuint index, GLint64 *data);
GL_APICALL void GL_APIENTRY glGetBufferParameteri64v (GLenum target, GLenum pname, GLint64 *params);
GL_APICALL void GL_APIENTRY glGenSamplers (GLsizei count, GLuint *samplers);
GL_APICALL void GL_APIENTRY glDeleteSamplers (GLsizei count, const GLuint *samplers);
GL_APICALL GLboolean GL_APIENTRY glIsSampler (GLuint sampler);
GL_APICALL void GL_APIENTRY glBindSampler (GLuint unit, GLuint sampler);
GL_APICALL void GL_APIENTRY glSamplerParameteri (GLuint sampler, GLenum pname, GLint param);
GL_APICALL void GL_APIENTRY glSamplerParameteriv (GLuint sampler, GLenum pname, const GLint *param);
GL_APICALL void GL_APIENTRY glSamplerParameterf (GLuint sampler, GLenum pname, GLfloat param);
GL_APICALL void GL_APIENTRY glSamplerParameterfv (GLuint sampler, GLenum pname, const GLfloat *param);
GL_APICALL void GL_APIENTRY glGetSamplerParameteriv (GLuint sampler, GLenum pname, GLint *params);
GL_APICALL void GL_APIENTRY glGetSamplerParameterfv (GLuint sampler, GLenum pname, GLfloat *params);
GL_APICALL void GL_APIENTRY glVertexAttribDivisor (GLuint index, GLuint divisor);
GL_APICALL void GL_APIENTRY glBindTransformFeedback (GLenum target, GLuint id);
GL_APICALL void GL_APIENTRY glDeleteTransformFeedbacks (GLsizei n, const GLuint *ids);
GL_APICALL void GL_APIENTRY glGenTransformFeedbacks (GLsizei n, GLuint *ids);
GL_APICALL GLboolean GL_APIENTRY glIsTransformFeedback (GLuint id);
GL_APICALL void GL_APIENTRY glPauseTransformFeedback (void);
GL_APICALL void GL_APIENTRY glResumeTransformFeedback (void);
GL_APICALL void GL_APIENTRY glGetProgramBinary (GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary);
GL_APICALL void GL_APIENTRY glProgramBinary (GLuint program, GLenum binaryFormat, const void *binary, GLsizei length);
GL_APICALL void GL_APIENTRY glProgramParameteri (GLuint program, GLenum pname, GLint value);
GL_APICALL void GL_APIENTRY glInvalidateFramebuffer (GLenum target, GLsizei numAttachments, const GLenum *attachments);
GL_APICALL void GL_APIENTRY glInvalidateSubFramebuffer (GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height);
GL_APICALL void GL_APIENTRY glTexStorage2D (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
GL_APICALL void GL_APIENTRY glTexStorage3D (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
GL_APICALL void GL_APIENTRY glGetInternalformativ (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params);
#endif
#endif /* GL_ES_VERSION_3_0 */

#ifdef __cplusplus
}
#endif

#endif


#endif

#ifndef __wgl_h_
#define __wgl_h_ 1

#ifdef __cplusplus
extern "C" {
#endif

/*
** Copyright (c) 2013-2017 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/
/*
** This header is generated from the Khronos OpenGL / OpenGL ES XML
** API Registry. The current version of the Registry, generator scripts
** used to make the header, and the header can be found at
**   https://github.com/KhronosGroup/OpenGL-Registry
*/

#if defined(_WIN32) && !defined(APIENTRY) && !defined(__CYGWIN__) && !defined(__SCITECH_SNAP__)
#define WIN32_LEAN_AND_MEAN 1
#include <windows.h>
#endif

/* Generated on date 20170121 */

/* Generated C header for:
 * API: wgl
 * Versions considered: .*
 * Versions emitted: .*
 * Default extensions included: wgl
 * Additional extensions included: _nomatch_^
 * Extensions removed: _nomatch_^
 */

#ifndef WGL_VERSION_1_0
#define WGL_VERSION_1_0 1
#define WGL_FONT_LINES                    0
#define WGL_FONT_POLYGONS                 1
#define WGL_SWAP_MAIN_PLANE               0x00000001
#define WGL_SWAP_OVERLAY1                 0x00000002
#define WGL_SWAP_OVERLAY2                 0x00000004
#define WGL_SWAP_OVERLAY3                 0x00000008
#define WGL_SWAP_OVERLAY4                 0x00000010
#define WGL_SWAP_OVERLAY5                 0x00000020
#define WGL_SWAP_OVERLAY6                 0x00000040
#define WGL_SWAP_OVERLAY7                 0x00000080
#define WGL_SWAP_OVERLAY8                 0x00000100
#define WGL_SWAP_OVERLAY9                 0x00000200
#define WGL_SWAP_OVERLAY10                0x00000400
#define WGL_SWAP_OVERLAY11                0x00000800
#define WGL_SWAP_OVERLAY12                0x00001000
#define WGL_SWAP_OVERLAY13                0x00002000
#define WGL_SWAP_OVERLAY14                0x00004000
#define WGL_SWAP_OVERLAY15                0x00008000
#define WGL_SWAP_UNDERLAY1                0x00010000
#define WGL_SWAP_UNDERLAY2                0x00020000
#define WGL_SWAP_UNDERLAY3                0x00040000
#define WGL_SWAP_UNDERLAY4                0x00080000
#define WGL_SWAP_UNDERLAY5                0x00100000
#define WGL_SWAP_UNDERLAY6                0x00200000
#define WGL_SWAP_UNDERLAY7                0x00400000
#define WGL_SWAP_UNDERLAY8                0x00800000
#define WGL_SWAP_UNDERLAY9                0x01000000
#define WGL_SWAP_UNDERLAY10               0x02000000
#define WGL_SWAP_UNDERLAY11               0x04000000
#define WGL_SWAP_UNDERLAY12               0x08000000
#define WGL_SWAP_UNDERLAY13               0x10000000
#define WGL_SWAP_UNDERLAY14               0x20000000
#define WGL_SWAP_UNDERLAY15               0x40000000
typedef int (WINAPI * PFNCHOOSEPIXELFORMATPROC) (HDC hDc, const PIXELFORMATDESCRIPTOR *pPfd);
typedef int (WINAPI * PFNDESCRIBEPIXELFORMATPROC) (HDC hdc, int ipfd, UINT cjpfd, const PIXELFORMATDESCRIPTOR *ppfd);
typedef UINT (WINAPI * PFNGETENHMETAFILEPIXELFORMATPROC) (HENHMETAFILE hemf, const PIXELFORMATDESCRIPTOR *ppfd);
typedef int (WINAPI * PFNGETPIXELFORMATPROC) (HDC hdc);
typedef BOOL (WINAPI * PFNSETPIXELFORMATPROC) (HDC hdc, int ipfd, const PIXELFORMATDESCRIPTOR *ppfd);
typedef BOOL (WINAPI * PFNSWAPBUFFERSPROC) (HDC hdc);
typedef BOOL (WINAPI * PFNWGLCOPYCONTEXTPROC) (HGLRC hglrcSrc, HGLRC hglrcDst, UINT mask);
typedef HGLRC (WINAPI * PFNWGLCREATECONTEXTPROC) (HDC hDc);
typedef HGLRC (WINAPI * PFNWGLCREATELAYERCONTEXTPROC) (HDC hDc, int level);
typedef BOOL (WINAPI * PFNWGLDELETECONTEXTPROC) (HGLRC oldContext);
typedef BOOL (WINAPI * PFNWGLDESCRIBELAYERPLANEPROC) (HDC hDc, int pixelFormat, int layerPlane, UINT nBytes, const LAYERPLANEDESCRIPTOR *plpd);
typedef HGLRC (WINAPI * PFNWGLGETCURRENTCONTEXTPROC) (void);
typedef HDC (WINAPI * PFNWGLGETCURRENTDCPROC) (void);
typedef int (WINAPI * PFNWGLGETLAYERPALETTEENTRIESPROC) (HDC hdc, int iLayerPlane, int iStart, int cEntries, const COLORREF *pcr);
typedef PROC (WINAPI * PFNWGLGETPROCADDRESSPROC) (LPCSTR lpszProc);
typedef BOOL (WINAPI * PFNWGLMAKECURRENTPROC) (HDC hDc, HGLRC newContext);
typedef BOOL (WINAPI * PFNWGLREALIZELAYERPALETTEPROC) (HDC hdc, int iLayerPlane, BOOL bRealize);
typedef int (WINAPI * PFNWGLSETLAYERPALETTEENTRIESPROC) (HDC hdc, int iLayerPlane, int iStart, int cEntries, const COLORREF *pcr);
typedef BOOL (WINAPI * PFNWGLSHARELISTSPROC) (HGLRC hrcSrvShare, HGLRC hrcSrvSource);
typedef BOOL (WINAPI * PFNWGLSWAPLAYERBUFFERSPROC) (HDC hdc, UINT fuFlags);
typedef BOOL (WINAPI * PFNWGLUSEFONTBITMAPSPROC) (HDC hDC, DWORD first, DWORD count, DWORD listBase);
typedef BOOL (WINAPI * PFNWGLUSEFONTBITMAPSAPROC) (HDC hDC, DWORD first, DWORD count, DWORD listBase);
typedef BOOL (WINAPI * PFNWGLUSEFONTBITMAPSWPROC) (HDC hDC, DWORD first, DWORD count, DWORD listBase);
typedef BOOL (WINAPI * PFNWGLUSEFONTOUTLINESPROC) (HDC hDC, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, LPGLYPHMETRICSFLOAT lpgmf);
typedef BOOL (WINAPI * PFNWGLUSEFONTOUTLINESAPROC) (HDC hDC, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, LPGLYPHMETRICSFLOAT lpgmf);
typedef BOOL (WINAPI * PFNWGLUSEFONTOUTLINESWPROC) (HDC hDC, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, LPGLYPHMETRICSFLOAT lpgmf);
#ifdef WGL_WGLEXT_PROTOTYPES
int WINAPI ChoosePixelFormat (HDC hDc, const PIXELFORMATDESCRIPTOR *pPfd);
int WINAPI DescribePixelFormat (HDC hdc, int ipfd, UINT cjpfd, const PIXELFORMATDESCRIPTOR *ppfd);
UINT WINAPI GetEnhMetaFilePixelFormat (HENHMETAFILE hemf, const PIXELFORMATDESCRIPTOR *ppfd);
int WINAPI GetPixelFormat (HDC hdc);
BOOL WINAPI SetPixelFormat (HDC hdc, int ipfd, const PIXELFORMATDESCRIPTOR *ppfd);
BOOL WINAPI SwapBuffers (HDC hdc);
BOOL WINAPI wglCopyContext (HGLRC hglrcSrc, HGLRC hglrcDst, UINT mask);
HGLRC WINAPI wglCreateContext (HDC hDc);
HGLRC WINAPI wglCreateLayerContext (HDC hDc, int level);
BOOL WINAPI wglDeleteContext (HGLRC oldContext);
BOOL WINAPI wglDescribeLayerPlane (HDC hDc, int pixelFormat, int layerPlane, UINT nBytes, const LAYERPLANEDESCRIPTOR *plpd);
HGLRC WINAPI wglGetCurrentContext (void);
HDC WINAPI wglGetCurrentDC (void);
int WINAPI wglGetLayerPaletteEntries (HDC hdc, int iLayerPlane, int iStart, int cEntries, const COLORREF *pcr);
PROC WINAPI wglGetProcAddress (LPCSTR lpszProc);
BOOL WINAPI wglMakeCurrent (HDC hDc, HGLRC newContext);
BOOL WINAPI wglRealizeLayerPalette (HDC hdc, int iLayerPlane, BOOL bRealize);
int WINAPI wglSetLayerPaletteEntries (HDC hdc, int iLayerPlane, int iStart, int cEntries, const COLORREF *pcr);
BOOL WINAPI wglShareLists (HGLRC hrcSrvShare, HGLRC hrcSrvSource);
BOOL WINAPI wglSwapLayerBuffers (HDC hdc, UINT fuFlags);
BOOL WINAPI wglUseFontBitmaps (HDC hDC, DWORD first, DWORD count, DWORD listBase);
BOOL WINAPI wglUseFontBitmapsA (HDC hDC, DWORD first, DWORD count, DWORD listBase);
BOOL WINAPI wglUseFontBitmapsW (HDC hDC, DWORD first, DWORD count, DWORD listBase);
BOOL WINAPI wglUseFontOutlines (HDC hDC, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, LPGLYPHMETRICSFLOAT lpgmf);
BOOL WINAPI wglUseFontOutlinesA (HDC hDC, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, LPGLYPHMETRICSFLOAT lpgmf);
BOOL WINAPI wglUseFontOutlinesW (HDC hDC, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, LPGLYPHMETRICSFLOAT lpgmf);
#endif
#endif /* WGL_VERSION_1_0 */

#ifndef WGL_ARB_buffer_region
#define WGL_ARB_buffer_region 1
#define WGL_FRONT_COLOR_BUFFER_BIT_ARB    0x00000001
#define WGL_BACK_COLOR_BUFFER_BIT_ARB     0x00000002
#define WGL_DEPTH_BUFFER_BIT_ARB          0x00000004
#define WGL_STENCIL_BUFFER_BIT_ARB        0x00000008
typedef HANDLE (WINAPI * PFNWGLCREATEBUFFERREGIONARBPROC) (HDC hDC, int iLayerPlane, UINT uType);
typedef VOID (WINAPI * PFNWGLDELETEBUFFERREGIONARBPROC) (HANDLE hRegion);
typedef BOOL (WINAPI * PFNWGLSAVEBUFFERREGIONARBPROC) (HANDLE hRegion, int x, int y, int width, int height);
typedef BOOL (WINAPI * PFNWGLRESTOREBUFFERREGIONARBPROC) (HANDLE hRegion, int x, int y, int width, int height, int xSrc, int ySrc);
#ifdef WGL_WGLEXT_PROTOTYPES
HANDLE WINAPI wglCreateBufferRegionARB (HDC hDC, int iLayerPlane, UINT uType);
VOID WINAPI wglDeleteBufferRegionARB (HANDLE hRegion);
BOOL WINAPI wglSaveBufferRegionARB (HANDLE hRegion, int x, int y, int width, int height);
BOOL WINAPI wglRestoreBufferRegionARB (HANDLE hRegion, int x, int y, int width, int height, int xSrc, int ySrc);
#endif
#endif /* WGL_ARB_buffer_region */

#ifndef WGL_ARB_context_flush_control
#define WGL_ARB_context_flush_control 1
#define WGL_CONTEXT_RELEASE_BEHAVIOR_ARB  0x2097
#define WGL_CONTEXT_RELEASE_BEHAVIOR_NONE_ARB 0
#define WGL_CONTEXT_RELEASE_BEHAVIOR_FLUSH_ARB 0x2098
#endif /* WGL_ARB_context_flush_control */

#ifndef WGL_ARB_create_context
#define WGL_ARB_create_context 1
#define WGL_CONTEXT_DEBUG_BIT_ARB         0x00000001
#define WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB 0x00000002
#define WGL_CONTEXT_MAJOR_VERSION_ARB     0x2091
#define WGL_CONTEXT_MINOR_VERSION_ARB     0x2092
#define WGL_CONTEXT_LAYER_PLANE_ARB       0x2093
#define WGL_CONTEXT_FLAGS_ARB             0x2094
#define ERROR_INVALID_VERSION_ARB         0x2095
typedef HGLRC (WINAPI * PFNWGLCREATECONTEXTATTRIBSARBPROC) (HDC hDC, HGLRC hShareContext, const int *attribList);
#ifdef WGL_WGLEXT_PROTOTYPES
HGLRC WINAPI wglCreateContextAttribsARB (HDC hDC, HGLRC hShareContext, const int *attribList);
#endif
#endif /* WGL_ARB_create_context */

#ifndef WGL_ARB_create_context_profile
#define WGL_ARB_create_context_profile 1
#define WGL_CONTEXT_PROFILE_MASK_ARB      0x9126
#define WGL_CONTEXT_CORE_PROFILE_BIT_ARB  0x00000001
#define WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB 0x00000002
#define ERROR_INVALID_PROFILE_ARB         0x2096
#endif /* WGL_ARB_create_context_profile */

#ifndef WGL_ARB_create_context_robustness
#define WGL_ARB_create_context_robustness 1
#define WGL_CONTEXT_ROBUST_ACCESS_BIT_ARB 0x00000004
#define WGL_LOSE_CONTEXT_ON_RESET_ARB     0x8252
#define WGL_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB 0x8256
#define WGL_NO_RESET_NOTIFICATION_ARB     0x8261
#endif /* WGL_ARB_create_context_robustness */

#ifndef WGL_ARB_extensions_string
#define WGL_ARB_extensions_string 1
typedef const char *(WINAPI * PFNWGLGETEXTENSIONSSTRINGARBPROC) (HDC hdc);
#ifdef WGL_WGLEXT_PROTOTYPES
const char *WINAPI wglGetExtensionsStringARB (HDC hdc);
#endif
#endif /* WGL_ARB_extensions_string */

#ifndef WGL_ARB_framebuffer_sRGB
#define WGL_ARB_framebuffer_sRGB 1
#define WGL_FRAMEBUFFER_SRGB_CAPABLE_ARB  0x20A9
#endif /* WGL_ARB_framebuffer_sRGB */

#ifndef WGL_ARB_make_current_read
#define WGL_ARB_make_current_read 1
#define ERROR_INVALID_PIXEL_TYPE_ARB      0x2043
#define ERROR_INCOMPATIBLE_DEVICE_CONTEXTS_ARB 0x2054
typedef BOOL (WINAPI * PFNWGLMAKECONTEXTCURRENTARBPROC) (HDC hDrawDC, HDC hReadDC, HGLRC hglrc);
typedef HDC (WINAPI * PFNWGLGETCURRENTREADDCARBPROC) (void);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglMakeContextCurrentARB (HDC hDrawDC, HDC hReadDC, HGLRC hglrc);
HDC WINAPI wglGetCurrentReadDCARB (void);
#endif
#endif /* WGL_ARB_make_current_read */

#ifndef WGL_ARB_multisample
#define WGL_ARB_multisample 1
#define WGL_SAMPLE_BUFFERS_ARB            0x2041
#define WGL_SAMPLES_ARB                   0x2042
#endif /* WGL_ARB_multisample */

#ifndef WGL_ARB_pbuffer
#define WGL_ARB_pbuffer 1
DECLARE_HANDLE(HPBUFFERARB);
#define WGL_DRAW_TO_PBUFFER_ARB           0x202D
#define WGL_MAX_PBUFFER_PIXELS_ARB        0x202E
#define WGL_MAX_PBUFFER_WIDTH_ARB         0x202F
#define WGL_MAX_PBUFFER_HEIGHT_ARB        0x2030
#define WGL_PBUFFER_LARGEST_ARB           0x2033
#define WGL_PBUFFER_WIDTH_ARB             0x2034
#define WGL_PBUFFER_HEIGHT_ARB            0x2035
#define WGL_PBUFFER_LOST_ARB              0x2036
typedef HPBUFFERARB (WINAPI * PFNWGLCREATEPBUFFERARBPROC) (HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *piAttribList);
typedef HDC (WINAPI * PFNWGLGETPBUFFERDCARBPROC) (HPBUFFERARB hPbuffer);
typedef int (WINAPI * PFNWGLRELEASEPBUFFERDCARBPROC) (HPBUFFERARB hPbuffer, HDC hDC);
typedef BOOL (WINAPI * PFNWGLDESTROYPBUFFERARBPROC) (HPBUFFERARB hPbuffer);
typedef BOOL (WINAPI * PFNWGLQUERYPBUFFERARBPROC) (HPBUFFERARB hPbuffer, int iAttribute, int *piValue);
#ifdef WGL_WGLEXT_PROTOTYPES
HPBUFFERARB WINAPI wglCreatePbufferARB (HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *piAttribList);
HDC WINAPI wglGetPbufferDCARB (HPBUFFERARB hPbuffer);
int WINAPI wglReleasePbufferDCARB (HPBUFFERARB hPbuffer, HDC hDC);
BOOL WINAPI wglDestroyPbufferARB (HPBUFFERARB hPbuffer);
BOOL WINAPI wglQueryPbufferARB (HPBUFFERARB hPbuffer, int iAttribute, int *piValue);
#endif
#endif /* WGL_ARB_pbuffer */

#ifndef WGL_ARB_pixel_format
#define WGL_ARB_pixel_format 1
#define WGL_NUMBER_PIXEL_FORMATS_ARB      0x2000
#define WGL_DRAW_TO_WINDOW_ARB            0x2001
#define WGL_DRAW_TO_BITMAP_ARB            0x2002
#define WGL_ACCELERATION_ARB              0x2003
#define WGL_NEED_PALETTE_ARB              0x2004
#define WGL_NEED_SYSTEM_PALETTE_ARB       0x2005
#define WGL_SWAP_LAYER_BUFFERS_ARB        0x2006
#define WGL_SWAP_METHOD_ARB               0x2007
#define WGL_NUMBER_OVERLAYS_ARB           0x2008
#define WGL_NUMBER_UNDERLAYS_ARB          0x2009
#define WGL_TRANSPARENT_ARB               0x200A
#define WGL_TRANSPARENT_RED_VALUE_ARB     0x2037
#define WGL_TRANSPARENT_GREEN_VALUE_ARB   0x2038
#define WGL_TRANSPARENT_BLUE_VALUE_ARB    0x2039
#define WGL_TRANSPARENT_ALPHA_VALUE_ARB   0x203A
#define WGL_TRANSPARENT_INDEX_VALUE_ARB   0x203B
#define WGL_SHARE_DEPTH_ARB               0x200C
#define WGL_SHARE_STENCIL_ARB             0x200D
#define WGL_SHARE_ACCUM_ARB               0x200E
#define WGL_SUPPORT_GDI_ARB               0x200F
#define WGL_SUPPORT_OPENGL_ARB            0x2010
#define WGL_DOUBLE_BUFFER_ARB             0x2011
#define WGL_STEREO_ARB                    0x2012
#define WGL_PIXEL_TYPE_ARB                0x2013
#define WGL_COLOR_BITS_ARB                0x2014
#define WGL_RED_BITS_ARB                  0x2015
#define WGL_RED_SHIFT_ARB                 0x2016
#define WGL_GREEN_BITS_ARB                0x2017
#define WGL_GREEN_SHIFT_ARB               0x2018
#define WGL_BLUE_BITS_ARB                 0x2019
#define WGL_BLUE_SHIFT_ARB                0x201A
#define WGL_ALPHA_BITS_ARB                0x201B
#define WGL_ALPHA_SHIFT_ARB               0x201C
#define WGL_ACCUM_BITS_ARB                0x201D
#define WGL_ACCUM_RED_BITS_ARB            0x201E
#define WGL_ACCUM_GREEN_BITS_ARB          0x201F
#define WGL_ACCUM_BLUE_BITS_ARB           0x2020
#define WGL_ACCUM_ALPHA_BITS_ARB          0x2021
#define WGL_DEPTH_BITS_ARB                0x2022
#define WGL_STENCIL_BITS_ARB              0x2023
#define WGL_AUX_BUFFERS_ARB               0x2024
#define WGL_NO_ACCELERATION_ARB           0x2025
#define WGL_GENERIC_ACCELERATION_ARB      0x2026
#define WGL_FULL_ACCELERATION_ARB         0x2027
#define WGL_SWAP_EXCHANGE_ARB             0x2028
#define WGL_SWAP_COPY_ARB                 0x2029
#define WGL_SWAP_UNDEFINED_ARB            0x202A
#define WGL_TYPE_RGBA_ARB                 0x202B
#define WGL_TYPE_COLORINDEX_ARB           0x202C
typedef BOOL (WINAPI * PFNWGLGETPIXELFORMATATTRIBIVARBPROC) (HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *piAttributes, int *piValues);
typedef BOOL (WINAPI * PFNWGLGETPIXELFORMATATTRIBFVARBPROC) (HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *piAttributes, FLOAT *pfValues);
typedef BOOL (WINAPI * PFNWGLCHOOSEPIXELFORMATARBPROC) (HDC hdc, const int *piAttribIList, const FLOAT *pfAttribFList, UINT nMaxFormats, int *piFormats, UINT *nNumFormats);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglGetPixelFormatAttribivARB (HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *piAttributes, int *piValues);
BOOL WINAPI wglGetPixelFormatAttribfvARB (HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *piAttributes, FLOAT *pfValues);
BOOL WINAPI wglChoosePixelFormatARB (HDC hdc, const int *piAttribIList, const FLOAT *pfAttribFList, UINT nMaxFormats, int *piFormats, UINT *nNumFormats);
#endif
#endif /* WGL_ARB_pixel_format */

#ifndef WGL_ARB_pixel_format_float
#define WGL_ARB_pixel_format_float 1
#define WGL_TYPE_RGBA_FLOAT_ARB           0x21A0
#endif /* WGL_ARB_pixel_format_float */

#ifndef WGL_ARB_render_texture
#define WGL_ARB_render_texture 1
#define WGL_BIND_TO_TEXTURE_RGB_ARB       0x2070
#define WGL_BIND_TO_TEXTURE_RGBA_ARB      0x2071
#define WGL_TEXTURE_FORMAT_ARB            0x2072
#define WGL_TEXTURE_TARGET_ARB            0x2073
#define WGL_MIPMAP_TEXTURE_ARB            0x2074
#define WGL_TEXTURE_RGB_ARB               0x2075
#define WGL_TEXTURE_RGBA_ARB              0x2076
#define WGL_NO_TEXTURE_ARB                0x2077
#define WGL_TEXTURE_CUBE_MAP_ARB          0x2078
#define WGL_TEXTURE_1D_ARB                0x2079
#define WGL_TEXTURE_2D_ARB                0x207A
#define WGL_MIPMAP_LEVEL_ARB              0x207B
#define WGL_CUBE_MAP_FACE_ARB             0x207C
#define WGL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB 0x207D
#define WGL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB 0x207E
#define WGL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB 0x207F
#define WGL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB 0x2080
#define WGL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB 0x2081
#define WGL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB 0x2082
#define WGL_FRONT_LEFT_ARB                0x2083
#define WGL_FRONT_RIGHT_ARB               0x2084
#define WGL_BACK_LEFT_ARB                 0x2085
#define WGL_BACK_RIGHT_ARB                0x2086
#define WGL_AUX0_ARB                      0x2087
#define WGL_AUX1_ARB                      0x2088
#define WGL_AUX2_ARB                      0x2089
#define WGL_AUX3_ARB                      0x208A
#define WGL_AUX4_ARB                      0x208B
#define WGL_AUX5_ARB                      0x208C
#define WGL_AUX6_ARB                      0x208D
#define WGL_AUX7_ARB                      0x208E
#define WGL_AUX8_ARB                      0x208F
#define WGL_AUX9_ARB                      0x2090
typedef BOOL (WINAPI * PFNWGLBINDTEXIMAGEARBPROC) (HPBUFFERARB hPbuffer, int iBuffer);
typedef BOOL (WINAPI * PFNWGLRELEASETEXIMAGEARBPROC) (HPBUFFERARB hPbuffer, int iBuffer);
typedef BOOL (WINAPI * PFNWGLSETPBUFFERATTRIBARBPROC) (HPBUFFERARB hPbuffer, const int *piAttribList);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglBindTexImageARB (HPBUFFERARB hPbuffer, int iBuffer);
BOOL WINAPI wglReleaseTexImageARB (HPBUFFERARB hPbuffer, int iBuffer);
BOOL WINAPI wglSetPbufferAttribARB (HPBUFFERARB hPbuffer, const int *piAttribList);
#endif
#endif /* WGL_ARB_render_texture */

#ifndef WGL_ARB_robustness_application_isolation
#define WGL_ARB_robustness_application_isolation 1
#define WGL_CONTEXT_RESET_ISOLATION_BIT_ARB 0x00000008
#endif /* WGL_ARB_robustness_application_isolation */

#ifndef WGL_ARB_robustness_share_group_isolation
#define WGL_ARB_robustness_share_group_isolation 1
#endif /* WGL_ARB_robustness_share_group_isolation */

#ifndef WGL_3DFX_multisample
#define WGL_3DFX_multisample 1
#define WGL_SAMPLE_BUFFERS_3DFX           0x2060
#define WGL_SAMPLES_3DFX                  0x2061
#endif /* WGL_3DFX_multisample */

#ifndef WGL_3DL_stereo_control
#define WGL_3DL_stereo_control 1
#define WGL_STEREO_EMITTER_ENABLE_3DL     0x2055
#define WGL_STEREO_EMITTER_DISABLE_3DL    0x2056
#define WGL_STEREO_POLARITY_NORMAL_3DL    0x2057
#define WGL_STEREO_POLARITY_INVERT_3DL    0x2058
typedef BOOL (WINAPI * PFNWGLSETSTEREOEMITTERSTATE3DLPROC) (HDC hDC, UINT uState);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglSetStereoEmitterState3DL (HDC hDC, UINT uState);
#endif
#endif /* WGL_3DL_stereo_control */

#ifndef WGL_AMD_gpu_association
#define WGL_AMD_gpu_association 1
#define WGL_GPU_VENDOR_AMD                0x1F00
#define WGL_GPU_RENDERER_STRING_AMD       0x1F01
#define WGL_GPU_OPENGL_VERSION_STRING_AMD 0x1F02
#define WGL_GPU_FASTEST_TARGET_GPUS_AMD   0x21A2
#define WGL_GPU_RAM_AMD                   0x21A3
#define WGL_GPU_CLOCK_AMD                 0x21A4
#define WGL_GPU_NUM_PIPES_AMD             0x21A5
#define WGL_GPU_NUM_SIMD_AMD              0x21A6
#define WGL_GPU_NUM_RB_AMD                0x21A7
#define WGL_GPU_NUM_SPI_AMD               0x21A8
typedef UINT (WINAPI * PFNWGLGETGPUIDSAMDPROC) (UINT maxCount, UINT *ids);
typedef INT (WINAPI * PFNWGLGETGPUINFOAMDPROC) (UINT id, int property, GLenum dataType, UINT size, void *data);
typedef UINT (WINAPI * PFNWGLGETCONTEXTGPUIDAMDPROC) (HGLRC hglrc);
typedef HGLRC (WINAPI * PFNWGLCREATEASSOCIATEDCONTEXTAMDPROC) (UINT id);
typedef HGLRC (WINAPI * PFNWGLCREATEASSOCIATEDCONTEXTATTRIBSAMDPROC) (UINT id, HGLRC hShareContext, const int *attribList);
typedef BOOL (WINAPI * PFNWGLDELETEASSOCIATEDCONTEXTAMDPROC) (HGLRC hglrc);
typedef BOOL (WINAPI * PFNWGLMAKEASSOCIATEDCONTEXTCURRENTAMDPROC) (HGLRC hglrc);
typedef HGLRC (WINAPI * PFNWGLGETCURRENTASSOCIATEDCONTEXTAMDPROC) (void);
typedef VOID (WINAPI * PFNWGLBLITCONTEXTFRAMEBUFFERAMDPROC) (HGLRC dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
#ifdef WGL_WGLEXT_PROTOTYPES
UINT WINAPI wglGetGPUIDsAMD (UINT maxCount, UINT *ids);
INT WINAPI wglGetGPUInfoAMD (UINT id, int property, GLenum dataType, UINT size, void *data);
UINT WINAPI wglGetContextGPUIDAMD (HGLRC hglrc);
HGLRC WINAPI wglCreateAssociatedContextAMD (UINT id);
HGLRC WINAPI wglCreateAssociatedContextAttribsAMD (UINT id, HGLRC hShareContext, const int *attribList);
BOOL WINAPI wglDeleteAssociatedContextAMD (HGLRC hglrc);
BOOL WINAPI wglMakeAssociatedContextCurrentAMD (HGLRC hglrc);
HGLRC WINAPI wglGetCurrentAssociatedContextAMD (void);
VOID WINAPI wglBlitContextFramebufferAMD (HGLRC dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
#endif
#endif /* WGL_AMD_gpu_association */

#ifndef WGL_ATI_pixel_format_float
#define WGL_ATI_pixel_format_float 1
#define WGL_TYPE_RGBA_FLOAT_ATI           0x21A0
#endif /* WGL_ATI_pixel_format_float */

#ifndef WGL_EXT_colorspace
#define WGL_EXT_colorspace 1
#define WGL_COLORSPACE_EXT                0x3087
#define WGL_COLORSPACE_SRGB_EXT           0x3089
#define WGL_COLORSPACE_LINEAR_EXT         0x308A
#endif /* WGL_EXT_colorspace */

#ifndef WGL_EXT_create_context_es2_profile
#define WGL_EXT_create_context_es2_profile 1
#define WGL_CONTEXT_ES2_PROFILE_BIT_EXT   0x00000004
#endif /* WGL_EXT_create_context_es2_profile */

#ifndef WGL_EXT_create_context_es_profile
#define WGL_EXT_create_context_es_profile 1
#define WGL_CONTEXT_ES_PROFILE_BIT_EXT    0x00000004
#endif /* WGL_EXT_create_context_es_profile */

#ifndef WGL_EXT_depth_float
#define WGL_EXT_depth_float 1
#define WGL_DEPTH_FLOAT_EXT               0x2040
#endif /* WGL_EXT_depth_float */

#ifndef WGL_EXT_display_color_table
#define WGL_EXT_display_color_table 1
typedef GLboolean (WINAPI * PFNWGLCREATEDISPLAYCOLORTABLEEXTPROC) (GLushort id);
typedef GLboolean (WINAPI * PFNWGLLOADDISPLAYCOLORTABLEEXTPROC) (const GLushort *table, GLuint length);
typedef GLboolean (WINAPI * PFNWGLBINDDISPLAYCOLORTABLEEXTPROC) (GLushort id);
typedef VOID (WINAPI * PFNWGLDESTROYDISPLAYCOLORTABLEEXTPROC) (GLushort id);
#ifdef WGL_WGLEXT_PROTOTYPES
GLboolean WINAPI wglCreateDisplayColorTableEXT (GLushort id);
GLboolean WINAPI wglLoadDisplayColorTableEXT (const GLushort *table, GLuint length);
GLboolean WINAPI wglBindDisplayColorTableEXT (GLushort id);
VOID WINAPI wglDestroyDisplayColorTableEXT (GLushort id);
#endif
#endif /* WGL_EXT_display_color_table */

#ifndef WGL_EXT_extensions_string
#define WGL_EXT_extensions_string 1
typedef const char *(WINAPI * PFNWGLGETEXTENSIONSSTRINGEXTPROC) (void);
#ifdef WGL_WGLEXT_PROTOTYPES
const char *WINAPI wglGetExtensionsStringEXT (void);
#endif
#endif /* WGL_EXT_extensions_string */

#ifndef WGL_EXT_framebuffer_sRGB
#define WGL_EXT_framebuffer_sRGB 1
#define WGL_FRAMEBUFFER_SRGB_CAPABLE_EXT  0x20A9
#endif /* WGL_EXT_framebuffer_sRGB */

#ifndef WGL_EXT_make_current_read
#define WGL_EXT_make_current_read 1
#define ERROR_INVALID_PIXEL_TYPE_EXT      0x2043
typedef BOOL (WINAPI * PFNWGLMAKECONTEXTCURRENTEXTPROC) (HDC hDrawDC, HDC hReadDC, HGLRC hglrc);
typedef HDC (WINAPI * PFNWGLGETCURRENTREADDCEXTPROC) (void);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglMakeContextCurrentEXT (HDC hDrawDC, HDC hReadDC, HGLRC hglrc);
HDC WINAPI wglGetCurrentReadDCEXT (void);
#endif
#endif /* WGL_EXT_make_current_read */

#ifndef WGL_EXT_multisample
#define WGL_EXT_multisample 1
#define WGL_SAMPLE_BUFFERS_EXT            0x2041
#define WGL_SAMPLES_EXT                   0x2042
#endif /* WGL_EXT_multisample */

#ifndef WGL_EXT_pbuffer
#define WGL_EXT_pbuffer 1
DECLARE_HANDLE(HPBUFFEREXT);
#define WGL_DRAW_TO_PBUFFER_EXT           0x202D
#define WGL_MAX_PBUFFER_PIXELS_EXT        0x202E
#define WGL_MAX_PBUFFER_WIDTH_EXT         0x202F
#define WGL_MAX_PBUFFER_HEIGHT_EXT        0x2030
#define WGL_OPTIMAL_PBUFFER_WIDTH_EXT     0x2031
#define WGL_OPTIMAL_PBUFFER_HEIGHT_EXT    0x2032
#define WGL_PBUFFER_LARGEST_EXT           0x2033
#define WGL_PBUFFER_WIDTH_EXT             0x2034
#define WGL_PBUFFER_HEIGHT_EXT            0x2035
typedef HPBUFFEREXT (WINAPI * PFNWGLCREATEPBUFFEREXTPROC) (HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *piAttribList);
typedef HDC (WINAPI * PFNWGLGETPBUFFERDCEXTPROC) (HPBUFFEREXT hPbuffer);
typedef int (WINAPI * PFNWGLRELEASEPBUFFERDCEXTPROC) (HPBUFFEREXT hPbuffer, HDC hDC);
typedef BOOL (WINAPI * PFNWGLDESTROYPBUFFEREXTPROC) (HPBUFFEREXT hPbuffer);
typedef BOOL (WINAPI * PFNWGLQUERYPBUFFEREXTPROC) (HPBUFFEREXT hPbuffer, int iAttribute, int *piValue);
#ifdef WGL_WGLEXT_PROTOTYPES
HPBUFFEREXT WINAPI wglCreatePbufferEXT (HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *piAttribList);
HDC WINAPI wglGetPbufferDCEXT (HPBUFFEREXT hPbuffer);
int WINAPI wglReleasePbufferDCEXT (HPBUFFEREXT hPbuffer, HDC hDC);
BOOL WINAPI wglDestroyPbufferEXT (HPBUFFEREXT hPbuffer);
BOOL WINAPI wglQueryPbufferEXT (HPBUFFEREXT hPbuffer, int iAttribute, int *piValue);
#endif
#endif /* WGL_EXT_pbuffer */

#ifndef WGL_EXT_pixel_format
#define WGL_EXT_pixel_format 1
#define WGL_NUMBER_PIXEL_FORMATS_EXT      0x2000
#define WGL_DRAW_TO_WINDOW_EXT            0x2001
#define WGL_DRAW_TO_BITMAP_EXT            0x2002
#define WGL_ACCELERATION_EXT              0x2003
#define WGL_NEED_PALETTE_EXT              0x2004
#define WGL_NEED_SYSTEM_PALETTE_EXT       0x2005
#define WGL_SWAP_LAYER_BUFFERS_EXT        0x2006
#define WGL_SWAP_METHOD_EXT               0x2007
#define WGL_NUMBER_OVERLAYS_EXT           0x2008
#define WGL_NUMBER_UNDERLAYS_EXT          0x2009
#define WGL_TRANSPARENT_EXT               0x200A
#define WGL_TRANSPARENT_VALUE_EXT         0x200B
#define WGL_SHARE_DEPTH_EXT               0x200C
#define WGL_SHARE_STENCIL_EXT             0x200D
#define WGL_SHARE_ACCUM_EXT               0x200E
#define WGL_SUPPORT_GDI_EXT               0x200F
#define WGL_SUPPORT_OPENGL_EXT            0x2010
#define WGL_DOUBLE_BUFFER_EXT             0x2011
#define WGL_STEREO_EXT                    0x2012
#define WGL_PIXEL_TYPE_EXT                0x2013
#define WGL_COLOR_BITS_EXT                0x2014
#define WGL_RED_BITS_EXT                  0x2015
#define WGL_RED_SHIFT_EXT                 0x2016
#define WGL_GREEN_BITS_EXT                0x2017
#define WGL_GREEN_SHIFT_EXT               0x2018
#define WGL_BLUE_BITS_EXT                 0x2019
#define WGL_BLUE_SHIFT_EXT                0x201A
#define WGL_ALPHA_BITS_EXT                0x201B
#define WGL_ALPHA_SHIFT_EXT               0x201C
#define WGL_ACCUM_BITS_EXT                0x201D
#define WGL_ACCUM_RED_BITS_EXT            0x201E
#define WGL_ACCUM_GREEN_BITS_EXT          0x201F
#define WGL_ACCUM_BLUE_BITS_EXT           0x2020
#define WGL_ACCUM_ALPHA_BITS_EXT          0x2021
#define WGL_DEPTH_BITS_EXT                0x2022
#define WGL_STENCIL_BITS_EXT              0x2023
#define WGL_AUX_BUFFERS_EXT               0x2024
#define WGL_NO_ACCELERATION_EXT           0x2025
#define WGL_GENERIC_ACCELERATION_EXT      0x2026
#define WGL_FULL_ACCELERATION_EXT         0x2027
#define WGL_SWAP_EXCHANGE_EXT             0x2028
#define WGL_SWAP_COPY_EXT                 0x2029
#define WGL_SWAP_UNDEFINED_EXT            0x202A
#define WGL_TYPE_RGBA_EXT                 0x202B
#define WGL_TYPE_COLORINDEX_EXT           0x202C
typedef BOOL (WINAPI * PFNWGLGETPIXELFORMATATTRIBIVEXTPROC) (HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *piAttributes, int *piValues);
typedef BOOL (WINAPI * PFNWGLGETPIXELFORMATATTRIBFVEXTPROC) (HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *piAttributes, FLOAT *pfValues);
typedef BOOL (WINAPI * PFNWGLCHOOSEPIXELFORMATEXTPROC) (HDC hdc, const int *piAttribIList, const FLOAT *pfAttribFList, UINT nMaxFormats, int *piFormats, UINT *nNumFormats);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglGetPixelFormatAttribivEXT (HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *piAttributes, int *piValues);
BOOL WINAPI wglGetPixelFormatAttribfvEXT (HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *piAttributes, FLOAT *pfValues);
BOOL WINAPI wglChoosePixelFormatEXT (HDC hdc, const int *piAttribIList, const FLOAT *pfAttribFList, UINT nMaxFormats, int *piFormats, UINT *nNumFormats);
#endif
#endif /* WGL_EXT_pixel_format */

#ifndef WGL_EXT_pixel_format_packed_float
#define WGL_EXT_pixel_format_packed_float 1
#define WGL_TYPE_RGBA_UNSIGNED_FLOAT_EXT  0x20A8
#endif /* WGL_EXT_pixel_format_packed_float */

#ifndef WGL_EXT_swap_control
#define WGL_EXT_swap_control 1
typedef BOOL (WINAPI * PFNWGLSWAPINTERVALEXTPROC) (int interval);
typedef int (WINAPI * PFNWGLGETSWAPINTERVALEXTPROC) (void);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglSwapIntervalEXT (int interval);
int WINAPI wglGetSwapIntervalEXT (void);
#endif
#endif /* WGL_EXT_swap_control */

#ifndef WGL_EXT_swap_control_tear
#define WGL_EXT_swap_control_tear 1
#endif /* WGL_EXT_swap_control_tear */

#ifndef WGL_I3D_digital_video_control
#define WGL_I3D_digital_video_control 1
#define WGL_DIGITAL_VIDEO_CURSOR_ALPHA_FRAMEBUFFER_I3D 0x2050
#define WGL_DIGITAL_VIDEO_CURSOR_ALPHA_VALUE_I3D 0x2051
#define WGL_DIGITAL_VIDEO_CURSOR_INCLUDED_I3D 0x2052
#define WGL_DIGITAL_VIDEO_GAMMA_CORRECTED_I3D 0x2053
typedef BOOL (WINAPI * PFNWGLGETDIGITALVIDEOPARAMETERSI3DPROC) (HDC hDC, int iAttribute, int *piValue);
typedef BOOL (WINAPI * PFNWGLSETDIGITALVIDEOPARAMETERSI3DPROC) (HDC hDC, int iAttribute, const int *piValue);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglGetDigitalVideoParametersI3D (HDC hDC, int iAttribute, int *piValue);
BOOL WINAPI wglSetDigitalVideoParametersI3D (HDC hDC, int iAttribute, const int *piValue);
#endif
#endif /* WGL_I3D_digital_video_control */

#ifndef WGL_I3D_gamma
#define WGL_I3D_gamma 1
#define WGL_GAMMA_TABLE_SIZE_I3D          0x204E
#define WGL_GAMMA_EXCLUDE_DESKTOP_I3D     0x204F
typedef BOOL (WINAPI * PFNWGLGETGAMMATABLEPARAMETERSI3DPROC) (HDC hDC, int iAttribute, int *piValue);
typedef BOOL (WINAPI * PFNWGLSETGAMMATABLEPARAMETERSI3DPROC) (HDC hDC, int iAttribute, const int *piValue);
typedef BOOL (WINAPI * PFNWGLGETGAMMATABLEI3DPROC) (HDC hDC, int iEntries, USHORT *puRed, USHORT *puGreen, USHORT *puBlue);
typedef BOOL (WINAPI * PFNWGLSETGAMMATABLEI3DPROC) (HDC hDC, int iEntries, const USHORT *puRed, const USHORT *puGreen, const USHORT *puBlue);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglGetGammaTableParametersI3D (HDC hDC, int iAttribute, int *piValue);
BOOL WINAPI wglSetGammaTableParametersI3D (HDC hDC, int iAttribute, const int *piValue);
BOOL WINAPI wglGetGammaTableI3D (HDC hDC, int iEntries, USHORT *puRed, USHORT *puGreen, USHORT *puBlue);
BOOL WINAPI wglSetGammaTableI3D (HDC hDC, int iEntries, const USHORT *puRed, const USHORT *puGreen, const USHORT *puBlue);
#endif
#endif /* WGL_I3D_gamma */

#ifndef WGL_I3D_genlock
#define WGL_I3D_genlock 1
#define WGL_GENLOCK_SOURCE_MULTIVIEW_I3D  0x2044
#define WGL_GENLOCK_SOURCE_EXTERNAL_SYNC_I3D 0x2045
#define WGL_GENLOCK_SOURCE_EXTERNAL_FIELD_I3D 0x2046
#define WGL_GENLOCK_SOURCE_EXTERNAL_TTL_I3D 0x2047
#define WGL_GENLOCK_SOURCE_DIGITAL_SYNC_I3D 0x2048
#define WGL_GENLOCK_SOURCE_DIGITAL_FIELD_I3D 0x2049
#define WGL_GENLOCK_SOURCE_EDGE_FALLING_I3D 0x204A
#define WGL_GENLOCK_SOURCE_EDGE_RISING_I3D 0x204B
#define WGL_GENLOCK_SOURCE_EDGE_BOTH_I3D  0x204C
typedef BOOL (WINAPI * PFNWGLENABLEGENLOCKI3DPROC) (HDC hDC);
typedef BOOL (WINAPI * PFNWGLDISABLEGENLOCKI3DPROC) (HDC hDC);
typedef BOOL (WINAPI * PFNWGLISENABLEDGENLOCKI3DPROC) (HDC hDC, BOOL *pFlag);
typedef BOOL (WINAPI * PFNWGLGENLOCKSOURCEI3DPROC) (HDC hDC, UINT uSource);
typedef BOOL (WINAPI * PFNWGLGETGENLOCKSOURCEI3DPROC) (HDC hDC, UINT *uSource);
typedef BOOL (WINAPI * PFNWGLGENLOCKSOURCEEDGEI3DPROC) (HDC hDC, UINT uEdge);
typedef BOOL (WINAPI * PFNWGLGETGENLOCKSOURCEEDGEI3DPROC) (HDC hDC, UINT *uEdge);
typedef BOOL (WINAPI * PFNWGLGENLOCKSAMPLERATEI3DPROC) (HDC hDC, UINT uRate);
typedef BOOL (WINAPI * PFNWGLGETGENLOCKSAMPLERATEI3DPROC) (HDC hDC, UINT *uRate);
typedef BOOL (WINAPI * PFNWGLGENLOCKSOURCEDELAYI3DPROC) (HDC hDC, UINT uDelay);
typedef BOOL (WINAPI * PFNWGLGETGENLOCKSOURCEDELAYI3DPROC) (HDC hDC, UINT *uDelay);
typedef BOOL (WINAPI * PFNWGLQUERYGENLOCKMAXSOURCEDELAYI3DPROC) (HDC hDC, UINT *uMaxLineDelay, UINT *uMaxPixelDelay);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglEnableGenlockI3D (HDC hDC);
BOOL WINAPI wglDisableGenlockI3D (HDC hDC);
BOOL WINAPI wglIsEnabledGenlockI3D (HDC hDC, BOOL *pFlag);
BOOL WINAPI wglGenlockSourceI3D (HDC hDC, UINT uSource);
BOOL WINAPI wglGetGenlockSourceI3D (HDC hDC, UINT *uSource);
BOOL WINAPI wglGenlockSourceEdgeI3D (HDC hDC, UINT uEdge);
BOOL WINAPI wglGetGenlockSourceEdgeI3D (HDC hDC, UINT *uEdge);
BOOL WINAPI wglGenlockSampleRateI3D (HDC hDC, UINT uRate);
BOOL WINAPI wglGetGenlockSampleRateI3D (HDC hDC, UINT *uRate);
BOOL WINAPI wglGenlockSourceDelayI3D (HDC hDC, UINT uDelay);
BOOL WINAPI wglGetGenlockSourceDelayI3D (HDC hDC, UINT *uDelay);
BOOL WINAPI wglQueryGenlockMaxSourceDelayI3D (HDC hDC, UINT *uMaxLineDelay, UINT *uMaxPixelDelay);
#endif
#endif /* WGL_I3D_genlock */

#ifndef WGL_I3D_image_buffer
#define WGL_I3D_image_buffer 1
#define WGL_IMAGE_BUFFER_MIN_ACCESS_I3D   0x00000001
#define WGL_IMAGE_BUFFER_LOCK_I3D         0x00000002
typedef LPVOID (WINAPI * PFNWGLCREATEIMAGEBUFFERI3DPROC) (HDC hDC, DWORD dwSize, UINT uFlags);
typedef BOOL (WINAPI * PFNWGLDESTROYIMAGEBUFFERI3DPROC) (HDC hDC, LPVOID pAddress);
typedef BOOL (WINAPI * PFNWGLASSOCIATEIMAGEBUFFEREVENTSI3DPROC) (HDC hDC, const HANDLE *pEvent, const LPVOID *pAddress, const DWORD *pSize, UINT count);
typedef BOOL (WINAPI * PFNWGLRELEASEIMAGEBUFFEREVENTSI3DPROC) (HDC hDC, const LPVOID *pAddress, UINT count);
#ifdef WGL_WGLEXT_PROTOTYPES
LPVOID WINAPI wglCreateImageBufferI3D (HDC hDC, DWORD dwSize, UINT uFlags);
BOOL WINAPI wglDestroyImageBufferI3D (HDC hDC, LPVOID pAddress);
BOOL WINAPI wglAssociateImageBufferEventsI3D (HDC hDC, const HANDLE *pEvent, const LPVOID *pAddress, const DWORD *pSize, UINT count);
BOOL WINAPI wglReleaseImageBufferEventsI3D (HDC hDC, const LPVOID *pAddress, UINT count);
#endif
#endif /* WGL_I3D_image_buffer */

#ifndef WGL_I3D_swap_frame_lock
#define WGL_I3D_swap_frame_lock 1
typedef BOOL (WINAPI * PFNWGLENABLEFRAMELOCKI3DPROC) (void);
typedef BOOL (WINAPI * PFNWGLDISABLEFRAMELOCKI3DPROC) (void);
typedef BOOL (WINAPI * PFNWGLISENABLEDFRAMELOCKI3DPROC) (BOOL *pFlag);
typedef BOOL (WINAPI * PFNWGLQUERYFRAMELOCKMASTERI3DPROC) (BOOL *pFlag);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglEnableFrameLockI3D (void);
BOOL WINAPI wglDisableFrameLockI3D (void);
BOOL WINAPI wglIsEnabledFrameLockI3D (BOOL *pFlag);
BOOL WINAPI wglQueryFrameLockMasterI3D (BOOL *pFlag);
#endif
#endif /* WGL_I3D_swap_frame_lock */

#ifndef WGL_I3D_swap_frame_usage
#define WGL_I3D_swap_frame_usage 1
typedef BOOL (WINAPI * PFNWGLGETFRAMEUSAGEI3DPROC) (float *pUsage);
typedef BOOL (WINAPI * PFNWGLBEGINFRAMETRACKINGI3DPROC) (void);
typedef BOOL (WINAPI * PFNWGLENDFRAMETRACKINGI3DPROC) (void);
typedef BOOL (WINAPI * PFNWGLQUERYFRAMETRACKINGI3DPROC) (DWORD *pFrameCount, DWORD *pMissedFrames, float *pLastMissedUsage);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglGetFrameUsageI3D (float *pUsage);
BOOL WINAPI wglBeginFrameTrackingI3D (void);
BOOL WINAPI wglEndFrameTrackingI3D (void);
BOOL WINAPI wglQueryFrameTrackingI3D (DWORD *pFrameCount, DWORD *pMissedFrames, float *pLastMissedUsage);
#endif
#endif /* WGL_I3D_swap_frame_usage */

#ifndef WGL_NV_DX_interop
#define WGL_NV_DX_interop 1
#define WGL_ACCESS_READ_ONLY_NV           0x00000000
#define WGL_ACCESS_READ_WRITE_NV          0x00000001
#define WGL_ACCESS_WRITE_DISCARD_NV       0x00000002
typedef BOOL (WINAPI * PFNWGLDXSETRESOURCESHAREHANDLENVPROC) (void *dxObject, HANDLE shareHandle);
typedef HANDLE (WINAPI * PFNWGLDXOPENDEVICENVPROC) (void *dxDevice);
typedef BOOL (WINAPI * PFNWGLDXCLOSEDEVICENVPROC) (HANDLE hDevice);
typedef HANDLE (WINAPI * PFNWGLDXREGISTEROBJECTNVPROC) (HANDLE hDevice, void *dxObject, GLuint name, GLenum type, GLenum access);
typedef BOOL (WINAPI * PFNWGLDXUNREGISTEROBJECTNVPROC) (HANDLE hDevice, HANDLE hObject);
typedef BOOL (WINAPI * PFNWGLDXOBJECTACCESSNVPROC) (HANDLE hObject, GLenum access);
typedef BOOL (WINAPI * PFNWGLDXLOCKOBJECTSNVPROC) (HANDLE hDevice, GLint count, HANDLE *hObjects);
typedef BOOL (WINAPI * PFNWGLDXUNLOCKOBJECTSNVPROC) (HANDLE hDevice, GLint count, HANDLE *hObjects);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglDXSetResourceShareHandleNV (void *dxObject, HANDLE shareHandle);
HANDLE WINAPI wglDXOpenDeviceNV (void *dxDevice);
BOOL WINAPI wglDXCloseDeviceNV (HANDLE hDevice);
HANDLE WINAPI wglDXRegisterObjectNV (HANDLE hDevice, void *dxObject, GLuint name, GLenum type, GLenum access);
BOOL WINAPI wglDXUnregisterObjectNV (HANDLE hDevice, HANDLE hObject);
BOOL WINAPI wglDXObjectAccessNV (HANDLE hObject, GLenum access);
BOOL WINAPI wglDXLockObjectsNV (HANDLE hDevice, GLint count, HANDLE *hObjects);
BOOL WINAPI wglDXUnlockObjectsNV (HANDLE hDevice, GLint count, HANDLE *hObjects);
#endif
#endif /* WGL_NV_DX_interop */

#ifndef WGL_NV_DX_interop2
#define WGL_NV_DX_interop2 1
#endif /* WGL_NV_DX_interop2 */

#ifndef WGL_NV_copy_image
#define WGL_NV_copy_image 1
typedef BOOL (WINAPI * PFNWGLCOPYIMAGESUBDATANVPROC) (HGLRC hSrcRC, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, HGLRC hDstRC, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglCopyImageSubDataNV (HGLRC hSrcRC, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, HGLRC hDstRC, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
#endif
#endif /* WGL_NV_copy_image */

#ifndef WGL_NV_delay_before_swap
#define WGL_NV_delay_before_swap 1
typedef BOOL (WINAPI * PFNWGLDELAYBEFORESWAPNVPROC) (HDC hDC, GLfloat seconds);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglDelayBeforeSwapNV (HDC hDC, GLfloat seconds);
#endif
#endif /* WGL_NV_delay_before_swap */

#ifndef WGL_NV_float_buffer
#define WGL_NV_float_buffer 1
#define WGL_FLOAT_COMPONENTS_NV           0x20B0
#define WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_R_NV 0x20B1
#define WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RG_NV 0x20B2
#define WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGB_NV 0x20B3
#define WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGBA_NV 0x20B4
#define WGL_TEXTURE_FLOAT_R_NV            0x20B5
#define WGL_TEXTURE_FLOAT_RG_NV           0x20B6
#define WGL_TEXTURE_FLOAT_RGB_NV          0x20B7
#define WGL_TEXTURE_FLOAT_RGBA_NV         0x20B8
#endif /* WGL_NV_float_buffer */

#ifndef WGL_NV_gpu_affinity
#define WGL_NV_gpu_affinity 1
DECLARE_HANDLE(HGPUNV);
struct _GPU_DEVICE {
    DWORD  cb;
    CHAR   DeviceName[32];
    CHAR   DeviceString[128];
    DWORD  Flags;
    RECT   rcVirtualScreen;
};
typedef struct _GPU_DEVICE *PGPU_DEVICE;
#define ERROR_INCOMPATIBLE_AFFINITY_MASKS_NV 0x20D0
#define ERROR_MISSING_AFFINITY_MASK_NV    0x20D1
typedef BOOL (WINAPI * PFNWGLENUMGPUSNVPROC) (UINT iGpuIndex, HGPUNV *phGpu);
typedef BOOL (WINAPI * PFNWGLENUMGPUDEVICESNVPROC) (HGPUNV hGpu, UINT iDeviceIndex, PGPU_DEVICE lpGpuDevice);
typedef HDC (WINAPI * PFNWGLCREATEAFFINITYDCNVPROC) (const HGPUNV *phGpuList);
typedef BOOL (WINAPI * PFNWGLENUMGPUSFROMAFFINITYDCNVPROC) (HDC hAffinityDC, UINT iGpuIndex, HGPUNV *hGpu);
typedef BOOL (WINAPI * PFNWGLDELETEDCNVPROC) (HDC hdc);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglEnumGpusNV (UINT iGpuIndex, HGPUNV *phGpu);
BOOL WINAPI wglEnumGpuDevicesNV (HGPUNV hGpu, UINT iDeviceIndex, PGPU_DEVICE lpGpuDevice);
HDC WINAPI wglCreateAffinityDCNV (const HGPUNV *phGpuList);
BOOL WINAPI wglEnumGpusFromAffinityDCNV (HDC hAffinityDC, UINT iGpuIndex, HGPUNV *hGpu);
BOOL WINAPI wglDeleteDCNV (HDC hdc);
#endif
#endif /* WGL_NV_gpu_affinity */

#ifndef WGL_NV_multisample_coverage
#define WGL_NV_multisample_coverage 1
#define WGL_COVERAGE_SAMPLES_NV           0x2042
#define WGL_COLOR_SAMPLES_NV              0x20B9
#endif /* WGL_NV_multisample_coverage */

#ifndef WGL_NV_present_video
#define WGL_NV_present_video 1
DECLARE_HANDLE(HVIDEOOUTPUTDEVICENV);
#define WGL_NUM_VIDEO_SLOTS_NV            0x20F0
typedef int (WINAPI * PFNWGLENUMERATEVIDEODEVICESNVPROC) (HDC hDC, HVIDEOOUTPUTDEVICENV *phDeviceList);
typedef BOOL (WINAPI * PFNWGLBINDVIDEODEVICENVPROC) (HDC hDC, unsigned int uVideoSlot, HVIDEOOUTPUTDEVICENV hVideoDevice, const int *piAttribList);
typedef BOOL (WINAPI * PFNWGLQUERYCURRENTCONTEXTNVPROC) (int iAttribute, int *piValue);
#ifdef WGL_WGLEXT_PROTOTYPES
int WINAPI wglEnumerateVideoDevicesNV (HDC hDC, HVIDEOOUTPUTDEVICENV *phDeviceList);
BOOL WINAPI wglBindVideoDeviceNV (HDC hDC, unsigned int uVideoSlot, HVIDEOOUTPUTDEVICENV hVideoDevice, const int *piAttribList);
BOOL WINAPI wglQueryCurrentContextNV (int iAttribute, int *piValue);
#endif
#endif /* WGL_NV_present_video */

#ifndef WGL_NV_render_depth_texture
#define WGL_NV_render_depth_texture 1
#define WGL_BIND_TO_TEXTURE_DEPTH_NV      0x20A3
#define WGL_BIND_TO_TEXTURE_RECTANGLE_DEPTH_NV 0x20A4
#define WGL_DEPTH_TEXTURE_FORMAT_NV       0x20A5
#define WGL_TEXTURE_DEPTH_COMPONENT_NV    0x20A6
#define WGL_DEPTH_COMPONENT_NV            0x20A7
#endif /* WGL_NV_render_depth_texture */

#ifndef WGL_NV_render_texture_rectangle
#define WGL_NV_render_texture_rectangle 1
#define WGL_BIND_TO_TEXTURE_RECTANGLE_RGB_NV 0x20A0
#define WGL_BIND_TO_TEXTURE_RECTANGLE_RGBA_NV 0x20A1
#define WGL_TEXTURE_RECTANGLE_NV          0x20A2
#endif /* WGL_NV_render_texture_rectangle */

#ifndef WGL_NV_swap_group
#define WGL_NV_swap_group 1
typedef BOOL (WINAPI * PFNWGLJOINSWAPGROUPNVPROC) (HDC hDC, GLuint group);
typedef BOOL (WINAPI * PFNWGLBINDSWAPBARRIERNVPROC) (GLuint group, GLuint barrier);
typedef BOOL (WINAPI * PFNWGLQUERYSWAPGROUPNVPROC) (HDC hDC, GLuint *group, GLuint *barrier);
typedef BOOL (WINAPI * PFNWGLQUERYMAXSWAPGROUPSNVPROC) (HDC hDC, GLuint *maxGroups, GLuint *maxBarriers);
typedef BOOL (WINAPI * PFNWGLQUERYFRAMECOUNTNVPROC) (HDC hDC, GLuint *count);
typedef BOOL (WINAPI * PFNWGLRESETFRAMECOUNTNVPROC) (HDC hDC);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglJoinSwapGroupNV (HDC hDC, GLuint group);
BOOL WINAPI wglBindSwapBarrierNV (GLuint group, GLuint barrier);
BOOL WINAPI wglQuerySwapGroupNV (HDC hDC, GLuint *group, GLuint *barrier);
BOOL WINAPI wglQueryMaxSwapGroupsNV (HDC hDC, GLuint *maxGroups, GLuint *maxBarriers);
BOOL WINAPI wglQueryFrameCountNV (HDC hDC, GLuint *count);
BOOL WINAPI wglResetFrameCountNV (HDC hDC);
#endif
#endif /* WGL_NV_swap_group */

#ifndef WGL_NV_vertex_array_range
#define WGL_NV_vertex_array_range 1
typedef void *(WINAPI * PFNWGLALLOCATEMEMORYNVPROC) (GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority);
typedef void (WINAPI * PFNWGLFREEMEMORYNVPROC) (void *pointer);
#ifdef WGL_WGLEXT_PROTOTYPES
void *WINAPI wglAllocateMemoryNV (GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority);
void WINAPI wglFreeMemoryNV (void *pointer);
#endif
#endif /* WGL_NV_vertex_array_range */

#ifndef WGL_NV_video_capture
#define WGL_NV_video_capture 1
DECLARE_HANDLE(HVIDEOINPUTDEVICENV);
#define WGL_UNIQUE_ID_NV                  0x20CE
#define WGL_NUM_VIDEO_CAPTURE_SLOTS_NV    0x20CF
typedef BOOL (WINAPI * PFNWGLBINDVIDEOCAPTUREDEVICENVPROC) (UINT uVideoSlot, HVIDEOINPUTDEVICENV hDevice);
typedef UINT (WINAPI * PFNWGLENUMERATEVIDEOCAPTUREDEVICESNVPROC) (HDC hDc, HVIDEOINPUTDEVICENV *phDeviceList);
typedef BOOL (WINAPI * PFNWGLLOCKVIDEOCAPTUREDEVICENVPROC) (HDC hDc, HVIDEOINPUTDEVICENV hDevice);
typedef BOOL (WINAPI * PFNWGLQUERYVIDEOCAPTUREDEVICENVPROC) (HDC hDc, HVIDEOINPUTDEVICENV hDevice, int iAttribute, int *piValue);
typedef BOOL (WINAPI * PFNWGLRELEASEVIDEOCAPTUREDEVICENVPROC) (HDC hDc, HVIDEOINPUTDEVICENV hDevice);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglBindVideoCaptureDeviceNV (UINT uVideoSlot, HVIDEOINPUTDEVICENV hDevice);
UINT WINAPI wglEnumerateVideoCaptureDevicesNV (HDC hDc, HVIDEOINPUTDEVICENV *phDeviceList);
BOOL WINAPI wglLockVideoCaptureDeviceNV (HDC hDc, HVIDEOINPUTDEVICENV hDevice);
BOOL WINAPI wglQueryVideoCaptureDeviceNV (HDC hDc, HVIDEOINPUTDEVICENV hDevice, int iAttribute, int *piValue);
BOOL WINAPI wglReleaseVideoCaptureDeviceNV (HDC hDc, HVIDEOINPUTDEVICENV hDevice);
#endif
#endif /* WGL_NV_video_capture */

#ifndef WGL_NV_video_output
#define WGL_NV_video_output 1
DECLARE_HANDLE(HPVIDEODEV);
#define WGL_BIND_TO_VIDEO_RGB_NV          0x20C0
#define WGL_BIND_TO_VIDEO_RGBA_NV         0x20C1
#define WGL_BIND_TO_VIDEO_RGB_AND_DEPTH_NV 0x20C2
#define WGL_VIDEO_OUT_COLOR_NV            0x20C3
#define WGL_VIDEO_OUT_ALPHA_NV            0x20C4
#define WGL_VIDEO_OUT_DEPTH_NV            0x20C5
#define WGL_VIDEO_OUT_COLOR_AND_ALPHA_NV  0x20C6
#define WGL_VIDEO_OUT_COLOR_AND_DEPTH_NV  0x20C7
#define WGL_VIDEO_OUT_FRAME               0x20C8
#define WGL_VIDEO_OUT_FIELD_1             0x20C9
#define WGL_VIDEO_OUT_FIELD_2             0x20CA
#define WGL_VIDEO_OUT_STACKED_FIELDS_1_2  0x20CB
#define WGL_VIDEO_OUT_STACKED_FIELDS_2_1  0x20CC
typedef BOOL (WINAPI * PFNWGLGETVIDEODEVICENVPROC) (HDC hDC, int numDevices, HPVIDEODEV *hVideoDevice);
typedef BOOL (WINAPI * PFNWGLRELEASEVIDEODEVICENVPROC) (HPVIDEODEV hVideoDevice);
typedef BOOL (WINAPI * PFNWGLBINDVIDEOIMAGENVPROC) (HPVIDEODEV hVideoDevice, HPBUFFERARB hPbuffer, int iVideoBuffer);
typedef BOOL (WINAPI * PFNWGLRELEASEVIDEOIMAGENVPROC) (HPBUFFERARB hPbuffer, int iVideoBuffer);
typedef BOOL (WINAPI * PFNWGLSENDPBUFFERTOVIDEONVPROC) (HPBUFFERARB hPbuffer, int iBufferType, unsigned long *pulCounterPbuffer, BOOL bBlock);
typedef BOOL (WINAPI * PFNWGLGETVIDEOINFONVPROC) (HPVIDEODEV hpVideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglGetVideoDeviceNV (HDC hDC, int numDevices, HPVIDEODEV *hVideoDevice);
BOOL WINAPI wglReleaseVideoDeviceNV (HPVIDEODEV hVideoDevice);
BOOL WINAPI wglBindVideoImageNV (HPVIDEODEV hVideoDevice, HPBUFFERARB hPbuffer, int iVideoBuffer);
BOOL WINAPI wglReleaseVideoImageNV (HPBUFFERARB hPbuffer, int iVideoBuffer);
BOOL WINAPI wglSendPbufferToVideoNV (HPBUFFERARB hPbuffer, int iBufferType, unsigned long *pulCounterPbuffer, BOOL bBlock);
BOOL WINAPI wglGetVideoInfoNV (HPVIDEODEV hpVideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo);
#endif
#endif /* WGL_NV_video_output */

#ifndef WGL_OML_sync_control
#define WGL_OML_sync_control 1
typedef BOOL (WINAPI * PFNWGLGETSYNCVALUESOMLPROC) (HDC hdc, INT64 *ust, INT64 *msc, INT64 *sbc);
typedef BOOL (WINAPI * PFNWGLGETMSCRATEOMLPROC) (HDC hdc, INT32 *numerator, INT32 *denominator);
typedef INT64 (WINAPI * PFNWGLSWAPBUFFERSMSCOMLPROC) (HDC hdc, INT64 target_msc, INT64 divisor, INT64 remainder);
typedef INT64 (WINAPI * PFNWGLSWAPLAYERBUFFERSMSCOMLPROC) (HDC hdc, int fuPlanes, INT64 target_msc, INT64 divisor, INT64 remainder);
typedef BOOL (WINAPI * PFNWGLWAITFORMSCOMLPROC) (HDC hdc, INT64 target_msc, INT64 divisor, INT64 remainder, INT64 *ust, INT64 *msc, INT64 *sbc);
typedef BOOL (WINAPI * PFNWGLWAITFORSBCOMLPROC) (HDC hdc, INT64 target_sbc, INT64 *ust, INT64 *msc, INT64 *sbc);
#ifdef WGL_WGLEXT_PROTOTYPES
BOOL WINAPI wglGetSyncValuesOML (HDC hdc, INT64 *ust, INT64 *msc, INT64 *sbc);
BOOL WINAPI wglGetMscRateOML (HDC hdc, INT32 *numerator, INT32 *denominator);
INT64 WINAPI wglSwapBuffersMscOML (HDC hdc, INT64 target_msc, INT64 divisor, INT64 remainder);
INT64 WINAPI wglSwapLayerBuffersMscOML (HDC hdc, int fuPlanes, INT64 target_msc, INT64 divisor, INT64 remainder);
BOOL WINAPI wglWaitForMscOML (HDC hdc, INT64 target_msc, INT64 divisor, INT64 remainder, INT64 *ust, INT64 *msc, INT64 *sbc);
BOOL WINAPI wglWaitForSbcOML (HDC hdc, INT64 target_sbc, INT64 *ust, INT64 *msc, INT64 *sbc);
#endif
#endif /* WGL_OML_sync_control */

#ifdef __cplusplus
}
#endif

#endif


#pragma comment(lib, "OpenGL32.lib")

namespace GW
{
	namespace I
	{
		class GOpenGLSurfaceImplementation : public virtual GOpenGLSurfaceInterface,
			private virtual GEventResponderImplementation, private virtual GThreadSharedImplementation
		{
		private:
			GW::SYSTEM::GWindow gwindow;
			GW::CORE::GEventResponder responder;
			GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE UWH = {nullptr, nullptr};
			unsigned int width = 0;
			unsigned int height = 0;
			float aspectRatio = 0;

			GLint extensionCount = 0;
			const char* glExtensions = nullptr;

			HDC                         hdc			= NULL;
			HGLRC                       OGLcontext	= NULL;
			//				 WGL FUNCTION POINTERS				   //
			PFNWGLGETEXTENSIONSSTRINGARBPROC	wglGetExtensionsStringARB = NULL;
			PFNWGLGETEXTENSIONSSTRINGEXTPROC	wglGetExtensionsStringEXT = NULL;
			PFNWGLCREATECONTEXTATTRIBSARBPROC	wglCreateContextAttribsARB = NULL;
			PFNWGLSWAPINTERVALEXTPROC			wglSwapIntervalEXT = NULL;
			PFNWGLGETPIXELFORMATATTRIBIVARBPROC wglGetPixelFormatAttribivARB = NULL;

		public:
			GReturn Create(GW::SYSTEM::GWindow _gwindow, unsigned long long _initMask)
			{
				if (!_gwindow)
					return GReturn::INVALID_ARGUMENT;

				gwindow = _gwindow;
				//Check if valid _initMask was passed in
				unsigned long long allowed = ~(GW::GRAPHICS::COLOR_10_BIT | GW::GRAPHICS::DEPTH_BUFFER_SUPPORT | GW::GRAPHICS::DEPTH_STENCIL_SUPPORT | GW::GRAPHICS::OPENGL_ES_SUPPORT);
				if (allowed & _initMask)
				{
					return GReturn::FEATURE_UNSUPPORTED;
				}

				gwindow.GetWindowHandle(UWH);
				gwindow.GetClientWidth(width);
				gwindow.GetClientHeight(height);
				aspectRatio = static_cast<float>(width) / static_cast<float>(height);
				hdc = GetDC(static_cast<HWND>(UWH.window));

				PIXELFORMATDESCRIPTOR pfd =
				{
					sizeof(PIXELFORMATDESCRIPTOR),
					1,
					PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,
					PFD_TYPE_RGBA,
					32,
					8, 0,
					8, 0,
					8, 0,
					8, 0,
					0,
					0, 0, 0, 0,
					32,
					0,
					0,
					PFD_MAIN_PLANE,
					0,
					0, 0, 0
				};

				int pixelFormat = ChoosePixelFormat(hdc, &pfd);
				bool ret = SetPixelFormat(hdc, pixelFormat, &pfd);

				OGLcontext = wglCreateContext(hdc);
				if (OGLcontext == NULL) // is OpenGL functional?
					return GReturn::HARDWARE_UNAVAILABLE;

				wglMakeCurrent(hdc, OGLcontext);

				wglGetExtensionsStringARB = (PFNWGLGETEXTENSIONSSTRINGARBPROC)wglGetProcAddress("wglGetExtensionsStringARB");
				wglGetExtensionsStringEXT = (PFNWGLGETEXTENSIONSSTRINGEXTPROC)wglGetProcAddress("wglGetExtensionsStringEXT");
				wglCreateContextAttribsARB = (PFNWGLCREATECONTEXTATTRIBSARBPROC)wglGetProcAddress("wglCreateContextAttribsARB");
				wglSwapIntervalEXT = (PFNWGLSWAPINTERVALEXTPROC)wglGetProcAddress("wglSwapIntervalEXT");
				wglGetPixelFormatAttribivARB = (PFNWGLGETPIXELFORMATATTRIBIVARBPROC)wglGetProcAddress("wglGetPixelFormatAttribivARB");

				int pixelAttributes[] =
				{
					WGL_SUPPORT_OPENGL_ARB, GL_TRUE,
					WGL_DRAW_TO_WINDOW_ARB, GL_TRUE,
					WGL_COLOR_BITS_ARB, 32,
					WGL_RED_BITS_ARB, 8,
					WGL_GREEN_BITS_ARB, 8,
					WGL_BLUE_BITS_ARB, 8,
					WGL_ALPHA_BITS_ARB, 8,
					WGL_DEPTH_BITS_ARB, 0,
					WGL_STENCIL_BITS_ARB, 0,
					WGL_DOUBLE_BUFFER_ARB, GL_TRUE,
					WGL_PIXEL_TYPE_ARB, WGL_TYPE_RGBA_ARB,
					0, 0
				};

				if (_initMask & GW::GRAPHICS::COLOR_10_BIT)
				{
					pixelAttributes[7] = 10;
					pixelAttributes[9] = 10;
					pixelAttributes[11] = 10;
					pixelAttributes[13] = 2;
				}

				if (_initMask & GW::GRAPHICS::DEPTH_BUFFER_SUPPORT)
					pixelAttributes[15] = 32;

				if (_initMask & GW::GRAPHICS::DEPTH_STENCIL_SUPPORT)
				{
					pixelAttributes[15] = 24;
					pixelAttributes[17] = 8;
				}

				UINT pixelCount = 0;

				PFNWGLCHOOSEPIXELFORMATARBPROC wglChoosePixelFormatARB = nullptr;
				QueryExtensionFunction("WGL_ARB_extensions_string", "wglChoosePixelFormatARB", (void**)&wglChoosePixelFormatARB);

				ret = wglChoosePixelFormatARB(hdc, pixelAttributes, NULL, 1, &pixelFormat, &pixelCount);
				ret = SetPixelFormat(hdc, pixelFormat, &pfd);

				wglMakeCurrent(NULL, NULL);
				ReleaseDC(static_cast<HWND>(UWH.window), hdc);
				wglDeleteContext(OGLcontext);

				// Create an OpenGL 3.0 Context //
				int contextAttributes[] =
				{
					WGL_CONTEXT_MAJOR_VERSION_ARB, 3,
					WGL_CONTEXT_MINOR_VERSION_ARB, 0,
					WGL_CONTEXT_PROFILE_MASK_ARB, WGL_CONTEXT_CORE_PROFILE_BIT_ARB,
					0
				};

				if (_initMask & GW::GRAPHICS::OPENGL_ES_SUPPORT)
				{
					// Create an OpenGL ES 3.0 Context //
					contextAttributes[5] = WGL_CONTEXT_ES2_PROFILE_BIT_EXT;
				}

				OGLcontext = wglCreateContextAttribsARB(hdc, 0, contextAttributes);
				wglMakeCurrent(hdc, OGLcontext);

				if (_initMask & GW::GRAPHICS::DEPTH_BUFFER_SUPPORT)
					glEnable(GL_DEPTH_TEST);

				if (_initMask & GW::GRAPHICS::DEPTH_STENCIL_SUPPORT)
					glEnable(GL_STENCIL_TEST);

				int pfValues[6] = { 0 };
				int pfQuery[] =
				{
					WGL_RED_BITS_ARB,
					WGL_GREEN_BITS_ARB,
					WGL_BLUE_BITS_ARB,
					WGL_ALPHA_BITS_ARB,
					WGL_DEPTH_BITS_ARB,
					WGL_STENCIL_BITS_ARB
				};

				ret = wglGetPixelFormatAttribivARB(hdc, pixelFormat, PFD_MAIN_PLANE, 6, pfQuery, pfValues);

				// CHECK IF INIT FLAGS WERE MET //
				// 10 BIT COLOR //
				if (_initMask & GW::GRAPHICS::COLOR_10_BIT)
				{
					if (pfValues[0] != 10 && pfValues[1] != 10 && pfValues[2] != 10)
						return GReturn::FEATURE_UNSUPPORTED;
				}

				// DEPTH BUFFER SUPPORT //
				if (_initMask & GW::GRAPHICS::DEPTH_BUFFER_SUPPORT)
				{
					if (pfValues[4] == 0 || !glIsEnabled(GL_DEPTH_TEST))
						return GReturn::FEATURE_UNSUPPORTED;
				}

				// DEPTH STENCIL SUPPORT //
				if (_initMask & GW::GRAPHICS::DEPTH_STENCIL_SUPPORT)
				{
					if (pfValues[5] == 0 || !glIsEnabled(GL_STENCIL_TEST))
						return GReturn::FEATURE_UNSUPPORTED;
				}

				// ES CONTEXT SUPPORT //
				if (_initMask & GW::GRAPHICS::OPENGL_ES_SUPPORT)
				{
					char* version = (char*)glGetString(GL_VERSION);

					if (strstr(version, "OpenGL ES") == NULL)
						return GReturn::FEATURE_UNSUPPORTED;
				}

				// DIRECT2D SUPPORT //
				if (_initMask & GW::GRAPHICS::DIRECT2D_SUPPORT)
				{
					return GReturn::FEATURE_UNSUPPORTED;
				}

				// Call back event handler for OpenGL
				GReturn result = responder.Create([&](const GEvent& g)
				{
					GW::SYSTEM::GWindow::Events e;
					GW::SYSTEM::GWindow::EVENT_DATA d;
					if (+g.Read(e, d)) 	
					{
						switch (e)
						{
							case GW::SYSTEM::GWindow::Events::MINIMIZE:
							case GW::SYSTEM::GWindow::Events::DESTROY:
								break;

							case GW::SYSTEM::GWindow::Events::MAXIMIZE:
							case GW::SYSTEM::GWindow::Events::RESIZE:
							case GW::SYSTEM::GWindow::Events::MOVE:
							{
								gwindow.GetClientWidth(width);
								gwindow.GetClientHeight(height);
								aspectRatio = static_cast<float>(width) / static_cast<float>(height);
								glViewport(0, 0, width, height);
							}
							break;
						}
					}
				});
				if (G_PASS(result)) 
				{
					gwindow.Register(responder);
				}

				return result;
			}

			GReturn GetAspectRatio(float& _outRatio) const override
			{
				if (!gwindow)
					return GReturn::FAILURE;

				_outRatio = aspectRatio;
				return GReturn::SUCCESS;
			}

			GReturn GetContext(void** _outContext) const override
			{
				if (!OGLcontext)
					return GReturn::FAILURE;

				*_outContext = OGLcontext;
				return GReturn::SUCCESS;
			}

			GReturn UniversalSwapBuffers() override
			{
				if (!hdc)
					return GReturn::FAILURE;

				SwapBuffers(hdc);
				return GReturn::SUCCESS;
			}

			GReturn QueryExtensionFunction(const char* _extension, const char* _funcName, void** _outFuncAddress) override
			{
				if ((_funcName == nullptr && _outFuncAddress != nullptr) ||
					(_funcName != nullptr && _outFuncAddress == nullptr) ||
					_extension == nullptr && _funcName == nullptr)
					return GReturn::INVALID_ARGUMENT;

				// User only passed in function name, without extension //
				if (_extension == nullptr && _funcName != nullptr && _outFuncAddress != nullptr)
				{
					*_outFuncAddress = wglGetProcAddress(_funcName);
					if (*_outFuncAddress == nullptr)
						return GReturn::FAILURE;
					return GReturn::SUCCESS;
				}

				// User only passed in extension name, without function //
				if (_funcName == nullptr && _outFuncAddress == nullptr)
				{
					if (wglGetExtensionsStringEXT)
					{
						glExtensions = wglGetExtensionsStringEXT();
						if (strstr(glExtensions, _extension) != NULL)
							return GReturn::SUCCESS;
					}
					if (wglGetExtensionsStringARB)
					{
						glExtensions = wglGetExtensionsStringARB(hdc);
						if (strstr(glExtensions, _extension) != NULL)
							return GReturn::SUCCESS;
					}
					return GReturn::FAILURE;
				}

				// User passed in extension name and function name //
				if (wglGetExtensionsStringEXT)
				{
					glExtensions = wglGetExtensionsStringEXT();
					if (strstr(glExtensions, _extension) != NULL)
					{
						if (_funcName != NULL)
							*_outFuncAddress = wglGetProcAddress(_funcName);
						else
							*_outFuncAddress = wglGetProcAddress(_extension);
						return GReturn::SUCCESS;
					}
				}
				if (wglGetExtensionsStringARB)
				{
					glExtensions = wglGetExtensionsStringARB(hdc);
					if (strstr(glExtensions, _extension) != NULL)
					{
						if (_funcName != NULL)
							_outFuncAddress = (void**)wglGetProcAddress(_funcName);
						else
							_outFuncAddress = (void**)wglGetProcAddress(_extension);
						return GReturn::SUCCESS;
					}
				}
				return GReturn::FAILURE;
			}

			GReturn EnableSwapControl(bool _setSwapControl)
			{
				if (!wglSwapIntervalEXT)
					return GReturn::FEATURE_UNSUPPORTED;
				if (!OGLcontext)
					return GReturn::FAILURE;

				if (_setSwapControl == true)
					wglSwapIntervalEXT(1);
				else
					wglSwapIntervalEXT(0);

				return GReturn::SUCCESS;
			}

			//GEventResponderInterface
			GReturn Assign(std::function<void()> _newHandler) override {
				return responder.Assign(_newHandler);
			}
			GReturn Assign(std::function<void(const GEvent&)> _newEventHandler) override {
				return responder.Assign(_newEventHandler);
			}
			GReturn Invoke() const override {
				return responder.Invoke();
			}
			GReturn Invoke(const GEvent& _incomingEvent) const override {
				return responder.Invoke(_incomingEvent);
			}
		};
	}
}

#endif


namespace GW
{
	namespace GRAPHICS
	{
		class GOpenGLSurface final
			: public I::GProxy<I::GOpenGLSurfaceInterface, I::GOpenGLSurfaceImplementation, GW::SYSTEM::GWindow, unsigned long long>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GOpenGLSurface)
			GATEWARE_CONST_FUNCTION(GetAspectRatio)
			GATEWARE_CONST_FUNCTION(GetContext)
			GATEWARE_FUNCTION(UniversalSwapBuffers)
			GATEWARE_FUNCTION(QueryExtensionFunction)
			GATEWARE_FUNCTION(EnableSwapControl)

			// reimplemented functions
			// from GEventResponderInterface
			GATEWARE_FUNCTION(Assign)
			GATEWARE_CONST_FUNCTION(Invoke)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GOPENGLSURFACE_H

/*---------------------------------
|	End of GOpenGLSurface.h
----------------------------------*/


/*---------------------------------
|	Begin of GDirectX12Surface.h
----------------------------------*/
#ifndef GDIRECTX12SURFACE_H
#define GDIRECTX12SURFACE_H






namespace GW
{
	namespace I
	{
		class GDirectX12SurfaceInterface : public virtual GEventResponderInterface
		{
		public:
			virtual GReturn GetAspectRatio(float& outRatio) const = 0;
			virtual GReturn GetSwapchain4(void** ppOutSwapchain) const = 0;
			virtual GReturn GetSwapChainBufferIndex(unsigned int& outSwapChainBufferIndex) const = 0;

			virtual GReturn GetDevice(void** ppOutDevice) const = 0;

			virtual GReturn GetCommandList(void** ppOutDirectCommandList) const = 0;
			virtual GReturn GetCommandAllocator(void** ppOutDirectCommandAllocator) const = 0;
			virtual GReturn GetCommandQueue(void** ppOutDirectCommandQueue) const = 0;
			virtual GReturn GetFence(void** ppOutDirectFence) const = 0;

			virtual GReturn GetCBSRUADescriptorSize(unsigned int& outCBSRUADescriptorSize) const = 0;
			virtual GReturn GetSamplerDescriptorSize(unsigned int& outSamplerDescriptorSize) const = 0;
			virtual GReturn GetRenderTargetDescriptorSize(unsigned int& outRenderTargetDescriptorSize) const = 0;
			virtual GReturn GetDepthStencilDescriptorSize(unsigned int& outDepthStencilDescriptorSize) const = 0;

			virtual GReturn GetCurrentRenderTarget(void** ppOutRenderTarget) const = 0;
			virtual GReturn GetDepthStencil(void** ppOutDepthStencil) const = 0;

			virtual GReturn GetCurrentRenderTargetView(void* pOutRenderTargetView) const = 0;
			virtual GReturn GetDepthStencilView(void* pOutDepthStencilView) const = 0;

			virtual GReturn StartFrame() = 0;
			virtual GReturn EndFrame(bool VSync) = 0;
		};
	}
}

// Implementaion for GDirectX12Surface.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_GRAPHICS) || defined(GATEWARE_DISABLE_GDIRECTX12SURFACE) || defined(__APPLE__) || defined(__linux__) || \
    (defined(GATEWARE_ENABLE_GRAPHICS) && !defined(GATEWARE_DISABLE_GDIRECTX12SURFACE) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
	namespace I
	{
		class GDirectX12SurfaceImplementation : public virtual GDirectX12SurfaceInterface
		{
		public:
			GReturn Create(GW::SYSTEM::GWindow _gwindow, unsigned long long _initMask) { return GReturn::FEATURE_UNSUPPORTED; }

			GReturn GetAspectRatio(float& outRatio) const override { return GReturn::FAILURE; }
			GReturn GetSwapchain4(void** ppOutSwapchain) const override { return GReturn::FAILURE; }
			GReturn GetSwapChainBufferIndex(unsigned int& outSwapChainBufferIndex) const override { return GReturn::FAILURE; }

			GReturn GetDevice(void** ppOutDevice) const override { return GReturn::FAILURE; }

			GReturn GetCommandList(void** ppOutDirectCommandList) const override { return GReturn::FAILURE; }
			GReturn GetCommandAllocator(void** ppOutDirectCommandAllocator) const override { return GReturn::FAILURE; }
			GReturn GetCommandQueue(void** ppOutDirectCommandQueue) const override { return GReturn::FAILURE; }
			GReturn GetFence(void** ppOutDirectFence) const override { return GReturn::FAILURE; }

			GReturn GetCBSRUADescriptorSize(unsigned int& outCBSRUADescriptorSize) const override { return GReturn::FAILURE; }
			GReturn GetSamplerDescriptorSize(unsigned int& outSamplerDescriptorSize) const override { return GReturn::FAILURE; }
			GReturn GetRenderTargetDescriptorSize(unsigned int& outRenderTargetDescriptorSize) const override { return GReturn::FAILURE; }
			GReturn GetDepthStencilDescriptorSize(unsigned int& outDepthStencilDescriptorSize) const override { return GReturn::FAILURE; }

			GReturn GetCurrentRenderTarget(void** ppOutRenderTarget) const override { return GReturn::FAILURE; }
			GReturn GetDepthStencil(void** ppOutDepthStencil) const override { return GReturn::FAILURE; }

			GReturn GetCurrentRenderTargetView(void* pOutRenderTargetView) const override { return GReturn::FAILURE; }
			GReturn GetDepthStencilView(void* pOutDepthStencilView) const override { return GReturn::FAILURE; }

			GReturn StartFrame() override { return GReturn::FAILURE; }
			GReturn EndFrame(bool VSync) override { return GReturn::FAILURE; }

			//GEventResponderInterface
			GReturn Assign(std::function<void()> _newHandler) override { return GReturn::FAILURE; }
			GReturn Assign(std::function<void(const GEvent&)> _newEventHandler) override { return GReturn::FAILURE; }
			GReturn Invoke() const override { return GReturn::FAILURE; }
			GReturn Invoke(const GEvent& _incomingEvent) const override { return GReturn::FAILURE; }
		};
	}
}

#elif defined(_WIN32)
    #pragma warning(disable : 26812) // prefer enum class over enum warning
#include <wrl/client.h>
#include <dxgi1_6.h>
#if defined(_DEBUG)
#include <dxgidebug.h>
#endif
#pragma comment(lib, "dxgi.lib")
#pragma comment(lib, "dxguid.lib")
#include <d3d12.h>
#pragma comment(lib, "d3d12.lib")
#include <vector>

namespace GW
{
	namespace I
	{
		class GDirectX12SurfaceImplementation : public virtual GDirectX12SurfaceInterface,
			private virtual GEventResponderImplementation, private virtual GThreadSharedImplementation
		{
		private:
			template<class T>
			void SafeRelease(T*& COMObject)
			{
				if (COMObject)
				{
					COMObject->Release();
					COMObject = nullptr;
				}
			}

			GW::SYSTEM::GWindow m_GWindow;
			GW::CORE::GEventResponder m_GEventResponder;
			GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE m_UWH;
			unsigned int m_Width = 0;
			unsigned int m_Height = 0;
			float m_AspectRatio = 0.0f;

			bool m_Deallocated;

			static constexpr UINT m_SwapChainBufferCount = 2u; // How many swapchain back buffers will be createcd

			DXGI_FORMAT m_SwapChainBufferFormat;
			DXGI_FORMAT m_DepthBufferFormat;
			bool m_DepthBufferSupport;

			IDXGIFactory6* m_pDXGIFactory = nullptr;
			IDXGISwapChain4* m_pSwapChain = nullptr;
			IDXGIAdapter4* m_pAdapter = nullptr;

			ID3D12Device* m_pDevice = nullptr;

			struct CommandList
			{
				ID3D12CommandAllocator* m_pCommandAllocator;
				ID3D12GraphicsCommandList* m_pCommandList;

				CommandList()
				{
					m_pCommandAllocator = nullptr;
					m_pCommandList = nullptr;
				}
			} m_CommandList;

			struct CommandQueue
			{
				ID3D12CommandQueue* m_pCommandQueue;
				ID3D12Fence* m_pFence;
				HANDLE m_EventHandle; // Handle used to synchronize
				UINT64 m_FenceValue; // The fence value CPU should wait for

				operator bool()
				{
					return m_pCommandQueue && m_pFence && m_EventHandle;
				}

				void Signal()
				{
					m_pCommandQueue->Signal(m_pFence, ++m_FenceValue);
				}

				void Flush()
				{
					if (!(m_pFence->GetCompletedValue() >= m_FenceValue))
					{
						HRESULT hr = m_pFence->SetEventOnCompletion(m_FenceValue, m_EventHandle);
						if (FAILED(hr))
							return;
						::WaitForSingleObjectEx(m_EventHandle, INFINITE, FALSE);
					}
				}

				CommandQueue()
				{
					m_pCommandQueue = nullptr;
					m_pFence = nullptr;
					m_EventHandle = nullptr;
					m_FenceValue = 0u;
				}
			} m_CommandQueue;

			struct DescriptorInfo
			{
				UINT CBSRUADescriptorSize;
				UINT SamplerDescriptorSize;
				UINT RenderTargetDescriptorSize;
				UINT DepthStencilDescriptorSize;

				DescriptorInfo()
				{
					CBSRUADescriptorSize = 0;
					SamplerDescriptorSize = 0;
					RenderTargetDescriptorSize = 0;
					DepthStencilDescriptorSize = 0;
				}
			} m_DescriptorInfo;

			ID3D12DescriptorHeap* m_pRenderTargetDescriptorHeap = nullptr;
			ID3D12DescriptorHeap* m_pDepthStencilDescriptorHeap = nullptr;

			ID3D12Resource* m_pRenderTargets[m_SwapChainBufferCount] = { nullptr, nullptr };
			ID3D12Resource* m_pDepthStencil = nullptr;

			D3D12_VIEWPORT m_ScreenViewport = {};
			D3D12_RECT m_ScissorRect = {};

			GReturn CreateFactory()
			{
				UINT factoryFlags = 0;
#if defined (_DEBUG)
				factoryFlags = DXGI_CREATE_FACTORY_DEBUG;
#endif
				HRESULT hr = ::CreateDXGIFactory2(factoryFlags, IID_PPV_ARGS(&m_pDXGIFactory));
				if (FAILED(hr))
					return GW::GReturn::FAILURE;
				return GW::GReturn::SUCCESS;
			}

			GReturn QueryAdapter()
			{
				std::vector<Microsoft::WRL::ComPtr<IDXGIAdapter4>> m_pAdapters;
				// Enumerate hardware
				{
					// Enumerating iGPU, dGPU, xGPU
					Microsoft::WRL::ComPtr<IDXGIAdapter1> pAdapter1 = nullptr;
					Microsoft::WRL::ComPtr<IDXGIAdapter4> pAdapter4 = nullptr;
					for (UINT index = 0; m_pDXGIFactory->EnumAdapterByGpuPreference(index, DXGI_GPU_PREFERENCE_HIGH_PERFORMANCE, IID_PPV_ARGS(pAdapter1.GetAddressOf())) != DXGI_ERROR_NOT_FOUND; ++index)
					{
						pAdapter1.As(&pAdapter4);
						m_pAdapters.push_back(pAdapter4);
						pAdapter1.Reset();
					}
				}

				if (m_pAdapters.size() == 0)
					return GW::GReturn::HARDWARE_UNAVAILABLE;

				// Quering adapter
				{
					HRESULT hardwareResult = E_FAIL;
					DXGI_ADAPTER_DESC3 adapterDesc;

					for (unsigned int i = 0; i < static_cast<unsigned int>(m_pAdapters.size()); ++i)
					{
						HRESULT hr = m_pAdapters[i]->GetDesc3(&adapterDesc);
						if (FAILED(hr))
							return GW::GReturn::FAILURE;
						// Attempt to create a DX12 compatible device
						if ((adapterDesc.Flags & DXGI_ADAPTER_FLAG_SOFTWARE) == 0)
						{
							hardwareResult = ::D3D12CreateDevice(
								m_pAdapters[i].Get(),
								D3D_FEATURE_LEVEL_11_0,
								__uuidof(ID3D12Device), nullptr);
							if (SUCCEEDED(hardwareResult))
							{
								m_pAdapter = m_pAdapters[i].Get();
								m_pAdapter->AddRef();
								break;
							}
						}
					}

					if (!m_pAdapter)
						return GW::GReturn::HARDWARE_UNAVAILABLE;
				}
				return GW::GReturn::SUCCESS;
			}

			GReturn CreateDevice()
			{
				HRESULT hr;
#if defined(_DEBUG)
				// NOTE: Enabling the debug layer after creating the ID3D12Device will cause the DX runtime to remove the device.
				ID3D12Debug* pDebug = nullptr;
				hr = ::D3D12GetDebugInterface(IID_PPV_ARGS(&pDebug));
				if (FAILED(hr))
					return GW::GReturn::FAILURE;
				pDebug->EnableDebugLayer();
				pDebug->Release();
#endif

				// Create our virtual device used for interacting with the GPU so we can create resources
				{
					hr = ::D3D12CreateDevice(m_pAdapter, D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(&m_pDevice));
					if (FAILED(hr))
						return GW::GReturn::FAILURE;
				}

				// Query descriptor size (descriptor size vary based on GPU vendor)
				{
					m_DescriptorInfo.CBSRUADescriptorSize = m_pDevice->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
					m_DescriptorInfo.SamplerDescriptorSize = m_pDevice->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER);
					m_DescriptorInfo.RenderTargetDescriptorSize = m_pDevice->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);
					m_DescriptorInfo.DepthStencilDescriptorSize = m_pDevice->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_DSV);
				}
				return GW::GReturn::SUCCESS;
			}

			GReturn CreateCommandLists()
			{
				HRESULT hr = m_pDevice->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&m_CommandList.m_pCommandAllocator));
				if (FAILED(hr))
					return GW::GReturn::FAILURE;
				hr = m_pDevice->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT,
					m_CommandList.m_pCommandAllocator,
					nullptr, IID_PPV_ARGS(&m_CommandList.m_pCommandList));
				if (FAILED(hr))
					return GW::GReturn::FAILURE;
				hr = m_CommandList.m_pCommandList->Close();
				if (FAILED(hr))
					return GW::GReturn::FAILURE;
				return GW::GReturn::SUCCESS;
			}

			GReturn CreateCommandQueues()
			{
				D3D12_COMMAND_QUEUE_DESC commandQueueDesc = {};
				commandQueueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
				commandQueueDesc.Priority = D3D12_COMMAND_QUEUE_PRIORITY_NORMAL;
				commandQueueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;
				commandQueueDesc.NodeMask = 0;
				HRESULT hr = m_pDevice->CreateCommandQueue(&commandQueueDesc, IID_PPV_ARGS(&m_CommandQueue.m_pCommandQueue));
				if (FAILED(hr))
					return GW::GReturn::FAILURE;
				hr = m_pDevice->CreateFence(m_CommandQueue.m_FenceValue, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&m_CommandQueue.m_pFence));
				if (FAILED(hr))
					return GW::GReturn::FAILURE;
				m_CommandQueue.m_EventHandle = ::CreateEventEx(nullptr, nullptr, false, EVENT_ALL_ACCESS);
				if (!m_CommandQueue.m_EventHandle)
					return GW::GReturn::FAILURE;
				return GW::GReturn::SUCCESS;
			}

			GReturn CreateSwapChain()
			{
				Microsoft::WRL::ComPtr<IDXGISwapChain4> pSwapChain;
				DXGI_SWAP_CHAIN_DESC1 swapChainDesc;
				swapChainDesc.Width = m_Width;
				swapChainDesc.Height = m_Height;
				swapChainDesc.Format = m_SwapChainBufferFormat;
				swapChainDesc.Stereo = FALSE;
				swapChainDesc.SampleDesc.Count = 1u;
				swapChainDesc.SampleDesc.Quality = 0u;
				swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
				swapChainDesc.BufferCount = m_SwapChainBufferCount;
				swapChainDesc.Scaling = DXGI_SCALING_NONE;
				swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
				swapChainDesc.AlphaMode = DXGI_ALPHA_MODE_UNSPECIFIED;
				swapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
				Microsoft::WRL::ComPtr<IDXGISwapChain1> pSwapChain1;
				HRESULT hr = m_pDXGIFactory->CreateSwapChainForHwnd(m_CommandQueue.m_pCommandQueue,
					static_cast<HWND>(m_UWH.window), &swapChainDesc, nullptr, nullptr, pSwapChain1.GetAddressOf());
				if (FAILED(hr))
					return GW::GReturn::FAILURE;
				hr = m_pDXGIFactory->MakeWindowAssociation(static_cast<HWND>(m_UWH.window), DXGI_MWA_NO_ALT_ENTER);
				if (FAILED(hr))
					return GW::GReturn::FAILURE;
				hr = pSwapChain1.As(&pSwapChain);
				if (FAILED(hr))
					return GW::GReturn::FAILURE;
				m_pSwapChain = pSwapChain.Get();
				m_pSwapChain->AddRef();
				return GW::GReturn::SUCCESS;
			}

			GReturn CreateDescriptorHeap()
			{
				// RT Descriptor Heap
				{
					D3D12_DESCRIPTOR_HEAP_DESC descriptorHeapDesc;
					descriptorHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
					descriptorHeapDesc.NumDescriptors = m_SwapChainBufferCount;
					descriptorHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
					descriptorHeapDesc.NodeMask = 0;

					HRESULT hr = m_pDevice->CreateDescriptorHeap(&descriptorHeapDesc, IID_PPV_ARGS(&m_pRenderTargetDescriptorHeap));
					if (FAILED(hr))
						return GW::GReturn::FAILURE;
				}

				if (m_DepthBufferSupport)
				{
					// DS Descriptor Heap
					{
						D3D12_DESCRIPTOR_HEAP_DESC descriptorHeapDesc;
						descriptorHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;
						descriptorHeapDesc.NumDescriptors = 1;
						descriptorHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
						descriptorHeapDesc.NodeMask = 0;

						HRESULT hr = m_pDevice->CreateDescriptorHeap(&descriptorHeapDesc, IID_PPV_ARGS(&m_pDepthStencilDescriptorHeap));
						if (FAILED(hr))
							return GW::GReturn::FAILURE;
					}
				}
				return GW::GReturn::SUCCESS;
			}

			void Resize()
			{
				m_GWindow.GetClientWidth(m_Width);
				m_GWindow.GetClientHeight(m_Height);
				m_AspectRatio = static_cast<float>(m_Width) / static_cast<float>(m_Height);

				// Wait for GPU to finish before changing any resources
				m_CommandQueue.Signal();
				m_CommandQueue.Flush();
				{
					// Release resources
					for (unsigned int i = 0; i < m_SwapChainBufferCount; ++i)
						if (m_pRenderTargets[i])
							m_pRenderTargets[i]->Release();

					// Resize backbuffer
					UINT nodes[m_SwapChainBufferCount] = { 0, 0 };
					IUnknown* commandQueues[m_SwapChainBufferCount] =
					{
						m_CommandQueue.m_pCommandQueue,
						m_CommandQueue.m_pCommandQueue
					};
					m_pSwapChain->ResizeBuffers1(m_SwapChainBufferCount, m_Width, m_Height, m_SwapChainBufferFormat,
						DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH, nodes, commandQueues);

					// Recreate RT resource and descriptors
					for (unsigned int i = 0; i < m_SwapChainBufferCount; ++i)
					{
						ID3D12Resource* pBackBuffer = nullptr;
						m_pSwapChain->GetBuffer(i, IID_PPV_ARGS(&pBackBuffer));
						m_pRenderTargets[i] = pBackBuffer;
						D3D12_RENDER_TARGET_VIEW_DESC renderTargetViewDesc = {};
						renderTargetViewDesc.Format = m_SwapChainBufferFormat;
						renderTargetViewDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2D;
						renderTargetViewDesc.Texture2D.MipSlice = 0;
						renderTargetViewDesc.Texture2D.PlaneSlice = 0;
						D3D12_CPU_DESCRIPTOR_HANDLE cpuHandle;
						cpuHandle.ptr = m_pRenderTargetDescriptorHeap->GetCPUDescriptorHandleForHeapStart().ptr + (static_cast<size_t>(i) * m_DescriptorInfo.RenderTargetDescriptorSize);
						m_pDevice->CreateRenderTargetView(m_pRenderTargets[i], &renderTargetViewDesc, cpuHandle);
					}

					if (m_DepthBufferSupport)
					{
						// Recreate DS resource and descriptors
						if (m_pDepthStencil)
						{
							m_pDepthStencil->Release();
							m_pDepthStencil = nullptr;
						}

						D3D12_RESOURCE_DESC resourceDesc = {};
						resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
						resourceDesc.Alignment = D3D12_DEFAULT_RESOURCE_PLACEMENT_ALIGNMENT;
						resourceDesc.Width = m_Width;
						resourceDesc.Height = m_Height;
						resourceDesc.DepthOrArraySize = resourceDesc.MipLevels = 1;
						resourceDesc.Format = m_DepthBufferFormat;
						resourceDesc.SampleDesc = { 1, 0 };
						resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
						resourceDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;

						D3D12_CLEAR_VALUE clearValue = {};
						clearValue.Format = m_DepthBufferFormat;
						clearValue.DepthStencil.Depth = 1.0f;
						clearValue.DepthStencil.Stencil = 0;

						// Create GPU Memory
						{
							D3D12_HEAP_PROPERTIES defaultHeapProperties;
							defaultHeapProperties.Type = D3D12_HEAP_TYPE_DEFAULT;
							defaultHeapProperties.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_UNKNOWN;
							defaultHeapProperties.MemoryPoolPreference = D3D12_MEMORY_POOL_UNKNOWN;
							defaultHeapProperties.CreationNodeMask = 1;
							defaultHeapProperties.VisibleNodeMask = 1;
							const D3D12_HEAP_FLAGS heapFlags = D3D12_HEAP_FLAG_NONE;
							const D3D12_RESOURCE_STATES depthWriteState = D3D12_RESOURCE_STATE_DEPTH_WRITE;
							m_pDevice->CreateCommittedResource(&defaultHeapProperties, heapFlags,
								&resourceDesc, depthWriteState, &clearValue, IID_PPV_ARGS(&m_pDepthStencil));
						}

						D3D12_DEPTH_STENCIL_VIEW_DESC depthStencilViewDesc = {};
						depthStencilViewDesc.Format = m_DepthBufferFormat;
						depthStencilViewDesc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D;
						depthStencilViewDesc.Flags = D3D12_DSV_FLAG_NONE;
						depthStencilViewDesc.Texture2D.MipSlice = 0;
						m_pDevice->CreateDepthStencilView(m_pDepthStencil, &depthStencilViewDesc, m_pDepthStencilDescriptorHeap->GetCPUDescriptorHandleForHeapStart());
					}

					// Update the viewport transform to cover the client area.
					m_ScreenViewport.TopLeftX = m_ScreenViewport.TopLeftY = 0.0f;
					m_ScreenViewport.Width = static_cast<FLOAT>(m_Width);
					m_ScreenViewport.Height = static_cast<FLOAT>(m_Height);
					m_ScreenViewport.MinDepth = 0.0f;
					m_ScreenViewport.MaxDepth = 1.0f;
					m_ScissorRect.left = m_ScissorRect.top = 0;
					m_ScissorRect.right = m_Width;
					m_ScissorRect.bottom = m_Height;
				}
				// Wait until resize is complete.
				m_CommandQueue.Signal();
				m_CommandQueue.Flush();
			}

			void Release()
			{
				if (!m_Deallocated)
				{
					if (m_CommandQueue)
					{
						m_CommandQueue.Signal();
						m_CommandQueue.Flush();
					}
					SafeRelease(m_pDepthStencil);
					for (unsigned int i = 0; i < m_SwapChainBufferCount; ++i)
					{
						SafeRelease(m_pRenderTargets[i]);
					}
					SafeRelease(m_pDepthStencilDescriptorHeap);
					SafeRelease(m_pRenderTargetDescriptorHeap);
					::CloseHandle(m_CommandQueue.m_EventHandle);
					if (m_CommandQueue)
					{
						m_CommandQueue.m_EventHandle = nullptr;
					}
					SafeRelease(m_CommandQueue.m_pFence);
					SafeRelease(m_CommandQueue.m_pCommandQueue);
					SafeRelease(m_CommandList.m_pCommandList);
					SafeRelease(m_CommandList.m_pCommandAllocator);
					SafeRelease(m_pDevice);
					SafeRelease(m_pAdapter);
					SafeRelease(m_pSwapChain);
					SafeRelease(m_pDXGIFactory);
					m_Deallocated = true;
				}
			}
		public:
			~GDirectX12SurfaceImplementation()
			{
				Release();
			}

			GReturn Create(GW::SYSTEM::GWindow _gwindow, unsigned long long _initMask)
			{
				if (!_gwindow)
					return GReturn::INVALID_ARGUMENT;

				m_GWindow = _gwindow;
				//Check if valid _initMask was passed in
				unsigned long long allowed = ~(GW::GRAPHICS::COLOR_10_BIT | GW::GRAPHICS::DEPTH_BUFFER_SUPPORT | GW::GRAPHICS::DEPTH_STENCIL_SUPPORT);
				if (allowed & _initMask)
				{
					return GReturn::INVALID_ARGUMENT;
				}

				// Set swap chain buffer format
				if (_initMask & GW::GRAPHICS::COLOR_10_BIT)
					m_SwapChainBufferFormat = DXGI_FORMAT_R10G10B10A2_UNORM;
				else if (_initMask & GW::GRAPHICS::DIRECT2D_SUPPORT)
					m_SwapChainBufferFormat = DXGI_FORMAT_B8G8R8A8_UNORM;
				else
					m_SwapChainBufferFormat = DXGI_FORMAT_R8G8B8A8_UNORM;

				// If depth buffer or depth stencil support is requested, set m_DepthBufferSupport to true, else false
				if (_initMask & GW::GRAPHICS::DEPTH_BUFFER_SUPPORT || _initMask & GW::GRAPHICS::DEPTH_STENCIL_SUPPORT)
				{
					m_DepthBufferSupport = true;
					// If depth stencil support is requested set format to DXGI_FORMAT_D24_UNORM_S8_UINT, else DXGI_FORMAT_D32_FLOAT
					if (_initMask & GW::GRAPHICS::DEPTH_STENCIL_SUPPORT)
						m_DepthBufferFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;
					else
						m_DepthBufferFormat = DXGI_FORMAT_D32_FLOAT;
				}
				else
					m_DepthBufferSupport = false;

				m_GWindow.GetWindowHandle(m_UWH);
				m_GWindow.GetClientWidth(m_Width);
				m_GWindow.GetClientHeight(m_Height);
				m_AspectRatio = static_cast<float>(m_Width) / static_cast<float>(m_Height);

				m_Deallocated = false;

				GReturn gr = CreateFactory();
				if (G_FAIL(gr))
					return gr;

				gr = QueryAdapter();
				if (G_FAIL(gr))
					return gr;

				gr = CreateDevice();
				if (G_FAIL(gr))
					return gr;

				gr = CreateCommandLists();
				if (G_FAIL(gr))
					return gr;

				gr = CreateCommandQueues();
				if (G_FAIL(gr))
					return gr;

				gr = CreateSwapChain();
				if (G_FAIL(gr))
					return gr;

				gr = CreateDescriptorHeap();
				if (G_FAIL(gr))
					return gr;

				Resize();

				m_GEventResponder.Create([&](const GW::GEvent& event)
				{
					GW::SYSTEM::GWindow::Events windowEvent;
					GW::SYSTEM::GWindow::EVENT_DATA windowEventData;
					if (+event.Read(windowEvent, windowEventData))
					{
						switch (windowEvent)
						{
						case GW::SYSTEM::GWindow::Events::MINIMIZE: {} break;
						case GW::SYSTEM::GWindow::Events::DESTROY:
						{
							Release();
						}
						break;

						case GW::SYSTEM::GWindow::Events::MOVE:
						case GW::SYSTEM::GWindow::Events::MAXIMIZE:
						case GW::SYSTEM::GWindow::Events::RESIZE:
						{
							Resize();
						}
						break;
						}
					}
				});
				return m_GWindow.Register(m_GEventResponder);
			}

			GReturn GetAspectRatio(float& outRatio) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_GWindow)
					return GReturn::FAILURE;

				outRatio = m_AspectRatio;
				return GReturn::SUCCESS;
			}

			GReturn GetSwapchain4(void** ppOutSwapchain) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_pSwapChain)
					return GReturn::FAILURE;

				if (!ppOutSwapchain)
					return GReturn::INVALID_ARGUMENT;

				*ppOutSwapchain = m_pSwapChain;
				m_pSwapChain->AddRef();
				return GReturn::SUCCESS;
			}

			GReturn GetSwapChainBufferIndex(unsigned int& outSwapChainBufferIndex) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_pSwapChain)
					return GReturn::FAILURE;

				outSwapChainBufferIndex = m_pSwapChain->GetCurrentBackBufferIndex();
				return GReturn::SUCCESS;
			}

			GReturn GetDevice(void** ppOutDevice) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_pDevice)
					return GReturn::FAILURE;

				if (!ppOutDevice)
					return GReturn::INVALID_ARGUMENT;

				*ppOutDevice = m_pDevice;
				m_pDevice->AddRef();
				return GReturn::SUCCESS;
			}

			GReturn GetCommandList(void** ppOutDirectCommandList) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_CommandList.m_pCommandList)
					return GReturn::FAILURE;

				if (!ppOutDirectCommandList)
					return GReturn::INVALID_ARGUMENT;

				*ppOutDirectCommandList = m_CommandList.m_pCommandList;
				m_CommandList.m_pCommandList->AddRef();
				return GReturn::SUCCESS;
			}

			GReturn GetCommandAllocator(void** ppOutDirectCommandAllocator) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_CommandList.m_pCommandAllocator)
					return GReturn::FAILURE;

				if (!ppOutDirectCommandAllocator)
					return GReturn::INVALID_ARGUMENT;

				*ppOutDirectCommandAllocator = m_CommandList.m_pCommandAllocator;
				m_CommandList.m_pCommandAllocator->AddRef();
				return GReturn::SUCCESS;
			}

			GReturn GetCommandQueue(void** ppOutDirectCommandQueue) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_CommandQueue.m_pCommandQueue)
					return GReturn::FAILURE;

				if (!ppOutDirectCommandQueue)
					return GReturn::INVALID_ARGUMENT;

				*ppOutDirectCommandQueue = m_CommandQueue.m_pCommandQueue;
				m_CommandQueue.m_pCommandQueue->AddRef();
				return GReturn::SUCCESS;
			}

			GReturn GetFence(void** ppOutDirectFence) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_CommandQueue.m_pFence)
					return GReturn::FAILURE;

				if (!ppOutDirectFence)
					return GReturn::INVALID_ARGUMENT;

				*ppOutDirectFence = m_CommandQueue.m_pFence;
				m_CommandQueue.m_pFence->AddRef();
				return GReturn::SUCCESS;
			}

			GReturn GetCBSRUADescriptorSize(unsigned int& outCBSRUADescriptorSize) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_pDevice)
					return GReturn::FAILURE;

				outCBSRUADescriptorSize = m_DescriptorInfo.CBSRUADescriptorSize;
				return GReturn::SUCCESS;
			}
			GReturn GetSamplerDescriptorSize(unsigned int& outSamplerDescriptorSize) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_pDevice)
					return GReturn::FAILURE;

				outSamplerDescriptorSize = m_DescriptorInfo.SamplerDescriptorSize;
				return GReturn::SUCCESS;
			}
			GReturn GetRenderTargetDescriptorSize(unsigned int& outRenderTargetDescriptorSize) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_pDevice)
					return GReturn::FAILURE;

				outRenderTargetDescriptorSize = m_DescriptorInfo.RenderTargetDescriptorSize;
				return GReturn::SUCCESS;
			}
			GReturn GetDepthStencilDescriptorSize(unsigned int& outDepthStencilDescriptorSize) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_pDevice)
					return GReturn::FAILURE;

				outDepthStencilDescriptorSize = m_DescriptorInfo.DepthStencilDescriptorSize;
				return GReturn::SUCCESS;
			}

			GReturn GetCurrentRenderTarget(void** ppOutRenderTarget) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_pRenderTargets[m_pSwapChain->GetCurrentBackBufferIndex()])
					return GReturn::FAILURE;

				if (!ppOutRenderTarget)
					return GReturn::INVALID_ARGUMENT;

				*ppOutRenderTarget = m_pRenderTargets[m_pSwapChain->GetCurrentBackBufferIndex()];
				m_pRenderTargets[m_pSwapChain->GetCurrentBackBufferIndex()]->AddRef();
				return GReturn::SUCCESS;
			}
			GReturn GetDepthStencil(void** ppOutDepthStencil) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_pDepthStencil)
					return GReturn::FAILURE;

				if (!ppOutDepthStencil)
					return GReturn::INVALID_ARGUMENT;

				*ppOutDepthStencil = m_pDepthStencil;
				m_pDepthStencil->AddRef();
				return GReturn::SUCCESS;
			}

			GReturn GetCurrentRenderTargetView(void* pOutRenderTargetView) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_pRenderTargetDescriptorHeap)
					return GReturn::FAILURE;

				if (!pOutRenderTargetView)
					return GReturn::INVALID_ARGUMENT;

				reinterpret_cast<D3D12_CPU_DESCRIPTOR_HANDLE*>(pOutRenderTargetView)->ptr =
					m_pRenderTargetDescriptorHeap->GetCPUDescriptorHandleForHeapStart().ptr + (SIZE_T(m_pSwapChain->GetCurrentBackBufferIndex()) * SIZE_T(m_DescriptorInfo.RenderTargetDescriptorSize));
				return GReturn::SUCCESS;
			}
			GReturn GetDepthStencilView(void* pOutDepthStencilView) const override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_pDepthStencilDescriptorHeap)
					return GReturn::FAILURE;

				if (!pOutDepthStencilView)
					return GReturn::INVALID_ARGUMENT;

				reinterpret_cast<D3D12_CPU_DESCRIPTOR_HANDLE*>(pOutDepthStencilView)->ptr = m_pDepthStencilDescriptorHeap->GetCPUDescriptorHandleForHeapStart().ptr;
				return GReturn::SUCCESS;
			}

			GReturn StartFrame() override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_CommandQueue.m_pCommandQueue ||
					!m_CommandList.m_pCommandAllocator ||
					!m_CommandList.m_pCommandList)
					return GReturn::FAILURE;

				m_CommandQueue.Signal();
				m_CommandQueue.Flush();
				m_CommandList.m_pCommandAllocator->Reset();
				m_CommandList.m_pCommandList->Reset(m_CommandList.m_pCommandAllocator, nullptr);

				D3D12_RESOURCE_BARRIER rtTransitionBarrier = {};
				rtTransitionBarrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
				rtTransitionBarrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
				rtTransitionBarrier.Transition.pResource = m_pRenderTargets[m_pSwapChain->GetCurrentBackBufferIndex()];
				rtTransitionBarrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
				rtTransitionBarrier.Transition.StateBefore = D3D12_RESOURCE_STATE_PRESENT;
				rtTransitionBarrier.Transition.StateAfter = D3D12_RESOURCE_STATE_RENDER_TARGET;
				m_CommandList.m_pCommandList->ResourceBarrier(1, &rtTransitionBarrier);

				m_CommandList.m_pCommandList->RSSetViewports(1, &m_ScreenViewport);
				m_CommandList.m_pCommandList->RSSetScissorRects(1, &m_ScissorRect);

				return GReturn::SUCCESS;
			}
			GReturn EndFrame(bool VSync) override
			{
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				if (!m_CommandQueue.m_pCommandQueue ||
					!m_CommandList.m_pCommandAllocator ||
					!m_CommandList.m_pCommandList ||
					!m_pSwapChain)
					return GReturn::FAILURE;

				D3D12_RESOURCE_BARRIER rtTransitionBarrier = {};
				rtTransitionBarrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
				rtTransitionBarrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
				rtTransitionBarrier.Transition.pResource = m_pRenderTargets[m_pSwapChain->GetCurrentBackBufferIndex()];
				rtTransitionBarrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
				rtTransitionBarrier.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;
				rtTransitionBarrier.Transition.StateAfter = D3D12_RESOURCE_STATE_PRESENT;
				m_CommandList.m_pCommandList->ResourceBarrier(1, &rtTransitionBarrier);

				ID3D12CommandList* DirectCommandList[] = { m_CommandList.m_pCommandList };
				m_CommandList.m_pCommandList->Close();
				m_CommandQueue.m_pCommandQueue->ExecuteCommandLists(1, DirectCommandList);

				UINT SyncInterval = VSync ? 1u : 0u;
				UINT PresentFlags = 0u;
				DXGI_PRESENT_PARAMETERS PresentParameters = { 0u, NULL, NULL, NULL };
				HRESULT hr = m_pSwapChain->Present1(SyncInterval, PresentFlags, &PresentParameters);
				if (FAILED(hr))
					return GReturn::FAILURE;
				return GReturn::SUCCESS;
			}
			//GEventResponderInterface
			GReturn Assign(std::function<void()> _newHandler) override {
				return m_GEventResponder.Assign(_newHandler);
			}
			GReturn Assign(std::function<void(const GEvent&)> _newEventHandler) override {
				return m_GEventResponder.Assign(_newEventHandler);
			}
			GReturn Invoke() const override {
				return m_GEventResponder.Invoke();
			}
			GReturn Invoke(const GEvent& _incomingEvent) const override {
				return m_GEventResponder.Invoke(_incomingEvent);
			}
		};
	}
}

#endif


namespace GW
{
	namespace GRAPHICS
	{
		class GDirectX12Surface final
			: public I::GProxy<	I::GDirectX12SurfaceInterface, I::GDirectX12SurfaceImplementation, 
								GW::SYSTEM::GWindow, unsigned long long>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GDirectX12Surface)
			GATEWARE_CONST_FUNCTION(GetAspectRatio)
			GATEWARE_CONST_FUNCTION(GetSwapchain4)
			GATEWARE_CONST_FUNCTION(GetSwapChainBufferIndex)
			GATEWARE_CONST_FUNCTION(GetDevice)
			GATEWARE_CONST_FUNCTION(GetCommandList)
			GATEWARE_CONST_FUNCTION(GetCommandAllocator)
			GATEWARE_CONST_FUNCTION(GetCommandQueue)
			GATEWARE_CONST_FUNCTION(GetFence)
			GATEWARE_CONST_FUNCTION(GetCBSRUADescriptorSize)
			GATEWARE_CONST_FUNCTION(GetSamplerDescriptorSize)
			GATEWARE_CONST_FUNCTION(GetRenderTargetDescriptorSize)
			GATEWARE_CONST_FUNCTION(GetDepthStencilDescriptorSize)
			GATEWARE_CONST_FUNCTION(GetCurrentRenderTarget)
			GATEWARE_CONST_FUNCTION(GetDepthStencil)
			GATEWARE_CONST_FUNCTION(GetCurrentRenderTargetView)
			GATEWARE_CONST_FUNCTION(GetDepthStencilView)
			GATEWARE_FUNCTION(StartFrame)
			GATEWARE_FUNCTION(EndFrame)
			
			// reimplemented functions
			// from GEventResponderInterface
			GATEWARE_FUNCTION(Assign)
			GATEWARE_CONST_FUNCTION(Invoke)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GDIRECTX12SURFACE_H

/*---------------------------------
|	End of GDirectX12Surface.h
----------------------------------*/


/*---------------------------------
|	Begin of GRasterSurface.h
----------------------------------*/
#ifndef GRASTERSURFACE_H
#define GRASTERSURFACE_H




namespace GW
{
	namespace I
	{
		class GRasterSurfaceInterface : public virtual GEventResponderInterface
		{
		public:
			virtual GReturn Clear(unsigned int _xrgbColor) = 0;
			virtual GReturn UpdateSurface(const unsigned int* _xrgbPixels, unsigned int _numPixels) = 0;
			virtual GReturn UpdateSurfaceSubset(const unsigned int* _xrgbPixels, unsigned short _numRows, unsigned short _rowWidth, unsigned short _rowStride, int _destX, int _destY) = 0;
			virtual GReturn SmartUpdateSurface(const unsigned int* _xrgbPixels, unsigned int _numPixels, unsigned short _rowWidth, unsigned int _drawOptionFlags) = 0;
			virtual GReturn LockUpdateBufferWrite(unsigned int** _outMemoryBuffer, unsigned short& _outWidth, unsigned short& _outHeight) = 0;
			virtual GReturn LockUpdateBufferRead(const unsigned int** _outMemoryBuffer, unsigned short& _outWidth, unsigned short& _outHeight) = 0;
			virtual GReturn UnlockUpdateBufferWrite() = 0;
			virtual GReturn UnlockUpdateBufferRead() = 0;
			virtual GReturn Present() = 0;
		};
	};
};

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GRasterSurface.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if defined(GATEWARE_SKIP_CORE) || defined(GATEWARE_SKIP_GRASTERSURFACE) || \
	(defined(GATEWARE_ENABLE_GRAPHICS) && !defined(GATEWARE_DISABLE_GRASTERSURFACE) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	namespace GW
{
	namespace I
	{
		class GRasterSurfaceImplementation : public virtual GRasterSurfaceInterface,
			protected GEventResponderImplementation
		{
		public:
			GReturn Create(GW::SYSTEM::GWindow _gwindow) { return GReturn::INTERFACE_UNSUPPORTED; }
			GReturn Clear(unsigned int _xrgbColor) override { return GReturn::FAILURE; }
			GReturn UpdateSurface(const unsigned int* _xrgbPixels, unsigned int _numPixels) override { return GReturn::FAILURE; }
			GReturn UpdateSurfaceSubset(const unsigned int* _xrgbPixels, unsigned short _numRows, unsigned short _rowWidth, unsigned short _rowStride, int _destX, int _destY) override { return GReturn::FAILURE; }
			GReturn SmartUpdateSurface(const unsigned int* _xrgbPixels, unsigned int _numPixels, unsigned short _rowWidth, unsigned int _drawOptionFlags) override { return GReturn::FAILURE; }
			GReturn LockUpdateBufferWrite(unsigned int** _outMemoryBuffer, unsigned short& _outWidth, unsigned short& _outHeight) override { return GReturn::FAILURE; }
			GReturn LockUpdateBufferRead(const unsigned int** _outMemoryBuffer, unsigned short& _outWidth, unsigned short& _outHeight) override { return GReturn::FAILURE; }
			GReturn UnlockUpdateBufferWrite() override { return GReturn::FAILURE; }
			GReturn UnlockUpdateBufferRead() override { return GReturn::FAILURE; }
			GReturn Present() override { return GReturn::FAILURE; }
		}; // end class GRasterSurfaceImplementation
	} // end namespace I
} // end namespace GW


#elif defined(__APPLE__)
	#ifdef __OBJC__
@import Foundation;
@import Cocoa;
#endif

namespace GW
{
	namespace I
	{
		class GRasterSurfaceImplementation;
	}
}











#include <stdlib.h>
#include <cstring>
#include <iostream>
#include <assert.h>


//#define GRASTERSURFACE_DEBUG_MAC_SERIALIZE_SMARTUPDATE_COPY		// uncomment this line to disable multithreading in SmartUpdateSurface for debugging
//#define GRASTERSURFACE_DEBUG_MAC_DEBUG_ASSERTS					// uncomment this line to enable debug asserts
//#define GRASTERSURFACE_DEBUG_MAC_DEBUG_PRINTS						// uncomment this line to enable debug messages to be printed to the console
//#define GRASTERSURFACE_DEBUG_MAC_PRINT_PRIORITY_LEVEL 0			// use this to set the priority level of debug messages to print (lower number = higher priority, any priority levels greater than this will be ignored)


namespace internal_gw
{
	// GMacBLITView Interface

	// Data members of GMacBLITView
	G_OBJC_DATA_MEMBERS_STRUCT(GMacBLITView)
	{
		unsigned int* 	m_data;
		CGContextRef 	m_context;
		CGImageRef 		m_image;
		CGColorSpaceRef	m_colorspace;

		unsigned int 	m_width;
		unsigned int 	m_height;
		unsigned int 	m_bitsPerComponent;
		unsigned int 	m_bytesPerRow;
	};

	// Forward declarations of GMacMusic methods
	G_OBJC_HEADER_DATA_MEMBERS_PROPERTY_METHOD(GMacBLITView);

	G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacBLITView, id, initUsingFrame, NSRect _frameRect);
	G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacBLITView, void, drawRect, CGRect _rect); // Override of inherited function.
	G_OBJC_HEADER_INSTANCE_METHOD(GMacBLITView, BOOL, isFlipped); // Override of inherited function.
	G_OBJC_HEADER_INSTANCE_METHOD(GMacBLITView, void, cleanup);
	G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacBLITView, void, update, unsigned int* _pixels, unsigned int _pixelCount);

	// Creates the GMacBLITView class at runtime when G_OBJC_GET_CLASS(GMacBLITView) is called.
	G_OBJC_CLASS_BEGIN(GMacBLITView, NSView)
	{
		G_OBJC_CLASS_DATA_MEMBERS_PROPERTY(GMacBLITView);

		G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GMacBLITView, initUsingFrame, "@@:{CGRect={CGPoint=dd}{CGSize=dd}}", :);
		G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GMacBLITView, drawRect, "v@:{CGRect={CGPoint=dd}{CGSize=dd}}", :);
		G_OBJC_CLASS_METHOD(GMacBLITView, isFlipped, "c@:");
		G_OBJC_CLASS_METHOD(GMacBLITView, cleanup, "v@:");
		G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GMacBLITView, update, "v@:^II", ::);
	}
	G_OBJC_CLASS_END(GMacBLITView)

	// GMacBLITView Interface End
}


namespace GW
{
	namespace I
	{
		class GRasterSurfaceImplementation : public virtual GRasterSurfaceInterface,
			protected GEventResponderImplementation
		{
		private:

#pragma region DEFINES

			typedef unsigned int		Color; // XRGB quadruple
			typedef unsigned char		ColorChannel; // single value from a Color (X, R, G, or B)

#pragma endregion DEFINES
#pragma region ENUMS_STRUCTS_AND_CLASSES

			// GRasterUpdateFlags bit positions for left/right shifting
			enum UpdateFlagBitPosition
			{
				BIT_ALIGN_X_LEFT = 0,
				BIT_ALIGN_X_CENTER,
				BIT_ALIGN_X_RIGHT,
				BIT_ALIGN_Y_TOP,
				BIT_ALIGN_Y_CENTER,
				BIT_ALIGN_Y_BOTTOM,
				BIT_UPSCALE_2X,
				BIT_UPSCALE_3X,
				BIT_UPSCALE_4X,
				BIT_UPSCALE_8X,
				BIT_UPSCALE_16X,
				BIT_STRETCH_TO_FIT,
				BIT_INTERPOLATE_NEAREST,
				BIT_INTERPOLATE_BILINEAR,
			};

			// flags indicating the active state of the surface
			enum class SurfaceState : int
			{
				INVALID		= -1, // GWindow has been destroyed and surface cannot work properly
				INACTIVE	=  0, // surface is not active and will not draw
				ACTIVE		=  1, // surface is active and can draw
			};

			// class containing data unique to each buffer
			class Buffer : protected GThreadSharedImplementation
			{
			private:

				// prints a debug message to the console if GRASTERSURFACE_DEBUG_MAC_DEBUG_PRINTS is defined (only prints if priority level is set above 0)
				inline void const DebugPrint(const char* _msg) const
				{
#if defined(GRASTERSURFACE_DEBUG_MAC_PRINTS) && defined(GRASTERSURFACE_DEBUG_MAC_PRINT_PRIORITY_LEVEL)
				if (GRASTERSURFACE_DEBUG_MAC_PRINT_PRIORITY_LEVEL > 0)
					std::printf("%s buffer - %s", debugName, _msg);
#endif
				}

			public:

				Color*						data = nullptr;
				unsigned int				numLocks = 0;
				unsigned long long			frameNum = 0;
				char						debugName[16];

				GReturn Create(const char* _debugName)
				{
					INTERNAL::strcpy_s(debugName, 16, _debugName);
					DebugPrint("Create\n");
					return GThreadSharedImplementation::Create();
				}

				GReturn LockSyncWrite() override
				{
					DebugPrint("LockSyncWrite\n");
					return GThreadSharedImplementation::LockSyncWrite();
				}

				GReturn LockAsyncRead() const override
				{
					DebugPrint("LockAsyncRead\n");
					return GThreadSharedImplementation::LockAsyncRead();
				}

				GReturn UnlockSyncWrite() override
				{
					DebugPrint("UnlockSyncWrite\n");
					return GThreadSharedImplementation::UnlockSyncWrite();
				}

				GReturn UnlockAsyncRead() const override
				{
					DebugPrint("UnlockAsyncRead\n");
					return GThreadSharedImplementation::UnlockAsyncRead();
				}
			};

			// struct containing variables needed by SmartUpdateSurface
			struct SmartUpdateData
			{
				const Color*			inputColors = nullptr;			// pointer to input colors to use for update
				unsigned int			bitmapWidth = 0;				// local copy of bitmap width since it could be altered during execution
				unsigned int			bitmapHeight = 0;				// local copy of bitmap height, since it could be altered during execution
				unsigned int			rawDataWidth = 0;				// width of raw data passed to function
				unsigned int			rawDataHeight = 0;				// height of raw data passed to function
				unsigned int			upscaledDataWidth = 0;			// width of data after upscaling
				unsigned int			upscaledDataHeight = 0;			// height of data after upscaling
				int						offsetX = 0;					// horizontal offset of processed data
				int						offsetY = 0;					// vertical offset of processed data
				float					coordScaleRatioX = 1.0f;		// horizontal pixel coordinate scaling ratio
				float					coordScaleRatioY = 1.0f;		// vertical pixel coordinate scaling ratio
			};

#pragma endregion ENUMS_STRUCTS_AND_CLASSES
#pragma region VARIABLES

			// Gateware types are named as:		gVariableName
			// Cocoa/Mac types are named as:	cVariableName

			GW::SYSTEM::GWindow						m_gWindow;											// parent GWindow
			GW::CORE::GEventResponder				m_gEventListener;									// listener used to subscribe to GWindow events
			GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE		m_gUniversalWindowHandle = { nullptr, nullptr };	// universal window handle extracted from GWindow
			GW::SYSTEM::GConcurrent					m_gDrawThread;										// GConcurrent used for swapping buffers and drawing
			GW::SYSTEM::GConcurrent					m_gSmartUpdateRowProcessThread;						// GConcurrent used for copying data in SmartUpdateSurface

			unsigned int*							m_cImagePixelData = nullptr;						// bitmap needed by Cocoa image object
			id										m_cBlitView;										// instance of Cocoa view subclass

			SurfaceState							m_surfaceState = SurfaceState::INACTIVE;
			unsigned long long						m_frameCount = 0;
			Color*									m_bitmapData = nullptr;								// buffer color data (size is 2 * (width * height) since it contains both buffers' data)
			unsigned short							m_bitmapWidth = 0;									// width of surface data, as well as front and back buffers
			unsigned short							m_bitmapHeight = 0;									// height of surface data, as well as front and back buffers;
			Buffer									m_frontBuffer;										// buffer used to transfer the current frame to the screen
			Buffer									m_backBuffer; 										// buffer used to prepare the next frame

#pragma endregion VARIABLES
#pragma region PRIVATE_FUNCTIONS

			// Prints a debug message to the console if GRASTERSURFACE_DEBUG_MAC_DEBUG_PRINTS is defined.
			/*
			*	Used to assist with debugging, since multithreading makes debugging tools harder to use.
			*	If int arguments are passed, they will be inserted into the output if _msg is a format string.
			*/
			static inline void DebugPrint(int _priorityLevel, const char* _msg,
				long long _intArg0 = 0, long long _intArg1 = 0, long long _intArg2 = 0, long long _intArg3 = 0,
				long long _intArg4 = 0, long long _intArg5 = 0, long long _intArg6 = 0, long long _intArg7 = 0)
			{
#if defined(GRASTERSURFACE_DEBUG_MAC_PRINTS) && defined(GRASTERSURFACE_DEBUG_MAC_PRINT_PRIORITY_LEVEL)
				if (_priorityLevel <= GRASTERSURFACE_DEBUG_MAC_PRINT_PRIORITY_LEVEL)
					std::printf(_msg, _intArg0, _intArg1, _intArg2, _intArg3, _intArg4, _intArg5, _intArg6, _intArg7);
#endif
			}

			// Calls assert on the passed-in statement if GRASTERSURFACE_MAC_DEBUG_ASSERTS is defined.
			static inline void DebugAssert(bool _statement)
			{
#if defined(GRASTERSURFACE_DEBUG_MAC_DEBUG_ASSERTS)
				assert(_statement);
#endif
			}

			// Inverts the byte order of a color to match the format of an NSImage.
			inline Color ColorXRGBtoBGRX(Color _xrgbColor)
			{
				return (_xrgbColor & 0xff000000) >> 24
					|  (_xrgbColor & 0x00ff0000) >> 8
					|  (_xrgbColor & 0x0000ff00) << 8
					|  (_xrgbColor & 0x000000ff) << 24;
			}

			// Destroys and recreates bitmap data with new dimensions.
			/*
			*	Makes the surface active.
			*
			*	retval GReturn::SUCCESS					Completed successfully.
			*	retval GReturn::PREMATURE_DEALLOCATION	The associated GWindow was deallocated and the surface is now invalid.
			*	retval GReturn::UNEXPECTED_RESULT		The function entered an area it was not supposed to be able to.
			*/
			GReturn ResizeBitmap(unsigned int _width, unsigned int _height)
			{
				DebugPrint(1, "\nResizeBitmap\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "ResizeBitmap - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				// lock to prevent read/write conflicts
				DebugPrint(2, "ResizeBitmap - attempt to lock self, back buffer, front buffer for write\n");
				if (+LockSyncWrite()
					&& +m_backBuffer.LockSyncWrite()
					&& +m_frontBuffer.LockSyncWrite())
				{
					DebugPrint(2, "ResizeBitmap - locked self, back buffer, front buffer for write\n");
					// store new dimensions
					DebugPrint(2, "ResizeBitmap - store args\n");
					m_bitmapWidth = _width;
					m_bitmapHeight = _height;
					// destroy old Cocoa objects
					DebugPrint(2, "ResizeBitmap - destroy Cocoa objects\n");
					if (m_cImagePixelData)
					{
						free(m_cImagePixelData);
						m_cImagePixelData = nullptr;
					}
					// destroy old bitmap
					DebugPrint(2, "ResizeBitmap - destroy bitmap\n");
					if (m_bitmapData)
					{
						delete[] m_bitmapData;
						m_bitmapData = nullptr;
					}
					// allocate and clear new bitmap
					DebugPrint(2, "ResizeBitmap - create and clear bitmap\n");
					m_bitmapData = new Color[m_bitmapWidth * m_bitmapHeight * 2];
					memset(m_bitmapData, 0x00, (m_bitmapWidth * m_bitmapHeight * 2) * sizeof(Color));
					// reset buffer data pointers
					DebugPrint(2, "ResizeBitmap - reset buffer data pointers\n");
					m_backBuffer.data = &m_bitmapData[0];
					m_frontBuffer.data = &m_bitmapData[m_bitmapWidth * m_bitmapHeight];
					// recreate Cocoa objects
					DebugPrint(2, "ResizeBitmap - recreate Cocoa objects\n");
					m_cImagePixelData = static_cast<unsigned int*>(calloc(m_bitmapWidth * m_bitmapHeight, sizeof(unsigned int)));
					if (m_cBlitView)
					{
						[m_cBlitView removeFromSuperview]; // remove the view from the window
						internal_gw::G_OBJC_CALL_METHOD(GMacBLITView, m_cBlitView, cleanup);
						[m_cBlitView release];
					}
					NSRect windowRect = NSMakeRect(0, 0, _width, _height);
					m_cBlitView = [internal_gw::G_OBJC_GET_CLASS(GMacBLITView) alloc];
					m_cBlitView = internal_gw::G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GMacBLITView, m_cBlitView, initUsingFrame, windowRect);
					NSWindow* nsWindow = static_cast<NSWindow*>(m_gUniversalWindowHandle.window);
					[[nsWindow contentView] addSubview:m_cBlitView];
					[nsWindow makeFirstResponder:m_cBlitView];
					// mark surface as active
					DebugPrint(2, "ResizeBitmap - make surface active\n");
					m_surfaceState = SurfaceState::ACTIVE;
					// increment and store frame number in front buffer
					DebugPrint(2, "ResizeBitmap - increment and store frame number in front buffer\n");
					m_frontBuffer.frameNum = ++m_frameCount;
					// unlock and return
					DebugPrint(2, "ResizeBitmap - attempt to unlock self, back buffer, front buffer for write\n");
					if (+m_frontBuffer.UnlockSyncWrite()
						&& +m_backBuffer.UnlockSyncWrite()
						&& +UnlockSyncWrite())
					{
						DebugPrint(2, "ResizeBitmap - unlocked self, back buffer, front buffer for write; draw\n");
						DrawFrontBufferToScreen();
						DebugPrint(2, "ResizeBitmap - successful; return\n\n");
						return GReturn::SUCCESS;
					}
				}
				DebugPrint(2, "ResizeBitmap - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			// Swaps back buffer to front for drawing and front buffer to back for new data.
			/*
			*	retval GReturn::SUCCESS					Completed successfully.
			*	retval GReturn::IGNORED					Back buffer data is older than front buffer data.
			*	retval GReturn::PREMATURE_DEALLOCATION	The associated GWindow was deallocated and the surface is now invalid.
			*	retval GReturn::UNEXPECTED_RESULT		The function entered an area it was not supposed to be able to.
			*/
			GReturn SwapBackAndFrontBuffers()
			{
				DebugPrint(1, "\nSwapBackAndFrontBuffers\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "SwapBackAndFrontBuffers - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				DebugPrint(2, "SwapBackAndFrontBuffers - attempt to lock back buffer, front buffer for write\n");
				if (+m_backBuffer.LockSyncWrite()
					&& +m_frontBuffer.LockSyncWrite())
				{
					DebugPrint(2, "SwapBackAndFrontBuffers - locked back buffer, front buffer for write\n");
					GReturn gr;
					DebugPrint(2, "SwapBackAndFrontBuffers - compare frame numbers\n");
					if (m_backBuffer.frameNum > m_frontBuffer.frameNum)
					{
						DebugPrint(2, "SwapBackAndFrontBuffers - back buffer has new data; swap buffers\n");
						Color* temp = m_backBuffer.data;
						m_backBuffer.data = m_frontBuffer.data;
						m_frontBuffer.data = temp;
						gr = GReturn::SUCCESS;
					}
					else
					{
						DebugPrint(2, "SwapBackAndFrontBuffers - back buffer outdated\n");
						gr = GReturn::IGNORED;
					}
					DebugPrint(2, "SwapBackAndFrontBuffers - unlock and return\n");
					if (+m_frontBuffer.UnlockSyncWrite()
						&& +m_backBuffer.UnlockSyncWrite())
					{
						DebugPrint(2, "SwapBackAndFrontBuffers - unlocked back buffer, front buffer for write; successful; return\n\n");
						return gr;
					}
				}
				DebugPrint(2, "SwapBackAndFrontBuffers - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			// Draws data in front buffer to screen.
			/*
			*	retval GReturn::SUCCESS					Completed successfully.
			*	retval GReturn::FAILURE					A needed variable was invalid.
			*	retval GReturn::PREMATURE_DEALLOCATION	The associated GWindow was deallocated and the surface is now invalid.
			*	retval GReturn::UNEXPECTED_RESULT		The function entered an area it was not supposed to be able to.
			*/
			GReturn DrawFrontBufferToScreen()
			{
				DebugPrint(1, "\nDrawFrontBufferToScreen\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "DrawFrontBufferToScreen - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				DebugPrint(2, "DrawFrontBufferToScreen - attempt to lock front buffer for read\n");
				if (+m_frontBuffer.LockAsyncRead())
				{
					DebugPrint(2, "DrawFrontBufferToScreen - locked front buffer for read\n");
					GReturn gr;
					// validate needed variables
					DebugPrint(2, "DrawFrontBufferToScreen - validate vars\n");
					if (m_gWindow == nullptr
						|| m_frontBuffer.data == nullptr
						|| m_bitmapData == nullptr)
					{
						DebugPrint(2, "DrawFrontBufferToScreen - m_gWindow, m_frontBuffer.data, or m_bitmapData was nullptr\n");
						gr = GReturn::FAILURE;
					}
					else // if variables are valid, continue
					{
						DebugPrint(2, "DrawFrontBufferToScreen - vars valid\n");
						// prepare to draw
						// transfer data from front buffer to Cocoa image object bitmap
						DebugPrint(2, "DrawFrontBufferToScreen - copy front buffer to Cocoa image object\n");
						memcpy(m_cImagePixelData, m_frontBuffer.data, m_bitmapWidth * m_bitmapHeight * sizeof(Color));
						// ensure proper pixel format before draw
						//   note: this operation could potentially be sped up with multithreading
						DebugPrint(2, "DrawFrontBufferToScreen - invert color channel order in Cocoa image object\n");
						for (unsigned int i = 0; i < m_bitmapWidth * m_bitmapHeight; ++i)
							m_cImagePixelData[i] = ColorXRGBtoBGRX(m_cImagePixelData[i]);
						// draw front buffer to screen
						DebugPrint(2, "DrawFrontBufferToScreen - draw to screen\n");
						internal_gw::G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GMacBLITView, m_cBlitView, update, m_cImagePixelData, m_bitmapWidth * m_bitmapHeight);
						gr = GReturn::SUCCESS;
					}
					DebugPrint(2, "DrawFrontBufferToScreen - unlock and return\n");
					if (+m_frontBuffer.UnlockAsyncRead())
					{
						DebugPrint(2, "DrawFrontBufferToScreen - unlocked front buffer for read; return\n\n");
						return gr;
					}
				}
				DebugPrint(2, "DrawFrontBufferToScreen - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			// Swaps back and front buffers, then draws front buffer to screen.
			/*
			*	Executes on another thread.
			*
			*	retval GReturn::SUCCESS					Completed successfully.
			*	retval GReturn::FAILURE					Could not converge draw thread.
			*	retval GReturn::PREMATURE_DEALLOCATION	The associated GWindow was deallocated and the surface is now invalid.
			*/
			GReturn SwapBuffersAndDraw()
			{
				DebugPrint(1, "\nSwapBuffersAndDraw\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "SwapBuffersAndDraw - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				// Converge draw thread to force completion of outstanding tasks
				DebugPrint(2, "SwapBuffersAndDraw - attempt to converge draw thread\n");
				if (-m_gDrawThread.Converge(0))
				{
					DebugPrint(2, "SwapBuffersAndDraw - converge failed; return\n\n");
					return GReturn::FAILURE;
				}
				DebugPrint(2, "SwapBuffersAndDraw - converge succeeded\n");
				// swap buffers and draw to screen once no tasks are waiting
				DebugPrint(2, "SwapBuffersAndDraw - draw thread branch singular\n");
				m_gDrawThread.BranchSingular([&]() mutable
				{
					if (+SwapBackAndFrontBuffers()) // only draw front buffer if buffers were swapped
					{
						DebugPrint(2, "SwapBuffersAndDraw lambda - buffers were swapped; draw front buffer to screen\n");
						DrawFrontBufferToScreen();
					}
				});
				DebugPrint(2, "SwapBuffersAndDraw - return\n\n");
				return GReturn::SUCCESS;
			}

			// Returns the state of a single bit in a bitfield
			static inline bool IsolateBit(unsigned int _flags, unsigned short _bit)
			{
				return (_flags >> _bit) & 1;
			}

			// Interpolates linearly between two pixel color values.
			static inline Color LerpColor(Color _a, Color _b, float _r)
			{
				// split pixels into channels
				ColorChannel a_channels[4] =
				{
					static_cast<ColorChannel>( (_a & 0x000000FF)),
					static_cast<ColorChannel>(((_a & 0x0000FF00) >>  8)),
					static_cast<ColorChannel>(((_a & 0x00FF0000) >> 16)),
					static_cast<ColorChannel>(((_a & 0xFF000000) >> 24)),
				};
				ColorChannel b_channels[4] =
				{
					static_cast<ColorChannel>( (_b & 0x000000FF)),
					static_cast<ColorChannel>(((_b & 0x0000FF00) >>  8)),
					static_cast<ColorChannel>(((_b & 0x00FF0000) >> 16)),
					static_cast<ColorChannel>(((_b & 0xFF000000) >> 24)),
				};
				// interpolate results
				ColorChannel result[4] =
				{
					static_cast<ColorChannel>((G_LERP_PRECISE(a_channels[0], b_channels[0], _r))),
					static_cast<ColorChannel>((G_LERP_PRECISE(a_channels[1], b_channels[1], _r))),
					static_cast<ColorChannel>((G_LERP_PRECISE(a_channels[2], b_channels[2], _r))),
					static_cast<ColorChannel>((G_LERP_PRECISE(a_channels[3], b_channels[3], _r))),
				};
				return *(reinterpret_cast<Color*>(result));
			}

			// Returns color at truncated integer coordinate; Faster.
			/*
				_xrgbColors				Array of colors to interpolate within
				_width					Width of color array
				_height					Height of color array
				_u						Horizontal "texel" coordinate
				_v						Vertical "texel" coordinate
			*/
			static inline Color InterpolateColorNearest(const Color* _xrgbColors,
				unsigned int _width, unsigned int _height, float _u, float _v)
			{
				return _xrgbColors[static_cast<unsigned int>(_u) + static_cast<unsigned int>(_v) * _width];
			}

			// Returns color blended between nearest four pixels; Slower.
			/*
				_xrgbColors				Array of colors to interpolate within
				_width					Width of color array
				_height					Height of color array
				_u						Horizontal "texel" coordinate
				_v						Vertical "texel" coordinate
			*/
			static inline Color InterpolateColorBilinear(const Color* _xrgbColors,
				unsigned int _width, unsigned int _height, float _u, float _v)
			{
				// offset coordinates to use pixel corners instead of centers
				_u -= 0.5f;
				_u = (_u < 0.0f) ? 0.0f : _u;
				_v -= 0.5f;
				_v = (_v < 0.0f) ? 0.0f : _v;
				// get top-left coordinates
				unsigned int u0 = static_cast<unsigned int>(_u);
				unsigned int v0 = static_cast<unsigned int>(_v);
				// get bottom-right coordinates
				unsigned int u1 = (u0 < _width - 1)  ? u0 + 1 : u0;
				unsigned int v1 = (v0 < _height - 1) ? v0 + 1 : v0;
				// calculate interpolation ratios
				float rx = _u - u0;
				float ry = _v - v0;
				// interpolate results
				return LerpColor(
					LerpColor(_xrgbColors[u0 + (v0 * _width)], _xrgbColors[u1 + (v0 * _width)], rx),
					LerpColor(_xrgbColors[u0 + (v1 * _width)], _xrgbColors[u1 + (v1 * _width)], rx),
					ry);
			}

			// Iterates over a row of pixels and samples colors with nearest interpolation
			static void ProcessPixelRowNearest(const void* _unused, Color* _output, unsigned int _y, const void* _data)
			{
				DebugPrint(3, "\nProcessPixelRowNearest, row %d\n", _y);
				DebugAssert(_output != nullptr);
				// convert user data to correct type
				DebugAssert(_data != nullptr);
				const SmartUpdateData data = *(reinterpret_cast<const SmartUpdateData*>(_data));
				DebugAssert(data.inputColors != nullptr);
				DebugPrint(4, "ProcessPixelRowNearest, row %d - bitmap width = %d\n", _y, data.bitmapWidth);
				DebugPrint(4, "ProcessPixelRowNearest, row %d - bitmap height = %d\n", _y, data.bitmapHeight);
				DebugAssert(data.bitmapWidth > 0);
				DebugAssert(data.bitmapHeight > 0);
				DebugAssert(_y >= 0);
				DebugAssert(_y < data.bitmapHeight);
				// get y position within rectangular area to draw (should only draw between 0 and upscaled data height)
				int relativeY = _y - data.offsetY;
				// skip this row if not in range
				if (relativeY < 0 || relativeY >= static_cast<int>(data.upscaledDataHeight))
				{
					DebugPrint(5, "ProcessPixelRowNearest, row %d - row out of range\n", _y);
					return;
				}
				// init nearest algorithm vars
				float v = relativeY * data.coordScaleRatioY; // vertical "texel" to sample from in input data
				DebugPrint(4, "ProcessPixelRowNearest, row %d - v = %d\n", _y, static_cast<unsigned int>(v));
				DebugAssert(v >= 0);
				DebugAssert(v < data.bitmapHeight);
				// get x position within rectangular area to draw (should only draw between 0 and upscaled data width)
				int relativeX = G_CLAMP_MIN(-data.offsetX, 0);
				// iterate through pixel row and process pixels
				for (int x = G_CLAMP_MIN(data.offsetX, 0); x < G_CLAMP_MAX(data.offsetX + static_cast<int>(data.upscaledDataWidth), static_cast<int>(data.bitmapWidth)); ++x, ++relativeX)
				{
					float u = relativeX * data.coordScaleRatioX; // horizontal "texel" to sample from in input data
					DebugAssert(u >= 0);
					DebugAssert(u < data.bitmapWidth);
					_output[x] = InterpolateColorNearest(data.inputColors, data.rawDataWidth, data.rawDataHeight, u, v);
				}
				DebugPrint(3, "\n");
			}

			// Iterates over a row of pixels and samples colors with bilinear interpolation
			static void ProcessPixelRowBilinear(const void* _unused, Color* _output, unsigned int _y, const void* _data)
			{
				DebugPrint(3, "\nProcessPixelRowBilinear, row %d\n", _y);
				DebugAssert(_output != nullptr);
				// convert user data to correct type
				DebugAssert(_data != nullptr);
				SmartUpdateData data = *(const_cast<SmartUpdateData*>(reinterpret_cast<const SmartUpdateData*>(_data)));
				DebugAssert(data.inputColors != nullptr);
				DebugPrint(4, "ProcessPixelRowBilinear, row %d - bitmap width = %d\n", _y, data.bitmapWidth);
				DebugPrint(4, "ProcessPixelRowBilinear, row %d - bitmap height = %d\n", _y, data.bitmapHeight);
				DebugAssert(data.bitmapWidth > 0);
				DebugAssert(data.bitmapHeight > 0);
				DebugAssert(_y >= 0);
				DebugAssert(_y < data.bitmapHeight);
				// get y position within rectangular area to draw (should only draw between 0 and upscaled data height)
				int relativeY = _y - data.offsetY;
				// skip this row if not in range
				if (relativeY < 0 || relativeY >= static_cast<int>(data.upscaledDataHeight))
				{
					DebugPrint(5, "ProcessPixelRowBilinear, row %d - row out of range\n", _y);
					return;
				}
				// get x position within rectangular area to draw (should only draw between 0 and upscaled data width)
				int relativeX = G_CLAMP_MIN(-data.offsetX, 0);
				// init bilinear algorithm vars
				float v = relativeY * data.coordScaleRatioY; // vertical "texel" to sample from in input data
				DebugPrint(4, "ProcessPixelRowNearest, row %d - v = %d\n", _y, static_cast<unsigned int>(v));
				DebugAssert(v >= 0);
				DebugAssert(v < data.bitmapHeight);
				// iterate through row and process pixels
				for (int x = G_CLAMP_MIN(data.offsetX, 0); x < G_CLAMP_MAX(data.offsetX + static_cast<int>(data.upscaledDataWidth), static_cast<int>(data.bitmapWidth)); ++x, ++relativeX)
				{
					float u = relativeX * data.coordScaleRatioX; // horizontal "texel" to sample from in input data
					DebugAssert(u >= 0);
					DebugAssert(u < data.bitmapWidth);
					_output[x] = InterpolateColorBilinear(data.inputColors, data.rawDataWidth, data.rawDataHeight, u, v);
				}
				DebugPrint(3, "\n");
			}

			void Cleanup()
			{
				DebugPrint(1, "\nCleanup\n");
				DebugPrint(2, "Cleanup - ensure all locks are released\n");
				while (m_backBuffer.numLocks > 0)
				{
					m_backBuffer.UnlockSyncWrite();
					--m_backBuffer.numLocks;
				}
				while (m_frontBuffer.numLocks > 0)
				{
					m_frontBuffer.UnlockAsyncRead();
					--m_frontBuffer.numLocks;
				}

				DebugPrint(2, "Cleanup - deallocate draw thread object\n");
				m_gDrawThread = nullptr; // draw thread must be stopped before freeing the variables it uses

				DebugPrint(2, "Cleanup - attempt to lock self, back buffer, front buffer for write\n");
				if (+LockSyncWrite()
					&& +m_backBuffer.LockSyncWrite()
					&& +m_frontBuffer.LockSyncWrite())
				{
					DebugPrint(2, "Cleanup - locked self, back buffer, front buffer for write\n");

					DebugPrint(2, "Cleanup - deallocate Cocoa image object's bitmap data\n");
					if (m_cImagePixelData)
					{
						free(m_cImagePixelData);
						m_cImagePixelData = nullptr;
					}
					DebugPrint(2, "Cleanup - clear buffers' data pointers\n");
					if (m_backBuffer.data)
						m_backBuffer.data = nullptr;
					if (m_frontBuffer.data)
						m_frontBuffer.data = nullptr;
					DebugPrint(2, "Cleanup - clear bitmap data\n");
					if (m_bitmapData)
					{
						delete[] m_bitmapData;
						m_bitmapData = nullptr;
					}
					DebugPrint(2, "Cleanup - deallocate Cocoa view subclass object\n");
					if (m_cBlitView)
					{
						[m_cBlitView removeFromSuperview];
						internal_gw::G_OBJC_CALL_METHOD(GMacBLITView, m_cBlitView, cleanup);
						[m_cBlitView release];
						m_cBlitView = nullptr;
					}

					DebugPrint(2, "Cleanup - attempt to unlock self, back buffer, front buffer for write\n");
					if (+m_frontBuffer.UnlockSyncWrite()
						&& +m_backBuffer.UnlockSyncWrite()
						&& +UnlockSyncWrite())
						DebugPrint(2, "Cleanup - unlocked self, back buffer, front buffer for write\n");
					else
						DebugPrint(2, "Cleanup - unexpected result\n"); // should never reach here
				}
				else
				{
					DebugPrint(2, "Cleanup - unexpected result\n"); // should never reach here
				}
			}

#pragma endregion PRIVATE_FUNCTIONS

		public:

#pragma region CREATE_AND_DESTROY_FUNCTIONS

			~GRasterSurfaceImplementation()
			{
				DebugPrint(0, "\nGRasterSurface destructor\n");
				Cleanup();
			}

			GReturn Create(GW::SYSTEM::GWindow _gWindow)
			{
				DebugPrint(0, "\nCreate\n");
				
				// validate arguments
				DebugPrint(2, "Create - validate args\n");
				// ensure gwindow exists
				if (_gWindow == nullptr)
				{
					DebugPrint(2, "Create - m_gWindow was nullptr; return\n\n");
					return GW::GReturn::INVALID_ARGUMENT;
				}
				DebugPrint(2, "Create - args valid\n");

				// store arguments
				m_gWindow = _gWindow;
				DebugPrint(2, "Create - store args\n");

				// initialize buffers
				DebugPrint(2, "Create - initialize buffers\n");
				m_backBuffer.Create("back");
				m_frontBuffer.Create("front");

				// get universal window handle from GWindow
				DebugPrint(2, "Create - get universal window handle from gwindow\n");
				if (-m_gWindow.GetWindowHandle(m_gUniversalWindowHandle))
				{
					Cleanup();
					return GReturn::INVALID_ARGUMENT;
				}
				// get inner dimensions from window and resize bitmap to fit
				DebugPrint(2, "Create - get client dimensions of window\n");
				unsigned int newWidth, newHeight;
				if (-m_gWindow.GetClientWidth(newWidth) || -m_gWindow.GetClientHeight(newHeight))
				{
					Cleanup();
					return GReturn::INVALID_ARGUMENT;
				}
				DebugPrint(2, "Create - resize bitmap to client dimensions of window\n");
				ResizeBitmap(newWidth, newHeight);

				// create GConcurrent objects (false = no callbacks)
				DebugPrint(2, "Create - create GConcurrent objects\n");
				m_gDrawThread.Create(false);
				m_gSmartUpdateRowProcessThread.Create(false);
				// create event listener with callback function for GWindow to call
				DebugPrint(2, "Create - create event listener\n");
				GReturn gr = m_gEventListener.Create([&](GW::GEvent _event)
				{
					GW::SYSTEM::GWindow::Events windowEvent;
					GW::SYSTEM::GWindow::EVENT_DATA windowEventData;
					if (+_event.Read(windowEvent, windowEventData))
						switch (windowEvent)
						{
							case GW::SYSTEM::GWindow::Events::MINIMIZE:
							{
								DebugPrint(2, "Create callback lambda - MINIMIZE event received\n");
								// deactivate raster when minimized to prevent updating while window is not visible
								m_surfaceState = SurfaceState::INACTIVE;
							} break;
							case GW::SYSTEM::GWindow::Events::MAXIMIZE:
							{
								DebugPrint(2, "Create callback lambda - MAXIMIZE event received\n");
								// get client dimensions from window and resize bitmap to fit
								DebugPrint(2, "Create callback lambda - MAXIMIZE - resize bitmap\n");
								ResizeBitmap(windowEventData.clientWidth, windowEventData.clientHeight); // makes surface active
							} break;
							case GW::SYSTEM::GWindow::Events::RESIZE:
							{
								DebugPrint(2, "Create callback lambda - RESIZE event received\n");
								// get client dimensions from window and resize bitmap to fit
								DebugPrint(2, "Create callback lambda - RESIZE - resize bitmap\n");
								ResizeBitmap(windowEventData.clientWidth, windowEventData.clientHeight); // makes surface active
							} break;
							case GW::SYSTEM::GWindow::Events::DESTROY:
							{
								DebugPrint(2, "Create callback lambda - DESTROY event received\n");
								m_surfaceState = SurfaceState::INVALID;
								Cleanup();
							} break;
							default:
							{
								DebugPrint(2, "Create callback lambda - unknown event recieved\n");
							} break;
						} // end switch (windowEvent)
				});
				// register event listener with GWindow's event generator
				DebugPrint(2, "Create - register event listener\n");
				if (-m_gWindow.Register(m_gEventListener))
				{
					DebugPrint(2, "Create - registering event listener failed; return\n\n");
					Cleanup();
					return GReturn::INVALID_ARGUMENT;
				}
				DebugPrint(2, "Create - successful; return\n\n");
				return gr;
			}

#pragma endregion CREATE_AND_DESTROY_FUNCTIONS
#pragma region UPDATE_FUNCTIONS

			GReturn Clear(Color _xrgbColor) override
			{
				DebugPrint(0, "\nClear\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "Clear - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}

				DebugPrint(2, "Clear - attempt to lock back buffer for write\n");
				if (+m_backBuffer.LockSyncWrite())
				{
					DebugPrint(2, "Clear - locked back buffer for write\n");
					// store bitmap dimensions locally, since they could change
					unsigned int bitmapWidth = m_bitmapWidth;
					unsigned int bitmapHeight = m_bitmapHeight;
					// fill back buffer with passed color
					DebugPrint(2, "Clear - fill back buffer with color\n");
					for (unsigned int x = 0; x < bitmapWidth; ++x) // manually clear first row
						m_backBuffer.data[x] = _xrgbColor;
					for (unsigned int y = 1; y < bitmapHeight; ++y) // copy cleared row to each other row (much faster than manually clearing every pixel of every row)
						memcpy(&m_backBuffer.data[y * bitmapWidth], &m_backBuffer.data[0], bitmapWidth * sizeof(Color));
					// unlock and return
					DebugPrint(2, "Clear - attempt to unlock back buffer for write\n");
					if (+m_backBuffer.UnlockSyncWrite())
					{
						DebugPrint(2, "Clear - unlocked back buffer for write; successful; return\n\n");
						return GReturn::SUCCESS;
					}
					DebugPrint(2, "Clear - unexpected result; return\n\n");
					return GReturn::UNEXPECTED_RESULT; // should never reach here
				}
				DebugPrint(2, "Clear - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}
			GReturn UpdateSurface(const Color* _xrgbPixels, unsigned int _numPixels) override
			{
				DebugPrint(0, "\nUpdateSurface\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "UpdateSurface - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}

				// validate arguments
				DebugPrint(2, "UpdateSurface - validate args\n");
				// ensure valid pixel array was passed
				if (_xrgbPixels == nullptr)
				{
					DebugPrint(2, "UpdateSurface - _xrgbPixels was nullptr; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure pixel count is nonzero
				if (_numPixels < 1)
				{
					DebugPrint(2, "UpdateSurface - _numPixels was < 1; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure pixel count does not exceed surface pixel count
				if (_numPixels > static_cast<unsigned int>(m_bitmapWidth * m_bitmapHeight))
				{
					DebugPrint(2, "UpdateSurface - _numPixels was > surface's pixel count; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				DebugPrint(2, "UpdateSurface - args valid\n");

				// lock self and back buffer to prevent read/write conflicts
				DebugPrint(2, "UpdateSurface - attempt to lock self, back buffer for write\n");
				if (+LockSyncWrite()
					&& +m_backBuffer.LockSyncWrite())
				{
					DebugPrint(2, "UpdateSurface - locked self, back buffer for write\n");
					// BLIT pixel data to back buffer
					DebugPrint(2, "UpdateSurface - BLIT input pixels to back buffer\n");
					memcpy(m_backBuffer.data, _xrgbPixels, _numPixels * sizeof(Color));
					// increment and store frame number in back buffer
					DebugPrint(2, "UpdateSurface - increment and store frame number in back buffer\n");
					m_backBuffer.frameNum = ++m_frameCount;
					// unlock and return
					DebugPrint(2, "UpdateSurface - unlock and return\n");
					if (+m_backBuffer.UnlockSyncWrite()
						&& +UnlockSyncWrite())
					{
						DebugPrint(2, "UpdateSurface - unlocked self, back buffer for write; successful; return\n\n");
						return GReturn::SUCCESS;
					}
				}
				DebugPrint(2, "UpdateSurface - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}
			GReturn UpdateSurfaceSubset(const Color* _xrgbPixels, unsigned short _numRows, unsigned short _rowWidth, unsigned short _rowStride, int _destX, int _destY) override
			{
				DebugPrint(0, "\nUpdateSurfaceSubset\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "UpdateSurfaceSubset - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}

				// store dimensions locally, since they could potentially change during execution
				DebugPrint(2, "UpdateSurfaceSubset - store bitmap dimensions\n");
				unsigned int bitmapWidth = m_bitmapWidth;
				unsigned int bitmapHeight = m_bitmapHeight;
				// validate arguments
				DebugPrint(2, "UpdateSurfaceSubset - validate args\n");
				// ensure valid pixel array was passed
				if (_xrgbPixels == nullptr)
				{
					DebugPrint(2, "UpdateSurfaceSubset - _xrgbPixels was nullpt; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure row count is nonzero
				if (_numRows < 1)
				{
					DebugPrint(2, "UpdateSurfaceSubset - _numRows was < 1; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure row width is nonzero
				if (_rowWidth < 1)
				{
					DebugPrint(2, "UpdateSurfaceSubset - _numRows was < 1; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure row stride is >= row width, if provided
				if (_rowStride > 0 && _rowStride < _rowWidth)
				{
					DebugPrint(2, "UpdateSurfaceSubset - _rowStride was < _rowWidth; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				DebugPrint(2, "UpdateSurfaceSubset - args valid\n");

				// return immediately if subset is completely outside surface
				if (   _destX >= static_cast<int>(bitmapWidth)
					|| _destX + _rowWidth < 0
					|| _destY >= static_cast<int>(bitmapHeight)
					|| _destY + _numRows < 0)
				{
					DebugPrint(2, "UpdateSurfaceSubset - subset was outside surface; return\n\n");
					return GReturn::REDUNDANT;
				}

				// get row stride
				DebugPrint(2, "UpdateSurfaceSubset - get row stride\n");
				if (_rowStride == 0) _rowStride = _rowWidth;
				// clip subset to edges of surface
				//   left side
				DebugPrint(2, "UpdateSurfaceSubset - clip left side\n");
				if (_destX < 0)
				{
					// move starting location in source data right and shorten rows
					_xrgbPixels += -_destX;
					_rowWidth += _destX; // add, because coord is negative
					// clamp coord to surface edge
					_destX = 0;
				}
				//   right side
				DebugPrint(2, "UpdateSurfaceSubset - clip right side\n");
				if (_destX + _rowWidth > bitmapWidth)
				{
					// shorten rows
					_rowWidth -= (_destX + _rowWidth - bitmapWidth);
				}
				//   top side
				DebugPrint(2, "UpdateSurfaceSubset - clip top side\n");
				if (_destY < 0)
				{
					// move starting location in source data down and reduce row count
					_xrgbPixels += -_destY * _rowStride;
					_numRows += _destY; // add, because coord is negative
					// clamp coord to surface edge
					_destY = 0;
				}
				//   bottom side
				DebugPrint(2, "UpdateSurfaceSubset - clip bottom side\n");
				if (_destY + _numRows > bitmapHeight)
				{
					// reduce row count
					_numRows -= (_destY + _numRows - bitmapHeight);
				}
				// calculate starting index from destination x/y coords
				DebugPrint(2, "UpdateSurfaceSubset - calculate starting index\n");
				unsigned int startIndex = _destX + (_destY * bitmapWidth);

				// lock back buffer to prevent read/write conflicts
				DebugPrint(2, "UpdateSurfaceSubset - attempt to lock self, back buffer for write\n");
				if (+LockSyncWrite()
					&& +m_backBuffer.LockSyncWrite())
				{
					DebugPrint(2, "UpdateSurfaceSubset - locked self, back buffer for write\n");
					// calculate end index
					DebugPrint(2, "UpdateSurfaceSubset - calculate end index\n");
					unsigned int endIndex = startIndex + (bitmapWidth * (_numRows - 1)) + (_rowWidth - 1);
					// BLIT rows of subset block to back buffer
					DebugPrint(2, "UpdateSurfaceSubset - BLIT subset to back buffer\n");
					for (; startIndex < endIndex; startIndex += bitmapWidth, _xrgbPixels += _rowStride)
						memcpy(&m_backBuffer.data[startIndex], _xrgbPixels, _rowWidth * sizeof(Color));
					// increment and store frame count in back buffer
					DebugPrint(2, "UpdateSurfaceSubset - increment and store frame number in back buffer\n");
					m_backBuffer.frameNum = ++m_frameCount;
					// unlock and return
					DebugPrint(2, "UpdateSurfaceSubset - unlock and return\n");
					if (+m_backBuffer.UnlockSyncWrite()
						&& +UnlockSyncWrite())
					{
						DebugPrint(2, "UpdateSurfaceSubset - unlocked self, back buffer for write; successful; return\n\n");
						return GReturn::SUCCESS;
					}
				}
				DebugPrint(2, "UpdateSurfaceSubset - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}
			GReturn SmartUpdateSurface(const Color* _xrgbPixels, unsigned int _numPixels, unsigned short _rowWidth, unsigned int _drawOptionFlags) override
			{
				DebugPrint(0, "\nSmartUpdateSurface\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "SmartUpdateSurface - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}

				// validate arguments
				DebugPrint(2, "SmartUpdateSurface - validate args\n");
				// ensure valid pixel array was passed
				if (_xrgbPixels == nullptr)
				{
					DebugPrint(2, "SmartUpdateSurface - _xrgbPixels was nullptr; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure pixel count is nonzero
				if (_numPixels < 1)
				{
					DebugPrint(2, "SmartUpdateSurface - _numPixels was < 1; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure row width is nonzero
				if (_rowWidth < 1)
				{
					DebugPrint(2, "SmartUpdateSurface - _rowWidth was < 1; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// separate flags into sections and test each section
				const unsigned int bitmaskAlignX =
					  GW::GRAPHICS::GRasterUpdateFlags::ALIGN_X_LEFT
					| GW::GRAPHICS::GRasterUpdateFlags::ALIGN_X_CENTER
					| GW::GRAPHICS::GRasterUpdateFlags::ALIGN_X_RIGHT;
				const unsigned int bitmaskAlignY =
					  GW::GRAPHICS::GRasterUpdateFlags::ALIGN_Y_TOP
					| GW::GRAPHICS::GRasterUpdateFlags::ALIGN_Y_CENTER
					| GW::GRAPHICS::GRasterUpdateFlags::ALIGN_Y_BOTTOM;
				const unsigned int bitmaskUpscale =
					  GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_2X
					| GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_3X
					| GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_4X
					| GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_8X
					| GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_16X
					| GW::GRAPHICS::GRasterUpdateFlags::STRETCH_TO_FIT;
				const unsigned int bitmaskInterpolate =
					  GW::GRAPHICS::GRasterUpdateFlags::INTERPOLATE_NEAREST
					| GW::GRAPHICS::GRasterUpdateFlags::INTERPOLATE_BILINEAR;
				unsigned int testFlags = 0;
				// validate x alignment flags
				testFlags = _drawOptionFlags & bitmaskAlignX;
				if (( IsolateBit(testFlags, UpdateFlagBitPosition::BIT_ALIGN_X_LEFT)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_ALIGN_X_CENTER)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_ALIGN_X_RIGHT)
					) > 1)
				{
					DebugPrint(2, "SmartUpdateSurface - _drawOptionFlags contains conflicting x alignment flags; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// validate y alignment flags
				testFlags = _drawOptionFlags & bitmaskAlignY;
				if (( IsolateBit(testFlags, UpdateFlagBitPosition::BIT_ALIGN_Y_TOP)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_ALIGN_Y_CENTER)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_ALIGN_Y_BOTTOM)
					) > 1)
				{
					DebugPrint(2, "SmartUpdateSurface - _drawOptionFlags contains conflicting y alignment flags; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// validate upscaling flags
				testFlags = _drawOptionFlags & bitmaskUpscale;
				if ((  IsolateBit(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_2X)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_3X)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_4X)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_8X)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_16X)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_STRETCH_TO_FIT)
					) > 1)
				{
					DebugPrint(2, "SmartUpdateSurface - _drawOptionFlags contains conflicting upscaling flags; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// validate interpolation flags
				testFlags = _drawOptionFlags & bitmaskInterpolate;
				if (( IsolateBit(testFlags, UpdateFlagBitPosition::BIT_INTERPOLATE_NEAREST)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_INTERPOLATE_BILINEAR)
					) > 1)
				{
					DebugPrint(2, "SmartUpdateSurface - _drawOptionFlags contains conflicting interpolation flags; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				DebugPrint(2, "SmartUpdateSurface - args valid\n");
				// if arguments are valid, continue

				// store surface dimensions and border color locally to avoid needing to read data more than once
				unsigned int bitmapWidth = m_bitmapWidth;
				unsigned int bitmapHeight = m_bitmapHeight;

				// create struct to store data to use during processing
				SmartUpdateData data = {};
				// store color array and metadata
				data.inputColors = _xrgbPixels;
				data.bitmapWidth = bitmapWidth;
				data.bitmapHeight = bitmapHeight;
				data.rawDataWidth = _rowWidth;
				data.rawDataHeight = _numPixels / _rowWidth;
				// determine data dimensions after processing
				DebugPrint(2, "SmartUpdateSurface - calculate upscaled dimensions\n");
				testFlags = _drawOptionFlags & bitmaskUpscale;
				switch (testFlags)
				{
					case GW::GRAPHICS::UPSCALE_2X:
						data.upscaledDataWidth = data.rawDataWidth << 1;
						data.upscaledDataHeight = data.rawDataHeight << 1;
						break;
					case GW::GRAPHICS::UPSCALE_3X:
						data.upscaledDataWidth = data.rawDataWidth * 3;
						data.upscaledDataHeight = data.rawDataHeight * 3;
						break;
					case GW::GRAPHICS::UPSCALE_4X:
						data.upscaledDataWidth = data.rawDataWidth << 2;
						data.upscaledDataHeight = data.rawDataHeight << 2;
						break;
					case GW::GRAPHICS::UPSCALE_8X:
						data.upscaledDataWidth = data.rawDataWidth << 3;
						data.upscaledDataHeight = data.rawDataHeight << 3;
						break;
					case GW::GRAPHICS::UPSCALE_16X:
						data.upscaledDataWidth = data.rawDataWidth << 4;
						data.upscaledDataHeight = data.rawDataHeight << 4;
						break;
					case GW::GRAPHICS::STRETCH_TO_FIT:
						data.upscaledDataWidth = bitmapWidth;
						data.upscaledDataHeight = bitmapHeight;
						break;
					default:
						data.upscaledDataWidth = data.rawDataWidth;
						data.upscaledDataHeight = data.rawDataHeight;
						break;
				}

				// calculate pixel coordinate scaling ratios
				DebugPrint(2, "SmartUpdateSurface - calculate coordinate scaling ratios\n");
				data.coordScaleRatioX = data.rawDataWidth / static_cast<float>(data.upscaledDataWidth);
				data.coordScaleRatioY = data.rawDataHeight / static_cast<float>(data.upscaledDataHeight);

				// determine X alignment
				DebugPrint(2, "SmartUpdateSurface - determine x alignment\n");
				testFlags = _drawOptionFlags & bitmaskAlignX;
				switch (testFlags)
				{
					case GW::GRAPHICS::ALIGN_X_LEFT:
						data.offsetX = 0;
						break;
					case GW::GRAPHICS::ALIGN_X_RIGHT:
						data.offsetX = static_cast<int>(bitmapWidth) - static_cast<int>(data.upscaledDataWidth);
						break;
					case GW::GRAPHICS::ALIGN_X_CENTER:
					default:
						data.offsetX = (static_cast<int>(bitmapWidth) - static_cast<int>(data.upscaledDataWidth)) >> 1;
						break;
				}

				// determine Y alignment
				DebugPrint(2, "SmartUpdateSurface - determine y alignment\n");
				testFlags = _drawOptionFlags & bitmaskAlignY;
				switch (testFlags)
				{
					case GW::GRAPHICS::ALIGN_Y_TOP:
						data.offsetY = 0;
						break;
					case GW::GRAPHICS::ALIGN_Y_BOTTOM:
						data.offsetY = static_cast<int>(bitmapHeight) - static_cast<int>(data.upscaledDataHeight);
						break;
					case GW::GRAPHICS::ALIGN_Y_CENTER:
					default:
						data.offsetY = (static_cast<int>(bitmapHeight) - static_cast<int>(data.upscaledDataHeight)) >> 1;
						break;
				}

				// lock self and back buffer to prevent read/write conflicts
				DebugPrint(2, "SmartUpdateSurface - attempt to lock self, back buffer for write\n");
				if (+LockSyncWrite()
					&& +m_backBuffer.LockSyncWrite())
				{
					DebugPrint(2, "SmartUpdateSurface - locked back buffer for write\n");
#if !defined(GRASTERSURFACE_DEBUG_MAC_SERIALIZE_SMARTUPDATE_COPY)
					// calculate how many rows of the surface fit into 256 KB
					DebugPrint(2, "SmartUpdateSurface - calculate rows per thread\n");
					unsigned int rows = 262144 / (bitmapWidth * sizeof(Color));
					if (rows == 0) rows = 1; // min of 1
#endif

					// iterate through surface and process pixels
					if ((_drawOptionFlags & bitmaskInterpolate) == GW::GRAPHICS::INTERPOLATE_BILINEAR)
					{
#if defined(GRASTERSURFACE_DEBUG_MAC_SERIALIZE_SMARTUPDATE_COPY)
						DebugPrint(2, "SmartUpdateSurface - process rows w/ bilinear interp (SERIAL)\n");
						for (int y = 0; y < bitmapHeight; ++y)
							ProcessPixelRowBilinear(static_cast<const void*>(nullptr), &m_backBuffer.data[y * bitmapWidth], y, reinterpret_cast<const void*>(&data));
#else
						DebugPrint(2, "SmartUpdateSurface - process rows w/ bilinear interp (PARALLEL)\n");
						m_gSmartUpdateRowProcessThread.BranchParallel(ProcessPixelRowBilinear, rows, bitmapHeight, reinterpret_cast<const void*>(&data), 0,
							static_cast<const void*>(nullptr), static_cast<int>(bitmapWidth * sizeof(Color)), m_backBuffer.data);
#endif
					}
					else
					{
#if defined(GRASTERSURFACE_DEBUG_MAC_SERIALIZE_SMARTUPDATE_COPY)
						DebugPrint(2, "SmartUpdateSurface - process rows w/ nearest interp (SERIAL)\n");
						for (int y = 0; y < bitmapHeight; ++y)
							ProcessPixelRowNearest(static_cast<const void*>(nullptr), &m_backBuffer.data[y * bitmapWidth], y, reinterpret_cast<const void*>(&data));
#else
						DebugPrint(2, "SmartUpdateSurface - process rows w/ nearest interp (PARALLEL)\n");
						m_gSmartUpdateRowProcessThread.BranchParallel(ProcessPixelRowNearest, rows, bitmapHeight, reinterpret_cast<const void*>(&data), 0,
							static_cast<const void*>(nullptr), static_cast<int>(bitmapWidth * sizeof(Color)), m_backBuffer.data);
#endif
					}

#if !defined(GRASTERSURFACE_DEBUG_MAC_SERIALIZE_SMARTUPDATE_COPY)
					// wait for data to finish processing
					DebugPrint(2, "SmartUpdateSurface - converge row processing threads\n");
					GReturn convergeResult = m_gSmartUpdateRowProcessThread.Converge(0);
					if (G_FAIL(convergeResult))
					{
						DebugPrint(2, "SmartUpdateSurface - converge failed, attempt to unlock back buffer for write\n");
						if (+m_backBuffer.UnlockSyncWrite())
						{
							DebugPrint(2, "SmartUpdateSurface - unlocked back buffer for write; return\n\n");
							return convergeResult;
						}
					}
#endif

					//	// increment and store frame count in buffer
					DebugPrint(2, "SmartUpdateSurface - increment and store frame number in back buffer\n");
					m_backBuffer.frameNum = ++m_frameCount;
					// unlock and return
					DebugPrint(2, "SmartUpdateSurface - unlock and return\n");
					if (+m_backBuffer.UnlockSyncWrite()
						&& +UnlockSyncWrite())
					{
						DebugPrint(2, "SmartUpdateSurface - unlocked self, back buffer for write; successful; return\n\n");
						return GReturn::SUCCESS;
					}
				}
				DebugPrint(2, "SmartUpdateSurface - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

#pragma endregion UPDATE_FUNCTIONS
#pragma region LOCK_AND_UNLOCK_FUNCTIONS

			GReturn LockUpdateBufferWrite(Color** _outMemoryBuffer, unsigned short& _outWidth, unsigned short& _outHeight) override
			{
				DebugPrint(0, "\nLockUpdateBufferWrite\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "LockUpdateBufferWrite - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}

				// validate arguments
				if (_outMemoryBuffer == nullptr)
				{
					DebugPrint(2, "LockUpdateBufferWrite - _outMemoryBuffer was nullptr; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// if args are valid, continue

				// reject lock if already locked for writing
				DebugPrint(2, "LockUpdateBufferWrite - check number of active write locks\n");
				if (m_backBuffer.numLocks > 0)
				{
					DebugPrint(2, "LockUpdateBufferWrite - write lock already active; return\n\n");
					return GReturn::FAILURE;
				}
				// otherwise, try to lock for writing
				DebugPrint(2, "LockUpdateBufferWrite - attempt to lock back buffer for write\n");
				if (+m_backBuffer.LockSyncWrite())
				{
					DebugPrint(2, "LockUpdateBufferWrite - locked back buffer for write\n");
					++m_backBuffer.numLocks;
					DebugPrint(2, "LockUpdateBufferWrite - %d write locks\n", m_backBuffer.numLocks);
					// give buffer data pointer and dimensions to caller and return
					DebugPrint(2, "LockUpdateBufferWrite - set return values\n");
					*_outMemoryBuffer = m_backBuffer.data;
					_outWidth = m_bitmapWidth;
					_outHeight = m_bitmapHeight;
					DebugPrint(2, "LockUpdateBufferWrite - successful; return\n\n");
					return GReturn::SUCCESS;
				}
				DebugPrint(2, "LockUpdateBufferWrite - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}
			GReturn LockUpdateBufferRead(const Color** _outMemoryBuffer, unsigned short& _outWidth, unsigned short& _outHeight) override
			{
				DebugPrint(0, "\nLockUpdateBufferRead\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "LockUpdateBufferRead - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}

				// validate arguments
				if (_outMemoryBuffer == nullptr)
				{
					DebugPrint(2, "LockUpdateBufferWrite - _outMemoryBuffer was nullptr; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// if args are valid, continue

				// reject lock if already locked for reading
				DebugPrint(2, "LockUpdateBufferRead - check number of active read locks\n");
				if (m_frontBuffer.numLocks > 0)
				{
					DebugPrint(2, "LockUpdateBufferRead - read lock already active; return\n\n");
					return GReturn::FAILURE;
				}
				// otherwise, try to lock for reading
				DebugPrint(2, "LockUpdateBufferRead - attempt to lock front buffer for read\n");
				if (+m_frontBuffer.LockAsyncRead())
				{
					DebugPrint(2, "LockUpdateBufferRead - locked front buffer for read\n");
					++m_frontBuffer.numLocks;
					DebugPrint(2, "LockUpdateBufferRead - %d read locks\n", m_frontBuffer.numLocks);
					// give buffer data pointer and dimensions to caller and return
					DebugPrint(2, "LockUpdateBufferRead - set return values\n");
					*_outMemoryBuffer = reinterpret_cast<const Color*>(m_frontBuffer.data);
					_outWidth = m_bitmapWidth;
					_outHeight = m_bitmapHeight;
					DebugPrint(2, "LockUpdateBufferRead - successful; return\n\n");
					return GReturn::SUCCESS;
				}
				DebugPrint(2, "LockUpdateBufferRead - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			GReturn UnlockUpdateBufferWrite() override
			{
				DebugPrint(0, "\nUnlockUpdateBufferWrite\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "UnlockUpdateBufferWrite - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				// ignore unlock if not locked
				if (m_backBuffer.numLocks == 0)
				{
					DebugPrint(2, "UnlockUpdateBufferWrite - redundant; return\n\n");
					return GReturn::REDUNDANT;
				}

				--m_backBuffer.numLocks;
				DebugPrint(2, "UnlockUpdateBufferWrite - %d write locks\n", m_backBuffer.numLocks);

				// otherwise, update frame number in buffer and unlock
				DebugPrint(2, "UnlockUpdateBufferWrite - attempt to lock self for write\n");
				if (+LockSyncWrite())
				{
					DebugPrint(2, "UnlockUpdateBufferWrite - locked self for write\n");
					// increment and store frame count in buffer
					DebugPrint(2, "UnlockUpdateBufferWrite - increment and store frame number in back buffer\n");
					m_backBuffer.frameNum = ++m_frameCount;
					// unlock and return
					DebugPrint(2, "UnlockUpdateBufferWrite - attempt to unlock self, back buffer for write\n");
					if (+UnlockSyncWrite()
						&& +m_backBuffer.UnlockSyncWrite())
					{
						DebugPrint(2, "UnlockUpdateBufferWrite - unlocked self, back buffer for write; successful; return\n\n");
						return GReturn::SUCCESS;
					}
					DebugPrint(2, "UnlockUpdateBufferWrite - unexpected result; return\n\n");
					return GReturn::UNEXPECTED_RESULT; // should never reach here
				}
				DebugPrint(2, "UnlockUpdateBufferWrite - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}
			GReturn UnlockUpdateBufferRead() override
			{
				DebugPrint(0, "\nUnlockUpdateBufferRead\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "UnlockUpdateBufferRead - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				// ignore unlock if not locked
				if (m_frontBuffer.numLocks < 1)
				{
					DebugPrint(2, "UnlockUpdateBufferRead - redundant; return\n\n");
					return GReturn::REDUNDANT;
				}
				// otherwise, unlock
				--m_frontBuffer.numLocks;
				DebugPrint(2, "UnlockUpdateBufferRead - %d read locks\n", m_frontBuffer.numLocks);
				DebugPrint(2, "UnlockUpdateBufferRead - attempt to unlock front buffer for read\n");
				if (+m_frontBuffer.UnlockAsyncRead())
				{
					DebugPrint(2, "UnlockUpdateBufferRead - unlocked front buffer for read\n");
					DebugPrint(2, "UnlockUpdateBufferRead - successful; return\n\n", m_frontBuffer.numLocks);
					return GReturn::SUCCESS;
				}
				DebugPrint(2, "UnlockUpdateBufferRead - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

#pragma endregion LOCK_AND_UNLOCK_FUNCTIONS

			GReturn Present() override
			{
				DebugPrint(0, "\nPresent\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "Present - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				DebugPrint(2, "Present - draw\n");
				if (-SwapBuffersAndDraw())
				{
					DebugPrint(2, "Present - draw failed; return\n");
					return GReturn::FAILURE;
				}
				DebugPrint(2, "Present - successful; return\n");
				return GReturn::SUCCESS;
			}

		}; // end class GRasterSurfaceImplementation
	} // end namespace I
} // end namespace GW


namespace internal_gw
{
	// GMacBLITView Implementation

	G_OBJC_IMPLEMENTATION_DATA_MEMBERS_PROPERTY_METHOD(GMacBLITView);

	// Constructor
	G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacBLITView, id, initUsingFrame, NSRect _frameRect)
	{
		//NSLog(@"initUsingFrame: %@", self);
		self = [self initWithFrame:_frameRect];

		if (self)
		{

			// Retrieve the data members of this instance.
			G_OBJC_DATA_MEMBERS_TYPE(GMacBLITView)& selfDM = G_OBJC_GET_DATA_MEMBERS(GMacBLITView, self);

			selfDM.m_colorspace = CGColorSpaceCreateDeviceRGB();
			selfDM.m_bitsPerComponent = 8;
			selfDM.m_width = _frameRect.size.width;
			selfDM.m_height = _frameRect.size.height;
			selfDM.m_bytesPerRow = selfDM.m_width * sizeof(unsigned int);

			selfDM.m_data = static_cast<unsigned int*>(calloc(selfDM.m_width * selfDM.m_height, sizeof(unsigned int)));

			// kCGImageAlphaNoneSkipFirst is ARGB format but it skips the alpha channel.
			CGContextRef bitmapContext = CGBitmapContextCreate(selfDM.m_data,
															   static_cast<CGFloat>(selfDM.m_width),
															   static_cast<CGFloat>(selfDM.m_height),
															   selfDM.m_bitsPerComponent,
															   selfDM.m_bytesPerRow,
															   selfDM.m_colorspace,
															   kCGImageAlphaNoneSkipFirst);

			selfDM.m_image = CGBitmapContextCreateImage(bitmapContext);
			CGContextRelease(bitmapContext);
		}

		return self;
	}

	// Updates the view. Not to be called directly. Must use [self setNeedsDisplay:YES] to trigger call.
	G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacBLITView, void, drawRect, CGRect _rect)
	{
		G_OBJC_DATA_MEMBERS_TYPE(GMacBLITView)& selfDM = G_OBJC_GET_DATA_MEMBERS(GMacBLITView, self);

		// CGContext isn't available prior to calling drawRect
		if (!selfDM.m_context)
			selfDM.m_context = [[NSGraphicsContext currentContext] CGContext];

		if (selfDM.m_context && selfDM.m_image)
		{
			CGContextDrawImage(selfDM.m_context, _rect, selfDM.m_image);
			CGImageRelease(selfDM.m_image);
			selfDM.m_image = nil;
		}
	}

	// This override ensures the coordinate system origin is always in the upper-left corner.
	G_OBJC_HEADER_INSTANCE_METHOD(GMacBLITView, BOOL, isFlipped)
	{
		return NO;
	}

	// Frees dynamic memory used by the object.
	G_OBJC_HEADER_INSTANCE_METHOD(GMacBLITView, void, cleanup)
	{
		G_OBJC_DATA_MEMBERS_TYPE(GMacBLITView)& selfDM = G_OBJC_GET_DATA_MEMBERS(GMacBLITView, self);

		free(selfDM.m_data);
		selfDM.m_data = nullptr;

		if (selfDM.m_image)
		{
			CGImageRelease(selfDM.m_image);
			selfDM.m_image = nil;
		}
	}

	// Creates image to be displayed from given pixels.
	G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacBLITView, void, update, unsigned int* _pixels, unsigned int _pixelCount)
	{
		G_OBJC_DATA_MEMBERS_TYPE(GMacBLITView)& selfDM = G_OBJC_GET_DATA_MEMBERS(GMacBLITView, self);

		if (selfDM.m_image) // If this is true, then there is a frame that hasn't been drawn yet.
			return; // Rather than keep overriding frames, we drop them until the last one has been drawn.

		// Copy pixels into the raster data
		memcpy(selfDM.m_data, _pixels, _pixelCount * sizeof(unsigned int));

		// bitmapContext and image are immutable, so they need to be recreated every time.
		CGContextRef bitmapContext = CGBitmapContextCreate(selfDM.m_data,
														   static_cast<CGFloat>(selfDM.m_width),
														   static_cast<CGFloat>(selfDM.m_height),
														   selfDM.m_bitsPerComponent,
														   selfDM.m_bytesPerRow,
														   selfDM.m_colorspace,
														   kCGImageAlphaNoneSkipFirst);

		selfDM.m_image = CGBitmapContextCreateImage(bitmapContext);
		CGContextRelease(bitmapContext);

		// Notify system to redraw view and call drawRect. This must be done on the main thread.
		dispatch_async(dispatch_get_main_queue(), ^ {
			[self setNeedsDisplay:YES];
		});
	}

	// GMacBLITView Implementation End
}


#if defined(GRASTERSURFACE_DEBUG_MAC_SERIALIZE_SMARTUPDATE_COPY)
#undef GRASTERSURFACE_DEBUG_MAC_SERIALIZE_SMARTUPDATE_COPY
#endif
#if defined(GRASTERSURFACE_DEBUG_MAC_DEBUG_ASSERTS)
#undef GRASTERSURFACE_DEBUG_MAC_DEBUG_ASSERTS
#endif
#if defined(GRASTERSURFACE_DEBUG_MAC_DEBUG_PRINTS)
#undef GRASTERSURFACE_DEBUG_MAC_DEBUG_PRINTS
#endif
#if defined(GRASTERSURFACE_DEBUG_MAC_DEBUG_PRINT_PRIORITY_LEVEL)
#undef GRASTERSURFACE_DEBUG_MAC_DEBUG_PRINT_PRIORITY_LEVEL
#endif


#elif defined(__linux__)
	







#include <stdlib.h>
#include <cstring>
#include <iostream>
#include <assert.h>

#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xresource.h>


//#define GRASTERSURFACE_DEBUG_LINUX_SERIALIZE_SMARTUPDATE_COPY		// uncomment this line to disable multithreading in SmartUpdateSurface for debugging
//#define GRASTERSURFACE_DEBUG_LINUX_ASSERTS						// uncomment this line to enable debug asserts
//#define GRASTERSURFACE_DEBUG_LINUX_PRINTS							// uncomment this line to enable debug messages to be printed to the console
//#define GRASTERSURFACE_DEBUG_LINUX_PRINT_PRIORITY_LEVEL 0			// use this to set the priority level of debug messages to print (lower number = higher priority, any priority levels greater than this will be ignored)


namespace GW
{
	namespace I
	{
		class GRasterSurfaceImplementation : public virtual GRasterSurfaceInterface,
			protected GEventResponderImplementation
		{
		private:

#pragma region DEFINES

			typedef unsigned int		Color; // XRGB quadruple
			typedef unsigned char		ColorChannel; // single value from a Color (X, R, G, or B)

#pragma endregion DEFINES
#pragma region ENUMS_STRUCTS_AND_CLASSES

			// GRasterUpdateFlags bit positions for left/right shifting
			enum UpdateFlagBitPosition
			{
				BIT_ALIGN_X_LEFT = 0,
				BIT_ALIGN_X_CENTER,
				BIT_ALIGN_X_RIGHT,
				BIT_ALIGN_Y_TOP,
				BIT_ALIGN_Y_CENTER,
				BIT_ALIGN_Y_BOTTOM,
				BIT_UPSCALE_2X,
				BIT_UPSCALE_3X,
				BIT_UPSCALE_4X,
				BIT_UPSCALE_8X,
				BIT_UPSCALE_16X,
				BIT_STRETCH_TO_FIT,
				BIT_INTERPOLATE_NEAREST,
				BIT_INTERPOLATE_BILINEAR,
			};

			// flags indicating the active state of the surface
			enum class SurfaceState : int
			{
				INVALID		= -1, // GWindow has been destroyed and surface cannot work properly
				INACTIVE	=  0, // surface is not active and will not draw
				ACTIVE		=  1, // surface is active and can draw
			};

			// class containing data unique to each buffer
			class Buffer : protected GThreadSharedImplementation
			{
			private:

				// prints a debug message to the console if GRASTERSURFACE_DEBUG_LINUX_PRINTS is defined (only prints if priority level is set above 0)
				inline void const DebugPrint(const char* _msg) const
				{
#if defined(GRASTERSURFACE_DEBUG_LINUX_PRINTS) && defined(GRASTERSURFACE_DEBUG_LINUX_PRINT_PRIORITY_LEVEL)
				if (GRASTERSURFACE_DEBUG_LINUX_PRINT_PRIORITY_LEVEL > 0)
					std::printf("%s buffer - %s", debugName, _msg);
#endif
				}

			public:

				Color*						data = nullptr;
				unsigned int				numLocks = 0;
				unsigned long long			frameNum = 0;
				char						debugName[16];

				GReturn Create(const char* _debugName)
				{
					INTERNAL::strcpy_s(debugName, 16, _debugName);
					DebugPrint("Create\n");
					return GThreadSharedImplementation::Create();
				}

				GReturn LockSyncWrite() override
				{
					DebugPrint("LockSyncWrite\n");
					return GThreadSharedImplementation::LockSyncWrite();
				}

				GReturn LockAsyncRead() const override
				{
					DebugPrint("LockAsyncRead\n");
					return GThreadSharedImplementation::LockAsyncRead();
				}

				GReturn UnlockSyncWrite() override
				{
					DebugPrint("UnlockSyncWrite\n");
					return GThreadSharedImplementation::UnlockSyncWrite();
				}

				GReturn UnlockAsyncRead() const override
				{
					DebugPrint("UnlockAsyncRead\n");
					return GThreadSharedImplementation::UnlockAsyncRead();
				}
			};

			// struct containing variables needed by SmartUpdateSurface
			struct SmartUpdateData
			{
				const Color*			inputColors = nullptr;			// pointer to input colors to use for update
				unsigned int			bitmapWidth = 0;				// local copy of bitmap width, since it could be altered during execution
				unsigned int			bitmapHeight = 0;				// local copy of bitmap height, since it could be altered during execution
				unsigned int			rawDataWidth = 0;				// width of raw data passed to function, in pixels
				unsigned int			rawDataHeight = 0;				// height of raw data passed to function, in pixels
				unsigned int			upscaledDataWidth = 0;			// width of data after upscaling, in pixels
				unsigned int			upscaledDataHeight = 0;			// height of data after upscaling, in pixels
				int						offsetX = 0;					// horizontal offset of processed data, in pixels
				int						offsetY = 0;					// vertical offset of processed data, in pixels
				float					coordScaleRatioX = 1.0f;		// horizontal pixel coordinate scaling ratio
				float					coordScaleRatioY = 1.0f;		// vertical pixel coordinate scaling ratio
			};

#pragma endregion ENUMS_STRUCTS_AND_CLASSES
#pragma region VARIABLES

			// Gateware types are named as:		gVariableName
			// X11/Linux types are named as:	xVariableName

			GW::SYSTEM::GWindow						m_gWindow;											// parent GWindow
			GW::CORE::GEventResponder				m_gEventListener;									// listener used to subscribe to GWindow events
			GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE		m_gUniversalWindowHandle = { nullptr, nullptr };	// universal window handle extracted from GWindow
			GW::SYSTEM::GConcurrent					m_gDrawThread;										// GConcurrent used for swapping buffers and drawing
			GW::SYSTEM::GConcurrent					m_gSmartUpdateRowProcessThread;						// GConcurrent used for copying data in SmartUpdateSurface

			Display*								m_xDisplay = nullptr;								// X11 display extracted from universal window handle
			int										m_xScreen = -1;										// X11 screen extracted from X11 display
			Window									m_xWindow;											// X11 window extracted from universal window handle
			XImage*									m_xFrontBufferImage = nullptr;						// XImage used to draw to screen

			SurfaceState							m_surfaceState = SurfaceState::INACTIVE;
			unsigned long long						m_frameCount = 0;
			Color*									m_bitmapData = nullptr;								// buffer color data (size is 2 * (width * height) since it contains both buffers' data)
			unsigned short							m_bitmapWidth = 0;									// width of surface data, as well as front and back buffers
			unsigned short							m_bitmapHeight = 0;									// height of surface data, as well as front and back buffers;
			Buffer									m_frontBuffer;										// buffer used to transfer the current frame to the screen
			Buffer									m_backBuffer; 										// buffer used to prepare the next frame

#pragma endregion VARIABLES
#pragma region PRIVATE_FUNCTIONS

			// Prints a debug message to the console if GRASTERSURFACE_DEBUG_LINUX_PRINTS is defined.
			/*
			*	Used to assist with debugging, since multi-threading makes debugging tools harder to use.
			*	If int arguments are passed, they will be inserted into the output if _msg is a format string.
			*/
			static inline void DebugPrint(int _priorityLevel, const char* _msg,
				long long _intArg0 = 0, long long _intArg1 = 0, long long _intArg2 = 0, long long _intArg3 = 0,
				long long _intArg4 = 0, long long _intArg5 = 0, long long _intArg6 = 0, long long _intArg7 = 0)
			{
#if defined(GRASTERSURFACE_DEBUG_LINUX_PRINTS) && defined(GRASTERSURFACE_DEBUG_LINUX_PRINT_PRIORITY_LEVEL)
				if (_priorityLevel <= GRASTERSURFACE_DEBUG_LINUX_PRINT_PRIORITY_LEVEL)
					std::printf(_msg, _intArg0, _intArg1, _intArg2, _intArg3, _intArg4, _intArg5, _intArg6, _intArg7);
#endif
			}

			// Calls assert on the passed-in statement if GRASTERSURFACE_DEBUG_LINUX_DEBUG_ASSERTS is defined.
			static inline void DebugAssert(bool _statement)
			{
#if defined(GRASTERSURFACE_DEBUG_LINUX_DEBUG_ASSERTS)
				assert(_statement);
#endif
			}

			// Destroys and recreates bitmap data with new dimensions.
			/*
			*	Makes the surface active.
			*
			*	retval GReturn::SUCCESS					Completed successfully.
			*	retval GReturn::PREMATURE_DEALLOCATION	The associated GWindow was deallocated and the surface is now invalid.
			*	retval GReturn::UNEXPECTED_RESULT		The function entered an area it was not supposed to be able to.
			*/
			GReturn ResizeBitmap(unsigned int _width, unsigned int _height)
			{
				DebugPrint(1, "\nResizeBitmap\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "ResizeBitmap - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				// lock to prevent read/write conflicts
				DebugPrint(2, "ResizeBitmap - attempt to lock self, back buffer, front buffer for write\n");
				if (+LockSyncWrite()
					&& +m_backBuffer.LockSyncWrite()
					&& +m_frontBuffer.LockSyncWrite())
				{
					DebugPrint(2, "ResizeBitmap - locked self, back buffer, front buffer for write\n");
					// store new dimensions
					DebugPrint(2, "ResizeBitmap - store args\n");
					m_bitmapWidth = _width;
					m_bitmapHeight = _height;
					// destroy old XImage
					if (m_xFrontBufferImage)
					{
						DebugPrint(2, "ResizeBitmap - destroy XImage\n");
						m_xFrontBufferImage->data = nullptr;
						XDestroyImage(m_xFrontBufferImage);
						m_xFrontBufferImage = nullptr;
					}
					// destroy old bitmap
					DebugPrint(2, "ResizeBitmap - destroy bitmap\n");
					if (m_bitmapData)
					{
						delete[] m_bitmapData;
						m_bitmapData = nullptr;
					}
					// allocate and clear new bitmap
					DebugPrint(2, "ResizeBitmap - create and clear bitmap\n");
					m_bitmapData = new Color[m_bitmapWidth * m_bitmapHeight * 2];
					memset(m_bitmapData, 0x00, (m_bitmapWidth * m_bitmapHeight * 2) * sizeof(Color));
					// reset buffer data pointers
					DebugPrint(2, "ResizeBitmap - reset buffer data pointers\n");
					m_backBuffer.data = &m_bitmapData[0];
					m_frontBuffer.data = &m_bitmapData[m_bitmapWidth * m_bitmapHeight];
					// create new XImage
					DebugPrint(2, "ResizeBitmap - create XImage\n");
					m_xFrontBufferImage = XCreateImage(m_xDisplay,		// display
						DefaultVisual(m_xDisplay, m_xScreen),			// visual
						DefaultDepth(m_xDisplay, m_xScreen),			// depth
						ZPixmap,										// format
						0,												// offset (pixels to ignore at start of scanline)
						reinterpret_cast<char*>(m_frontBuffer.data),	// data
						m_bitmapWidth,									// image width
						m_bitmapHeight,									// image height
						32,												// bits per pixel
						0);												// bytes per line (0 = auto-calculated)
					// mark surface as active
					DebugPrint(2, "ResizeBitmap - make surface active\n");
					m_surfaceState = SurfaceState::ACTIVE;
					// increment and store frame number in front buffer
					DebugPrint(2, "ResizeBitmap - increment and store frame number in front buffer\n");
					m_frontBuffer.frameNum = ++m_frameCount;
					// unlock and return
					DebugPrint(2, "ResizeBitmap - attempt to unlock self, back buffer, front buffer for write\n");
					if (+m_frontBuffer.UnlockSyncWrite()
						&& +m_backBuffer.UnlockSyncWrite()
						&& +UnlockSyncWrite())
					{
						DebugPrint(2, "ResizeBitmap - unlocked self, back buffer, front buffer for write; draw\n");
						DrawFrontBufferToScreen();
						DebugPrint(2, "ResizeBitmap - successful; return\n\n");
						return GReturn::SUCCESS;
					}
				}
				DebugPrint(2, "ResizeBitmap - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			// Swaps back buffer to front for drawing and front buffer to back for new data.
			/*
			*	retval GReturn::SUCCESS					Completed successfully.
			*	retval GReturn::IGNORED					Back buffer data is older than front buffer data.
			*	retval GReturn::PREMATURE_DEALLOCATION	The associated GWindow was deallocated and the surface is now invalid.
			*	retval GReturn::UNEXPECTED_RESULT		The function entered an area it was not supposed to be able to.
			*/
			GReturn SwapBackAndFrontBuffers()
			{
				DebugPrint(1, "\nSwapBackAndFrontBuffers\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "SwapBackAndFrontBuffers - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				DebugPrint(2, "SwapBackAndFrontBuffers - attempt to lock back buffer, front buffer for write\n");
				if (+m_backBuffer.LockSyncWrite()
					&& +m_frontBuffer.LockSyncWrite())
				{
					DebugPrint(2, "SwapBackAndFrontBuffers - locked back buffer, front buffer for write\n");
					GReturn gr;
					DebugPrint(2, "SwapBackAndFrontBuffers - compare frame numbers\n");
					if (m_backBuffer.frameNum > m_frontBuffer.frameNum)
					{
						DebugPrint(2, "SwapBackAndFrontBuffers - back buffer has new data; swap buffers\n");
						Color* temp = m_backBuffer.data;
						m_backBuffer.data = m_frontBuffer.data;
						m_frontBuffer.data = temp;
						gr = GReturn::SUCCESS;
					}
					else
					{
						DebugPrint(2, "SwapBackAndFrontBuffers - back buffer outdated\n");
						gr = GReturn::IGNORED;
					}
					DebugPrint(2, "SwapBackAndFrontBuffers - unlock and return\n");
					if (+m_frontBuffer.UnlockSyncWrite()
						&& +m_backBuffer.UnlockSyncWrite())
					{
						DebugPrint(2, "SwapBackAndFrontBuffers - unlocked back buffer, front buffer for write; successful; return\n\n");
						return gr;
					}
				}
				DebugPrint(2, "SwapBackAndFrontBuffers - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			// Draws data in front buffer to screen.
			/*
			*	retval GReturn::SUCCESS					Completed successfully.
			*	retval GReturn::FAILURE					A needed variable was invalid.
			*	retval GReturn::PREMATURE_DEALLOCATION	The associated GWindow was deallocated and the surface is now invalid.
			*	retval GReturn::UNEXPECTED_RESULT		The function entered an area it was not supposed to be able to.
			*/
			GReturn DrawFrontBufferToScreen()
			{
				DebugPrint(1, "\nDrawFrontBufferToScreen\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "DrawFrontBufferToScreen - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				DebugPrint(2, "DrawFrontBufferToScreen - attempt to lock front buffer for read\n");
				if (+m_frontBuffer.LockAsyncRead())
				{
					DebugPrint(2, "DrawFrontBufferToScreen - locked front buffer for read\n");
					GReturn gr;
					// validate needed variables
					DebugPrint(2, "DrawFrontBufferToScreen - validate vars\n");
					if (m_gWindow == nullptr
						|| m_xDisplay == nullptr
						|| m_xScreen < 0
						|| m_xFrontBufferImage == nullptr
						|| m_frontBuffer.data == nullptr
						|| m_bitmapData == nullptr
						|| m_xFrontBufferImage->data == nullptr)
					{
						DebugPrint(2, "DrawFrontBufferToScreen - m_gWindow, m_xDisplay, m_xFrontBufferImage, m_frontBuffer.data, m_bitmapData, or m_xFrontBufferImage->data was nullptr, or m_xScreen was < 0\n");
						gr = GReturn::FAILURE;
					}
					else // if variables are valid, continue
					{
						DebugPrint(2, "DrawFrontBufferToScreen - vars valid\n");
						// update image's data pointer
						if (m_xFrontBufferImage)
						{
							DebugPrint(2, "DrawFrontBufferToScreen - update XImage data pointer\n");
							m_xFrontBufferImage->data = reinterpret_cast<char*>(m_frontBuffer.data);
						}
						// draw front buffer to screen
						DebugPrint(2, "DrawFrontBufferToScreen - draw to screen\n");
						int result = XPutImage(m_xDisplay, m_xWindow, DefaultGC(m_xDisplay, m_xScreen), m_xFrontBufferImage, 0, 0, 0, 0, m_bitmapWidth, m_bitmapHeight);
						DebugPrint(2, "DrawFrontBufferToScreen - XPutImage returned %d\n", result);
						gr = GReturn::SUCCESS;
					}
					DebugPrint(2, "DrawFrontBufferToScreen - unlock and return\n");
					if (+m_frontBuffer.UnlockAsyncRead())
					{
						DebugPrint(2, "DrawFrontBufferToScreen - unlocked front buffer for read; return\n\n");
						return gr;
					}
				}
				DebugPrint(2, "DrawFrontBufferToScreen - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			// Swaps back and front buffers, then draws front buffer to screen.
			/*
			*	retval GReturn::SUCCESS					Completed successfully.
			*	retval GReturn::PREMATURE_DEALLOCATION	The associated GWindow was deallocated and the surface is now invalid.
			*/
			GReturn SwapBuffersAndDraw()
			{
				DebugPrint(1, "\nSwapBuffersAndDraw\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "SwapBuffersAndDraw - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				// converge draw thread to force completion of outstanding tasks
				DebugPrint(2, "SwapBuffersAndDraw - attempt to converge draw thread\n");
				if (-m_gDrawThread.Converge(0))
				{
					DebugPrint(2, "SwapBuffersAndDraw - converge failed; return\n\n");
					return GReturn::FAILURE;
				}
				DebugPrint(2, "SwapBuffersAndDraw - converge succeeded\n");
				// swap buffers and draw to screen once no tasks are waiting
				DebugPrint(2, "SwapBuffersAndDraw - draw thread branch singular\n");
				m_gDrawThread.BranchSingular([&]() mutable
				{
					if (+SwapBackAndFrontBuffers()) // only draw front buffer if buffers were swapped
					{
						DebugPrint(2, "SwapBuffersAndDraw lambda - buffers were swapped; draw front buffer to screen\n");
						DrawFrontBufferToScreen();
					}
				});
				DebugPrint(2, "SwapBuffersAndDraw - return\n\n");
				return GReturn::SUCCESS;
			}

			// Returns the state of a single bit in a bitfield
			static inline bool IsolateBit(unsigned int _flags, unsigned short _bit)
			{
				return (_flags >> _bit) & 1;
			}

			// Interpolates linearly between two pixel color values.
			static inline Color LerpColor(Color _a, Color _b, float _r)
			{
				// split pixels into channels
				ColorChannel a_channels[4] =
				{
					static_cast<ColorChannel>( (_a & 0x000000FF)),
					static_cast<ColorChannel>(((_a & 0x0000FF00) >>  8)),
					static_cast<ColorChannel>(((_a & 0x00FF0000) >> 16)),
					static_cast<ColorChannel>(((_a & 0xFF000000) >> 24)),
				};
				ColorChannel b_channels[4] =
				{
					static_cast<ColorChannel>( (_b & 0x000000FF)),
					static_cast<ColorChannel>(((_b & 0x0000FF00) >>  8)),
					static_cast<ColorChannel>(((_b & 0x00FF0000) >> 16)),
					static_cast<ColorChannel>(((_b & 0xFF000000) >> 24)),
				};
				// interpolate results
				ColorChannel result[4] =
				{
					static_cast<ColorChannel>((G_LERP_PRECISE(a_channels[0], b_channels[0], _r))),
					static_cast<ColorChannel>((G_LERP_PRECISE(a_channels[1], b_channels[1], _r))),
					static_cast<ColorChannel>((G_LERP_PRECISE(a_channels[2], b_channels[2], _r))),
					static_cast<ColorChannel>((G_LERP_PRECISE(a_channels[3], b_channels[3], _r))),
				};
				return *(reinterpret_cast<Color*>(result));
			}

			// Returns color at truncated integer coordinate; Faster.
			/*
				_xrgbColors				Array of colors to interpolate within
				_width					Width of color array
				_height					Height of color array
				_u						Horizontal "texel" coordinate
				_v						Vertical "texel" coordinate
			*/
			static inline Color InterpolateColorNearest(const Color* _xrgbColors,
				unsigned int _width, unsigned int _height, float _u, float _v)
			{
				return _xrgbColors[static_cast<unsigned int>(_u) + static_cast<unsigned int>(_v) * _width];
			}

			// Returns color blended between nearest four pixels; Slower.
			/*
				_xrgbColors				Array of colors to interpolate within
				_width					Width of color array
				_height					Height of color array
				_u						Horizontal "texel" coordinate
				_v						Vertical "texel" coordinate
			*/
			static inline Color InterpolateColorBilinear(const Color* _xrgbColors,
				unsigned int _width, unsigned int _height, float _u, float _v)
			{
				// offset coordinates to use pixel corners instead of centers
				_u -= 0.5f;
				_u = (_u < 0.0f) ? 0.0f : _u;
				_v -= 0.5f;
				_v = (_v < 0.0f) ? 0.0f : _v;
				// get top-left coordinates
				unsigned int u0 = static_cast<unsigned int>(_u);
				unsigned int v0 = static_cast<unsigned int>(_v);
				// get bottom-right coordinates
				unsigned int u1 = (u0 < _width - 1)  ? u0 + 1 : u0;
				unsigned int v1 = (v0 < _height - 1) ? v0 + 1 : v0;
				// calculate interpolation ratios
				float rx = _u - u0;
				float ry = _v - v0;
				// interpolate results
				return LerpColor(
					LerpColor(_xrgbColors[u0 + (v0 * _width)], _xrgbColors[u1 + (v0 * _width)], rx),
					LerpColor(_xrgbColors[u0 + (v1 * _width)], _xrgbColors[u1 + (v1 * _width)], rx),
					ry);
			}

			// Iterates over a row of pixels and samples colors with nearest interpolation
			static void ProcessPixelRowNearest(const void* _unused, Color* _output, unsigned int _y, const void* _data)
			{
				DebugPrint(3, "\nProcessPixelRowNearest, row %d\n", _y);
				DebugAssert(_output != nullptr);
				// convert user data to correct type
				DebugAssert(_data != nullptr);
				const SmartUpdateData data = *(reinterpret_cast<const SmartUpdateData*>(_data));
				DebugAssert(data.inputColors != nullptr);
				DebugPrint(4, "ProcessPixelRowNearest, row %d - bitmap width = %d\n", _y, data.bitmapWidth);
				DebugPrint(4, "ProcessPixelRowNearest, row %d - bitmap height = %d\n", _y, data.bitmapHeight);
				DebugAssert(data.bitmapWidth > 0);
				DebugAssert(data.bitmapHeight > 0);
				DebugAssert(_y >= 0);
				DebugAssert(_y < data.bitmapHeight);
				// get y position within rectangular area to draw (should only draw between 0 and upscaled data height)
				int relativeY = _y - data.offsetY;
				// skip this row if not in range
				if (relativeY < 0 || relativeY >= static_cast<int>(data.upscaledDataHeight))
				{
					DebugPrint(5, "ProcessPixelRowNearest, row %d - row out of range\n", _y);
					return;
				}
				// init nearest algorithm vars
				float v = relativeY * data.coordScaleRatioY; // vertical "texel" to sample from in input data
				DebugPrint(4, "ProcessPixelRowNearest, row %d - v = %d\n", _y, static_cast<unsigned int>(v));
				DebugAssert(v >= 0);
				DebugAssert(v < data.bitmapHeight);
				// get x position within rectangular area to draw (should only draw between 0 and upscaled data width)
				int relativeX = G_CLAMP_MIN(-data.offsetX, 0);
				// iterate through pixel row and process pixels
				for (int x = G_CLAMP_MIN(data.offsetX, 0); x < G_CLAMP_MAX(data.offsetX + static_cast<int>(data.upscaledDataWidth), static_cast<int>(data.bitmapWidth)); ++x, ++relativeX)
				{
					float u = relativeX * data.coordScaleRatioX; // horizontal "texel" to sample from in input data
					DebugAssert(u >= 0);
					DebugAssert(u < data.bitmapWidth);
					_output[x] = InterpolateColorNearest(data.inputColors, data.rawDataWidth, data.rawDataHeight, u, v);
				}
				DebugPrint(3, "\n");
			}

			// Iterates over a row of pixels and samples colors with bilinear interpolation
			static void ProcessPixelRowBilinear(const void* _unused, Color* _output, unsigned int _y, const void* _data)
			{
				DebugPrint(3, "\nProcessPixelRowBilinear, row %d\n", _y);
				DebugAssert(_output != nullptr);
				// convert user data to correct type
				DebugAssert(_data != nullptr);
				SmartUpdateData data = *(const_cast<SmartUpdateData*>(reinterpret_cast<const SmartUpdateData*>(_data)));
				DebugAssert(data.inputColors != nullptr);
				DebugPrint(4, "ProcessPixelRowBilinear, row %d - bitmap width = %d\n", _y, data.bitmapWidth);
				DebugPrint(4, "ProcessPixelRowBilinear, row %d - bitmap height = %d\n", _y, data.bitmapHeight);
				DebugAssert(data.bitmapWidth > 0);
				DebugAssert(data.bitmapHeight > 0);
				DebugAssert(_y >= 0);
				DebugAssert(_y < data.bitmapHeight);
				// get y position within rectangular area to draw (should only draw between 0 and upscaled data height)
				int relativeY = _y - data.offsetY;
				// skip this row if not in range
				if (relativeY < 0 || relativeY >= static_cast<int>(data.upscaledDataHeight))
				{
					DebugPrint(5, "ProcessPixelRowBilinear, row %d - row out of range\n", _y);
					return;
				}
				// get x position within rectangular area to draw (should only draw between 0 and upscaled data width)
				int relativeX = G_CLAMP_MIN(-data.offsetX, 0);
				// init bilinear algorithm vars
				float v = relativeY * data.coordScaleRatioY; // vertical "texel" to sample from in input data
				DebugPrint(4, "ProcessPixelRowNearest, row %d - v = %d\n", _y, static_cast<unsigned int>(v));
				DebugAssert(v >= 0);
				DebugAssert(v < data.bitmapHeight);
				// iterate through row and process pixels
				for (int x = G_CLAMP_MIN(data.offsetX, 0); x < G_CLAMP_MAX(data.offsetX + static_cast<int>(data.upscaledDataWidth), static_cast<int>(data.bitmapWidth)); ++x, ++relativeX)
				{
					float u = relativeX * data.coordScaleRatioX; // horizontal "texel" to sample from in input data
					DebugAssert(u >= 0);
					DebugAssert(u < data.bitmapWidth);
					_output[x] = InterpolateColorBilinear(data.inputColors, data.rawDataWidth, data.rawDataHeight, u, v);
				}
				DebugPrint(3, "\n");
			}

			void Cleanup()
			{
				DebugPrint(1, "\nCleanup\n");
				DebugPrint(2, "Cleanup - ensure all locks are released\n");
				while (m_backBuffer.numLocks > 0)
				{
					m_backBuffer.UnlockSyncWrite();
					--m_backBuffer.numLocks;
				}
				while (m_frontBuffer.numLocks > 0)
				{
					m_frontBuffer.UnlockAsyncRead();
					--m_frontBuffer.numLocks;
				}

				DebugPrint(2, "Cleanup - deallocate draw thread object\n");
				m_gDrawThread = nullptr; // draw thread must be stopped before freeing the variables it uses

				DebugPrint(2, "Cleanup - attempt to lock self, back buffer, front buffer for write\n");
				if (+LockSyncWrite()
					&& +m_backBuffer.LockSyncWrite()
					&& +m_frontBuffer.LockSyncWrite())
				{
					DebugPrint(2, "Cleanup - locked self, back buffer, front buffer for write\n");

					DebugPrint(2, "Cleanup - deallocate X11 image object\n");
					if (m_xFrontBufferImage)
					{
						m_xFrontBufferImage->data = nullptr;
						XDestroyImage(m_xFrontBufferImage);
						m_xFrontBufferImage = nullptr;
					}
					DebugPrint(2, "Cleanup - clear X11 display object\n");
					if (m_xDisplay)
						m_xDisplay = nullptr;
					DebugPrint(2, "Cleanup - clear buffers' data pointers\n");
					if (m_backBuffer.data)
						m_backBuffer.data = nullptr;
					if (m_frontBuffer.data)
						m_frontBuffer.data = nullptr;
					DebugPrint(2, "Cleanup - clear bitmap data\n");
					if (m_bitmapData)
					{
						delete[] m_bitmapData;
						m_bitmapData = nullptr;
					}

					DebugPrint(2, "Cleanup - attempt to unlock self, back buffer, front buffer for write\n");
					if (+m_frontBuffer.UnlockSyncWrite()
						&& +m_backBuffer.UnlockSyncWrite()
						&& +UnlockSyncWrite())
						DebugPrint(2, "Cleanup - unlocked self, back buffer, front buffer for write\n");
					else
						DebugPrint(2, "Cleanup - unexpected result\n"); // should never reach here
				}
				else
				{
					DebugPrint(2, "Cleanup - unexpected result\n"); // should never reach here
				}
			}

#pragma endregion PRIVATE_FUNCTIONS

		public:

#pragma region CREATE_AND_DESTROY_FUNCTIONS

			~GRasterSurfaceImplementation()
			{
				DebugPrint(0, "\nGRasterSurface destructor\n");
				Cleanup();
			}

			GReturn Create(GW::SYSTEM::GWindow _gWindow)
			{
				DebugPrint(0, "\nCreate\n");

				// validate arguments
				DebugPrint(2, "Create - validate args\n");
				// ensure gwindow exists
				if (_gWindow == nullptr)
				{
					DebugPrint(2, "Create - m_gWindow was nullptr; return\n\n");
					return GW::GReturn::INVALID_ARGUMENT;
				}
				DebugPrint(2, "Create - args valid\n");

				// store arguments
				DebugPrint(2, "Create - store args\n");
				m_gWindow = _gWindow;

				// initialize buffers
				DebugPrint(2, "Create - initialize buffers\n");
				m_backBuffer.Create("back");
				m_frontBuffer.Create("front");

				// get universal window handle from GWindow
				DebugPrint(2, "Create - get universal window handle from gwindow\n");
				if (-m_gWindow.GetWindowHandle(m_gUniversalWindowHandle))
				{
					Cleanup();
					return GReturn::INVALID_ARGUMENT;
				}
				// get X11 objects from window handle
				DebugPrint(2, "Create - get X11 objects from universal window handle\n");
				m_xDisplay = reinterpret_cast<Display*>(m_gUniversalWindowHandle.display);
				m_xScreen = DefaultScreen(m_xDisplay);
				m_xWindow = *(reinterpret_cast<Window*>(m_gUniversalWindowHandle.window));
				// get inner dimensions from window and resize surface to fit
				DebugPrint(2, "Create - get client dimensions of window\n");
				unsigned int newWidth, newHeight;
				if (-m_gWindow.GetClientWidth(newWidth) || -m_gWindow.GetClientHeight(newHeight))
				{
					Cleanup();
					return GReturn::INVALID_ARGUMENT;
				}
				DebugPrint(2, "Create - resize bitmap to client dimensions of window\n");
				ResizeBitmap(newWidth, newHeight);

				// create GConcurrent objects (false = no callbacks)
				DebugPrint(2, "Create - create GConcurrent objects\n");
				m_gDrawThread.Create(false);
				m_gSmartUpdateRowProcessThread.Create(false);
				// create event listener with callback function for GWindow to call
				DebugPrint(2, "Create - create event listener\n");
				GReturn gr = m_gEventListener.Create([&](GW::GEvent _event)
				{
					GW::SYSTEM::GWindow::Events windowEvent;
					GW::SYSTEM::GWindow::EVENT_DATA windowEventData;
					if (+_event.Read(windowEvent, windowEventData))
						switch (windowEvent)
						{
							case GW::SYSTEM::GWindow::Events::MINIMIZE:
							{
								DebugPrint(2, "Create callback lambda - MINIMIZE event received\n");
								// deactivate raster when minimized to prevent updating while window is not visible
								m_surfaceState = SurfaceState::INACTIVE;
							} break;
							case GW::SYSTEM::GWindow::Events::MAXIMIZE:
							{
								DebugPrint(2, "Create callback lambda - MAXIMIZE event received\n");
								// get client dimensions from window and resize bitmap to fit
								DebugPrint(2, "Create callback lambda - MAXIMIZE - resize bitmap\n");
								ResizeBitmap(windowEventData.clientWidth, windowEventData.clientHeight); // makes surface active
							} break;
							case GW::SYSTEM::GWindow::Events::RESIZE:
							{
								DebugPrint(2, "Create callback lambda - RESIZE event received\n");
								// get client dimensions from window and resize bitmap to fit
								DebugPrint(2, "Create callback lambda - RESIZE - resize bitmap\n");
								ResizeBitmap(windowEventData.clientWidth, windowEventData.clientHeight); // makes surface active
							} break;
							case GW::SYSTEM::GWindow::Events::DESTROY:
							{
								DebugPrint(2, "Create callback lambda - DESTROY event received\n");
								m_surfaceState = SurfaceState::INVALID;
								Cleanup();
							} break;
							default:
							{
								DebugPrint(2, "Create callback lambda - unknown event recieved\n");
							} break;
						} // end switch (windowEvent)
				});
				// register event listener with GWindow's event generator
				DebugPrint(2, "Create - register event listener\n");
				if (-m_gWindow.Register(m_gEventListener))
				{
					DebugPrint(2, "Create - registering event listener failed; return\n\n");
					Cleanup();
					return GReturn::INVALID_ARGUMENT;
				}
				DebugPrint(2, "Create - successful; return\n\n");
				return gr;
			}

#pragma endregion CREATE_AND_DESTROY_FUNCTIONS
#pragma region UPDATE_FUNCTIONS

			GReturn Clear(Color _xrgbColor) override
			{
				DebugPrint(0, "\nClear\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "Clear - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}

				DebugPrint(2, "Clear - attempt to lock back buffer for write\n");
				if (+m_backBuffer.LockSyncWrite())
				{
					DebugPrint(2, "Clear - locked back buffer for write\n");
					// store bitmap dimensions locally, since they could change
					unsigned int bitmapWidth = m_bitmapWidth;
					unsigned int bitmapHeight = m_bitmapHeight;
					// fill back buffer with passed color
					DebugPrint(2, "Clear - fill back buffer with color\n");
					for (unsigned int x = 0; x < bitmapWidth; ++x) // manually clear first row
						m_backBuffer.data[x] = _xrgbColor;
					for (unsigned int y = 1; y < bitmapHeight; ++y) // copy cleared row to each other row (much faster than manually clearing every pixel of every row)
						memcpy(&m_backBuffer.data[y * bitmapWidth], &m_backBuffer.data[0], bitmapWidth * sizeof(Color));
					// unlock and return
					DebugPrint(2, "Clear - attempt to unlock back buffer for write\n");
					if (+m_backBuffer.UnlockSyncWrite())
					{
						DebugPrint(2, "Clear - unlocked back buffer for write; successful; return\n\n");
						return GReturn::SUCCESS;
					}
					DebugPrint(2, "Clear - unexpected result; return\n\n");
					return GReturn::UNEXPECTED_RESULT; // should never reach here
				}
				DebugPrint(2, "Clear - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}
			GReturn UpdateSurface(const Color* _xrgbPixels, unsigned int _numPixels) override
			{
				DebugPrint(0, "\nUpdateSurface\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "UpdateSurface - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				
				// validate arguments
				DebugPrint(2, "UpdateSurface - validate args\n");
				// ensure valid pixel array was passed
				if (_xrgbPixels == nullptr)
				{
					DebugPrint(2, "UpdateSurface - _xrgbPixels was nullptr; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure pixel count is nonzero
				if (_numPixels < 1)
				{
					DebugPrint(2, "UpdateSurface - _numPixels was < 1; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure pixel count does not exceed surface pixel count
				if (_numPixels > static_cast<unsigned int>(m_bitmapWidth * m_bitmapHeight))
				{
					DebugPrint(2, "UpdateSurface - _numPixels was > surface's pixel count; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				DebugPrint(2, "UpdateSurface - args valid\n");

				// lock self and back buffer to prevent read/write conflicts
				DebugPrint(2, "UpdateSurface - attempt to lock self, back buffer for write\n");
				if (+LockSyncWrite()
					&& +m_backBuffer.LockSyncWrite())
				{
					DebugPrint(2, "UpdateSurface - locked self, back buffer for write\n");
					// BLIT pixel data to back buffer
					DebugPrint(2, "UpdateSurface - BLIT input pixels to back buffer\n");
					memcpy(m_backBuffer.data, _xrgbPixels, _numPixels * sizeof(Color));
					// increment and store frame number in back buffer
					DebugPrint(2, "UpdateSurface - increment and store frame number in back buffer\n");
					m_backBuffer.frameNum = ++m_frameCount;
					// unlock and return
					DebugPrint(2, "UpdateSurface - unlock and return\n");
					if (+m_backBuffer.UnlockSyncWrite()
						&& +UnlockSyncWrite())
					{
						DebugPrint(2, "UpdateSurface - unlocked self, back buffer for write; successful; return\n\n");
						return GReturn::SUCCESS;
					}
				}
				DebugPrint(2, "UpdateSurface - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}
			GReturn UpdateSurfaceSubset(const Color* _xrgbPixels, unsigned short _numRows, unsigned short _rowWidth, unsigned short _rowStride, int _destX, int _destY) override
			{
				DebugPrint(0, "\nUpdateSurfaceSubset\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "UpdateSurfaceSubset - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}

				// store dimensions locally, since they could potentially change during execution
				DebugPrint(2, "UpdateSurfaceSubset - store bitmap dimensions\n");
				unsigned int bitmapWidth = m_bitmapWidth;
				unsigned int bitmapHeight = m_bitmapHeight;
				// validate arguments
				DebugPrint(2, "UpdateSurfaceSubset - validate args\n");
				// ensure valid pixel array was passed
				if (_xrgbPixels == nullptr)
				{
					DebugPrint(2, "UpdateSurfaceSubset - _xrgbPixels was nullpt; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure row count is nonzero
				if (_numRows < 1)
				{
					DebugPrint(2, "UpdateSurfaceSubset - _numRows was < 1; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure row width is nonzero
				if (_rowWidth < 1)
				{
					DebugPrint(2, "UpdateSurfaceSubset - _numRows was < 1; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure row stride is >= row width, if provided
				if (_rowStride > 0 && _rowStride < _rowWidth)
				{
					DebugPrint(2, "UpdateSurfaceSubset - _rowStride was < _rowWidth; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				DebugPrint(2, "UpdateSurfaceSubset - args valid\n");

				// return immediately if subset is completely outside surface
				if (   _destX >= static_cast<int>(bitmapWidth)
					|| _destX + _rowWidth < 0
					|| _destY >= static_cast<int>(bitmapHeight)
					|| _destY + _numRows < 0)
				{
					DebugPrint(2, "UpdateSurfaceSubset - subset was outside surface; return\n\n");
					return GReturn::REDUNDANT;
				}

				// get row stride
				DebugPrint(2, "UpdateSurfaceSubset - get row stride\n");
				if (_rowStride == 0) _rowStride = _rowWidth;
				// clip subset to edges of surface
				//   left side
				DebugPrint(2, "UpdateSurfaceSubset - clip left side\n");
				if (_destX < 0)
				{
					// move starting location in source data right and shorten rows
					_xrgbPixels += -_destX;
					_rowWidth += _destX; // add, because coord is negative
					// clamp coord to surface edge
					_destX = 0;
				}
				//   right side
				DebugPrint(2, "UpdateSurfaceSubset - clip right side\n");
				if (_destX + _rowWidth > bitmapWidth)
				{
					// shorten rows
					_rowWidth -= (_destX + _rowWidth - bitmapWidth);
				}
				//   top side
				DebugPrint(2, "UpdateSurfaceSubset - clip top side\n");
				if (_destY < 0)
				{
					// move starting location in source data down and reduce row count
					_xrgbPixels += -_destY * _rowStride;
					_numRows += _destY; // add, because coord is negative
					// clamp coord to surface edge
					_destY = 0;
				}
				//   bottom side
				DebugPrint(2, "UpdateSurfaceSubset - clip bottom side\n");
				if (_destY + _numRows > bitmapHeight)
				{
					// reduce row count
					_numRows -= (_destY + _numRows - bitmapHeight);
				}
				// calculate starting index from destination x/y coords
				DebugPrint(2, "UpdateSurfaceSubset - calculate starting index\n");
				unsigned int startIndex = _destX + (_destY * bitmapWidth);

				// lock back buffer to prevent read/write conflicts
				DebugPrint(2, "UpdateSurfaceSubset - attempt to lock self, back buffer for write\n");
				if (+LockSyncWrite()
					&& +m_backBuffer.LockSyncWrite())
				{
					DebugPrint(2, "UpdateSurfaceSubset - locked self, back buffer for write\n");
					// calculate end index
					DebugPrint(2, "UpdateSurfaceSubset - calculate end index\n");
					unsigned int endIndex = startIndex + (bitmapWidth * (_numRows - 1)) + (_rowWidth - 1);
					// BLIT rows of subset block to back buffer
					DebugPrint(2, "UpdateSurfaceSubset - BLIT subset to back buffer\n");
					for (; startIndex < endIndex; startIndex += bitmapWidth, _xrgbPixels += _rowStride)
						memcpy(&m_backBuffer.data[startIndex], _xrgbPixels, _rowWidth * sizeof(Color));
					// increment and store frame count in back buffer
					DebugPrint(2, "UpdateSurfaceSubset - increment and store frame number in back buffer\n");
					m_backBuffer.frameNum = ++m_frameCount;
					// unlock and return
					DebugPrint(2, "UpdateSurfaceSubset - unlock and return\n");
					if (+m_backBuffer.UnlockSyncWrite()
						&& +UnlockSyncWrite())
					{
						DebugPrint(2, "UpdateSurfaceSubset - unlocked self, back buffer for write; successful; return\n\n");
						return GReturn::SUCCESS;
					}
				}
				DebugPrint(2, "UpdateSurfaceSubset - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}
			GReturn SmartUpdateSurface(const Color* _xrgbPixels, unsigned int _numPixels, unsigned short _rowWidth, unsigned int _drawOptionFlags) override
			{
				DebugPrint(0, "\nSmartUpdateSurface\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "SmartUpdateSurface - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}

				// validate arguments
				DebugPrint(2, "SmartUpdateSurface - validate args\n");
				// ensure valid pixel array was passed
				if (_xrgbPixels == nullptr)
				{
					DebugPrint(2, "SmartUpdateSurface - _xrgbPixels was nullptr; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure pixel count is nonzero
				if (_numPixels < 1)
				{
					DebugPrint(2, "SmartUpdateSurface - _numPixels was < 1; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure row width is nonzero
				if (_rowWidth < 1)
				{
					DebugPrint(2, "SmartUpdateSurface - _rowWidth was < 1; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// separate flags into sections and test each section
				const unsigned int bitmaskAlignX =
					  GW::GRAPHICS::GRasterUpdateFlags::ALIGN_X_LEFT
					| GW::GRAPHICS::GRasterUpdateFlags::ALIGN_X_CENTER
					| GW::GRAPHICS::GRasterUpdateFlags::ALIGN_X_RIGHT;
				const unsigned int bitmaskAlignY =
					  GW::GRAPHICS::GRasterUpdateFlags::ALIGN_Y_TOP
					| GW::GRAPHICS::GRasterUpdateFlags::ALIGN_Y_CENTER
					| GW::GRAPHICS::GRasterUpdateFlags::ALIGN_Y_BOTTOM;
				const unsigned int bitmaskUpscale =
					  GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_2X
					| GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_3X
					| GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_4X
					| GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_8X
					| GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_16X
					| GW::GRAPHICS::GRasterUpdateFlags::STRETCH_TO_FIT;
				const unsigned int bitmaskInterpolate =
					  GW::GRAPHICS::GRasterUpdateFlags::INTERPOLATE_NEAREST
					| GW::GRAPHICS::GRasterUpdateFlags::INTERPOLATE_BILINEAR;
				unsigned int testFlags = 0;
				// validate x alignment flags
				testFlags = _drawOptionFlags & bitmaskAlignX;
				if (( IsolateBit(testFlags, UpdateFlagBitPosition::BIT_ALIGN_X_LEFT)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_ALIGN_X_CENTER)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_ALIGN_X_RIGHT)
					) > 1)
				{
					DebugPrint(2, "SmartUpdateSurface - _drawOptionFlags contains conflicting x alignment flags; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// validate y alignment flags
				testFlags = _drawOptionFlags & bitmaskAlignY;
				if (( IsolateBit(testFlags, UpdateFlagBitPosition::BIT_ALIGN_Y_TOP)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_ALIGN_Y_CENTER)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_ALIGN_Y_BOTTOM)
					) > 1)
				{
					DebugPrint(2, "SmartUpdateSurface - _drawOptionFlags contains conflicting y alignment flags; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// validate upscaling flags
				testFlags = _drawOptionFlags & bitmaskUpscale;
				if ((  IsolateBit(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_2X)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_3X)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_4X)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_8X)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_16X)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_STRETCH_TO_FIT)
					) > 1)
				{
					DebugPrint(2, "SmartUpdateSurface - _drawOptionFlags contains conflicting upscaling flags; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// validate interpolation flags
				testFlags = _drawOptionFlags & bitmaskInterpolate;
				if (( IsolateBit(testFlags, UpdateFlagBitPosition::BIT_INTERPOLATE_NEAREST)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_INTERPOLATE_BILINEAR)
					) > 1)
				{
					DebugPrint(2, "SmartUpdateSurface - _drawOptionFlags contains conflicting interpolation flags\n");
					DebugPrint(2, "SmartUpdateSurface - return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				DebugPrint(2, "SmartUpdateSurface - args valid\n");
				// if arguments are valid, continue

				// store surface dimensions and border color locally to avoid needing to read data more than once
				unsigned int bitmapWidth = m_bitmapWidth;
				unsigned int bitmapHeight = m_bitmapHeight;

				// create struct to store data to use during processing
				SmartUpdateData data = {};
				// store color array and metadata
				data.inputColors = _xrgbPixels;
				data.bitmapWidth = bitmapWidth;
				data.bitmapHeight = bitmapHeight;
				data.rawDataWidth = _rowWidth;
				data.rawDataHeight = _numPixels / _rowWidth;
				// determine data dimensions after processing
				DebugPrint(2, "SmartUpdateSurface - calculate upscaled dimensions\n");
				testFlags = _drawOptionFlags & bitmaskUpscale;
				switch (testFlags)
				{
					case GW::GRAPHICS::UPSCALE_2X:
						data.upscaledDataWidth = data.rawDataWidth << 1;
						data.upscaledDataHeight = data.rawDataHeight << 1;
						break;
					case GW::GRAPHICS::UPSCALE_3X:
						data.upscaledDataWidth = data.rawDataWidth * 3;
						data.upscaledDataHeight = data.rawDataHeight * 3;
						break;
					case GW::GRAPHICS::UPSCALE_4X:
						data.upscaledDataWidth = data.rawDataWidth << 2;
						data.upscaledDataHeight = data.rawDataHeight << 2;
						break;
					case GW::GRAPHICS::UPSCALE_8X:
						data.upscaledDataWidth = data.rawDataWidth << 3;
						data.upscaledDataHeight = data.rawDataHeight << 3;
						break;
					case GW::GRAPHICS::UPSCALE_16X:
						data.upscaledDataWidth = data.rawDataWidth << 4;
						data.upscaledDataHeight = data.rawDataHeight << 4;
						break;
					case GW::GRAPHICS::STRETCH_TO_FIT:
						data.upscaledDataWidth = bitmapWidth;
						data.upscaledDataHeight = bitmapHeight;
						break;
					default:
						data.upscaledDataWidth = data.rawDataWidth;
						data.upscaledDataHeight = data.rawDataHeight;
						break;
				}

				// calculate pixel coordinate scaling ratios
				DebugPrint(2, "SmartUpdateSurface - calculate coordinate scaling ratios\n");
				data.coordScaleRatioX = data.rawDataWidth / static_cast<float>(data.upscaledDataWidth);
				data.coordScaleRatioY = data.rawDataHeight / static_cast<float>(data.upscaledDataHeight);

				// determine X alignment
				DebugPrint(2, "SmartUpdateSurface - determine x alignment\n");
				testFlags = _drawOptionFlags & bitmaskAlignX;
				switch (testFlags)
				{
					case GW::GRAPHICS::ALIGN_X_LEFT:
						data.offsetX = 0;
						break;
					case GW::GRAPHICS::ALIGN_X_RIGHT:
						data.offsetX = static_cast<int>(bitmapWidth) - static_cast<int>(data.upscaledDataWidth);
						break;
					case GW::GRAPHICS::ALIGN_X_CENTER:
					default:
						data.offsetX = (static_cast<int>(bitmapWidth) - static_cast<int>(data.upscaledDataWidth)) >> 1;
						break;
				}

				// determine Y alignment
				DebugPrint(2, "SmartUpdateSurface - determine y alignment\n");
				testFlags = _drawOptionFlags & bitmaskAlignY;
				switch (testFlags)
				{
					case GW::GRAPHICS::ALIGN_Y_TOP:
						data.offsetY = 0;
						break;
					case GW::GRAPHICS::ALIGN_Y_BOTTOM:
						data.offsetY = static_cast<int>(bitmapHeight) - static_cast<int>(data.upscaledDataHeight);
						break;
					case GW::GRAPHICS::ALIGN_Y_CENTER:
					default:
						data.offsetY = (static_cast<int>(bitmapHeight) - static_cast<int>(data.upscaledDataHeight)) >> 1;
						break;
				}

				// lock self and back buffer to prevent read/write conflicts
				DebugPrint(2, "SmartUpdateSurface - attempt to lock self, back buffer for write\n");
				if (+LockSyncWrite()
					&& +m_backBuffer.LockSyncWrite())
				{
					DebugPrint(2, "SmartUpdateSurface - locked back buffer for write\n");
#if !defined(GRASTERSURFACE_DEBUG_LINUX_SERIALIZE_SMARTUPDATE_COPY)
					// calculate how many rows of the surface fit into 256 KB
					DebugPrint(2, "SmartUpdateSurface - calculate rows per thread\n");
					unsigned int rows = 262144 / (bitmapWidth * sizeof(Color));
					if (rows == 0) rows = 1; // min of 1
#endif

					// iterate through surface and process pixels
					if ((_drawOptionFlags & bitmaskInterpolate) == GW::GRAPHICS::INTERPOLATE_BILINEAR)
					{
#if defined(GRASTERSURFACE_DEBUG_LINUX_SERIALIZE_SMARTUPDATE_COPY)
						DebugPrint(2, "SmartUpdateSurface - process rows w/ bilinear interp (SERIAL)\n");
						for (int y = 0; y < bitmapHeight; ++y)
							ProcessPixelRowBilinear(static_cast<const void*>(nullptr), &m_backBuffer.data[y * bitmapWidth], y, reinterpret_cast<const void*>(&data));
#else
						DebugPrint(2, "SmartUpdateSurface - process rows w/ bilinear interp (PARALLEL)\n");
						m_gSmartUpdateRowProcessThread.BranchParallel(ProcessPixelRowBilinear, rows, bitmapHeight, reinterpret_cast<const void*>(&data), 0,
							static_cast<const void*>(nullptr), static_cast<int>(bitmapWidth * sizeof(Color)), m_backBuffer.data);
#endif
					}
					else
					{
#if defined(GRASTERSURFACE_DEBUG_LINUX_SERIALIZE_SMARTUPDATE_COPY)
						DebugPrint(2, "SmartUpdateSurface - process rows w/ nearest interp (SERIAL)\n");
						for (int y = 0; y < bitmapHeight; ++y)
							ProcessPixelRowNearest(static_cast<const void*>(nullptr), &m_backBuffer.data[y * bitmapWidth], y, reinterpret_cast<const void*>(&data));
#else
						DebugPrint(2, "SmartUpdateSurface - process rows w/ nearest interp (PARALLEL)\n");
						m_gSmartUpdateRowProcessThread.BranchParallel(ProcessPixelRowNearest, rows, bitmapHeight, reinterpret_cast<const void*>(&data), 0,
							static_cast<const void*>(nullptr), static_cast<int>(bitmapWidth * sizeof(Color)), m_backBuffer.data);
#endif
					}

#if !defined(GRASTERSURFACE_DEBUG_LINUX_SERIALIZE_SMARTUPDATE_COPY)
					// wait for data to finish processing
					DebugPrint(2, "SmartUpdateSurface - converge row processing threads\n");
					GReturn convergeResult = m_gSmartUpdateRowProcessThread.Converge(0);
					if (G_FAIL(convergeResult))
					{
						DebugPrint(2, "SmartUpdateSurface - converge failed, attempt to unlock back buffer for write\n");
						if (+m_backBuffer.UnlockSyncWrite())
						{
							DebugPrint(2, "SmartUpdateSurface - unlocked back buffer for write; return\n\n");
							return convergeResult;
						}
					}
#endif

					//	// increment and store frame count in buffer
					DebugPrint(2, "SmartUpdateSurface - increment and store frame number in back buffer\n");
					m_backBuffer.frameNum = ++m_frameCount;
					// unlock and return
					if (+m_backBuffer.UnlockSyncWrite()
						&& +UnlockSyncWrite())
					{
						DebugPrint(2, "SmartUpdateSurface - unlocked self, back buffer for write; successful; return\n\n");
						return GReturn::SUCCESS;
					}
				}
				DebugPrint(2, "SmartUpdateSurface - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

#pragma endregion UPDATE_FUNCTIONS
#pragma region LOCK_AND_UNLOCK_FUNCTIONS

			GReturn LockUpdateBufferWrite(Color** _outMemoryBuffer, unsigned short& _outWidth, unsigned short& _outHeight) override
			{
				DebugPrint(0, "\nLockUpdateBufferWrite\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "LockUpdateBufferWrite - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}

				// validate arguments
				if (_outMemoryBuffer == nullptr)
				{
					DebugPrint(2, "LockUpdateBufferWrite - _outMemoryBuffer was nullptr; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// if args are valid, continue

				// reject lock if already locked for writing
				DebugPrint(2, "LockUpdateBufferWrite - check number of active write locks\n");
				if (m_backBuffer.numLocks > 0)
				{
					DebugPrint(2, "LockUpdateBufferWrite - write lock already active; return\n\n");
					return GReturn::FAILURE;
				}
				// otherwise, try to lock for writing
				DebugPrint(2, "LockUpdateBufferWrite - attempt to lock back buffer for write\n");
				if (+m_backBuffer.LockSyncWrite())
				{
					DebugPrint(2, "LockUpdateBufferWrite - locked back buffer for write\n");
					++m_backBuffer.numLocks;
					DebugPrint(2, "LockUpdateBufferWrite - %d write locks\n", m_backBuffer.numLocks);
					// give buffer data pointer and dimensions to caller and return
					DebugPrint(2, "LockUpdateBufferWrite - set return values\n");
					*_outMemoryBuffer = m_backBuffer.data;
					_outWidth = m_bitmapWidth;
					_outHeight = m_bitmapHeight;
					DebugPrint(2, "LockUpdateBufferWrite - successful; return\n\n");
					return GReturn::SUCCESS;
				}
				DebugPrint(2, "LockUpdateBufferWrite - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}
			GReturn LockUpdateBufferRead(const Color** _outMemoryBuffer, unsigned short& _outWidth, unsigned short& _outHeight) override
			{
				DebugPrint(0, "\nLockUpdateBufferRead\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "LockUpdateBufferRead - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}

				// validate arguments
				if (_outMemoryBuffer == nullptr)
				{
					DebugPrint(2, "LockUpdateBufferWrite - _outMemoryBuffer was nullptr; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// if args are valid, continue

				// reject lock if already locked for reading
				DebugPrint(2, "LockUpdateBufferRead - check number of active read locks\n");
				if (m_frontBuffer.numLocks > 0)
				{
					DebugPrint(2, "LockUpdateBufferRead - read lock already active; return\n\n");
					return GReturn::FAILURE;
				}
				// otherwise, try to lock for reading
				DebugPrint(2, "LockUpdateBufferRead - attempt to lock front buffer for read\n");
				if (+m_frontBuffer.LockAsyncRead())
				{
					DebugPrint(2, "LockUpdateBufferRead - locked front buffer for read\n");
					++m_frontBuffer.numLocks;
					DebugPrint(2, "LockUpdateBufferRead - %d read locks\n", m_frontBuffer.numLocks);
					// give buffer data pointer and dimensions to caller and return
					DebugPrint(2, "LockUpdateBufferRead - set return values\n");
					*_outMemoryBuffer = reinterpret_cast<const Color*>(m_frontBuffer.data);
					_outWidth = m_bitmapWidth;
					_outHeight = m_bitmapHeight;
					DebugPrint(2, "LockUpdateBufferRead - successful; return\n\n");
					return GReturn::SUCCESS;
				}
				DebugPrint(2, "LockUpdateBufferRead - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			GReturn UnlockUpdateBufferWrite() override
			{
				DebugPrint(0, "\nUnlockUpdateBufferWrite\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "UnlockUpdateBufferWrite - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				// ignore unlock if not locked
				if (m_backBuffer.numLocks == 0)
				{
					DebugPrint(2, "UnlockUpdateBufferWrite - redundant; return\n\n");
					return GReturn::REDUNDANT;
				}

				--m_backBuffer.numLocks;
				DebugPrint(2, "UnlockUpdateBufferWrite - %d write locks\n", m_backBuffer.numLocks);

				// otherwise, update frame number in buffer and unlock
				DebugPrint(2, "UnlockUpdateBufferWrite - attempt to lock self for write\n");
				if (+LockSyncWrite())
				{
					DebugPrint(2, "UnlockUpdateBufferWrite - locked self for write\n");
					// increment and store frame count in buffer
					DebugPrint(2, "UnlockUpdateBufferWrite - increment and store frame number in back buffer\n");
					m_backBuffer.frameNum = ++m_frameCount;
					// unlock and return
					DebugPrint(2, "UnlockUpdateBufferWrite - attempt to unlock self, back buffer for write\n");
					if (+UnlockSyncWrite()
						&& +m_backBuffer.UnlockSyncWrite())
					{
						DebugPrint(2, "UnlockUpdateBufferWrite - unlocked self, back buffer for write; successful; return\n\n");
						return GReturn::SUCCESS;
					}
					DebugPrint(2, "UnlockUpdateBufferWrite - unexpected result; return\n\n");
					return GReturn::UNEXPECTED_RESULT; // should never reach here
				}
				DebugPrint(2, "UnlockUpdateBufferWrite - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}
			GReturn UnlockUpdateBufferRead() override
			{
				DebugPrint(0, "\nUnlockUpdateBufferRead\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "UnlockUpdateBufferRead - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				// ignore unlock if not locked
				if (m_frontBuffer.numLocks < 1)
				{
					DebugPrint(2, "UnlockUpdateBufferRead - redundant; return\n\n");
					return GReturn::REDUNDANT;
				}
				// otherwise, unlock
				--m_frontBuffer.numLocks;
				DebugPrint(2, "UnlockUpdateBufferRead - %d read locks\n", m_frontBuffer.numLocks);
				DebugPrint(2, "UnlockUpdateBufferRead - attempt to unlock front buffer for read\n");
				if (+m_frontBuffer.UnlockAsyncRead())
				{
					DebugPrint(2, "UnlockUpdateBufferRead - unlocked front buffer for read\n");
					DebugPrint(2, "UnlockUpdateBufferRead - successful; return\n\n", m_frontBuffer.numLocks);
					return GReturn::SUCCESS;
				}
				DebugPrint(2, "UnlockUpdateBufferRead - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

#pragma endregion LOCK_AND_UNLOCK_FUNCTIONS

			GReturn Present() override
			{
				DebugPrint(0, "\nPresent\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "Present - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				DebugPrint(2, "Present - draw\n");
				if (-SwapBuffersAndDraw())
				{
					DebugPrint(2, "Present - draw failed; return\n");
					return GReturn::FAILURE;
				}
				DebugPrint(2, "Present - successful; return\n");
				return GReturn::SUCCESS;
			}

		}; // end class GRasterSurfaceImplementation
	} // end namespace I
} // end namespace GW


#if defined(GRASTERSURFACE_DEBUG_LINUX_SERIALIZE_SMARTUPDATE_COPY)
#undef GRASTERSURFACE_DEBUG_LINUX_SERIALIZE_SMARTUPDATE_COPY
#endif
#if defined(GRASTERSURFACE_DEBUG_LINUX_DEBUG_ASSERTS)
#undef GRASTERSURFACE_DEBUG_LINUX_DEBUG_ASSERTS
#endif
#if defined(GRASTERSURFACE_DEBUG_LINUX_PRINTS)
#undef GRASTERSURFACE_DEBUG_LINUX_PRINTS
#endif
#if defined(GRASTERSURFACE_DEBUG_LINUX_PRINT_PRIORITY_LEVEL)
#undef GRASTERSURFACE_DEBUG_LINUX_PRINT_PRIORITY_LEVEL
#endif


#elif defined(_WIN32)
	






#include <stdlib.h>
#include <cstring>
#include <iostream>
#include <assert.h>

#include <Windows.h>


//#define GRASTERSURFACE_DEBUG_WIN32_VERBOSE_NEW					// uncomment this line to override the "new" keyword with a macro that stores additional data to track down memory leaks more easily (WIN32 Debug only)
//#define GRASTERSURFACE_DEBUG_WIN32_SERIALIZE_SMARTUPDATE_COPY		// uncomment this line to disable multithreading in SmartUpdateSurface for debugging
//#define GRASTERSURFACE_DEBUG_WIN32_ASSERTS						// uncomment this line to enable debug asserts
//#define GRASTERSURFACE_DEBUG_WIN32_PRINTS							// uncomment this line to enable debug messages to be printed to the console
//#define GRASTERSURFACE_DEBUG_WIN32_PRINT_PRIORITY_LEVEL 0			// use this to set the priority level of debug messages to print (lower number = higher priority, any priority levels greater than this will be ignored)

#if defined(_WIN32) && !defined(NDEBUG) && defined(GRASTERSURFACE_DEBUG_WIN32_VERBOSE_NEW)
#define new new(_NORMAL_BLOCK, __FILE__, __LINE__)
#endif


namespace GW
{
	namespace I
	{
		class GRasterSurfaceImplementation : public virtual GRasterSurfaceInterface,
			protected GEventResponderImplementation
		{
		private:

#pragma region DEFINES

			typedef unsigned int		Color; // XRGB quadruple
			typedef unsigned char		ColorChannel; // single value from a Color (X, R, G, or B)

#pragma endregion DEFINES
#pragma region ENUMS_STRUCTS_AND_CLASSES

			// GRasterUpdateFlags bit positions for left/right shifting
			enum UpdateFlagBitPosition
			{
				BIT_ALIGN_X_LEFT = 0,
				BIT_ALIGN_X_CENTER,
				BIT_ALIGN_X_RIGHT,
				BIT_ALIGN_Y_TOP,
				BIT_ALIGN_Y_CENTER,
				BIT_ALIGN_Y_BOTTOM,
				BIT_UPSCALE_2X,
				BIT_UPSCALE_3X,
				BIT_UPSCALE_4X,
				BIT_UPSCALE_8X,
				BIT_UPSCALE_16X,
				BIT_STRETCH_TO_FIT,
				BIT_INTERPOLATE_NEAREST,
				BIT_INTERPOLATE_BILINEAR,
			};

			// flags indicating the active state of the surface
			enum class SurfaceState : int
			{
				INVALID		= -1, // GWindow has been destroyed and surface cannot work properly
				INACTIVE	=  0, // surface is not active and will not draw
				ACTIVE		=  1, // surface is active and can draw
			};

			// class containing data unique to each buffer
			class Buffer : protected GThreadSharedImplementation
			{
			private:

				// prints a debug message to the console if GRASTERSURFACE_DEBUG_WIN32_PRINTS is defined (only prints if priority level is set above 0)
				inline void const DebugPrint(const char* _msg) const
				{
#if defined(GRASTERSURFACE_DEBUG_WIN32_PRINTS) && defined(GRASTERSURFACE_DEBUG_WIN32_PRINT_PRIORITY_LEVEL)
				if (GRASTERSURFACE_DEBUG_WIN32_PRINT_PRIORITY_LEVEL > 0)
					std::printf("%s buffer - %s", debugName, _msg);
#endif
				}

			public:

				Color*						data = nullptr;
				unsigned int				numLocks = 0;
				unsigned long long			frameNum = 0;
				char						debugName[16];

				GReturn Create(const char* _debugName)
				{
					strcpy_s(debugName, 16, _debugName);
					DebugPrint("Create\n");
					return GThreadSharedImplementation::Create();
				}

				GReturn LockSyncWrite() override
				{
					DebugPrint("LockSyncWrite\n");
					return GThreadSharedImplementation::LockSyncWrite();
				}

				GReturn LockAsyncRead() const override
				{
					DebugPrint("LockAsyncRead\n");
					return GThreadSharedImplementation::LockAsyncRead();
				}

				GReturn UnlockSyncWrite() override
				{
					DebugPrint("UnlockSyncWrite\n");
					return GThreadSharedImplementation::UnlockSyncWrite();
				}

				GReturn UnlockAsyncRead() const override
				{
					DebugPrint("UnlockAsyncRead\n");
					return GThreadSharedImplementation::UnlockAsyncRead();
				}
			};

			// struct containing variables needed by SmartUpdateSurface
			struct SmartUpdateData
			{
				const Color*			inputColors = nullptr;			// pointer to input colors to use for update
				unsigned int			bitmapWidth = 0;				// local copy of bitmap width since it could be altered during execution
				unsigned int			bitmapHeight = 0;				// local copy of bitmap height, since it could be altered during execution
				unsigned int			rawDataWidth = 0;				// width of raw data passed to function
				unsigned int			rawDataHeight = 0;				// height of raw data passed to function
				unsigned int			upscaledDataWidth = 0;			// width of data after upscaling
				unsigned int			upscaledDataHeight = 0;			// height of data after upscaling
				int						offsetX = 0;					// horizontal offset of processed data
				int						offsetY = 0;					// vertical offset of processed data
				float					coordScaleRatioX = 1.0f;		// horizontal pixel coordinate scaling ratio
				float					coordScaleRatioY = 1.0f;		// vertical pixel coordinate scaling ratio
			};

#pragma endregion ENUMS_STRUCTS_AND_CLASSES
#pragma region VARIABLES

			// Gateware types are named as:		gVariableName
			// Win32 types are named as:		wVariableName

			GW::SYSTEM::GWindow						m_gWindow;											// parent GWindow
			GW::CORE::GEventResponder				m_gEventListener;									// listener used to subscribe to GWindow events
			GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE		m_gUniversalWindowHandle = { nullptr, nullptr };	// universal window handle extracted from GWindow
			GW::SYSTEM::GConcurrent					m_gDrawThread;										// GConcurrent used for swapping buffers and drawing
			GW::SYSTEM::GConcurrent					m_gSmartUpdateRowProcessThread;						// GConcurrent used for copying data in SmartUpdateSurface

			HDC										m_wWindowDeviceContext = nullptr;					// window device context extracted from universal window handle

			SurfaceState							m_surfaceState = SurfaceState::INACTIVE;
			unsigned long long						m_frameCount = 0;
			Color*									m_bitmapData = nullptr;								// buffer color data (size is 2 * (width * height) since it contains both buffers' data)
			unsigned short							m_bitmapWidth = 0;									// width of surface data, as well as front and back buffers
			unsigned short							m_bitmapHeight = 0;									// height of surface data, as well as front and back buffers
			Buffer									m_backBuffer;										// buffer used to transfer the current frame to the screen
			Buffer									m_frontBuffer;										// buffer used to prepare the next frame
			
#pragma endregion VARIABLES
#pragma region PRIVATE_FUNCTIONS

			// Prints a debug message to the console if GRASTERSURFACE_DEBUG_WIN32_PRINTS is defined.
			/*
			*	Used to assist with debugging, since multi-threading makes debugging tools harder to use.
			*	If int arguments are passed, they will be inserted into the output if _msg is a format string.
			*/
			static inline void DebugPrint(int _priorityLevel, const char* _msg,
				long long _intArg0 = 0, long long _intArg1 = 0, long long _intArg2 = 0, long long _intArg3 = 0,
				long long _intArg4 = 0, long long _intArg5 = 0, long long _intArg6 = 0, long long _intArg7 = 0)
			{
#if defined(GRASTERSURFACE_DEBUG_WIN32_PRINTS) && defined(GRASTERSURFACE_DEBUG_WIN32_PRINT_PRIORITY_LEVEL)
				if (_priorityLevel <= GRASTERSURFACE_DEBUG_WIN32_PRINT_PRIORITY_LEVEL)
					std::printf(_msg, _intArg0, _intArg1, _intArg2, _intArg3, _intArg4, _intArg5, _intArg6, _intArg7);
#endif
			}

			// Calls assert on the passed-in statement if GRASTERSURFACE_DEBUG_WIN32_ASSERTS is defined.
			static inline void DebugAssert(bool _statement)
			{
#if defined(GRASTERSURFACE_DEBUG_LINUX_ASSERTS)
				assert(_statement);
#endif
			}

			// Destroys and recreates bitmap data with new dimensions.
			/*
			*	Makes the surface active.
			*
			*	retval GReturn::SUCCESS					Completed successfully.
			*	retval GReturn::PREMATURE_DEALLOCATION	The associated GWindow was deallocated and the surface is now invalid.
			*	retval GReturn::UNEXPECTED_RESULT		The function entered an area it was not supposed to be able to.
			*/
			GReturn ResizeBitmap(unsigned int _width, unsigned int _height)
			{
				DebugPrint(1, "\nResizeBitmap\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "ResizeBitmap - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				// lock to prevent read/write conflicts
				DebugPrint(2, "ResizeBitmap - attempt to lock self, back buffer, front buffer for write\n");
				if (+LockSyncWrite()
					&& +m_backBuffer.LockSyncWrite()
					&& +m_frontBuffer.LockSyncWrite())
				{
					DebugPrint(2, "ResizeBitmap - locked self, back buffer, front buffer for write\n");
					// store new dimensions
					DebugPrint(2, "ResizeBitmap - store args\n");
					m_bitmapWidth = _width;
					m_bitmapHeight = _height;
					// destroy old surface data
					DebugPrint(2, "ResizeBitmap - destroy bitmap\n");
					if (m_bitmapData)
					{
						delete[] m_bitmapData;
						m_bitmapData = nullptr;
					}
					// allocate and clear new bitmap
					DebugPrint(2, "ResizeBitmap - create and clear bitmap\n");
					m_bitmapData = new Color[m_bitmapWidth * m_bitmapHeight * 2];
					memset(m_bitmapData, 0x00, (m_bitmapWidth * m_bitmapHeight * 2) * sizeof(Color));
					// reset buffer data pointers
					DebugPrint(2, "ResizeBitmap - reset buffer data pointers\n");
					m_backBuffer.data = &m_bitmapData[0];
					m_frontBuffer.data = &m_bitmapData[m_bitmapWidth * m_bitmapHeight];
					// mark surface as active
					DebugPrint(2, "ResizeBitmap - make surface active\n");
					m_surfaceState = SurfaceState::ACTIVE;
					// increment and store frame number in front buffer
					DebugPrint(2, "ResizeBitmap - increment and store frame number in front buffer\n");
					m_frontBuffer.frameNum = ++m_frameCount;
					// unlock and return
					DebugPrint(2, "ResizeBitmap - attempt to unlock self, back buffer, front buffer for write\n");
					if (+m_frontBuffer.UnlockSyncWrite()
						&& +m_backBuffer.UnlockSyncWrite()
						&& +UnlockSyncWrite())
					{
						DebugPrint(2, "ResizeBitmap - unlocked self, back buffer, front buffer for write; draw\n");
						DrawFrontBufferToScreen();
						DebugPrint(2, "ResizeBitmap - successful; return\n\n");
						return GReturn::SUCCESS;
					}
				}
				DebugPrint(2, "ResizeBitmap - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			// Swaps back buffer to front for drawing and front buffer to back for new data.
			/*
			*	retval GReturn::SUCCESS					Completed successfully.
			*	retval GReturn::IGNORED					Back buffer data is older than front buffer data.
			*	retval GReturn::PREMATURE_DEALLOCATION	The associated GWindow was deallocated and the surface is now invalid.
			*	retval GReturn::UNEXPECTED_RESULT		The function entered an area it was not supposed to be able to.
			*/
			GReturn SwapBackAndFrontBuffers()
			{
				DebugPrint(1, "\nSwapBackAndFrontBuffers\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "SwapBackAndFrontBuffers - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				DebugPrint(2, "SwapBackAndFrontBuffers - attempt to lock back buffer, front buffer for write\n");
				if (+m_backBuffer.LockSyncWrite()
					&& +m_frontBuffer.LockSyncWrite())
				{
					DebugPrint(2, "SwapBackAndFrontBuffers - locked back buffer, front buffer for write\n");
					GReturn gr;
					DebugPrint(2, "SwapBackAndFrontBuffers - compare frame numbers\n");
					if (m_backBuffer.frameNum > m_frontBuffer.frameNum)
					{
						DebugPrint(2, "SwapBackAndFrontBuffers - back buffer has new data; swap buffers\n");
						Color* temp = m_backBuffer.data;
						m_backBuffer.data = m_frontBuffer.data;
						m_frontBuffer.data = temp;
						gr = GReturn::SUCCESS;
					}
					else
					{
						DebugPrint(2, "SwapBackAndFrontBuffers - back buffer outdated\n");
						gr = GReturn::IGNORED;
					}
					DebugPrint(2, "SwapBackAndFrontBuffers - unlock and return\n");
					if (+m_frontBuffer.UnlockSyncWrite()
						&& +m_backBuffer.UnlockSyncWrite())
					{
						DebugPrint(2, "SwapBackAndFrontBuffers - unlocked back buffer, front buffer for write; successful; return\n\n");
						return gr;
					}
				}
				DebugPrint(2, "SwapBackAndFrontBuffers - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			// Draws data in front buffer to screen.
			/*
			*	retval GReturn::SUCCESS					Completed successfully.
			*	retval GReturn::FAILURE					A needed variable was invalid.
			*	retval GReturn::PREMATURE_DEALLOCATION	The associated GWindow was deallocated and the surface is now invalid.
			*	retval GReturn::UNEXPECTED_RESULT		The function entered an area it was not supposed to be able to.
			*/
			GReturn DrawFrontBufferToScreen()
			{
				DebugPrint(1, "\nDrawFrontBufferToScreen\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "DrawFrontBufferToScreen - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				DebugPrint(2, "DrawFrontBufferToScreen - attempt to lock front buffer for read\n");
				if (+m_frontBuffer.LockAsyncRead())
				{
					DebugPrint(2, "DrawFrontBufferToScreen - locked front buffer for read\n");
					GReturn gr;
					// validate needed variables
					DebugPrint(2, "DrawFrontBufferToScreen - validate vars\n");
					if (m_gWindow == nullptr
						|| m_wWindowDeviceContext == nullptr
						|| m_frontBuffer.data == nullptr
						|| m_bitmapData == nullptr)
					{
						DebugPrint(2, "DrawFrontBufferToScreen - m_gWindow, m_wWindowDeviceContext, m_frontBuffer.data, or m_bitmapData was nullptr\n");
						gr = GReturn::FAILURE;
					}
					else // if variables are valid, continue
					{
						DebugPrint(2, "DrawFrontBufferToScreen - vars valid\n");
						// prepare to draw
						DebugPrint(2, "DrawFrontBufferToScreen - prepare to draw to screen\n");
						static BITMAPINFO toDraw;
						ZeroMemory(&toDraw, sizeof(BITMAPINFO));
						toDraw.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
						toDraw.bmiHeader.biWidth = m_bitmapWidth;
						toDraw.bmiHeader.biHeight = -int(m_bitmapHeight); // flip
						toDraw.bmiHeader.biPlanes = 1;
						toDraw.bmiHeader.biBitCount = 32;
						toDraw.bmiHeader.biCompression = BI_RGB;
						// draw front buffer to screen
						DebugPrint(2, "DrawFrontBufferToScreen - draw to screen\n");
						SetDIBitsToDevice(m_wWindowDeviceContext, 0, 0, m_bitmapWidth, m_bitmapHeight, 0, 0, 0, m_bitmapHeight, m_frontBuffer.data, &toDraw, DIB_RGB_COLORS);
						gr = GReturn::SUCCESS;
					}
					DebugPrint(2, "DrawFrontBufferToScreen - unlock and return\n");
					if (+m_frontBuffer.UnlockAsyncRead())
					{
						DebugPrint(2, "DrawFrontBufferToScreen - unlocked front buffer for read; return\n\n");
						return gr;
					}
				}
				DebugPrint(2, "DrawFrontBufferToScreen - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			// Swaps back and front buffers, then draws front buffer to screen.
			/*
			*	Executes on another thread.
			*
			*	retval GReturn::SUCCESS					Completed successfully.
			*	retval GReturn::FAILURE					Could not converge draw thread.
			*	retval GReturn::PREMATURE_DEALLOCATION	The associated GWindow was deallocated and the surface is now invalid.
			*/
			GReturn SwapBuffersAndDraw()
			{
				DebugPrint(1, "\nSwapBuffersAndDraw\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "SwapBuffersAndDraw - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				// converge draw thread to force completion of outstanding tasks
				DebugPrint(2, "SwapBuffersAndDraw - attempt to converge draw thread\n");
				if (-m_gDrawThread.Converge(0))
				{
					DebugPrint(2, "SwapBuffersAndDraw - converge failed; return\n\n");
					return GReturn::FAILURE;
				}
				DebugPrint(2, "SwapBuffersAndDraw - converge succeeded\n");
				// swap buffers and draw to screen once no tasks are waiting
				DebugPrint(2, "SwapBuffersAndDraw - draw thread branch singular\n");
				m_gDrawThread.BranchSingular([&]() mutable
				{
					if (+SwapBackAndFrontBuffers()) // only draw front buffer if buffers were swapped
					{
						DebugPrint(2, "SwapBuffersAndDraw lambda - buffers were swapped; draw front buffer to screen\n");
						DrawFrontBufferToScreen();
					}
				});
				DebugPrint(2, "SwapBuffersAndDraw - successful; return\n\n");
				return GReturn::SUCCESS;
			}

			// Returns the state of a single bit in a bitfield
			static inline bool IsolateBit(unsigned int _flags, unsigned short _bit)
			{
				return (_flags >> _bit) & 1;
			}

			// Interpolates linearly between two pixel color values.
			static inline Color LerpColor(Color _a, Color _b, float _r)
			{
				// split pixels into channels
				ColorChannel a_channels[4] =
				{
					static_cast<ColorChannel>( (_a & 0x000000FF)),
					static_cast<ColorChannel>(((_a & 0x0000FF00) >>  8)),
					static_cast<ColorChannel>(((_a & 0x00FF0000) >> 16)),
					static_cast<ColorChannel>(((_a & 0xFF000000) >> 24)),
				};
				ColorChannel b_channels[4] =
				{
					static_cast<ColorChannel>( (_b & 0x000000FF)),
					static_cast<ColorChannel>(((_b & 0x0000FF00) >>  8)),
					static_cast<ColorChannel>(((_b & 0x00FF0000) >> 16)),
					static_cast<ColorChannel>(((_b & 0xFF000000) >> 24)),
				};
				// interpolate results
				ColorChannel result[4] =
				{
					static_cast<ColorChannel>((G_LERP_PRECISE(a_channels[0], b_channels[0], _r))),
					static_cast<ColorChannel>((G_LERP_PRECISE(a_channels[1], b_channels[1], _r))),
					static_cast<ColorChannel>((G_LERP_PRECISE(a_channels[2], b_channels[2], _r))),
					static_cast<ColorChannel>((G_LERP_PRECISE(a_channels[3], b_channels[3], _r))),
				};
				return *(reinterpret_cast<Color*>(result));
			}

			// Returns color at truncated integer coordinate; Faster.
			/*
				_xrgbColors				Array of colors to interpolate within
				_width					Width of color array
				_height					Height of color array
				_u						Horizontal "texel" coordinate
				_v						Vertical "texel" coordinate
			*/
			static inline Color InterpolateColorNearest(const Color* _xrgbColors,
				unsigned int _width, unsigned int _height, float _u, float _v)
			{
				return _xrgbColors[static_cast<unsigned int>(_u) + static_cast<unsigned int>(_v) * _width];
			}

			// Returns color blended between nearest four pixels; Slower.
			/*
				_xrgbColors				Array of colors to interpolate within
				_width					Width of color array
				_height					Height of color array
				_u						Horizontal "texel" coordinate
				_v						Vertical "texel" coordinate
			*/
			static inline Color InterpolateColorBilinear(const Color* _xrgbColors,
				unsigned int _width, unsigned int _height, float _u, float _v)
			{
				// offset coordinates to use pixel corners instead of centers
				_u -= 0.5f;
				_u = (_u < 0.0f) ? 0.0f : _u;
				_v -= 0.5f;
				_v = (_v < 0.0f) ? 0.0f : _v;
				// get top-left coordinates
				unsigned int u0 = static_cast<unsigned int>(_u);
				unsigned int v0 = static_cast<unsigned int>(_v);
				// get bottom-right coordinates
				unsigned int u1 = (u0 < _width - 1)  ? u0 + 1 : u0;
				unsigned int v1 = (v0 < _height - 1) ? v0 + 1 : v0;
				// calculate interpolation ratios
				float rx = _u - u0;
				float ry = _v - v0;
				// interpolate results
				return LerpColor(
					LerpColor(_xrgbColors[u0 + (v0 * _width)], _xrgbColors[u1 + (v0 * _width)], rx),
					LerpColor(_xrgbColors[u0 + (v1 * _width)], _xrgbColors[u1 + (v1 * _width)], rx),
					ry);
			}

			// Iterates over a row of pixels and samples colors with nearest interpolation
			static void ProcessPixelRowNearest(const void* _unused, Color* _output, unsigned int _y, const void* _data)
			{
				DebugPrint(3, "\nProcessPixelRowNearest, row %d\n", _y);
				DebugAssert(_output != nullptr);
				// convert user data to correct type
				DebugAssert(_data != nullptr);
				const SmartUpdateData data = *(reinterpret_cast<const SmartUpdateData*>(_data));
				DebugAssert(data.inputColors != nullptr);
				DebugPrint(4, "ProcessPixelRowNearest, row %d - bitmap width = %d\n", _y, data.bitmapWidth);
				DebugPrint(4, "ProcessPixelRowNearest, row %d - bitmap height = %d\n", _y, data.bitmapHeight);
				DebugAssert(data.bitmapWidth > 0);
				DebugAssert(data.bitmapHeight > 0);
				DebugAssert(_y >= 0);
				DebugAssert(_y < data.bitmapHeight);
				// get y position within rectangular area to draw (should only draw between 0 and upscaled data height)
				int relativeY = _y - data.offsetY;
				// skip this row if not in range
				if (relativeY < 0 || relativeY >= static_cast<int>(data.upscaledDataHeight))
				{
					DebugPrint(5, "ProcessPixelRowNearest, row %d - row out of range\n", _y);
					return;
				}
				// init nearest algorithm vars
				float v = relativeY * data.coordScaleRatioY; // vertical "texel" to sample from in input data
				DebugPrint(4, "ProcessPixelRowNearest, row %d - v = %d\n", _y, static_cast<unsigned int>(v));
				DebugAssert(v >= 0);
				DebugAssert(v < data.bitmapHeight);
				// get x position within rectangular area to draw (should only draw between 0 and upscaled data width)
				int relativeX = G_CLAMP_MIN(-data.offsetX, 0);
				// iterate through pixel row and process pixels
				for (int x = G_CLAMP_MIN(data.offsetX, 0); x < G_CLAMP_MAX(data.offsetX + static_cast<int>(data.upscaledDataWidth), static_cast<int>(data.bitmapWidth)); ++x, ++relativeX)
				{
					float u = relativeX * data.coordScaleRatioX; // horizontal "texel" to sample from in input data
					DebugAssert(u >= 0);
					DebugAssert(u < data.bitmapWidth);
					_output[x] = InterpolateColorNearest(data.inputColors, data.rawDataWidth, data.rawDataHeight, u, v);
				}
				DebugPrint(3, "\n");
			}

			// Iterates over a row of pixels and samples colors with bilinear interpolation
			static void ProcessPixelRowBilinear(const void* _unused, Color* _output, unsigned int _y, const void* _data)
			{
				DebugPrint(3, "\nProcessPixelRowBilinear, row %d\n", _y);
				DebugAssert(_output != nullptr);
				// convert user data to correct type
				DebugAssert(_data != nullptr);
				SmartUpdateData data = *(const_cast<SmartUpdateData*>(reinterpret_cast<const SmartUpdateData*>(_data)));
				DebugAssert(data.inputColors != nullptr);
				DebugPrint(4, "ProcessPixelRowBilinear, row %d - bitmap width = %d\n", _y, data.bitmapWidth);
				DebugPrint(4, "ProcessPixelRowBilinear, row %d - bitmap height = %d\n", _y, data.bitmapHeight);
				DebugAssert(data.bitmapWidth > 0);
				DebugAssert(data.bitmapHeight > 0);
				DebugAssert(_y >= 0);
				DebugAssert(_y < data.bitmapHeight);
				// get y position within rectangular area to draw (should only draw between 0 and upscaled data height)
				int relativeY = _y - data.offsetY;
				// skip this row if not in range
				if (relativeY < 0 || relativeY >= static_cast<int>(data.upscaledDataHeight))
				{
					DebugPrint(5, "ProcessPixelRowBilinear, row %d - row out of range\n", _y);
					return;
				}
				// get x position within rectangular area to draw (should only draw between 0 and upscaled data width)
				int relativeX = G_CLAMP_MIN(-data.offsetX, 0);
				// init bilinear algorithm vars
				float v = relativeY * data.coordScaleRatioY; // vertical "texel" to sample from in input data
				DebugPrint(4, "ProcessPixelRowNearest, row %d - v = %d\n", _y, static_cast<unsigned int>(v));
				DebugAssert(v >= 0);
				DebugAssert(v < data.bitmapHeight);
				// iterate through row and process pixels
				for (int x = G_CLAMP_MIN(data.offsetX, 0); x < G_CLAMP_MAX(data.offsetX + static_cast<int>(data.upscaledDataWidth), static_cast<int>(data.bitmapWidth)); ++x, ++relativeX)
				{
					float u = relativeX * data.coordScaleRatioX; // horizontal "texel" to sample from in input data
					DebugAssert(u >= 0);
					DebugAssert(u < data.bitmapWidth);
					_output[x] = InterpolateColorBilinear(data.inputColors, data.rawDataWidth, data.rawDataHeight, u, v);
				}
				DebugPrint(3, "\n");
			}

			void Cleanup()
			{
				DebugPrint(1, "\nCleanup\n");
				DebugPrint(2, "Cleanup - ensure all locks are released\n");
				while (m_backBuffer.numLocks > 0)
				{
					m_backBuffer.UnlockSyncWrite();
					--m_backBuffer.numLocks;
				}
				while (m_frontBuffer.numLocks > 0)
				{
					m_frontBuffer.UnlockAsyncRead();
					--m_frontBuffer.numLocks;
				}

				DebugPrint(2, "Cleanup - deallocate draw thread object\n");
				m_gDrawThread = nullptr; // draw thread must be stopped before freeing the variables it uses

				DebugPrint(2, "Cleanup - attempt to lock self, back buffer, front buffer for write\n");
				if (+LockSyncWrite()
					&& +m_backBuffer.LockSyncWrite()
					&& +m_frontBuffer.LockSyncWrite())
				{
					DebugPrint(2, "Cleanup - locked self, back buffer, front buffer for write\n");

					DebugPrint(2, "Cleanup - clear buffers' data pointers\n");
					if (m_backBuffer.data)
						m_backBuffer.data = nullptr;
					if (m_frontBuffer.data)
						m_frontBuffer.data = nullptr;
					DebugPrint(2, "Cleanup - clear bitmap data\n");
					if (m_bitmapData)
					{
						delete[] m_bitmapData;
						m_bitmapData = nullptr;
					}

					DebugPrint(2, "Cleanup - attempt to unlock self, back buffer, front buffer for write\n");
					if (+m_frontBuffer.UnlockSyncWrite()
						&& +m_backBuffer.UnlockSyncWrite()
						&& +UnlockSyncWrite())
						DebugPrint(2, "Cleanup - unlocked self, back buffer, front buffer for write\n");
					else
						DebugPrint(2, "Cleanup - unexpected result\n"); // should never reach here
				}
				else
				{
					DebugPrint(2, "Cleanup - unexpected result\n"); // should never reach here
				}
			}

#pragma endregion PRIVATE_FUNCTIONS

		public:

#pragma region CREATE_AND_DESTROY_FUNCTIONS

			~GRasterSurfaceImplementation()
			{
				DebugPrint(0, "\nGRasterSurface destructor\n");
				Cleanup();
			}

			GReturn Create(GW::SYSTEM::GWindow _gWindow)
			{
				DebugPrint(0, "\nCreate\n");

				// validate arguments
				DebugPrint(2, "Create - validate args\n");
				// ensure gwindow exists
				if (_gWindow == nullptr)
				{
					DebugPrint(2, "Create - m_gWindow was nullptr; return\n\n");
					return GW::GReturn::INVALID_ARGUMENT;
				}
				DebugPrint(2, "Create - args valid\n");

				// store arguments
				m_gWindow = _gWindow;
				DebugPrint(2, "Create - store args\n");

				// initialize buffers
				DebugPrint(2, "Create - initialize buffers\n");
				m_backBuffer.Create("back");
				m_frontBuffer.Create("front");

				// get universal window handle from GWindow
				DebugPrint(2, "Create - get universal window handle from gwindow\n");
				if (-m_gWindow.GetWindowHandle(m_gUniversalWindowHandle))
				{
					Cleanup();
					return GReturn::INVALID_ARGUMENT;
				}
				// get device context from window handle
				DebugPrint(2, "Create - get window device context from universal window handle\n");
				m_wWindowDeviceContext = GetDC(static_cast<HWND>(m_gUniversalWindowHandle.window));
				// get inner dimensions from window and resize surface to fit
				DebugPrint(2, "Create - get client dimensions of window\n");
				unsigned int newWidth, newHeight;
				if (-m_gWindow.GetClientWidth(newWidth) || -m_gWindow.GetClientHeight(newHeight))
				{
					Cleanup();
					return GReturn::INVALID_ARGUMENT;
				}
				DebugPrint(2, "Create - resize bitmap to client dimensions of window\n");
				ResizeBitmap(newWidth, newHeight);

				// create GConcurrent objects (false = no callbacks)
				DebugPrint(2, "Create - create GConcurrent objects\n");
				m_gDrawThread.Create(false);
				m_gSmartUpdateRowProcessThread.Create(false);
				// create event listener with callback function for GWindow to call
				DebugPrint(2, "Create - create event listener\n");
				GReturn gr = m_gEventListener.Create([&](GW::GEvent _event)
				{
					GW::SYSTEM::GWindow::Events windowEvent;
					GW::SYSTEM::GWindow::EVENT_DATA windowEventData;
					if (+_event.Read(windowEvent, windowEventData))
						switch (windowEvent)
						{
							case GW::SYSTEM::GWindow::Events::MINIMIZE:
							{
								DebugPrint(2, "Create callback lambda - MINIMIZE event received\n");
								// deactivate raster when minimized to prevent updating while window is not visible
								m_surfaceState = SurfaceState::INACTIVE;
							} break;
							case GW::SYSTEM::GWindow::Events::MAXIMIZE:
							{
								DebugPrint(2, "Create callback lambda - MAXIMIZE event received\n");
								// get client dimensions from window and resize bitmap to fit
								DebugPrint(2, "Create callback lambda - MAXIMIZE - resize bitmap\n");
								ResizeBitmap(windowEventData.clientWidth, windowEventData.clientHeight); // makes surface active
							} break;
							case GW::SYSTEM::GWindow::Events::RESIZE:
							{
								DebugPrint(2, "Create callback lambda - RESIZE event received\n");
								// get client dimensions from window and resize bitmap to fit
								DebugPrint(2, "Create callback lambda - RESIZE - resize bitmap\n");
								ResizeBitmap(windowEventData.clientWidth, windowEventData.clientHeight); // makes surface active
							} break;
							case GW::SYSTEM::GWindow::Events::DESTROY:
							{
								DebugPrint(2, "Create callback lambda - DESTROY event received\n");
								m_surfaceState = SurfaceState::INVALID;
								Cleanup();
							} break;
							default:
							{
								DebugPrint(2, "Create callback lambda - unknown event recieved\n");
							} break;
						} // end switch (windowEvent)
				});
				// register event listener with GWindow's event generator
				DebugPrint(2, "Create - register event listener\n");
				if (-m_gWindow.Register(m_gEventListener))
				{
					DebugPrint(2, "Create - registering event listener failed; return\n\n");
					Cleanup();
					return GReturn::INVALID_ARGUMENT;
				}
				DebugPrint(2, "Create - successful; return\n\n");
				return gr;
			}

#pragma endregion CREATE_AND_DESTROY_FUNCTIONS
#pragma region UPDATE_FUNCTIONS

			GReturn Clear(Color _xrgbColor) override
			{
				DebugPrint(0, "\nClear\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "Clear - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}

				DebugPrint(2, "Clear - attempt to lock back buffer for write\n");
				if (+m_backBuffer.LockSyncWrite())
				{
					DebugPrint(2, "Clear - locked back buffer for write\n");
					// store bitmap dimensions locally, since they could change
					unsigned int bitmapWidth = m_bitmapWidth;
					unsigned int bitmapHeight = m_bitmapHeight;
					// fill back buffer with passed color
					DebugPrint(2, "Clear - fill back buffer with color\n");
					for (unsigned int x = 0; x < bitmapWidth; ++x) // manually clear first row
						m_backBuffer.data[x] = _xrgbColor;
					for (unsigned int y = 1; y < bitmapHeight; ++y) // copy cleared row to each other row (much faster than manually clearing every pixel of every row)
						memcpy_s(&m_backBuffer.data[y * bitmapWidth], static_cast<rsize_t>(bitmapWidth * sizeof(Color)),
							&m_backBuffer.data[0], static_cast<rsize_t>(bitmapWidth * sizeof(Color)));
					// unlock and return
					DebugPrint(2, "Clear - attempt to unlock back buffer for write\n");
					if (+m_backBuffer.UnlockSyncWrite())
					{
						DebugPrint(2, "Clear - unlocked back buffer for write; successful; return\n\n");
						return GReturn::SUCCESS;
					}
					DebugPrint(2, "Clear - unexpected result; return\n\n");
					return GReturn::UNEXPECTED_RESULT; // should never reach here
				}
				DebugPrint(2, "Clear - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}
			GReturn UpdateSurface(const Color* _xrgbPixels, unsigned int _numPixels) override
			{
				DebugPrint(0, "\nUpdateSurface\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "UpdateSurface - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}

				// validate arguments
				DebugPrint(2, "UpdateSurface - validate args\n");
				// ensure valid pixel array was passed
				if (_xrgbPixels == nullptr)
				{
					DebugPrint(2, "UpdateSurface - _xrgbPixels was nullptr; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure pixel count is nonzero
				if (_numPixels < 1)
				{
					DebugPrint(2, "UpdateSurface - _numPixels was < 1; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure pixel count does not exceed surface pixel count
				if (_numPixels > static_cast<unsigned int>(m_bitmapWidth * m_bitmapHeight))
				{
					DebugPrint(2, "UpdateSurface - _numPixels was > surface's pixel count; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				DebugPrint(2, "UpdateSurface - args valid\n");

				// lock self and back buffer to prevent read/write conflicts
				DebugPrint(2, "UpdateSurface - attempt to lock self, back buffer for write\n");
				if (+LockSyncWrite()
					&& +m_backBuffer.LockSyncWrite())
				{
					DebugPrint(2, "UpdateSurface - locked self, back buffer for write\n");
					// BLIT pixel data to back buffer
					DebugPrint(2, "UpdateSurface - BLIT input pixels to back buffer\n");
					memcpy_s(m_backBuffer.data, static_cast<rsize_t>(_numPixels * sizeof(Color)),
						_xrgbPixels, static_cast<rsize_t>(_numPixels * sizeof(Color)));
					// increment and store frame number in back buffer
					DebugPrint(2, "UpdateSurface - increment and store frame number in back buffer\n");
					m_backBuffer.frameNum = ++m_frameCount;
					// unlock and return
					DebugPrint(2, "UpdateSurface - unlock and return\n");
					if (+m_backBuffer.UnlockSyncWrite()
						&& +UnlockSyncWrite())
					{
						DebugPrint(2, "UpdateSurface - unlocked self, back buffer for write; successful; return\n\n");
						return GReturn::SUCCESS;
					}
				}
				DebugPrint(2, "UpdateSurface - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}
			GReturn UpdateSurfaceSubset(const Color* _xrgbPixels, unsigned short _numRows, unsigned short _rowWidth, unsigned short _rowStride, int _destX, int _destY) override
			{
				DebugPrint(0, "\nUpdateSurfaceSubset\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "UpdateSurfaceSubset - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}

				// store dimensions locally, since they could potentially change during execution
				DebugPrint(2, "UpdateSurfaceSubset - store bitmap dimensions\n");
				unsigned short bitmapWidth = m_bitmapWidth;
				unsigned short bitmapHeight = m_bitmapHeight;
				// validate arguments
				DebugPrint(2, "UpdateSurfaceSubset - validate args\n");
				// ensure valid pixel array was passed
				if (_xrgbPixels == nullptr)
				{
					DebugPrint(2, "UpdateSurfaceSubset - _xrgbPixels was nullpt; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure row count is nonzero
				if (_numRows < 1)
				{
					DebugPrint(2, "UpdateSurfaceSubset - _numRows was < 1; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure row width is nonzero
				if (_rowWidth < 1)
				{
					DebugPrint(2, "UpdateSurfaceSubset - _numRows was < 1; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure row stride is >= row width, if provided
				if (_rowStride > 0 && _rowStride < _rowWidth)
				{
					DebugPrint(2, "UpdateSurfaceSubset - _rowStride was < _rowWidth; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				DebugPrint(2, "UpdateSurfaceSubset - args valid\n");

				// return immediately if subset is completely outside surface
				if (   _destX >= static_cast<int>(bitmapWidth)
					|| _destX + _rowWidth < 0
					|| _destY >= static_cast<int>(bitmapHeight)
					|| _destY + _numRows < 0)
				{
					DebugPrint(2, "UpdateSurfaceSubset - subset was outside surface; return\n\n");
					return GReturn::REDUNDANT;
				}

				// get row stride
				DebugPrint(2, "UpdateSurfaceSubset - get row stride\n");
				if (_rowStride == 0) _rowStride = _rowWidth;
				// clip subset to edges of surface
				//   left side
				DebugPrint(2, "UpdateSurfaceSubset - clip left side\n");
				if (_destX < 0)
				{
					// move starting location in source data right and shorten rows
					_xrgbPixels += -_destX;
					_rowWidth += _destX; // add, because coord is negative
					// clamp coord to surface edge
					_destX = 0;
				}
				//   right side
				DebugPrint(2, "UpdateSurfaceSubset - clip right side\n");
				if (_destX + _rowWidth > bitmapWidth)
				{
					// shorten rows
					_rowWidth -= (_destX + _rowWidth - bitmapWidth);
				}
				//   top side
				DebugPrint(2, "UpdateSurfaceSubset - clip top side\n");
				if (_destY < 0)
				{
					// move starting location in source data down and reduce row count
					_xrgbPixels += -_destY * _rowStride;
					_numRows += _destY; // add, because coord is negative
					// clamp coord to surface edge
					_destY = 0;
				}
				//   bottom side
				DebugPrint(2, "UpdateSurfaceSubset - clip bottom side\n");
				if (_destY + _numRows > bitmapHeight)
				{
					// reduce row count
					_numRows -= (_destY + _numRows - bitmapHeight);
				}
				// calculate starting index from destination x/y coords
				DebugPrint(2, "UpdateSurfaceSubset - calculate starting index\n");
				unsigned int startIndex = _destX + (_destY * bitmapWidth);

				// lock self and back buffer to prevent read/write conflicts
				DebugPrint(2, "UpdateSurfaceSubset - attempt to lock self, back buffer for write\n");
				if (+LockSyncWrite()
					&& +m_backBuffer.LockSyncWrite())
				{
					DebugPrint(2, "UpdateSurfaceSubset - locked self, back buffer for write\n");
					// calculate end index
					DebugPrint(2, "UpdateSurfaceSubset - calculate end index\n");
					unsigned int endIndex = startIndex + (bitmapWidth * (_numRows - 1)) + (_rowWidth - 1);
					// BLIT rows of subset block to back buffer
					DebugPrint(2, "UpdateSurfaceSubset - BLIT data to back buffer\n");
					for (; startIndex < endIndex; startIndex += bitmapWidth, _xrgbPixels += _rowStride)
						memcpy_s(&m_backBuffer.data[startIndex], static_cast<rsize_t>(_rowWidth * sizeof(Color)),
								_xrgbPixels, static_cast<rsize_t>(_rowWidth * sizeof(Color)));
					// increment and store frame count in back buffer
					DebugPrint(2, "UpdateSurfaceSubset - increment and store frame number in back buffer\n");
					m_backBuffer.frameNum = ++m_frameCount;
					// unlock and return
					DebugPrint(2, "UpdateSurfaceSubset - unlock and return\n");
					if (+m_backBuffer.UnlockSyncWrite()
						&& +UnlockSyncWrite())
					{
						DebugPrint(2, "UpdateSurfaceSubset - unlocked self, back buffer for write; successful; return\n\n");
						return GReturn::SUCCESS;
					}
				}
				DebugPrint(2, "UpdateSurfaceSubset - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}
			GReturn SmartUpdateSurface(const Color* _xrgbPixels, unsigned int _numPixels, unsigned short _rowWidth, unsigned int _drawOptionFlags) override
			{
				DebugPrint(0, "\nSmartUpdateSurface\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "SmartUpdateSurface - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}

				// validate arguments
				DebugPrint(2, "SmartUpdateSurface - validate args\n");
				// ensure valid pixel array was passed
				if (_xrgbPixels == nullptr)
				{
					DebugPrint(2, "SmartUpdateSurface - _xrgbPixels was nullptr; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure pixel count is nonzero
				if (_numPixels < 1)
				{
					DebugPrint(2, "SmartUpdateSurface - _numPixels was < 1; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// ensure row width is nonzero
				if (_rowWidth < 1)
				{
					DebugPrint(2, "SmartUpdateSurface - _rowWidth was < 1; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// separate flags into sections and test each section
				const unsigned int bitmaskAlignX =
					  GW::GRAPHICS::GRasterUpdateFlags::ALIGN_X_LEFT
					| GW::GRAPHICS::GRasterUpdateFlags::ALIGN_X_CENTER
					| GW::GRAPHICS::GRasterUpdateFlags::ALIGN_X_RIGHT;
				const unsigned int bitmaskAlignY =
					  GW::GRAPHICS::GRasterUpdateFlags::ALIGN_Y_TOP
					| GW::GRAPHICS::GRasterUpdateFlags::ALIGN_Y_CENTER
					| GW::GRAPHICS::GRasterUpdateFlags::ALIGN_Y_BOTTOM;
				const unsigned int bitmaskUpscale =
					  GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_2X
					| GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_3X
					| GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_4X
					| GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_8X
					| GW::GRAPHICS::GRasterUpdateFlags::UPSCALE_16X
					| GW::GRAPHICS::GRasterUpdateFlags::STRETCH_TO_FIT;
				const unsigned int bitmaskInterpolate =
					  GW::GRAPHICS::GRasterUpdateFlags::INTERPOLATE_NEAREST
					| GW::GRAPHICS::GRasterUpdateFlags::INTERPOLATE_BILINEAR;
				unsigned int testFlags = 0;
				// validate x alignment flags
				testFlags = _drawOptionFlags & bitmaskAlignX;
				if (( IsolateBit(testFlags, UpdateFlagBitPosition::BIT_ALIGN_X_LEFT)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_ALIGN_X_CENTER)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_ALIGN_X_RIGHT)
					) > 1)
				{
					DebugPrint(2, "SmartUpdateSurface - _drawOptionFlags contains conflicting x alignment flags; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// validate y alignment flags
				testFlags = _drawOptionFlags & bitmaskAlignY;
				if (( IsolateBit(testFlags, UpdateFlagBitPosition::BIT_ALIGN_Y_TOP)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_ALIGN_Y_CENTER)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_ALIGN_Y_BOTTOM)
					) > 1)
				{
					DebugPrint(2, "SmartUpdateSurface - _drawOptionFlags contains conflicting y alignment flags; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// validate upscaling flags
				testFlags = _drawOptionFlags & bitmaskUpscale;
				if (( IsolateBit(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_2X)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_3X)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_4X)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_8X)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_UPSCALE_16X)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_STRETCH_TO_FIT)
					) > 1)
				{
					DebugPrint(2, "SmartUpdateSurface - _drawOptionFlags contains conflicting upscaling flags; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// validate interpolation flags
				testFlags = _drawOptionFlags & bitmaskInterpolate;
				if (( IsolateBit(testFlags, UpdateFlagBitPosition::BIT_INTERPOLATE_NEAREST)
					+ IsolateBit(testFlags, UpdateFlagBitPosition::BIT_INTERPOLATE_BILINEAR)
					) > 1)
				{
					DebugPrint(2, "SmartUpdateSurface - _drawOptionFlags contains conflicting interpolation flags; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				DebugPrint(2, "SmartUpdateSurface - args valid\n");
				// if arguments are valid, continue

				// store surface dimensions and border color locally to avoid needing to read data more than once
				unsigned int bitmapWidth = m_bitmapWidth;
				unsigned int bitmapHeight = m_bitmapHeight;

				// create struct to store data to use during processing
				SmartUpdateData data = {};
				// store color array and metadata
				data.inputColors = _xrgbPixels;
				data.bitmapWidth = bitmapWidth;
				data.bitmapHeight = bitmapHeight;
				data.rawDataWidth = _rowWidth;
				data.rawDataHeight = _numPixels / _rowWidth;
				// determine data dimensions after processing
				DebugPrint(2, "SmartUpdateSurface - calculate upscaled dimensions\n");
				testFlags = _drawOptionFlags & bitmaskUpscale;
				switch (testFlags)
				{
					case GW::GRAPHICS::UPSCALE_2X:
						data.upscaledDataWidth = data.rawDataWidth << 1;
						data.upscaledDataHeight = data.rawDataHeight << 1;
						break;
					case GW::GRAPHICS::UPSCALE_3X:
						data.upscaledDataWidth = data.rawDataWidth * 3;
						data.upscaledDataHeight = data.rawDataHeight * 3;
						break;
					case GW::GRAPHICS::UPSCALE_4X:
						data.upscaledDataWidth = data.rawDataWidth << 2;
						data.upscaledDataHeight = data.rawDataHeight << 2;
						break;
					case GW::GRAPHICS::UPSCALE_8X:
						data.upscaledDataWidth = data.rawDataWidth << 3;
						data.upscaledDataHeight = data.rawDataHeight << 3;
						break;
					case GW::GRAPHICS::UPSCALE_16X:
						data.upscaledDataWidth = data.rawDataWidth << 4;
						data.upscaledDataHeight = data.rawDataHeight << 4;
						break;
					case GW::GRAPHICS::STRETCH_TO_FIT:
						data.upscaledDataWidth = bitmapWidth;
						data.upscaledDataHeight = bitmapHeight;
						break;
					default:
						data.upscaledDataWidth = data.rawDataWidth;
						data.upscaledDataHeight = data.rawDataHeight;
						break;
				}

				// calculate pixel coordinate scaling ratios
				DebugPrint(2, "SmartUpdateSurface - calculate coordinate scaling ratios\n");
				data.coordScaleRatioX = data.rawDataWidth / static_cast<float>(data.upscaledDataWidth);
				data.coordScaleRatioY = data.rawDataHeight / static_cast<float>(data.upscaledDataHeight);

				// determine X alignment
				DebugPrint(2, "SmartUpdateSurface - determine x alignment\n");
				testFlags = _drawOptionFlags & bitmaskAlignX;
				switch (testFlags)
				{
					case GW::GRAPHICS::ALIGN_X_LEFT:
						data.offsetX = 0;
						break;
					case GW::GRAPHICS::ALIGN_X_RIGHT:
						data.offsetX = static_cast<int>(bitmapWidth) - static_cast<int>(data.upscaledDataWidth);
						break;
					case GW::GRAPHICS::ALIGN_X_CENTER:
					default:
						data.offsetX = (static_cast<int>(bitmapWidth) - static_cast<int>(data.upscaledDataWidth)) >> 1;
						break;
				}

				// determine Y alignment
				DebugPrint(2, "SmartUpdateSurface - determine y alignment\n");
				testFlags = _drawOptionFlags & bitmaskAlignY;
				switch (testFlags)
				{
					case GW::GRAPHICS::ALIGN_Y_TOP:
						data.offsetY = 0;
						break;
					case GW::GRAPHICS::ALIGN_Y_BOTTOM:
						data.offsetY = static_cast<int>(bitmapHeight) - static_cast<int>(data.upscaledDataHeight);
						break;
					case GW::GRAPHICS::ALIGN_Y_CENTER:
					default:
						data.offsetY = (static_cast<int>(bitmapHeight) - static_cast<int>(data.upscaledDataHeight)) >> 1;
						break;
				}

				// lock self and back buffer to prevent read/write conflicts
				DebugPrint(2, "SmartUpdateSurface - attempt to lock self, back buffer for write\n");
				if (+LockSyncWrite()
					&& +m_backBuffer.LockSyncWrite())
				{
					DebugPrint(2, "SmartUpdateSurface - locked self, back buffer for write\n");
#if !defined(GRASTERSURFACE_DEBUG_WIN32_SERIALIZE_SMARTUPDATE_COPY)
					// calculate how many rows of the surface fit into 256 KB
					DebugPrint(2, "SmartUpdateSurface - calculate rows per thread\n");
					unsigned int rows = 262144 / (bitmapWidth * sizeof(Color));
					if (rows == 0) rows = 1; // min of 1
#endif

					// iterate through surface and process pixels
					if ((_drawOptionFlags & bitmaskInterpolate) == GW::GRAPHICS::INTERPOLATE_BILINEAR)
					{
#if defined(GRASTERSURFACE_DEBUG_WIN32_SERIALIZE_SMARTUPDATE_COPY)
						DebugPrint(2, "SmartUpdateSurface - process rows w/ bilinear interp (SERIAL)\n");
						for (unsigned int y = 0; y < bitmapHeight; ++y)
							ProcessPixelRowBilinear(static_cast<const void*>(nullptr), &m_backBuffer.data[y * bitmapWidth], y, reinterpret_cast<const void*>(&data));
#else
						DebugPrint(2, "SmartUpdateSurface - process rows w/ bilinear interp (PARALLEL)\n");
						m_gSmartUpdateRowProcessThread.BranchParallel(ProcessPixelRowBilinear,
							rows, bitmapHeight, reinterpret_cast<const void*>(&data),
							0, static_cast<const void*>(nullptr),
							static_cast<int>(bitmapWidth * sizeof(Color)), m_backBuffer.data);
#endif
					}
					else
					{
#if defined(GRASTERSURFACE_DEBUG_WIN32_SERIALIZE_SMARTUPDATE_COPY)
						DebugPrint(2, "SmartUpdateSurface - process rows w/ nearest interp (SERIAL)\n");
						for (unsigned int y = 0; y < bitmapHeight; ++y)
							ProcessPixelRowNearest(static_cast<const void*>(nullptr), &m_backBuffer.data[y * bitmapWidth], y, reinterpret_cast<const void*>(&data));
#else
						DebugPrint(2, "SmartUpdateSurface - process rows w/ nearest interp (PARALLEL)\n");
						m_gSmartUpdateRowProcessThread.BranchParallel(ProcessPixelRowNearest,
							rows, bitmapHeight, reinterpret_cast<const void*>(&data),
							0, static_cast<const void*>(nullptr),
							static_cast<int>(bitmapWidth * sizeof(Color)), m_backBuffer.data);
#endif
					}

#if !defined(GRASTERSURFACE_DEBUG_WIN32_SERIALIZE_SMARTUPDATE_COPY)
					// wait for data to finish processing
					DebugPrint(2, "SmartUpdateSurface - converge row processing threads\n");
					GReturn convergeResult = m_gSmartUpdateRowProcessThread.Converge(0);
					if (G_FAIL(convergeResult))
					{
						DebugPrint(2, "SmartUpdateSurface - converge failed, attempt to unlock back buffer for write\n");
						if (+m_backBuffer.UnlockSyncWrite())
						{
							DebugPrint(2, "SmartUpdateSurface - unlocked back buffer for write; return\n\n");
							return convergeResult;
						}
					}
#endif

					//	update frame number in buffer
					DebugPrint(2, "SmartUpdateSurface - increment and store frame number in back buffer\n");
					m_backBuffer.frameNum = ++m_frameCount;
					// unlock and return
					DebugPrint(2, "SmartUpdateSurface - unlock and return\n");
					if (+m_backBuffer.UnlockSyncWrite()
						&& +UnlockSyncWrite())
					{
						DebugPrint(2, "SmartUpdateSurface - unlocked self, back buffer for write; successful; return\n\n");
						return GReturn::SUCCESS;
					}
				}
				DebugPrint(2, "SmartUpdateSurface - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

#pragma endregion UPDATE_FUNCTIONS
#pragma region LOCK_AND_UNLOCK_FUNCTIONS

			GReturn LockUpdateBufferWrite(Color** _outMemoryBuffer, unsigned short& _outWidth, unsigned short& _outHeight) override
			{
				DebugPrint(0, "\nLockUpdateBufferWrite\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "LockUpdateBufferWrite - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}

				// validate arguments
				if (_outMemoryBuffer == nullptr)
				{
					DebugPrint(2, "LockUpdateBufferWrite - _outMemoryBuffer was nullptr; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// if args are valid, continue

				// reject lock if already locked for writing
				DebugPrint(2, "LockUpdateBufferWrite - check number of active write locks\n");
				if (m_backBuffer.numLocks > 0)
				{
					DebugPrint(2, "LockUpdateBufferWrite - write lock already active; return\n\n");
					return GReturn::FAILURE;
				}
				// otherwise, try to lock for writing
				DebugPrint(2, "LockUpdateBufferWrite - attempt to lock back buffer for write\n");
				if (+m_backBuffer.LockSyncWrite())
				{
					DebugPrint(2, "LockUpdateBufferWrite - locked back buffer for write\n");
					++m_backBuffer.numLocks;
					DebugPrint(2, "LockUpdateBufferWrite - %d write locks\n", m_backBuffer.numLocks);
					// give buffer data pointer and dimensions to caller and return
					DebugPrint(2, "LockUpdateBufferWrite - set return values\n");
					*_outMemoryBuffer = m_backBuffer.data;
					_outWidth = m_bitmapWidth;
					_outHeight = m_bitmapHeight;
					DebugPrint(2, "LockUpdateBufferWrite - successful; return\n\n");
					return GReturn::SUCCESS;
				}
				DebugPrint(2, "LockUpdateBufferWrite - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}
			GReturn LockUpdateBufferRead(const Color** _outMemoryBuffer, unsigned short& _outWidth, unsigned short& _outHeight) override
			{
				DebugPrint(0, "\nLockUpdateBufferRead\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "LockUpdateBufferRead - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}

				// validate arguments
				if (_outMemoryBuffer == nullptr)
				{
					DebugPrint(2, "LockUpdateBufferWrite - _outMemoryBuffer was nullptr; return\n\n");
					return GReturn::INVALID_ARGUMENT;
				}
				// if args are valid, continue

				// reject lock if already locked for reading
				DebugPrint(2, "LockUpdateBufferRead - check number of active read locks\n");
				if (m_frontBuffer.numLocks > 0)
				{
					DebugPrint(2, "LockUpdateBufferRead - read lock already active; return\n\n");
					return GReturn::FAILURE;
				}
				// otherwise, try to lock for reading
				DebugPrint(2, "LockUpdateBufferRead - attempt to lock front buffer for read\n");
				if (+m_frontBuffer.LockAsyncRead())
				{
					DebugPrint(2, "LockUpdateBufferRead - locked front buffer for read\n");
					++m_frontBuffer.numLocks;
					DebugPrint(2, "LockUpdateBufferRead - %d read locks\n", m_frontBuffer.numLocks);
					// give buffer data pointer and dimensions to caller and return
					DebugPrint(2, "LockUpdateBufferRead - set return values\n");
					*_outMemoryBuffer = const_cast<const Color*>(m_frontBuffer.data);
					_outWidth = m_bitmapWidth;
					_outHeight = m_bitmapHeight;
					DebugPrint(2, "LockUpdateBufferRead - successful; return\n\n");
					return GReturn::SUCCESS;
				}
				DebugPrint(2, "LockUpdateBufferRead - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

			GReturn UnlockUpdateBufferWrite() override
			{
				DebugPrint(0, "\nUnlockUpdateBufferWrite\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "UnlockUpdateBufferWrite - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				// ignore unlock if not locked
				if (m_backBuffer.numLocks < 1)
				{
					DebugPrint(2, "UnlockUpdateBufferWrite - redundant; return\n\n");
					return GReturn::REDUNDANT;
				}

				--m_backBuffer.numLocks;
				DebugPrint(2, "UnlockUpdateBufferWrite - %d write locks\n", m_backBuffer.numLocks);

				// otherwise, update frame number in buffer and unlock
				DebugPrint(2, "UnlockUpdateBufferWrite - attempt to lock self for write\n");
				if (+LockSyncWrite())
				{
					DebugPrint(2, "UnlockUpdateBufferWrite - locked self for write\n");
					// increment and store frame count in buffer
					DebugPrint(2, "UnlockUpdateBufferWrite - increment and store frame number in back buffer\n");
					m_backBuffer.frameNum = ++m_frameCount;
					// unlock and return
					DebugPrint(2, "UnlockUpdateBufferWrite - attempt to unlock self, back buffer for write\n");
					if (+UnlockSyncWrite()
						&& +m_backBuffer.UnlockSyncWrite())
					{
						DebugPrint(2, "UnlockUpdateBufferWrite - unlocked self, back buffer for write; successful; return\n\n");
						return GReturn::SUCCESS;
					}
					DebugPrint(2, "UnlockUpdateBufferWrite - unexpected result; return\n\n");
					return GReturn::UNEXPECTED_RESULT; // should never reach here
				}
				DebugPrint(2, "UnlockUpdateBufferWrite - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}
			GReturn UnlockUpdateBufferRead() override
			{
				DebugPrint(0, "\nUnlockUpdateBufferRead\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "UnlockUpdateBufferRead - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				// ignore unlock if not locked
				if (m_frontBuffer.numLocks < 1)
				{
					DebugPrint(2, "UnlockUpdateBufferRead - redundant; return\n\n");
					return GReturn::REDUNDANT;
				}
				// otherwise, unlock
				--m_frontBuffer.numLocks;
				DebugPrint(2, "UnlockUpdateBufferRead - %d read locks\n", m_frontBuffer.numLocks);
				DebugPrint(2, "UnlockUpdateBufferRead - attempt to unlock front buffer for read\n");
				if (+m_frontBuffer.UnlockAsyncRead())
				{
					DebugPrint(2, "UnlockUpdateBufferRead - unlocked front buffer for read\n");
					DebugPrint(2, "UnlockUpdateBufferRead - successful; return\n\n", m_frontBuffer.numLocks);
					return GReturn::SUCCESS;
				}
				DebugPrint(2, "UnlockUpdateBufferRead - unexpected result; return\n\n");
				return GReturn::UNEXPECTED_RESULT; // should never reach here
			}

#pragma endregion LOCK_AND_UNLOCK_FUNCTIONS

			GReturn Present() override
			{
				DebugPrint(0, "\nPresent\n");
				if (m_surfaceState == SurfaceState::INVALID)
				{
					DebugPrint(2, "Present - surface invalid; return\n\n");
					return GReturn::PREMATURE_DEALLOCATION;
				}
				DebugPrint(2, "Present - draw\n");
				if (-SwapBuffersAndDraw())
				{
					DebugPrint(2, "Present - draw failed; return\n\n");
					return GReturn::FAILURE;
				}
				DebugPrint(2, "Present - successful; return\n");
				return GReturn::SUCCESS;
			}

		}; // end class GRasterSurfaceImplementation
	} // end namespace I
} // end namespace GW


#if defined(_WIN32) && !defined(NDEBUG) && defined(GRASTERSURFACE_DEBUG_WIN32_VERBOSE_NEW)
#undef new
#endif

#if defined(GRASTERSURFACE_DEBUG_WIN32_VERBOSE_NEW)
#undef GRASTERSURFACE_DEBUG_WIN32_VERBOSE_NEW
#endif
#if defined(GRASTERSURFACE_DEBUG_WIN32_SERIALIZE_SMARTUPDATE_COPY)
#undef GRASTERSURFACE_DEBUG_WIN32_SERIALIZE_SMARTUPDATE_COPY
#endif
#if defined(GRASTERSURFACE_DEBUG_WIN32_ASSERTS)
#undef GRASTERSURFACE_DEBUG_WIN32_ASSERTS
#endif
#if defined(GRASTERSURFACE_DEBUG_WIN32_PRINTS)
#undef GRASTERSURFACE_DEBUG_WIN32_PRINTS
#endif
#if defined(GRASTERSURFACE_DEBUG_WIN32_PRINT_PRIORITY_LEVEL)
#undef GRASTERSURFACE_DEBUG_WIN32_PRINT_PRIORITY_LEVEL
#endif


#endif



namespace GW
{
	namespace GRAPHICS
	{
		class GRasterSurface final
			: public I::GProxy<I::GRasterSurfaceInterface, I::GRasterSurfaceImplementation, GW::SYSTEM::GWindow>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GRasterSurface)
			GATEWARE_FUNCTION(Clear)
			GATEWARE_FUNCTION(UpdateSurface)
			GATEWARE_FUNCTION(UpdateSurfaceSubset)
			GATEWARE_FUNCTION(SmartUpdateSurface)
			GATEWARE_FUNCTION(LockUpdateBufferWrite)
			GATEWARE_FUNCTION(LockUpdateBufferRead)
			GATEWARE_FUNCTION(UnlockUpdateBufferWrite)
			GATEWARE_FUNCTION(UnlockUpdateBufferRead)
			GATEWARE_FUNCTION(Present)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	};
};

#endif // GRASTERSURFACE_H

/*---------------------------------
|	End of GRasterSurface.h
----------------------------------*/


/*---------------------------------
|	Begin of GVulkanSurface.h
----------------------------------*/
// Currently there is no method to installing Vulkan in Linux Pipelines,
// enabling CICD feature flag skips this library entirely.
#ifndef GVULKANSURFACE_H
#define GVULKANSURFACE_H







namespace GW
{
	namespace I
	{
		class GVulkanSurfaceInterface : public virtual GEventResponderInterface, public virtual GEventGeneratorInterface
		{
		public:
			enum class Events {
				REBUILD_PIPELINE,
				RELEASE_RESOURCES
			};

			struct EVENT_DATA {
				int eventResult;
				unsigned int surfaceExtent[2];
			};

			struct GVulkanSurfaceQueryInfo {
				unsigned long long initializationMask;
				unsigned int instanceLayerCount;
				const char** instanceLayers;
				void*		 instanceLayerProperties;
				unsigned int instanceExtensionCount;
				const char** instanceExtensions;
				void*		 instanceExtensionProperties;
				unsigned int deviceExtensionCount;
				const char** deviceExtensions;
				void*		 deviceExtensionProperties;
				void*		 physicalDeviceFeatures;
			};

			virtual GReturn GetAspectRatio(float& _outRatio) const = 0;
			virtual GReturn GetSwapchainImageCount(unsigned int& _outImageCount) const = 0;
			virtual GReturn GetSwapchainCurrentImage(unsigned int& _outImageIndex) const = 0;
			virtual GReturn GetQueueFamilyIndices(unsigned int& _outGraphicsIndex, unsigned int& _outPresentIndex) const = 0;
			virtual GReturn GetGraphicsQueue(void** _outVkQueue) const = 0;
			virtual GReturn GetPresentQueue(void** _outVkQueue) const = 0;
			virtual GReturn GetSwapchainImage(const int& _index, void** _outVkImage) const = 0;
			virtual GReturn GetSwapchainView(const int& _index, void** _outVkImageView) const = 0;
			virtual GReturn GetSwapchainFramebuffer(const int& _index, void** _outVkFramebuffer) const = 0;

			virtual GReturn GetInstance(void** _outVkInstance) const = 0;
			virtual GReturn GetSurface(void** _outVkSurfaceKHR) const = 0;
			virtual GReturn GetPhysicalDevice(void** _outVkPhysicalDevice) const = 0;
			virtual GReturn GetDevice(void** _outVkDevice) const = 0;
			virtual GReturn GetCommandPool(void** _outCommandPool) const = 0;
			virtual GReturn GetSwapchain(void** _outVkSwapchainKHR) const = 0;
			virtual GReturn GetRenderPass(void** _outRenderPass) const = 0;
			virtual GReturn GetCommandBuffer(const int& _index, void** _outCommandBuffer) const = 0;
			virtual GReturn GetImageAvailableSemaphore(const int& _index, void** _outVkSemaphore) const = 0;
			virtual GReturn GetRenderFinishedSemaphore(const int& _index, void** _outVkSemaphore) const = 0;
			virtual GReturn GetRenderFence(const int& _index, void** _outVkFence) const = 0;

			virtual GReturn StartFrame(const unsigned int& _clearCount, void* _vkClearValues) = 0;
			virtual GReturn EndFrame(const bool& _vSync) = 0;
		};
	}
}

// Implementaion for GVulkanSurface.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_GRAPHICS) || defined(GATEWARE_DISABLE_GVULKANSURFACE) || \
    (defined(GATEWARE_ENABLE_GRAPHICS) && !defined(GATEWARE_DISABLE_GVULKANSURFACE) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    //The core namespace to which all Gateware interfaces/structures/defines must belong.
namespace GW
{
	//The namespace to which all Gateware internal implementation must belong.
	namespace I
	{
		class GVulkanSurfaceImplementation :	public virtual GVulkanSurfaceInterface,
												public GEventGeneratorImplementation
		{
		public:
            //Create
			GReturn Create(SYSTEM::GWindow _gwindow, unsigned long long _initMask) { return GReturn::FEATURE_UNSUPPORTED; }
			GReturn Create(SYSTEM::GWindow _gWindow, unsigned long long _initMask, unsigned int _layerCount, const char** _layers,
				unsigned int _instanceExtensionCount, const char** _instanceExtensions, unsigned int _deviceExtensionCount, const char** _deviceExtensions,
				bool allPhysicalDeviceFeatures) { return GReturn::FEATURE_UNSUPPORTED; }
			GReturn Create(SYSTEM::GWindow _gWindow, GVulkanSurfaceQueryInfo* _queryInfo) { return GReturn::FEATURE_UNSUPPORTED; }

            //GVulkanSurface
			GReturn GetAspectRatio(float& _outRatio) const override              		  { return GReturn::FAILURE; }
            GReturn GetSwapchainImageCount(unsigned int& _outImageCount) const override   { return GReturn::FAILURE; }
			GReturn GetSwapchainCurrentImage(unsigned int& _outImageIndex) const override { return GReturn::FAILURE; }
			GReturn GetGraphicsQueue(void** _outVkQueue) const override         		  { return GReturn::FAILURE; }
			GReturn GetPresentQueue(void** _outVkQueue) const override           		  { return GReturn::FAILURE; }
			GReturn GetQueueFamilyIndices(unsigned int& _outGraphicsIndex, unsigned int& _outPresentIndex) const override { return GReturn::FAILURE; }
			GReturn GetSwapchainImage(const int& _index, void** _outVkImage) const override								  { return GReturn::FAILURE; }
			GReturn GetSwapchainView(const int& _index, void** _outVkImageView) const override          				  { return GReturn::FAILURE; }
			GReturn GetSwapchainFramebuffer(const int& _index, void** _outVkFramebuffer) const override 		 		  { return GReturn::FAILURE; }

			GReturn GetInstance(void** _outVkInstance) const override               { return GReturn::FAILURE; }
			GReturn GetSurface(void** _outVkSurfaceKHR) const override              { return GReturn::FAILURE; }
			GReturn GetPhysicalDevice(void** _outVkPhysicalDevice) const override   { return GReturn::FAILURE; }
			GReturn GetDevice(void** _outVkDevice) const override                   { return GReturn::FAILURE; }
			GReturn GetCommandPool(void** _outCommandPool) const override           { return GReturn::FAILURE; }
			GReturn GetSwapchain(void** _outVkSwapchainKHR) const override          { return GReturn::FAILURE; }
			GReturn GetRenderPass(void** _outVkRenderPass) const override			{ return GReturn::FAILURE;}
			GReturn GetCommandBuffer(const int& _index, void** _outCommandBuffer) const override         { return GReturn::FAILURE; }
			GReturn GetImageAvailableSemaphore(const int& _index, void** _outVkSemaphore) const override { return GReturn::FAILURE; }
			GReturn GetRenderFinishedSemaphore(const int& _index, void** _outVkSemaphore) const override { return GReturn::FAILURE; }
			GReturn GetRenderFence(const int& _index, void** _outVkFence) const override                 { return GReturn::FAILURE; }

			GReturn StartFrame(const unsigned int& _clearCount, void* _vkClearValues) override { return GReturn::FAILURE; }
			GReturn EndFrame(const bool& _vSync) override { return GReturn::FAILURE; }

            //GEventResponderInterface
			GReturn Assign(std::function<void()> _newHandler) override 						{ return GReturn::FAILURE;}
			GReturn Assign(std::function<void(const GEvent&)> _newEventHandler) override 	{ return GReturn::FAILURE;}
			GReturn Invoke() const override													{ return GReturn::FAILURE;}
			GReturn Invoke(const GEvent& _incomingEvent) const override 					{ return GReturn::FAILURE;}
		};
    } // end I namespace
} // end GW namespace

    #define GVULKANSURFACE_DUMMY_INCLUDED
#elif defined(__APPLE__)
    //Get the Core
@import QuartzCore;

#include </usr/local/include/vulkan/vulkan.h>
#include </usr/local/include/vulkan/vulkan_macos.h>

namespace GW
{
    namespace I
    {
		class GVulkanSurfacePlatformFucts {
		public:
            //Get the Surface Extension for Macos
			const char* GetPlatformSurfaceExtension() {
				return VK_MVK_MACOS_SURFACE_EXTENSION_NAME;
			}
            //Get the Device Extension for Macos
            const char* GetPlatformDeviceExtension() {
                unsigned current = VK_HEADER_VERSION_COMPLETE;
#ifdef VK_MAKE_API_VERSION
                unsigned compatible = VK_MAKE_API_VERSION(0, 1, 2, 176);
#else
                unsigned compatible = VK_MAKE_VERSION(1, 2, 176);
#endif
                if (current >= compatible)
                    return "VK_KHR_portability_subset";
                else
                    return nullptr;
            }

			//Get the platform name
			char* GetPlatformWindowName(const GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE& uwh) {
				__block char* instance_app_name = nullptr;
				//Make sure this is on the main thread
				RUN_ON_UI_THREAD(^ {
					//Get the proper Window Handles
					NSWindow * nsWindow = reinterpret_cast<NSWindow*>(uwh.window);

				//Get the Window Title & Length
				const char* window_title = [nsWindow.title UTF8String];
				int len = strlen(window_title);

				//Create the Window Title
				if (len) {
					instance_app_name = new char[len + 1];
					strcpy(instance_app_name, window_title);
				}

				//If above fails, make a title
				if (!instance_app_name) {
					//Default Window Title[22] (21 Characters, +1 for null terminator)
					instance_app_name = new char[22];
					strcpy(instance_app_name, "Gateware Application");
				}
					});

				//Return The Window Title
				return instance_app_name;
			}

			//Create the surface
			VkResult CreateVkSurfaceKHR(const VkInstance& vkInstance, const GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE& uwh, VkSurfaceKHR& vkSurface) {
				//Create this as a block
				__block VkResult r = VK_ERROR_FEATURE_NOT_PRESENT;

				//Make sure this is on the main thread
				RUN_ON_UI_THREAD(^ {
					//Get NSWindow
					NSWindow * nsWindow = static_cast<NSWindow*>(uwh.window);

				//Get NSView and add a metal layer
				NSView* nsView = nsWindow.contentView;
				nsView.wantsLayer = YES;
				nsView.layer = [CAMetalLayer layer];

				//Setup Create Info
				VkMacOSSurfaceCreateInfoMVK create_info = {};
				create_info.sType = VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK;
				create_info.pView = nsView;
				create_info.flags = 0;
				create_info.pNext = VK_NULL_HANDLE;

				//Create the Surface
				r = vkCreateMacOSSurfaceMVK(vkInstance, &create_info, VK_NULL_HANDLE, &vkSurface);

				//Hi
				//FlushOnMacEvents();
					});
				return r;
			}

			VkResult PlatformDestroyGVulkanSurface(const std::function<void()>& callback) {
				//Cleanup Vulkan Surface
				callback();

				//Return Success
				return VK_SUCCESS;
			}
		};
    }
}


#elif defined(__linux__)
    //Get the Core
#include <string.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <vulkan/vulkan.h>
#include <vulkan/vulkan_xlib.h>

//The core namespace to which all Gateware interfaces/structures/defines must belong.
namespace GW
{
	//The namespace to which all Gateware internal implementation must belong.
	namespace I
	{
		class GVulkanSurfacePlatformFucts {
		public:
			const char* GetPlatformSurfaceExtension() {
				return VK_KHR_XLIB_SURFACE_EXTENSION_NAME;
			}
            const char* GetPlatformDeviceExtension() {
                return nullptr;
            }

			char* GetPlatformWindowName(const GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE& uwh) {
				//Setup Window and Display
				Display* dpy = static_cast<Display*>(uwh.display);
				Window wnd = *(static_cast<Window*>(uwh.window));

				//Get Window Title
				XTextProperty x11_window_title;
				int status = XGetWMName(dpy, wnd, &x11_window_title);

				//Create a Window Title Separate from X11 (Cause it needs to be Free'd by X11, According to the docs)
				char* window_title = nullptr;
				uint32_t len = strlen((char*)x11_window_title.value);
				if (x11_window_title.value && len)
				{
					window_title = new char[len + 1];
					strcpy(window_title, (char*)x11_window_title.value);
				}

				//If Above Fails (status returned 0, x11 title is nullptr, x11 title is empty), Make a Default
				if (!window_title) {
					//Default Window Title[22] (21 Characters, +1 for null terminator)
					window_title = new char[22];
					strcpy(window_title, "Gateware Application");
				}

				return window_title;
			}

			VkResult CreateVkSurfaceKHR(const VkInstance& vkInstance, const GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE& uwh, VkSurfaceKHR& vkSurface) {
				//Setup Window and Display
				Window wnd = *(static_cast<Window*>(uwh.window));
				Display* dpy = static_cast<Display*>(uwh.display);

				VkXlibSurfaceCreateInfoKHR create_info = {};
				create_info.sType = VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR;
				create_info.window = wnd;
				create_info.dpy = dpy;
				create_info.flags = 0;
				create_info.pNext = VK_NULL_HANDLE;

				VkResult r = vkCreateXlibSurfaceKHR(vkInstance, &create_info, VK_NULL_HANDLE, &vkSurface);
				return r;
			}

			VkResult PlatformDestroyGVulkanSurface(const std::function<void()>& callback) {
				//Cleanup Vulkan Surface
				//CleanupVulkanSurface();
				callback();

				//Return Success
				return VK_SUCCESS;
			}
		};
	} // I
} //GW


#elif defined(_WIN32)
    #include <Windows.h>
#include <vulkan/vulkan.h>
#include <vulkan/vulkan_win32.h>
#pragma comment(lib, "vulkan-1.lib")

namespace GW
{
	namespace I
	{
		class GVulkanSurfacePlatformFucts {
		public:
			const char* GetPlatformSurfaceExtension() {
				return VK_KHR_WIN32_SURFACE_EXTENSION_NAME;
			}
            const char* GetPlatformDeviceExtension() {
                return nullptr;
            }

			char* GetPlatformWindowName(const GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE& uwh) {
				//Get the proper window handle
				HWND hWnd = static_cast<HWND>(uwh.window);

				//Get Window Title
				char* str = new char[255]; int len;
				len = GetWindowTextA(hWnd, str, 255) + 1;

				//Create a Window Title
				char* window_title = nullptr;
				if (len) {
					window_title = new char[len];
					strcpy_s(window_title, len, str);
				}

				//If Above Fails
				if (!window_title) {
					//Default Window Title[22] (21 Characters, +1 for null terminator)
					window_title = new char[22];
					strcpy_s(window_title, 22, "Gateware Application");
				}

				delete[] str;
				return window_title;
			}

			VkResult CreateVkSurfaceKHR(const VkInstance& vkInstance, const GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE& uwh, VkSurfaceKHR& vkSurface) {
				HWND hWnd = static_cast<HWND>(uwh.window);
				HINSTANCE* hInst = reinterpret_cast<HINSTANCE*>(GetWindowLongPtr(static_cast<HWND>(hWnd), GWLP_HINSTANCE));

				VkWin32SurfaceCreateInfoKHR create_info;
				create_info.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
				create_info.hinstance = (*hInst) ? *hInst : nullptr;
				create_info.hwnd = hWnd;
				create_info.flags = 0;
				create_info.pNext = 0;

				VkResult r = vkCreateWin32SurfaceKHR(vkInstance, &create_info, VK_NULL_HANDLE, &vkSurface);
				return r;
			}

			VkResult PlatformDestroyGVulkanSurface(const std::function<void()>& callback) {
				//Cleanup Vulkan Surface
				callback();

				//Return Success
				return VK_SUCCESS;
			}
		};
	}
}



#endif


#if !defined(GVULKANSURFACE_DUMMY_INCLUDED)
    // This file is automatically generated by our CMake build scripts.
// Authors: Gerard Vega (original CMake build system) & Yangjie Yao(Wolfram auto-versioning)

#ifndef GVERSION_HPP
#define GVERSION_HPP

// Ensure developers are only building Gateware on x64 platforms.
static_assert(sizeof(void*) == 8, "Gateware supports x64 platforms only.");

// The Major version is increased when a new library is added.(minor & patch are reset)
#define GATEWARE_MAJOR 2
// The Minor version is increased whenever an interface is altered.(patch is reset)
#define GATEWARE_MINOR 0
// The Patch version is increased whenever a bug or leak is fixed.(nothing is reset)
#define GATEWARE_PATCH 'b'
// Pulled directly from GIT  
#define GATEWARE_BRANCH "master"
// Pulled directly from GIT
#define GATEWARE_COMMIT_HASH 0x96078a9
// Standard Window Title Bar
#define GATEWARE_VERSION_STRING "Gateware v2.0b"
// Window Title Bar displayed in DEBUG builds
#define GATEWARE_VERSION_STRING_LONG "Gateware v2.0b (master) [96078a9]"

#endif



#ifndef GVULKANHELPER_HPP
#define GVULKANHELPER_HPP

namespace GvkHelper {
	//Extension, Layers and Enumeration Support (RETRUNS: VK_FALSE IS SUCCESS, VK_TRUE IS FAILURE)
	inline VkResult check_instance_extension_name(const char* _extension);
	inline VkResult check_instance_layer_name(const char* _layer);
	inline VkResult check_device_extension_name(const VkPhysicalDevice& _physicalDevice, const char* _extension);
	inline VkResult get_instance_extensions(uint32_t* _outCount, VkExtensionProperties** _outExtensionProperties);
	inline VkResult get_instance_layers(uint32_t* _outCount, VkLayerProperties** _outLayerProperties);
	inline VkResult get_physical_devices(const VkInstance& _instance, uint32_t* _outCount, VkPhysicalDevice** _outPhysicalDevice);
	inline VkResult get_device_extensions(const VkPhysicalDevice& _physicalDevice, uint32_t* _outCount, VkExtensionProperties** _outExtensionProperties);

	//Surface & Swapchain Information
	inline VkResult get_surface_formats(const VkPhysicalDevice& _physicalDevice, const VkSurfaceKHR& _surface, uint32_t* _outCount, VkSurfaceFormatKHR** _outSurfaceFormats);
	inline VkResult get_surface_present_modes(const VkPhysicalDevice& _physicalDevice, const VkSurfaceKHR& _surface, uint32_t* _outCount, VkPresentModeKHR** _outPresentMode);
	inline VkResult get_best_surface_formats(const VkPhysicalDevice& _physicalDevice, const VkSurfaceKHR& _surface, VkSurfaceFormatKHR* _outSurfaceFormat);
	inline VkResult get_best_surface_present_mode(const VkPhysicalDevice& _physicalDevice, const VkSurfaceKHR& _surface, VkPresentModeKHR* _outPresentMode);
	inline VkResult get_surface_extent(const VkPhysicalDevice& _physicalDevice, const VkSurfaceKHR& _surface, const VkExtent2D& _winSize, VkExtent2D* _outExtent3D);
	inline VkResult find_depth_format(const VkPhysicalDevice& _physicalDevice, const VkImageTiling& _tiling, const VkFormatFeatureFlags& _formatFeatureFlags, const VkFormat* _formats, VkFormat* _outDepthFormat);

	//Physical Device Information
	inline VkResult get_best_gpu(const VkSurfaceKHR& _surface, const uint32_t& _totalDevices, VkPhysicalDevice* _allPhysicalDevices, const uint32_t& _totalDeviceExtensions, const char** _deviceExtensions, uint32_t* outIndex);
	inline VkResult get_best_queue_family_indices(const VkPhysicalDevice& _physicalDevice, const VkSurfaceKHR& _surface, int** _outIndices, VkBool32* _outCanCompute);
	inline VkResult get_best_msaa_format(const VkPhysicalDevice& _physicalDevice, const VkSampleCountFlagBits& _idealMSAAFlag, VkSampleCountFlagBits* _outMSAAFlag);

	//Command Help
	inline VkResult signal_command_start(const VkDevice& _device, const VkCommandPool& _commandPool, VkCommandBuffer* _outCommandBuffer);
	inline VkResult signal_command_end(const VkDevice& _device, const VkQueue& _graphicsQueue, const VkCommandPool& _commandPool, VkCommandBuffer* _commandBuffer);

	//Images Creation
	inline VkResult create_image(const VkPhysicalDevice& _physicalDevice, const VkDevice& _device, const VkExtent3D& _extent, const uint32_t& _mipLevels, const VkSampleCountFlagBits& _msaaBit,
		const VkFormat& _format, const VkImageTiling& _tiling, const VkImageUsageFlags& _usageFlags, const VkMemoryPropertyFlags& _memoryPropertyFlags, VkAllocationCallbacks* _allocator,
		VkImage* _outImage, VkDeviceMemory* _outImageMemory);
	inline VkResult create_image_view(const VkDevice& _device, const VkImage& _image, const VkFormat& _format, const VkImageAspectFlags& _imageAspectFlags, const uint32_t& _mipLevels, VkAllocationCallbacks* _allocator, VkImageView* _outImageView);
	inline VkResult transition_image_layout(const VkDevice& _device, const VkCommandPool& _commandPool, const VkQueue& _graphicsQueue, const uint32_t& _mipLevel, const VkImage& _image, const VkFormat& _format, const VkImageLayout& _previousLayout, const VkImageLayout& _currentLayout);
	inline VkResult create_image_set(const VkPhysicalDevice& _physicalDevice, const VkDevice& _device, const VkCommandPool& _commandPool, const VkExtent3D& _extent, const VkQueue& _graphicsQueue, const uint32_t& _mipLevels, const VkSampleCountFlagBits& _msaaSample, const VkFormat& _format,
		const VkImageTiling& _tiling, const VkImageUsageFlags& _usageFlags, const VkImageAspectFlags& _aspectFlags, const VkMemoryPropertyFlags& _memoryPropertyFlags, const VkImageLayout& _previousLayout, const VkImageLayout& _currentLayout, VkAllocationCallbacks* _allocator,
		VkImage* _outImage, VkImageView* _outImageView, VkDeviceMemory* _outDeviceMemory);
	inline VkResult copy_buffer_to_image(const VkDevice& device, const VkCommandPool& command_pool, const VkQueue& graphics_queue, const VkBuffer& buffer, const VkImage& image, const VkExtent3D& extent);
	inline VkResult create_mipmaps(const VkDevice& device, const VkCommandPool& command_pool, const VkQueue& graphics_queue, const VkImage& texture_image, const uint32_t& texture_width, const uint32_t& texture_height, const uint32_t& mip_levels);

	//Other useful functions
	inline VkResult find_memory_type(const VkPhysicalDevice& _physicalDevice, const uint32_t& _filter, const VkMemoryPropertyFlags& _propertyFlags, uint32_t* _outMemoryType);
	inline VkResult create_shader(const VkDevice& _device, const char* _fileName, const char* _entryPoint, const VkShaderStageFlagBits& _shaderType, VkShaderModule* _outShaderModule, VkPipelineShaderStageCreateInfo* _outStageInfo);

	//Overwite a buffer's data
	inline VkResult write_to_buffer(const VkDevice& device, VkDeviceMemory& memory, const void* data_to_write, unsigned int num_bytes)
	{
		void* data;
		VkResult r = vkMapMemory(device, memory, 0, num_bytes, 0, &data);

		if (r)
			return r;

		memcpy(data, data_to_write, num_bytes);
		vkUnmapMemory(device, memory);

		return r;
	}

	//Buffer Creation
	inline VkResult create_buffer(const VkPhysicalDevice& physical_device, const VkDevice& device, const VkDeviceSize& size, const VkBufferUsageFlags& usage_flags, const VkMemoryPropertyFlags& property_flags, VkBuffer* buffer, VkDeviceMemory* buffer_memory);
	inline VkResult copy_buffer(const VkDevice& _device, const VkCommandPool& _commandPool, const VkQueue& _queueGraphics, const VkBuffer& _sourceBuffer, const VkBuffer& _destinationBuffer, const VkDeviceSize& _deviceSize);

	//Shader Creation
	inline VkResult read_shader_file(const char* _fileName, uint64_t* _outShaderSize, char** _outShaderFile);
	inline VkResult create_shader_module(const VkDevice& _device, const uint64_t& _shaderSize, char* _shaderString, VkShaderModule* _outShaderModule);
}
namespace GvkHelper {
//WooWoo! Optional Class!
//This is created to simulate the "optional class" in C++17
template <typename T>
class optional
{
public:
	optional() { m_Value = nullptr; }
	optional(T p_Value) { *this = p_Value; }
	~optional() { reset(); }

	void operator=(T v) { if (!m_Value) m_Value = new T; *m_Value = v; }
	T operator->() { return *m_Value; }
	T operator*() { return *m_Value; }
	const T operator->() const { return *m_Value; }
	const T operator*() const { return *m_Value; }

	const bool has_value()  const { return m_Value; }
	const T value() const { return *m_Value; }

	void reset() { if (m_Value) delete m_Value; }

private:
	T* m_Value;
};

//Internal Helper Functions
template <typename T>
inline T gvk_min(const T &x, const T &y) { return x < y ? x : y; }

inline int64_t gpu_compatibility(const VkPhysicalDevice &_physicalDevice, const VkSurfaceKHR &_surface, const uint32_t & _deviceExtensionCount, const char** _deviceExtensions)
{
	//Gather all device extensions
	uint32_t extension_count = 0;
	VkExtensionProperties* all_extensions = VK_NULL_HANDLE;
	VkResult r = get_device_extensions(_physicalDevice, &extension_count, &all_extensions);

	//Setup Checks
	int64_t score = 0;
	bool is_compatible = false;

	//First check the true requirement
	const char* swapchain_ext = VK_KHR_SWAPCHAIN_EXTENSION_NAME;
	for (uint32_t i = 0; i < extension_count; ++i)
		if (!strcmp(all_extensions[i].extensionName, swapchain_ext))
		{
			is_compatible = true;
			break;
		}

	//Check if compatible
	if (!is_compatible)
		return static_cast<int64_t>(0xC000000000000000);

	//Check Swapchain Support (Format Count, Present Mode Count Checks)
	uint32_t format_count;
	r = vkGetPhysicalDeviceSurfaceFormatsKHR(_physicalDevice, _surface, &format_count, VK_NULL_HANDLE);
	if (r)
		return static_cast<int64_t>(0xC000000000000000);

	uint32_t present_mode_count;
	r = vkGetPhysicalDeviceSurfacePresentModesKHR(_physicalDevice, _surface, &present_mode_count, VK_NULL_HANDLE);
	if (r)
		return static_cast<int64_t>(0xC000000000000000);

	if (!(format_count && present_mode_count))
		return static_cast<int64_t>(0xC000000000000000);

	//Device Queue Compatibility
	int qf[2] = {-1, -1};
	int* pqf = qf;
	VkBool32 can_compute;
	get_best_queue_family_indices(_physicalDevice, _surface, &pqf, &can_compute);

	if (qf[0] == -1 || qf[1] == -1)
		return static_cast<int64_t>(0xC000000000000000);

	//Score if can compute
	score += can_compute ? 100000000 : 0;

	//Check other extensions that was sent.
	for (uint32_t i = 0; i < extension_count; ++i)
		for (uint32_t j = 0; j < _deviceExtensionCount; ++j)
			if (!strcmp(all_extensions[i].extensionName, _deviceExtensions[j]))
			{
				score += 1000000000;
				break;
			}

	//Passes everything. Completely Compatible
	score += static_cast<int64_t>(0x4000000000000000);
	delete[] all_extensions;
	return score;
}
inline int64_t gpu_device_type(const VkPhysicalDevice &_physicalDevice)
{
	//Gather Physical Device Properties
	VkPhysicalDeviceProperties all_properties;
	vkGetPhysicalDeviceProperties(_physicalDevice, &all_properties);
	VkPhysicalDeviceType current_type = all_properties.deviceType;

	//Score up based on Device Type
	int64_t score = 0;
	switch (current_type)
	{
	case VK_PHYSICAL_DEVICE_TYPE_OTHER:
		score += static_cast<int64_t>(0x80000000000000);
		break;
	case VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU:
		score += static_cast<int64_t>(0xC0000000000000);
		break;
	case VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU:
		score += static_cast<int64_t>(0xF0000000000000);
		break;
	case VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU:
		score += static_cast<int64_t>(0xE0000000000000);
		break;
	case VK_PHYSICAL_DEVICE_TYPE_CPU:
		break;
	default:
		break;
	}

	//Return Score
	return score;
}
inline int64_t gpu_features(const VkPhysicalDevice &physical_device)
{
	//Get the Device Features
	VkPhysicalDeviceFeatures device_feature;
	vkGetPhysicalDeviceFeatures(physical_device, &device_feature);

	//Score up the features
	int64_t score = 0;
	score += device_feature.tessellationShader * 100000000000;
	score += device_feature.geometryShader * 100000000000;
	score += device_feature.samplerAnisotropy * 50000000000;
	score += device_feature.sampleRateShading * 50000000000;
	score += device_feature.fillModeNonSolid * 10000000000;

	return score;
}
inline int64_t gpu_memory(const VkPhysicalDevice &_physicalDeviceBest, const VkPhysicalDevice &_physicalDeviceCurrent)
{
	//Get Memory Properties for current best GPU
	VkPhysicalDeviceMemoryProperties memory_properties_best = {};
	vkGetPhysicalDeviceMemoryProperties(_physicalDeviceBest, &memory_properties_best);

	//Get Memory Properties for current GPU
	VkPhysicalDeviceMemoryProperties memory_properties_current = {};
	vkGetPhysicalDeviceMemoryProperties(_physicalDeviceCurrent, &memory_properties_current);

	//Get the Memory Size for current best GPU
	uint64_t best_size = 0;
	for (uint32_t i = 0; i < memory_properties_best.memoryHeapCount; ++i)
		if (memory_properties_best.memoryHeaps[i].flags & VkMemoryHeapFlagBits::VK_MEMORY_HEAP_DEVICE_LOCAL_BIT)
		{
			best_size = memory_properties_best.memoryHeaps[i].size;
			break;
		}

	//Get the Memory Size for current GPU
	uint64_t current_size = 0;
	for (uint32_t i = 0; i < memory_properties_current.memoryHeapCount; ++i)
		if (memory_properties_best.memoryHeaps[i].flags & VkMemoryHeapFlagBits::VK_MEMORY_HEAP_DEVICE_LOCAL_BIT)
		{
			current_size = memory_properties_current.memoryHeaps[i].size;
			break;
		}

	if (current_size <= best_size)
		return -1;

	return 0;
}

//Extension, Layers and Enumeration Support
VkResult check_instance_extension_name(const char* _extension)
{
	//Gather all the instance extensions
	uint32_t count;
	VkExtensionProperties* available_extensions = VK_NULL_HANDLE;
	if (get_instance_extensions(&count, &available_extensions))
		return VK_NOT_READY;

	//compare all instance extensions with the parameter
	for (uint32_t i = 0; i < count; ++i)
	{
		if (!strcmp(available_extensions[i].extensionName, _extension))
		{
			delete[] available_extensions;
			return VK_SUCCESS;
		}
	}

	//Failed to find extension. Return MAX_ENUM
	delete[] available_extensions;
	return VK_ERROR_EXTENSION_NOT_PRESENT;
}
VkResult check_instance_layer_name(const char* _layer)
{
	//Gather all Instance Layers
	uint32_t count;
	VkLayerProperties* available_layers = VK_NULL_HANDLE;
	if (get_instance_layers(&count, &available_layers))
		return VK_NOT_READY;

	//Compare all instance layers with the parameter
	for (uint32_t i = 0; i < count; ++i)
	{
		if (!strcmp(available_layers[i].layerName, _layer))
		{
			delete[] available_layers;
			return VK_SUCCESS;
		}
	}

	//Failed to find extension. Return MAX_ENUM
	delete[] available_layers;
	return VK_ERROR_LAYER_NOT_PRESENT;
}
VkResult check_device_extension_name(const VkPhysicalDevice &_physicalDevice, const char* _extension)
{
	//Gather all the device extensions
	uint32_t count;
	VkExtensionProperties* available_extensions = VK_NULL_HANDLE;
	if (get_device_extensions(_physicalDevice, &count, &available_extensions))
		return VK_NOT_READY;

	//compare all device extensions with the parameter
	for (uint32_t i = 0; i < count; ++i)
	{
		if (!strcmp(available_extensions[i].extensionName, _extension))
		{
			delete[] available_extensions;
			return VK_SUCCESS;
		}
	}

	//Failed to find extension. Return MAX_ENUM
	delete[] available_extensions;
	return VK_ERROR_EXTENSION_NOT_PRESENT;
}
VkResult get_instance_extensions(uint32_t* _outCount, VkExtensionProperties **_outExtensionProperties)
{
	//Gather All Extensions
	VkExtensionProperties* out;
	VkResult r = vkEnumerateInstanceExtensionProperties(nullptr, _outCount, VK_NULL_HANDLE);

	if (*_outCount < 1)
	{
		//There are no extensions. Abort
		r = VK_ERROR_FEATURE_NOT_PRESENT;
		return r;
	}
	if (r)
		return r; //Failed to retrieve extensions. Abort.

	//Create a new array to hold all the extensions
	out = new VkExtensionProperties[*_outCount];
	r = vkEnumerateInstanceExtensionProperties(nullptr, _outCount, out);
	if (r)
	{
		//Is NOT VK_SUCCESS! Delete the newly created array and set to null handle
		delete[] out;
		out = VK_NULL_HANDLE;
	}

	//Give the new extension array to the parameter
	*_outExtensionProperties = out;

	//Return Result
	return r;
}
VkResult get_instance_layers(uint32_t* _outCount, VkLayerProperties **_outLayerProperties)
{
	//Gather All Layers
	VkLayerProperties* out;
	VkResult r = vkEnumerateInstanceLayerProperties(_outCount, VK_NULL_HANDLE);

	if (*_outCount < 1)
	{
		//There are no Layers. Abort
		r = VK_ERROR_FEATURE_NOT_PRESENT;
		return r;
	}
	if (r)
		return r; //Failed to retrieve Layers. Abort.

	//Create a new array to hold all the Layers
	out = new VkLayerProperties[*_outCount];
	r = vkEnumerateInstanceLayerProperties(_outCount, out);
	if (r)
	{
		//Is NOT VK_SUCCESS! Delete the newly created array and set to nullptr
		delete[] out;
		out = VK_NULL_HANDLE;
	}

	//Give the new Layer array to the parameter
	*_outLayerProperties = out;

	//Return Result
	return r;
}
VkResult get_physical_devices(const VkInstance &_instance, uint32_t *_outCount, VkPhysicalDevice **_outPhysicalDevice)
{
	//Gather All Devices
	VkPhysicalDevice* out;
	VkResult r = vkEnumeratePhysicalDevices(_instance, _outCount, VK_NULL_HANDLE);

	if (*_outCount < 1)
	{
		//There are no devices. Abort
		r = VK_ERROR_FEATURE_NOT_PRESENT;
		return r;
	}
	if (r)
		return r; //Failed to retrieve devices. Abort.

	//Create a new array to hold all the devices
	out = new VkPhysicalDevice[*_outCount];
	r = vkEnumeratePhysicalDevices(_instance, _outCount, out);
	if (r)
	{
		//Is NOT VK_SUCCESS! Delete the newly created array and set to null handle
		delete[] out;
		out = VK_NULL_HANDLE;
	}

	//Give the new device array to the parameter
	*_outPhysicalDevice = out;

	//Return Result
	return r;
}
VkResult get_device_extensions(const VkPhysicalDevice &_physicalDevice, uint32_t *_outCount, VkExtensionProperties **_outExtensionProperties)
{
	//Gather All Extensions
	VkExtensionProperties* out;
	VkResult r = vkEnumerateDeviceExtensionProperties(_physicalDevice, nullptr, _outCount, VK_NULL_HANDLE);

	if (*_outCount < 1)
	{
		//There are no extensions. Abort
		r = VK_ERROR_FEATURE_NOT_PRESENT;
		return r;
	}
	if (r)
		return r; //Failed to retrieve extensions. Abort.

	//Create a new array to hold all the extensions
	out = new VkExtensionProperties[*_outCount];
	r = vkEnumerateDeviceExtensionProperties(_physicalDevice, nullptr, _outCount, out);
	if (r)
	{
		//Is NOT VK_SUCCESS! Delete the newly created array and set to null handle
		delete[] out;
		out = VK_NULL_HANDLE;
	}

	//Give the new extension array to the parameter
	*_outExtensionProperties = out;

	//Return Result
	return r;
}

//Surface & Swapchain Information
VkResult get_surface_formats(const VkPhysicalDevice &_physicalDevice, const VkSurfaceKHR &_surface, uint32_t *_outCount, VkSurfaceFormatKHR **_outSurfaceFormats)
{
	//Gather all the surface formats
	VkSurfaceFormatKHR *out = *_outSurfaceFormats;
	VkResult r = vkGetPhysicalDeviceSurfaceFormatsKHR(_physicalDevice, _surface, _outCount, VK_NULL_HANDLE);

	if (*_outCount < 1)
	{
		//There are no surface formats. Abort
		r = VK_ERROR_FEATURE_NOT_PRESENT;
		return r;
	}
	if (r)
		return r; //Failed to retrieve surface formats. Abort.

	//Create a new array to hold all the surface formats
	out = new VkSurfaceFormatKHR[*_outCount];
	r = vkGetPhysicalDeviceSurfaceFormatsKHR(_physicalDevice, _surface, _outCount, out);
	if (r)
	{
		//Is NOT VK_SUCCESS! Delete the newly created array and set to null handle
		delete[] out;
		out = VK_NULL_HANDLE;
	}

	//Give the new extension array to the parameter
	*_outSurfaceFormats = out;

	//Return Result
	return r;
}
VkResult get_surface_present_modes(const VkPhysicalDevice &_physicalDevice, const VkSurfaceKHR &_surface, uint32_t *_outCount, VkPresentModeKHR **_outPresentMode)
{
	//Gather all the surface present modes
	VkPresentModeKHR* out = *_outPresentMode;
	VkResult r = vkGetPhysicalDeviceSurfacePresentModesKHR(_physicalDevice, _surface, _outCount, nullptr);

	if (*_outCount < 1)
	{
		//There are no surface present modes. Abort
		r = VK_ERROR_FEATURE_NOT_PRESENT;
		return r;
	}
	if (r)
		return r; //Failed to retrieve surface formats. Abort.

	//Create a new array to hold all the surface formats
	out = new VkPresentModeKHR[*_outCount];
	r = vkGetPhysicalDeviceSurfacePresentModesKHR(_physicalDevice, _surface, _outCount, out);
	if (r)
	{
		//Is NOT VK_SUCCESS! Delete the newly created array and set to null handle
		delete[] out;
		out = VK_NULL_HANDLE;
	}

	//Give the new extension array to the parameter
	*_outPresentMode = out;

	//Return Result
	return r;
}
VkResult get_best_surface_formats(const VkPhysicalDevice &_physicalDevice, const VkSurfaceKHR &_surface, VkSurfaceFormatKHR *_outSurfaceFormat)
{
	//Gather all the surface formats
	uint32_t count;
	VkSurfaceFormatKHR *surface_formats = VK_NULL_HANDLE;
	VkResult r = get_surface_formats(_physicalDevice, _surface, &count, &surface_formats);

	//If Count is 0, then something went wrong
	if (count < 1 || r)
	{
		//Failed to find surface formats. Abort.
		if (surface_formats) delete[] surface_formats;
		return VK_ERROR_FEATURE_NOT_PRESENT;
	}

	//If NOT VK_SUCCESS, then simply return r
	if (r)
	{
		//Failed to find surface formats. Abort.
		if (surface_formats) delete[] surface_formats;
		return r;
	}

	//If the count is 1 and the format is unknown, set a default format as best
	if (count == 1 && surface_formats[0].format == VK_FORMAT_UNDEFINED)
	{
		*_outSurfaceFormat = { VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR };
		delete[] surface_formats;
		return r;
	}

	//Loop through all formats and find the best format.
	for (uint32_t i = 0; i < count; ++i)
	{
		if (surface_formats[i].format == VK_FORMAT_B8G8R8A8_UNORM && surface_formats[i].colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR)
		{
			*_outSurfaceFormat = surface_formats[i];
			delete[] surface_formats;
			return r;
		}
	}

	if (surface_formats)
	{
		*_outSurfaceFormat = surface_formats[0];
		delete[] surface_formats;
	}
	return r;
}
VkResult get_best_surface_present_mode(const VkPhysicalDevice& _physicalDevice, const VkSurfaceKHR& _surface, VkPresentModeKHR *_outPresentMode)
{
	//Gather all surface present modes
	uint32_t count;
	VkPresentModeKHR *present_modes = VK_NULL_HANDLE;
	VkResult r = get_surface_present_modes(_physicalDevice, _surface, &count, &present_modes);

	//If Count is 0, then something went wrong
	if (count < 1)
	{
		//Failed to find present modes. Abort.
		if (present_modes) delete[] present_modes;
		return VK_ERROR_FEATURE_NOT_PRESENT;
	}

	//If NOT VK_SUCCESS, then simply return r
	if (r)
	{
		//Failed to find present modes. Abort.
		if (present_modes) delete[] present_modes;
		return r;
	}

	//Find the best mode (best: Mailbox, runner-up: Immediate, Default: FIFO)
	VkPresentModeKHR best_mode = VK_PRESENT_MODE_FIFO_KHR;
	for (uint32_t i = 0; i < count; ++i)
	{
		if (present_modes[i] == VK_PRESENT_MODE_MAILBOX_KHR)
		{
			best_mode = present_modes[i];
			*_outPresentMode = best_mode;
			break;
		}
		else if (present_modes[i] == VK_PRESENT_MODE_IMMEDIATE_KHR)
			best_mode = VK_PRESENT_MODE_IMMEDIATE_KHR;
	}

	if (present_modes)
	{
		delete[] present_modes;
		*_outPresentMode = best_mode;
	}
	return r;
}
VkResult get_surface_extent(const VkPhysicalDevice& _physicalDevice, const VkSurfaceKHR& _surface, const VkExtent2D &_winSize, VkExtent2D *_outExtent2D)
{
	//Gather all surface capabilities
	VkSurfaceCapabilitiesKHR surface_capabilities;
	VkResult r = vkGetPhysicalDeviceSurfaceCapabilitiesKHR(_physicalDevice, _surface, &surface_capabilities);
	if (r)
		return r;

	//If Capabilities's extent is not MAX, Set to those extents
	if (surface_capabilities.currentExtent.width != 0xFFFFFFFF)
		*_outExtent2D = surface_capabilities.currentExtent;
	else //Otherwise set it to window's width and height.
		*_outExtent2D = _winSize;

	return r;
}
VkResult find_depth_format(const VkPhysicalDevice& _physicalDevice, const VkImageTiling& _tiling, const VkFormatFeatureFlags& _formatFeatureFlags, const VkFormat *_formats, VkFormat* _outDepthFormat)
{
	//Setup Formats (Based on either input or default)
	VkFormat depth_formats[3];
	if (_formats)
	{
		depth_formats[0] = _formats[0];
		depth_formats[1] = _formats[1];
		depth_formats[2] = _formats[2];
	}
	else
	{
		depth_formats[0] = VK_FORMAT_D32_SFLOAT;
		depth_formats[1] = VK_FORMAT_D32_SFLOAT_S8_UINT;
		depth_formats[2] = VK_FORMAT_D24_UNORM_S8_UINT;
	}

	//Find the best compatible format for Depth
	for (uint32_t i = 0; i < 3; ++i)
	{
		VkFormatProperties format_properties;
		vkGetPhysicalDeviceFormatProperties(_physicalDevice, depth_formats[i], &format_properties);

		if (_tiling == VK_IMAGE_TILING_LINEAR &&
			(format_properties.linearTilingFeatures & _formatFeatureFlags) == _formatFeatureFlags)
		{
			*_outDepthFormat = depth_formats[i];
			return VK_SUCCESS;
		}
		else if (_tiling == VK_IMAGE_TILING_OPTIMAL &&
			(format_properties.optimalTilingFeatures & _formatFeatureFlags) == _formatFeatureFlags)
		{
			*_outDepthFormat = depth_formats[i];
			return VK_SUCCESS;
		}
	}

	//Format not found. Set to Undefined
	*_outDepthFormat = VK_FORMAT_UNDEFINED;

	//Return Max Enum
	return VK_RESULT_MAX_ENUM;
}

//Physical Device Information
VkResult get_best_gpu(const VkSurfaceKHR & _surface, const uint32_t& _totalDevices, VkPhysicalDevice* _allPhysicalDevices, const uint32_t &_totalDeviceExtensions, const char **_deviceExtensions, uint32_t *outIndex)
{
	/*
	The Idea:
	So, The purpose of this function is ideally to find the best GPU.
	The hard part, is that I cannot find a way to check clock speeds.
	So instead, i will base this on Compatibility, Device Type, Features and Memory.
		- Compatibility has the biggest impact. If its not compatible, then its a negative score.
		- Device Types will have a major impact. Best in order: Discrete GPU -> Virtual GPU -> Integrated GPU -> CPU
		- Features has minor impact. All features combined will have a great impact.
		- Memory will only come into play when scores are the same.
	There is absolutely no guarantee this is the best, but i want to be at least 95% accurate.
	*/

	//Gather Best GPU Index. Default is 0
	uint32_t best_index = 0;
	int64_t best_score = 0;
	for (uint32_t i = 0; i < _totalDevices; ++i)
	{
		int64_t score = 0;
		score += gpu_compatibility(_allPhysicalDevices[i], _surface, _totalDeviceExtensions, _deviceExtensions);
		score += gpu_device_type(_allPhysicalDevices[i]);
		score += gpu_features(_allPhysicalDevices[i]);

		if (score == best_score)
			score += gpu_memory(_allPhysicalDevices[best_index], _allPhysicalDevices[i]);

		if (score >= best_score)
		{
			best_index = i;
			best_score = score;
		}
	}

	*outIndex = best_index;
	return VK_SUCCESS;
}
VkResult get_best_queue_family_indices(const VkPhysicalDevice &_physicalDevice, const VkSurfaceKHR &_surface, int **_outIndices, VkBool32 *_outCanCompute)
{
    int* indices = *_outIndices;
    
	//Gather Queue Family Properties
	uint32_t count = 0;
	vkGetPhysicalDeviceQueueFamilyProperties(_physicalDevice, &count, nullptr);
	VkQueueFamilyProperties* queue_family_properties = new VkQueueFamilyProperties[count];
	vkGetPhysicalDeviceQueueFamilyProperties(_physicalDevice, &count, queue_family_properties);

	//Setup the Optional (Graphics and Present) Queue
	optional<int32_t> graphics;
	optional<int32_t> present;

	//Find Absolute Best: With Compute Shader
	for (uint32_t i = 0; i < count; ++i)
	{
		VkQueueFamilyProperties* cur = &queue_family_properties[i];
		if (cur->queueCount > 0 && cur->queueFlags & (VK_QUEUE_GRAPHICS_BIT | VK_QUEUE_COMPUTE_BIT))
		{
			graphics = i;
			*_outCanCompute = VK_TRUE;

			VkBool32 present_support = VK_FALSE;
			VkResult r = vkGetPhysicalDeviceSurfaceSupportKHR(_physicalDevice, i, _surface, &present_support);
			if (r)
				continue;

			if (present_support)
				present = i;

			if (present.has_value())
			{
				indices[0] = i;
				indices[1] = i;
				delete[] queue_family_properties;
				return r;
			}
		}
	}

	//No Compute Shader!
	_outCanCompute = VK_FALSE;
	for (uint32_t i = 0; i < count; ++i)
	{
		VkQueueFamilyProperties* cur = &queue_family_properties[i];
		if ( (cur->queueCount > 0) && (cur->queueFlags & VK_QUEUE_GRAPHICS_BIT))
		{
			graphics = i;

			VkBool32 present_support = VK_FALSE;
			VkResult r = vkGetPhysicalDeviceSurfaceSupportKHR(_physicalDevice, i, _surface, &present_support);
			if (r)
				continue;

			if (present_support)
				present = i;

			if (present.has_value())
			{
				indices[0] = i;
				indices[1] = i;
				delete[] queue_family_properties;
				return r;
			}
		}
	}

	indices[0] = -1;
	indices[1] = -1;
	delete[] queue_family_properties;
	return VK_RESULT_MAX_ENUM;
}
VkResult get_best_msaa_format(const VkPhysicalDevice& _physicalDevice, const VkSampleCountFlagBits&_idealMSAAFlag, VkSampleCountFlagBits *_outMSAAFlag)
{
	//Gather all physical device
	VkPhysicalDeviceProperties physical_device_properties;
	vkGetPhysicalDeviceProperties(_physicalDevice, &physical_device_properties);

	//Set a flag based on the minimum
	VkSampleCountFlagBits flags = static_cast<VkSampleCountFlagBits>( gvk_min(
		static_cast<int32_t>(physical_device_properties.limits.framebufferColorSampleCounts),
		static_cast<int32_t>(physical_device_properties.limits.framebufferDepthSampleCounts)
	) );

	//Find the highest MSAA
	for (VkSampleCountFlagBits bit = VK_SAMPLE_COUNT_64_BIT; bit > VK_SAMPLE_COUNT_1_BIT; bit = static_cast<VkSampleCountFlagBits>(bit >> 1))
	{
		if ((flags & bit))
		{
			*_outMSAAFlag = bit;

			if (bit >= _idealMSAAFlag)
				return VK_SUCCESS;
			else
				return VK_RESULT_MAX_ENUM;
		}
	}

	//Couldn't find MSAA, set default
	*_outMSAAFlag = VK_SAMPLE_COUNT_1_BIT;
	return VK_RESULT_MAX_ENUM;
}

//Command Help
VkResult signal_command_start(const VkDevice &_device, const VkCommandPool &_commandPool, VkCommandBuffer *_outCommandBuffer)
{
	//Command Buffer Allocate Info
	VkCommandBufferAllocateInfo command_buffer_allocate_info = {};
	command_buffer_allocate_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
	command_buffer_allocate_info.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
	command_buffer_allocate_info.commandPool = _commandPool;
	command_buffer_allocate_info.commandBufferCount = 1;

	//Create the command buffer and allocate the command buffer with create info
	VkResult r = vkAllocateCommandBuffers(_device, &command_buffer_allocate_info, _outCommandBuffer);
	if (r)
		return r;

	//Start the command buffer's create info
	VkCommandBufferBeginInfo command_buffer_begin_info = {};
	command_buffer_begin_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
	command_buffer_begin_info.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;

	//Begin the Command Buffer's recording process
	r = vkBeginCommandBuffer(*_outCommandBuffer, &command_buffer_begin_info);

	//Command Buffer has been successfully started!
	return r;
}
VkResult signal_command_end(const VkDevice& _device, const VkQueue& _graphicsQueue, const VkCommandPool& _commandPool, VkCommandBuffer *_commandBuffer)
{
	//End the Command Buffer's recording Process
	VkResult r = vkEndCommandBuffer(*_commandBuffer);
	if (r)
		throw "VkResult is NOT VK_SUCCESS!";

	//Create the submit info
	VkSubmitInfo submit_info = {};
	submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
	submit_info.commandBufferCount = 1;
	submit_info.pCommandBuffers = _commandBuffer;

	//Submit The Commands Recorded into the Queue. Then wait for the Graphics Queue to be idle
	r = vkQueueSubmit(_graphicsQueue, 1, &submit_info, VK_NULL_HANDLE);
	if (r)
	{
		throw "VkResult is NOT VK_SUCCESS!";
	}

	r = vkQueueWaitIdle(_graphicsQueue);
	if (r)
		throw "VkResult is NOT VK_SUCCESS!";

	//Free the command buffer from memory
	vkFreeCommandBuffers(_device, _commandPool, 1, _commandBuffer);

	//The Command Buffer has ended successfully!
	return r;
}

//Images Creation
VkResult create_image(const VkPhysicalDevice& _physicalDevice, const VkDevice& _device, const VkExtent3D& _extent, const uint32_t& _mipLevels, const VkSampleCountFlagBits& _msaaBit,
	const VkFormat& _format, const VkImageTiling& _tiling, const VkImageUsageFlags& _usageFlags, const VkMemoryPropertyFlags& _memoryPropertyFlags, VkAllocationCallbacks* _allocator,
	VkImage *_outImage, VkDeviceMemory *_outImageMemory)
{
	//Create image info
	VkImageCreateInfo create_info = {};
	create_info.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
	create_info.imageType = VK_IMAGE_TYPE_2D;
	create_info.extent = _extent;
	create_info.mipLevels = _mipLevels;
	create_info.arrayLayers = 1;
	create_info.format = _format;
	create_info.tiling = _tiling;
	create_info.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
	create_info.usage = _usageFlags;
	create_info.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
	create_info.samples = _msaaBit;
	create_info.flags = 0;

	//Create the image
	VkResult r = vkCreateImage(_device, &create_info, _allocator, _outImage);
	if (r)
	{
		*_outImageMemory = 0u;
		return r;
	}

	//Create the memory required for any the image passed into this function
	VkMemoryRequirements memory_requirements;
	vkGetImageMemoryRequirements(_device, *_outImage, &memory_requirements);

	uint32_t memory_type_index = 0;
	find_memory_type(_physicalDevice, memory_requirements.memoryTypeBits, _memoryPropertyFlags, &memory_type_index);

	//Memory Allocate Info
	VkMemoryAllocateInfo memory_allocate_info = {};
	memory_allocate_info.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
	memory_allocate_info.allocationSize = memory_requirements.size;
	memory_allocate_info.memoryTypeIndex = memory_type_index;

	//Allocate the memory created
	r = vkAllocateMemory(_device, &memory_allocate_info, _allocator, _outImageMemory);
	if (r)
	{
		vkDestroyImage(_device, *_outImage, _allocator);
		*_outImage = VK_NULL_HANDLE;
		_outImageMemory = 0u;
		return r;
	}

	//Bind the memory created
	r = vkBindImageMemory(_device, *_outImage, *_outImageMemory, 0);
	if (r)
	{
		vkDestroyImage(_device, *_outImage, VK_NULL_HANDLE);
		*_outImage = VK_NULL_HANDLE;
		vkFreeMemory(_device, *_outImageMemory, VK_NULL_HANDLE);
		return r;
	}

	//Image Creation has been successful!
	return r;
}
VkResult create_image_view(const VkDevice& _device, const VkImage& _image, const VkFormat& _format, const VkImageAspectFlags& _imageAspectFlags, const uint32_t& _mipLevels, VkAllocationCallbacks* _allocator, VkImageView *_outImageView)
{
	//Image View Create Info
	VkImageViewCreateInfo create_info = {};
	create_info.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
	create_info.image = _image;
	create_info.viewType = VK_IMAGE_VIEW_TYPE_2D;
	create_info.format = _format;
	create_info.subresourceRange.aspectMask = _imageAspectFlags;
	create_info.subresourceRange.baseMipLevel = 0;
	create_info.subresourceRange.levelCount = _mipLevels;
	create_info.subresourceRange.baseArrayLayer = 0;
	create_info.subresourceRange.layerCount = 1;

	//Create the Surface (With Results) [VK_SUCCESS = 0]
	VkResult r = vkCreateImageView(_device, &create_info, _allocator, _outImageView);

	//Image View has been created successfully, return it
	return r;
}
VkResult transition_image_layout(const VkDevice& _device, const VkCommandPool& _commandPool, const VkQueue& _graphicsQueue, const uint32_t& _mipLevel, const VkImage& _image, const VkFormat& _format, const VkImageLayout& _previousLayout, const VkImageLayout& _currentLayout)
{
	//Start the command buffer
	VkCommandBuffer command_buffer = VK_NULL_HANDLE;
	VkResult r = signal_command_start(_device, _commandPool, &command_buffer);

	//Create the image memory barrier
	VkImageMemoryBarrier image_memory_barrier = {};
	image_memory_barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
	image_memory_barrier.image = _image;
	image_memory_barrier.oldLayout = _previousLayout;
	image_memory_barrier.newLayout = _currentLayout;
	image_memory_barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
	image_memory_barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
	image_memory_barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
	image_memory_barrier.subresourceRange.baseMipLevel = 0;
	image_memory_barrier.subresourceRange.levelCount = _mipLevel;
	image_memory_barrier.subresourceRange.layerCount = 1;
	image_memory_barrier.subresourceRange.baseArrayLayer = 0;

	//Setup the source and destination stage flags. Will be set based on the Old and New Layout set from outside
	VkPipelineStageFlags source_stage = 0;
	VkPipelineStageFlags destrination_stage = 0;

	if (_currentLayout == VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL)
	{
		image_memory_barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT;
		if (_format == VK_FORMAT_D24_UNORM_S8_UINT || _format == VK_FORMAT_D32_SFLOAT_S8_UINT)
			image_memory_barrier.subresourceRange.aspectMask |= VK_IMAGE_ASPECT_STENCIL_BIT;
	}

	if (_previousLayout == VK_IMAGE_LAYOUT_UNDEFINED)
	{
		if (_currentLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL)
		{
			image_memory_barrier.srcAccessMask = 0;
			image_memory_barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;

			source_stage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
			destrination_stage = VK_PIPELINE_STAGE_TRANSFER_BIT;
		}
		else if (_currentLayout == VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL)
		{
			image_memory_barrier.srcAccessMask = 0;
			image_memory_barrier.dstAccessMask = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;

			source_stage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
			destrination_stage = VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;
		}
		else if (_currentLayout == VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL)
		{
			image_memory_barrier.srcAccessMask = 0;
			image_memory_barrier.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;

			source_stage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
			destrination_stage = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
		}
	}
	else if (_previousLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL && _currentLayout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL)
	{
		image_memory_barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
		image_memory_barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

		source_stage = VK_PIPELINE_STAGE_TRANSFER_BIT;
		destrination_stage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
	}

	vkCmdPipelineBarrier(command_buffer, source_stage, destrination_stage, 0, 0, nullptr, 0, nullptr, 1, &image_memory_barrier);

	r = signal_command_end(_device, _graphicsQueue, _commandPool, &command_buffer);
	return r;
}
VkResult copy_buffer_to_image(const VkDevice& device, const VkCommandPool& command_pool, const VkQueue& graphics_queue, const VkBuffer& buffer, const VkImage& image, const VkExtent3D& extent)
{
	//Start Command Buffer
	VkCommandBuffer command_buffer = VK_NULL_HANDLE;
	VkResult r = signal_command_start(device, command_pool, &command_buffer);

	//Setup The Buffer Image Copy
	VkBufferImageCopy buffer_image_copy = {};
	buffer_image_copy.bufferOffset = 0;
	buffer_image_copy.bufferRowLength = 0;
	buffer_image_copy.bufferImageHeight = 0;
	buffer_image_copy.imageSubresource.layerCount = 1;
	buffer_image_copy.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
	buffer_image_copy.imageSubresource.mipLevel = 0;
	buffer_image_copy.imageSubresource.baseArrayLayer = 0;
	buffer_image_copy.imageOffset = { 0,0,0 };
	buffer_image_copy.imageExtent = extent;

	//Send Command to Copy Buffer to Image
	vkCmdCopyBufferToImage(command_buffer, buffer, image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &buffer_image_copy);

	//End the Command buffer
	r = signal_command_end(device, graphics_queue, command_pool, &command_buffer);

	//Return result
	return r;
}
VkResult create_image_set(const VkPhysicalDevice& _physicalDevice, const VkDevice& _device, const VkCommandPool &_commandPool, const VkExtent3D& _extent, const VkQueue &_graphicsQueue, const uint32_t& _mipLevels, const VkSampleCountFlagBits& _msaaSample, const VkFormat& _format,
	const VkImageTiling& _tiling, const VkImageUsageFlags& _usageFlags, const VkImageAspectFlags &_aspectFlags, const VkMemoryPropertyFlags& _memoryPropertyFlags, const VkImageLayout &_previousLayout, const VkImageLayout &_currentLayout, VkAllocationCallbacks* _allocator,
	VkImage *_outImage, VkImageView *_outImageView, VkDeviceMemory *_outDeviceMemory)
{
	//Create Image
	VkResult r = create_image(_physicalDevice, _device, _extent, _mipLevels, _msaaSample, _format, _tiling, _usageFlags, _memoryPropertyFlags, _allocator, _outImage, _outDeviceMemory);
	if (r)
		return r;

	//Create Image View
	r = create_image_view(_device, *_outImage, _format, _aspectFlags, _mipLevels, _allocator, _outImageView);
	if (r)
		return r;

	//Bind the image layouts
	r = transition_image_layout(_device, _commandPool, _graphicsQueue, _mipLevels, *_outImage, _format, _previousLayout, _currentLayout);
	return r;
}
VkResult create_mipmaps(const VkDevice& device, const VkCommandPool& command_pool, const VkQueue& graphics_queue, const VkImage& texture_image, const uint32_t& texture_width, const uint32_t& texture_height, const uint32_t& mip_levels)
{
	//Start the command buffer
	VkCommandBuffer command_buffer;
	VkResult r = signal_command_start(device, command_pool, &command_buffer);

	//Create the Image Memory Barrier for Mipmapping
	VkImageMemoryBarrier image_memory_barrier = {};
	image_memory_barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
	image_memory_barrier.image = texture_image;
	image_memory_barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
	image_memory_barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
	image_memory_barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
	image_memory_barrier.subresourceRange.baseArrayLayer = 0;
	image_memory_barrier.subresourceRange.layerCount = 1;
	image_memory_barrier.subresourceRange.levelCount = 1;

	//Save the texture width and height for Mip levels
	int32_t mip_width = texture_width;
	int32_t mip_height = texture_height;

	//Loop for every Mip levels. NOTE: (i-1) is the current mip level, while (i) is the next mip level
	for (uint32_t i = 1; i < mip_levels; ++i) {
		//Setup the current mip level for blitting the image
		image_memory_barrier.subresourceRange.baseMipLevel = i - 1;
		image_memory_barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
		image_memory_barrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
		image_memory_barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
		image_memory_barrier.dstAccessMask = VK_ACCESS_TRANSFER_READ_BIT;

		//Transfer the layout and Access Mask Information
		vkCmdPipelineBarrier(command_buffer, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, 0,
			0, nullptr, 0, nullptr, 1, &image_memory_barrier);

		//Create the Blit Image. Src is (i-1), or current mip level. dst is (i), or next mip level.
		VkImageBlit image_blit = {};
		image_blit.srcSubresource.mipLevel = i - 1;
		image_blit.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
		image_blit.srcSubresource.baseArrayLayer = 0;
		image_blit.srcSubresource.layerCount = 1;
		image_blit.srcOffsets[0] = { 0, 0, 0 };
		image_blit.srcOffsets[1] = { mip_width, mip_height, 1 };

		image_blit.dstSubresource.mipLevel = i;
		image_blit.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
		image_blit.dstSubresource.baseArrayLayer = 0;
		image_blit.dstSubresource.layerCount = 1;
		image_blit.dstOffsets[0] = image_blit.srcOffsets[0];
		image_blit.dstOffsets[1] = { mip_width > 1 ? (mip_width >> 1) : 1 , mip_height > 1 ? (mip_height >> 1) : 1, 1 };

		//Blit the texture
		vkCmdBlitImage(command_buffer, texture_image, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, texture_image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
			1, &image_blit, VK_FILTER_LINEAR);

		//Set the layout and Access Mask (again) for the shader to read
		image_memory_barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
		image_memory_barrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
		image_memory_barrier.srcAccessMask = VK_ACCESS_TRANSFER_READ_BIT;
		image_memory_barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

		//Transfer the layout and Access Mask Information (Again, based on above values)
		vkCmdPipelineBarrier(command_buffer, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
			0, 0, nullptr, 0, nullptr, 1, &image_memory_barrier);

		//Reduce the Mip level down by 1 level [By cutting width and height in half]
		if (mip_width > 1) { mip_width >>= 1; }
		if (mip_height > 1) { mip_height >>= 1; }
	}

	image_memory_barrier.subresourceRange.baseMipLevel = mip_levels - 1;
	image_memory_barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
	image_memory_barrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
	image_memory_barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
	image_memory_barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

	vkCmdPipelineBarrier(command_buffer, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
		0, 0, nullptr, 0, nullptr, 1, &image_memory_barrier);

	//End the command
	r = signal_command_end(device, graphics_queue, command_pool, &command_buffer);

	//Mipmapping has been created successfully!
	return r;
}

//Other Important Functions
VkResult find_memory_type(const VkPhysicalDevice& _physicalDevice, const uint32_t& _filter, const VkMemoryPropertyFlags& _propertyFlags, uint32_t* _outMemoryType)
{
	//Get the Memory Properties from the Physical Device
	VkPhysicalDeviceMemoryProperties memory_properties;
	vkGetPhysicalDeviceMemoryProperties(_physicalDevice, &memory_properties);

	//Loop through the memory type count and see if there is a match with both the filter and property flags
	for (uint32_t i = 0; i < memory_properties.memoryTypeCount; ++i)
	{
		if ((_filter & (1 << i)) &&
			(memory_properties.memoryTypes[i].propertyFlags & _propertyFlags) == _propertyFlags)
		{
			*_outMemoryType = i;
			return VK_SUCCESS;
		}
	}

	//Failed to find memory
	*_outMemoryType = 0x7FFFFFFF;
	return VK_RESULT_MAX_ENUM;
}

//Buffer Creation
VkResult create_buffer(const VkPhysicalDevice& physical_device, const VkDevice& device, const VkDeviceSize& size, const VkBufferUsageFlags& usage_flags, const VkMemoryPropertyFlags& property_flags, VkBuffer* buffer, VkDeviceMemory* buffer_memory)
{
	//Create Buffer Create Info
	VkBufferCreateInfo buffer_create_info = {};
	buffer_create_info.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
	buffer_create_info.size = size;
	buffer_create_info.usage = usage_flags;
	buffer_create_info.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
	buffer_create_info.pNext = VK_NULL_HANDLE;

	//Create the buffer
	VkResult r = vkCreateBuffer(device, &buffer_create_info, nullptr, buffer);
	if (r)
		return r;

	//Get the memory required to allocate the buffer
	VkMemoryRequirements memory_requirement;
	vkGetBufferMemoryRequirements(device, *buffer, &memory_requirement);

	VkMemoryAllocateInfo memory_allocate_info = {};
	memory_allocate_info.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
	memory_allocate_info.allocationSize = memory_requirement.size;
	memory_allocate_info.pNext = VK_NULL_HANDLE;
	find_memory_type(physical_device, memory_requirement.memoryTypeBits, property_flags, &memory_allocate_info.memoryTypeIndex);

	//Allocate and Bind the buffer
	r = vkAllocateMemory(device, &memory_allocate_info, nullptr, buffer_memory);
	if (r)
		return r;

	r = vkBindBufferMemory(device, *buffer, *buffer_memory, 0);

	//Return the last result of that bind memory
	return r;
}
VkResult copy_buffer(const VkDevice& _device, const VkCommandPool& _commandPool, const VkQueue& _queueGraphics, const VkBuffer& _sourceBuffer, const VkBuffer& _destinationBuffer, const VkDeviceSize& _deviceSize)
{
	//Start the command buffer
	VkCommandBuffer command_buffer;
	VkResult r = signal_command_start(_device, _commandPool, &command_buffer);

	//Copy the buffer sent through
	VkBufferCopy buffer_copy = {};
	buffer_copy.srcOffset = 0;
	buffer_copy.dstOffset = 0;
	buffer_copy.size = _deviceSize;
	vkCmdCopyBuffer(command_buffer, _sourceBuffer, _destinationBuffer, 1, &buffer_copy);

	//End the command buffer
	r = signal_command_end(_device, _queueGraphics, _commandPool, &command_buffer);
	return r;
}
VkResult read_shader_file(const char* _fileName, uint64_t* _outShaderSize, char** _outShaderFile)
{
	//Open the File
	FILE* file;
	#ifdef _WIN32
	fopen_s(&file, _fileName, "rb");
	#else
	file = fopen(_fileName, "rb");
	#endif
	if (!file)
		return VK_RESULT_MAX_ENUM; //File Failed to Open

	//Get the size of the file
	fseek(file, 0, SEEK_END);
	uint64_t shaderSize =  *_outShaderSize = ftell(file);

	//Copy all the contents of the file.
	rewind(file);
	char* shaderFile = *_outShaderFile = new char[shaderSize + 1];
	uint64_t readSize = fread(shaderFile, sizeof(char), shaderSize, file);
	shaderFile[shaderSize] = '\0';
	if (readSize != shaderSize)
	{
		delete[] shaderFile;	//Something went wrong with the write...
		shaderFile = nullptr;	//So delete and set to nullptr
	}

	//Close the file and return whether it was successful or not.
	fclose(file);
	return shaderFile ? VK_SUCCESS : VK_RESULT_MAX_ENUM;
}
VkResult create_shader_module(const VkDevice& _device, const uint64_t& _shaderSize, char* _shaderString, VkShaderModule* _outShaderModule)
{
	//Setup create info
	VkShaderModuleCreateInfo create_info = {};
	create_info.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
	create_info.codeSize = _shaderSize;
	create_info.pCode = reinterpret_cast<const uint32_t*>(_shaderString);

	//Create the Shader Module and return the result of it.
	VkResult r = vkCreateShaderModule(_device, &create_info, nullptr, _outShaderModule);
	return r;
}
VkResult create_shader(const VkDevice& _device, const char* _fileName, const char* _entryPoint, const VkShaderStageFlagBits& _shaderType, VkShaderModule* _outShaderModule, VkPipelineShaderStageCreateInfo* _outStageInfo)
{
	//Read Shader
	uint64_t shader_size;
	char* shader_file = nullptr;
	VkResult r = read_shader_file(_fileName, &shader_size, &shader_file);
	if (r)
		return r;

	VkShaderModule shader_module = VK_NULL_HANDLE;
	r = create_shader_module(_device, shader_size, shader_file, &shader_module);
	if (r)
		return r;

	//Setup stage info
	VkPipelineShaderStageCreateInfo create_info = {};
	create_info.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
	create_info.stage = _shaderType;
	create_info.module = shader_module;
	create_info.pName = _entryPoint;

	//Set the out
	*_outStageInfo = create_info;
	*_outShaderModule = shader_module;

	//free memory
	delete[] shader_file;

	//return result
	return r;
}

}
#endif // #endif GVULKANHELPER_HPP

 // included so it will be part of the concatenated header
#include <vector>

#define GATEWARE_VK_FAIL(vkresult, greturn) if (vkresult) return greturn;

//The core namespace to which all Gateware interfaces/structures/defines must belong.
namespace GW
{
	//The namespace to which all Gateware internal implementation must belong.
	namespace I {
		class GVulkanSurfaceImplementation :	public virtual GVulkanSurfaceInterface,
												public GEventGeneratorImplementation
			{
		public:
			//Destructor
			~GVulkanSurfaceImplementation() { CleanupVulkanSurface(); DestroyQueryVariable(); }

            //Create
			GReturn Create(SYSTEM::GWindow _gWindow, unsigned long long _initMask) {
				//Redirect Create. Mainly for convenience if using DX Surface Also.
				return Create(_gWindow, _initMask, 0, nullptr, 0, nullptr, 0, nullptr, true);
			}
		
			GReturn Create(SYSTEM::GWindow _gWindow, unsigned long long _initMask, unsigned int _instanceLayerCount, const char** _instanceLayers, 
				unsigned int _instanceExtensionCount, const char** _instanceExtensions, unsigned int _deviceExtensionCount, const char** _deviceExtensions,
				bool _allPhysicalDeviceFeatures) {
					//Error Check #1: GWindow or surface is nullptr
					if (!_gWindow)
						return GReturn::INVALID_ARGUMENT;

					//Error Check #2: Instance Layer Count and Content Mismatch (Count vs Address)
					if (_instanceLayerCount == 0 && _instanceLayers)
						return GReturn::INVALID_ARGUMENT;
					else if (_instanceLayerCount > 0 && !_instanceLayers)
						return GReturn::INVALID_ARGUMENT;

					//Error Check #2: Instance Extension Count and Content Mismatch. (Count vs Address)
					if (_instanceExtensionCount == 0 && _instanceExtensions)
						return GReturn::INVALID_ARGUMENT;
					else if (_instanceExtensionCount > 0 && !_instanceExtensions)
						return GReturn::INVALID_ARGUMENT;

					//Error Check #4: Device Extension Count and Content Mismatch (Count vs Address)
					if (_deviceExtensionCount == 0 && _deviceExtensions)
						return GReturn::INVALID_ARGUMENT;
					else if (_deviceExtensionCount > 0 && !_deviceExtensions)
						return GReturn::INVALID_ARGUMENT;

					//Error Check #5: Supported Initialization Masks
					unsigned long long allowed = GRAPHICS::DEPTH_BUFFER_SUPPORT | GRAPHICS::DEPTH_STENCIL_SUPPORT | (GRAPHICS::MSAA_64X_SUPPORT - GRAPHICS::MSAA_2X_SUPPORT) | GRAPHICS::MSAA_64X_SUPPORT  | GRAPHICS::TRIPLE_BUFFER;
					if (~allowed & _initMask)
						return GReturn::INVALID_ARGUMENT;
					m_InitMask = _initMask;

					//Set GWindow & All Device Features
					m_GWindow = _gWindow;
					m_AllPhysicalDeviceFeatures = _allPhysicalDeviceFeatures;
					m_VkQueryInfo = nullptr;

					//Initialize all Vulkan Variables
					InitVariables();

					//Set Instance Layers
					m_InstanceLayerCount = _instanceLayerCount;
					m_InstanceLayers = new const char*[m_InstanceLayerCount];
					for (uint32_t i = 0; i < _instanceLayerCount; ++i)
						m_InstanceLayers[i] = _instanceLayers[i];

					//Error Check #6: No Swapchain or Surface Support
					m_InstanceExtensionCount = _instanceExtensionCount;
					m_DeviceExtensionCount = _deviceExtensionCount;
					if (CheckCompatibility(_instanceExtensions, _deviceExtensions)) {
						CleanupVulkanSurface();
						return GReturn::HARDWARE_UNAVAILABLE;
					}
					// temporarily enable VSync so we get enough Swapchain images for all situations.
					m_VSync = true; // on some cards we Get 5 swap images when VSync is ON.
					//Initialize Vulkan Surface
					GReturn toCreate = InitVulkanSurface(); 
					if (G_FAIL(toCreate)) {
						CleanupVulkanSurface();
						return toCreate;
					}
					// disable it by default.(once intialization has completed)
					m_VSync = false;
					return GReturn::SUCCESS;
				}

			GReturn Create(SYSTEM::GWindow _gWindow, GVulkanSurfaceQueryInfo** _queryInfo) {
				//Error Check: Bad Query Info Handle
				if (!_queryInfo)
					return GReturn::INVALID_ARGUMENT;

				//Error Check: Bad GWindow Handle
				if (!_gWindow)
					return GReturn::INVALID_ARGUMENT;
					
				//Setup Creation of QueryInfo
				CreateQueryVariable();

				//Setup Variables
				m_GWindow = _gWindow;
				m_VkQueryInfo->initializationMask = 0;
				VkLayerProperties* all_layer_properties = nullptr;
				VkExtensionProperties* all_instance_extensions = nullptr;
				VkExtensionProperties* all_device_extensions = nullptr;

				//Setup Vulkan Environment for Query
				InitVariables();
				CheckInstanceVectors();
				CheckCompatibility(nullptr, nullptr);
				CreateVkInstance();
				m_VulkanHelperOS.CreateVkSurfaceKHR(m_VkInstance, m_WindowHandle, m_VkSurfaceKHR);
				FindVkPhysicalDevice();
				CheckDeviceVector();
				CreateVkDevice();

				//Instance Layer Enumeration:
				vkEnumerateInstanceLayerProperties(&(m_VkQueryInfo->instanceLayerCount), VK_NULL_HANDLE);
				if (m_VkQueryInfo->instanceLayerCount) {
					all_layer_properties = new VkLayerProperties[m_VkQueryInfo->instanceLayerCount];
					vkEnumerateInstanceLayerProperties(&(m_VkQueryInfo->instanceLayerCount), all_layer_properties);

					//Instance Layers Copy
					m_VkQueryInfo->instanceLayers = new const char* [m_VkQueryInfo->instanceLayerCount];
					for (unsigned int i = 0; i < m_VkQueryInfo->instanceLayerCount; ++i)
						m_VkQueryInfo->instanceLayers[i] = all_layer_properties[i].layerName;
				}

				//Instance Extension Enumeration:
				vkEnumerateInstanceExtensionProperties(VK_NULL_HANDLE, &m_VkQueryInfo->instanceExtensionCount, VK_NULL_HANDLE);
				if (m_VkQueryInfo->instanceExtensionCount) {
					all_instance_extensions = new VkExtensionProperties[m_VkQueryInfo->instanceExtensionCount];
					vkEnumerateInstanceExtensionProperties(VK_NULL_HANDLE, &m_VkQueryInfo->instanceExtensionCount, all_instance_extensions);

					//Instance Extension Copy
					m_VkQueryInfo->instanceExtensions = new const char* [m_VkQueryInfo->instanceExtensionCount];
					for (unsigned int i = 0; i < m_VkQueryInfo->instanceExtensionCount; ++i)
						m_VkQueryInfo->instanceExtensions[i] = all_instance_extensions[i].extensionName;
				}

				//Instance Extension Enumeration:
				vkEnumerateDeviceExtensionProperties(m_VkPhysicalDevice, VK_NULL_HANDLE, &m_VkQueryInfo->deviceExtensionCount, VK_NULL_HANDLE);
				if (m_VkQueryInfo->deviceExtensionCount) {
					all_device_extensions = new VkExtensionProperties[m_VkQueryInfo->deviceExtensionCount];
					vkEnumerateDeviceExtensionProperties(m_VkPhysicalDevice, VK_NULL_HANDLE, &m_VkQueryInfo->deviceExtensionCount, all_device_extensions);

					//Instance Extension Copy
					m_VkQueryInfo->deviceExtensions = new const char* [m_VkQueryInfo->deviceExtensionCount];
					for (unsigned int i = 0; i < m_VkQueryInfo->deviceExtensionCount; ++i)
						m_VkQueryInfo->deviceExtensions[i] = all_device_extensions[i].extensionName;
				}

				//Physical Device Features Query
				VkPhysicalDeviceFeatures* all_device_features = new VkPhysicalDeviceFeatures;
				vkGetPhysicalDeviceFeatures(m_VkPhysicalDevice, all_device_features);
				m_VkQueryInfo->physicalDeviceFeatures = all_device_features;

				//Feature Support
				VkPhysicalDeviceProperties physical_device_properties;
				vkGetPhysicalDeviceProperties(m_VkPhysicalDevice, &physical_device_properties);
				VkSampleCountFlagBits flags;
				if (physical_device_properties.limits.framebufferColorSampleCounts < physical_device_properties.limits.framebufferDepthSampleCounts)
					flags = static_cast<VkSampleCountFlagBits>(physical_device_properties.limits.framebufferColorSampleCounts);
				else {
					flags = static_cast<VkSampleCountFlagBits>(G_LARGER(
					static_cast<int32_t>(physical_device_properties.limits.framebufferColorSampleCounts),
					static_cast<int32_t>(physical_device_properties.limits.framebufferDepthSampleCounts)
				));
				}

				m_VkQueryInfo->initializationMask |= static_cast<unsigned long long>(static_cast<unsigned long long>(flags) << static_cast<int>(__log2(static_cast<float>(GRAPHICS::MSAA_2X_SUPPORT)) - 1));
				m_VkQueryInfo->initializationMask |= GRAPHICS::DEPTH_BUFFER_SUPPORT | GRAPHICS::DEPTH_STENCIL_SUPPORT | GRAPHICS::TRIPLE_BUFFER;

				//Setting up the properties [When deleted, the const char* stuff gets erased, why not send the properties too?]
				m_VkQueryInfo->instanceLayerProperties		= all_layer_properties;
				m_VkQueryInfo->instanceExtensionProperties = all_instance_extensions;
				m_VkQueryInfo->deviceExtensionProperties	= all_device_extensions;
				CleanupVulkanSurface();

				*_queryInfo = m_VkQueryInfo;
				
				//Return Success
				return GReturn::SUCCESS;
			}

            //GVulkanSurface
			GReturn GetAspectRatio(float& _outRatio) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: GWindow fails to exist
				if (!m_GWindow)
					return GReturn::FAILURE;
				
				//Give out the Aspect Ratio
				_outRatio = m_AspectRatio;

				//Return Success
				return GReturn::SUCCESS;
			}
		
            GReturn GetSwapchainImageCount(unsigned int& _outImageCount) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Give the Maximum Image Count
				_outImageCount = m_MaxFrameCount;

				//Return Success
				return GReturn::SUCCESS;
			}
		
			GReturn GetSwapchainCurrentImage(unsigned int& _outImageIndex) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Give the Current Image Index
				_outImageIndex = m_CurrentFrame;

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetGraphicsQueue(void** _outVkQueue) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Parameter is Nullptr
				if (!_outVkQueue)
					return GReturn::INVALID_ARGUMENT;

				//Give the object to the parameter
				*_outVkQueue = m_VkQueueGraphics;

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetPresentQueue(void** _outVkQueue) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Parameter is Nullptr
				if (!_outVkQueue)
					return GReturn::INVALID_ARGUMENT;

				//Give the object to the parameter
				*_outVkQueue = m_VkQueuePresent;

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetQueueFamilyIndices(unsigned int& _outGraphicsIndex, unsigned int& _outPresentIndex) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Give out the Queue Indices
				_outGraphicsIndex = static_cast<uint32_t>(m_QueueFamilyIndices[0]);
				_outPresentIndex = static_cast<uint32_t>(m_QueueFamilyIndices[1]);

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetSwapchainImage(const int& _index, void** _outVkImage) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Index is out of bounds
				if (_index < -1 || _index >= static_cast<int32_t>(m_MaxFrameCount))
					return GReturn::INVALID_ARGUMENT;
				
				//Error Check: Parameter sent is Nullptr
				if (!_outVkImage)
					return GReturn::INVALID_ARGUMENT;

				//Error Check: Swapchain or Swapchain Image doesn't exist
				if (!m_VkSwapchainKHR || !m_VkImageSwapchain[0])
					return GReturn::FAILURE;

				//If index is -1, give the current object. otherwise give based on index
				if (_index == -1)
					*_outVkImage = m_VkImageSwapchain[m_CurrentFrame];
				else
					*_outVkImage = m_VkImageSwapchain[_index];

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetSwapchainView(const int& _index, void** _outVkImageView) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Index is out of bounds
				if (_index < -1 || _index >= static_cast<int32_t>(m_MaxFrameCount))
					return GReturn::INVALID_ARGUMENT;
				
				//Error Check: Parameter sent is Nullptr
				if (!_outVkImageView)
					return GReturn::INVALID_ARGUMENT;

				//Error Check: Swapchain and Swapchain's View Exist
				if (!m_VkSwapchainKHR || !m_VkImageViewSwapchain)
					return GReturn::FAILURE;

				//If index is -1, give the current object. otherwise give based on index
				if (_index == -1)
					*_outVkImageView = m_VkImageViewSwapchain[m_CurrentFrame];
				else
					*_outVkImageView = m_VkImageViewSwapchain[_index];

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetSwapchainFramebuffer(const int& _index, void** _outVkFramebuffer) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Index is out of bounds
				if (_index < -1 || _index >= static_cast<int32_t>(m_MaxFrameCount))
					return GReturn::INVALID_ARGUMENT;
				
				//Error Check: Parameter sent is Nullptr
				if (!_outVkFramebuffer)
					return GReturn::INVALID_ARGUMENT;

				//Error Check: No Swapchain or Framebuffer
				if (!m_VkSwapchainKHR || !m_VkFramebuffer[0])
					return GReturn::FAILURE;

				//If index is -1, give the current object. otherwise give based on index
				if (_index == -1)
					*_outVkFramebuffer = m_VkFramebuffer[m_CurrentFrame];
				else
					*_outVkFramebuffer = m_VkFramebuffer[_index];

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetInstance(void** _outVkInstance) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Parameter is Nullptr
				if (!_outVkInstance)
					return GReturn::INVALID_ARGUMENT;

				//Give the object to the parameter
				*_outVkInstance = m_VkInstance;

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetSurface(void** _outVkSurfaceKHR) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Parameter is Nullptr
				if (!_outVkSurfaceKHR)
					return GReturn::INVALID_ARGUMENT;

				//Give the object to the parameter
				*_outVkSurfaceKHR = m_VkSurfaceKHR;

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetPhysicalDevice(void** _outVkPhysicalDevice) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Parameter is Nullptr
				if (!_outVkPhysicalDevice)
					return GReturn::INVALID_ARGUMENT;

				//Give the object to the parameter
				*_outVkPhysicalDevice = m_VkPhysicalDevice;

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetDevice(void** _outVkDevice) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Parameter is Nullptr
				if (!_outVkDevice)
					return GReturn::INVALID_ARGUMENT;

				//Give the object to the parameter
				*_outVkDevice = m_VkDevice;

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetCommandPool(void** _outCommandPool) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Parameter is Nullptr
				if (!_outCommandPool)
					return GReturn::INVALID_ARGUMENT;

				//Give the object to the parameter
				*_outCommandPool = m_VkCommandPool;

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetSwapchain(void** _outVkSwapchainKHR) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Parameter is Nullptr
				if (!_outVkSwapchainKHR)
					return GReturn::INVALID_ARGUMENT;

				//Give the object to the parameter
				*_outVkSwapchainKHR = m_VkSwapchainKHR;

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetRenderPass(void** _outVkRenderPass) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Parameter is Nullptr
				if (!_outVkRenderPass)
					return GReturn::INVALID_ARGUMENT;

				//Give the object to the parameter
				*_outVkRenderPass = m_VkRenderPass;

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetCommandBuffer(const int& _index, void** _outCommandBuffer) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Index is out of bounds
				if (_index < -1 || _index >= static_cast<int32_t>(m_MaxFrameCount))
					return GReturn::INVALID_ARGUMENT;
				
				//Error Check: Parameter sent is Nullptr
				if (!_outCommandBuffer)
					return GReturn::INVALID_ARGUMENT;

				//If index is -1, give the current object. otherwise give based on index
				if (_index == -1)
					*_outCommandBuffer = m_VkCommandBuffer[m_CurrentFrame];
				else
					*_outCommandBuffer = m_VkCommandBuffer[_index];

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetImageAvailableSemaphore(const int& _index, void** _outVkSemaphore) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Index is out of bounds
				if (_index < -1 || _index >= static_cast<int32_t>(m_MaxFrameCount))
					return GReturn::INVALID_ARGUMENT;
				
				//Error Check: Parameter sent is Nullptr
				if (!_outVkSemaphore)
					return GReturn::INVALID_ARGUMENT;

				//If index is -1, give the current object. otherwise give based on index
				if (_index == -1)
					*_outVkSemaphore = m_VkSemaphoreImageAvailable[m_CurrentFrame];
				else
					*_outVkSemaphore = m_VkSemaphoreImageAvailable[_index];

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetRenderFinishedSemaphore(const int& _index, void** _outVkSemaphore) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Index is out of bounds
				if (_index < -1 || _index >= static_cast<int32_t>(m_MaxFrameCount))
					return GReturn::INVALID_ARGUMENT;
				
				//Error Check: Parameter sent is Nullptr
				if (!_outVkSemaphore)
					return GReturn::INVALID_ARGUMENT;

				//If index is -1, give the current object. otherwise give based on index
				if (_index == -1)
					*_outVkSemaphore = m_VkSemaphoreRenderFinished[m_CurrentFrame];
				else
					*_outVkSemaphore = m_VkSemaphoreRenderFinished[_index];

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn GetRenderFence(const int& _index, void** _outVkFence) const override {
				//Error Check: Deallocated
				if (m_Deallocated)
					return GReturn::PREMATURE_DEALLOCATION;

				//Error Check: Index is out of bounds
				if (_index < -1 || _index >= static_cast<int32_t>(m_MaxFrameCount))
					return GReturn::INVALID_ARGUMENT;
				
				//Error Check: Parameter sent is Nullptr
				if (!_outVkFence)
					return GReturn::INVALID_ARGUMENT;

				//If index is -1, give the current object. otherwise give based on index
				if (_index == -1)
					*_outVkFence = m_VkFenceRendering[m_CurrentFrame];
				else
					*_outVkFence = m_VkFenceRendering[_index];

				//Return Success
				return GReturn::SUCCESS;
			}

			GReturn StartFrame(const unsigned int& _clearCount, void* _vkClearValues) override {
					//Error Check: Deallocated
					if (m_Deallocated)
						return GReturn::PREMATURE_DEALLOCATION;

					//Error Check: Screen is minimized
					if (m_NoDrawing)
						return GReturn::FAILURE;

					//Error Check: Clear Count Bounds (0 - 2)
					if (_clearCount > 2)
						return GReturn::INVALID_ARGUMENT;
					
					//Error Check: Have Clear Count but no Clear Color
					if (_clearCount && !_vkClearValues)
						return GReturn::INVALID_ARGUMENT;

					//Error Check: Clear Count is 0 but have a Clear Value
					if (!_clearCount && _vkClearValues)
						return GReturn::INVALID_ARGUMENT;

					//Check if Frame is locked
					if (m_FrameLocked)
						UnlockSyncWrite();

					//Lock the Thread
					LockSyncWrite();

					//Frame is now Locked
					m_FrameLocked = true;

					//Wait for Queue to be ready
					//if (m_PrevFrame != m_CurrentFrame)
					vkWaitForFences(m_VkDevice, 1, &m_VkFenceRendering[m_CurrentFrame], VK_TRUE, ~(static_cast<uint64_t>(0)));

					//Get the Frame Result
					//m_PrevFrame = m_CurrentFrame;
					//Go to the next frame
					//if (++m_CurrentFrame >= m_MaxFrameCount)
					//	m_CurrentFrame = 0; 

					VkResult frame_result = vkAcquireNextImageKHR(m_VkDevice, m_VkSwapchainKHR, 
						~(0ull), m_VkSemaphoreImageAvailable[m_CurrentFrame], VK_NULL_HANDLE, &m_TargetImage);
					
					//Error Check: VkResult is NOT Successful (1: Swapchain Bad, 2: Unknown)
					if (frame_result == VK_ERROR_OUT_OF_DATE_KHR) {
						//Fix the Swapchain
						GReturn g = ResetSwapchain();

						//Unlock Thread
						UnlockSyncWrite();

						//Set Frame Unlocked
						m_FrameLocked = false;

						//Notify Observers a new swapchain was created
						EVENT_DATA edata = { frame_result, {m_VkExtent2DSurface.width, m_VkExtent2DSurface.height} };
						GEvent e;
						e.Write(Events::REBUILD_PIPELINE, edata);
						Push(e);

						//Return Failure [Pipelines must be reset right after this!]
						return G_PASS(g) ? GReturn::FAILURE : GReturn::UNEXPECTED_RESULT;
					}
					else if (frame_result && frame_result != VK_SUBOPTIMAL_KHR) {
						//Unlock Thread
						UnlockSyncWrite();

						//Set Frame Unlocked
						m_FrameLocked = false;

						//Please refer to your Validation Layer for more info.
						return GReturn::FAILURE;
					}
					//Create the Command Buffer's Begin Info
					VkCommandBufferBeginInfo command_buffer_begin_info = {};
					command_buffer_begin_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
					command_buffer_begin_info.flags = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT;
					command_buffer_begin_info.pInheritanceInfo = nullptr;
					vkBeginCommandBuffer(m_VkCommandBuffer[m_CurrentFrame], &command_buffer_begin_info);

					//Setup Clear Color
					VkClearValue clear_value[2];
					uint32_t clear_value_count = _clearCount; 
					if (!clear_value_count) {
						clear_value[0].color = {{ 0.0f, 0.0f, 0.0f, 1.0f }}; ++clear_value_count;
						if (m_InitMask & GRAPHICS::DEPTH_BUFFER_SUPPORT) {
							clear_value[1].depthStencil = { 1.0f, 16777216 }; ++clear_value_count;
						}
					}
					else {
						VkClearValue* paramClearValue = reinterpret_cast<VkClearValue*>(_vkClearValues);
						clear_value[0] = paramClearValue[0];
						if (clear_value_count == 2 && m_InitMask & GRAPHICS::DEPTH_BUFFER_SUPPORT)
							clear_value[1] = paramClearValue[1];
					}

					//Setup the Render Pass
					VkRenderPassBeginInfo render_pass_begin_info = {};
					render_pass_begin_info.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
					render_pass_begin_info.renderPass = m_VkRenderPass;
					render_pass_begin_info.framebuffer = m_VkFramebuffer[m_CurrentFrame];
					render_pass_begin_info.renderArea.extent = {m_VkExtent2DSurface.width, m_VkExtent2DSurface.height};
					render_pass_begin_info.clearValueCount = clear_value_count;
					render_pass_begin_info.pClearValues = clear_value;

					//Begin the Render Pass
					vkCmdBeginRenderPass(m_VkCommandBuffer[m_CurrentFrame], &render_pass_begin_info, VK_SUBPASS_CONTENTS_INLINE);

					//Return Success
					return GReturn::SUCCESS;
				}

			GReturn EndFrame(const bool& _vSync) override {
					//Error Check: GWindow Deallocated
					if (m_Deallocated) {
						//Check if Frame is Locked. If so Unlock it.
						if (m_FrameLocked) {
							UnlockSyncWrite();
							m_FrameLocked = false;
						}

						//Return Premature Deallocation
						return GReturn::PREMATURE_DEALLOCATION;
					}

					//Error Check: Window is not drawable
					if (m_NoDrawing) {
						//Check if Frame is Locked. If so Unlock it.
						if (m_FrameLocked) {
							UnlockSyncWrite();
							m_FrameLocked = false;
						}

						//Return Failure
						return GReturn::FAILURE;
					}

					//Error Check: Start Frame has not started! (It is supposed to be locked to prevent Swapchain from being rebuilt in between draws)
					if (!m_FrameLocked)
						return GReturn::FAILURE;

					//Stop the Render Pass
					vkCmdEndRenderPass(m_VkCommandBuffer[m_CurrentFrame]);
					vkEndCommandBuffer(m_VkCommandBuffer[m_CurrentFrame]);

					//Setup the Semaphores and Command Buffer to be sent into Queue Submit
					VkSemaphore wait_semaphores[] = { m_VkSemaphoreImageAvailable[m_CurrentFrame] };
					VkPipelineStageFlags wait_stages[] = { VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT };
					VkSemaphore signal_semaphore[] = { m_VkSemaphoreRenderFinished[m_CurrentFrame] };
					VkCommandBuffer pCommandBuffer[] = { m_VkCommandBuffer[m_CurrentFrame] };
					
					//Setup the Queue Submit Info
					VkSubmitInfo submit_info = {};
					submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
					submit_info.waitSemaphoreCount = 1;
					submit_info.pWaitSemaphores = wait_semaphores;
					submit_info.pWaitDstStageMask = wait_stages;
					submit_info.commandBufferCount = 1;
					submit_info.pCommandBuffers = pCommandBuffer;
					submit_info.signalSemaphoreCount = 1;
					submit_info.pSignalSemaphores = signal_semaphore;

					//Reset the Fence
					vkResetFences(m_VkDevice, 1, &m_VkFenceRendering[m_CurrentFrame]);

					//Submit Queue <--Something to come back to.
					VkResult r;
					r = vkQueueSubmit(m_VkQueueGraphics, 1, &submit_info, m_VkFenceRendering[m_CurrentFrame]);
					if (r) {
						//Unlock the Thread
						UnlockSyncWrite();

						//Set Frame to Unlock
						m_FrameLocked = false;

						//Please refer to your Validation Layer for more info before reporting.
						return GReturn::FAILURE;
					}

					//Setup the Present Info
					VkSwapchainKHR swapchains[] = { m_VkSwapchainKHR };
					VkPresentInfoKHR present_info = {};
					present_info.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
					present_info.waitSemaphoreCount = 1;
					present_info.pWaitSemaphores = signal_semaphore;
					present_info.swapchainCount = 1;
					present_info.pSwapchains = swapchains;
					present_info.pImageIndices = &m_TargetImage;//&m_CurrentFrame;
					present_info.pResults = nullptr;

					//Present onto the surface
					VkResult frame_result = vkQueuePresentKHR(m_VkQueuePresent, &present_info);

					//Error Check for Swapchain and VSync Changes
					if (frame_result == VK_ERROR_OUT_OF_DATE_KHR || frame_result == VK_SUBOPTIMAL_KHR || _vSync != m_VSync) {
						//Set VSync and its property.
						m_VSync = _vSync;
						
						//Clear the Swapchain
						GReturn g = ResetSwapchain();

						//Unlock Thread
						UnlockSyncWrite();

						//Set Frame to Unlock
						m_FrameLocked = false;

						//Notify Observers a new swapchain was created
						EVENT_DATA edata = { frame_result, {m_VkExtent2DSurface.width, m_VkExtent2DSurface.height} };
						GEvent e;
						e.Write(Events::REBUILD_PIPELINE, edata);
						Push(e);

						//Return Failure [Pipelines must be reset right after this!]
						return G_PASS(g) ? GReturn::FAILURE : GReturn::UNEXPECTED_RESULT;
					}
					else if (frame_result) {
						//Unlock Thread
						UnlockSyncWrite();

						//Set Frame to Unlock
						m_FrameLocked = false;

						//Please refer to your Validation Layer for more info.
						return GReturn::FAILURE;
					}

					//Go to the next frame
					if (++m_CurrentFrame >= m_MaxFrameCount)
						m_CurrentFrame = 0; 

					//Set Start Frame to false
					m_FrameLocked = false;

					//Unlock Thread
					UnlockSyncWrite();

					//Return Success
					return GReturn::SUCCESS;
			}

            //GEventResponderInterface
			GReturn Assign(std::function<void()> _newHandler) override { 
				return m_Deallocated ? GReturn::PREMATURE_DEALLOCATION : m_EventResponder.Assign(_newHandler); 
			}
			GReturn Assign(std::function<void(const GEvent&)> _newEventHandler) override { 
				return m_Deallocated ? GReturn::PREMATURE_DEALLOCATION : m_EventResponder.Assign(_newEventHandler); 
			}
			GReturn Invoke() const override { 
				return m_Deallocated ? GReturn::PREMATURE_DEALLOCATION : m_EventResponder.Invoke(); 
			}
			GReturn Invoke(const GEvent& _incomingEvent) const override { 
				return m_Deallocated ? GReturn::PREMATURE_DEALLOCATION : m_EventResponder.Invoke(_incomingEvent); 
			}
		private:
			//Init & Create Methods
			GReturn InitVulkanSurface() {
				//Error Check: Instance Layers & Extensions [Invalid Argument]
				GATEWARE_VK_FAIL(CheckInstanceVectors(), GReturn::INVALID_ARGUMENT);

				//Setup #1: VkInstance [ Failure: {Unknown: Need to Investigate} ]
				GATEWARE_VK_FAIL(CreateVkInstance(), GReturn::HARDWARE_UNAVAILABLE);

				//Setup #2: VkSurfaceKHR [ Failure: {Unknown: Need to Investigate} ]
				GATEWARE_VK_FAIL(m_VulkanHelperOS.CreateVkSurfaceKHR(m_VkInstance, m_WindowHandle, m_VkSurfaceKHR), GReturn::HARDWARE_UNAVAILABLE);

				//Setup #3: VkPhysicalDevice [ Feature Unsupported: MSAA Unsupported, Failure: {Unknown: Need to Investigate} ]
				VkResult r = FindVkPhysicalDevice(); 
				if (r == VK_ERROR_FORMAT_NOT_SUPPORTED) return GReturn::FEATURE_UNSUPPORTED;
				else if (r) return GReturn::FAILURE;

				//Error Check: Device Extension [Invalid Argument]
				GATEWARE_VK_FAIL(CheckDeviceVector(), GReturn::INVALID_ARGUMENT);

				//Setup #4: VkDevice [ Failure: {Unknown: Need to Investigate} ]
				GATEWARE_VK_FAIL(CreateVkDevice(), GReturn::HARDWARE_UNAVAILABLE);

				//Setup #5: VkCommandPool [ Failure: {Unknown: Need to Investigate} ]
				GATEWARE_VK_FAIL(CreateVkCommandPool(), GReturn::FAILURE);

				//Setup #6: Swapchain Properties [ Failure: {Unknown: Need to Investigate} ]
				GATEWARE_VK_FAIL(GetSurfaceData(), GReturn::FAILURE);

				//Setup #7: Swapchain [ Failure: {Unknown: Need to Investigate} ]
				GATEWARE_VK_FAIL(-CreateSwapchain(), GReturn::FAILURE);

				//Setup #8: Semaphores and Fences [ Failure: {Unknown: Need to Investigate} ]
				GATEWARE_VK_FAIL(CreateSyncObjects(), GReturn::FAILURE);

				//All Done!
				return GReturn::SUCCESS;
			}

			GReturn InitVariables() {
				//Basic GWindow Setup
				m_GWindow.GetWindowHandle(m_WindowHandle);
				m_GWindow.GetX(m_WindowTopLeft.width);
				m_GWindow.GetY(m_WindowTopLeft.height);
				m_GWindow.GetClientWidth(m_WindowExtent.width);
				m_GWindow.GetClientHeight(m_WindowExtent.height);
				m_WindowName = m_VulkanHelperOS.GetPlatformWindowName(m_WindowHandle);
				m_AspectRatio = m_WindowExtent.width / static_cast<float>(m_WindowExtent.height);
				m_Deallocated = false;
				m_NoDrawing = false;

				//Main Vulkan Objects Setup
				m_VkInstance = {};
				m_VkSurfaceKHR = {};
				m_VkPhysicalDevice = {};
				m_VkDevice = {};
				m_VkCommandPool = {};
				m_VkSwapchainKHR = {};

				//Feature-Based Images
				m_GVkImageMSAA = {};
				m_GVkImageDepth = {};
				m_VSync = false;
				m_MSAAOn = false;

				//Frame-Based Vulkan Objects & Properties
				m_MaxFrameCount = 0;
				m_CurrentFrame = 0;
				memset(m_VkImageSwapchain, 0, sizeof(VkImage) * GVK_SWAP_BUFFER_LIMIT); 
				memset(m_VkImageViewSwapchain, 0, sizeof(VkImageView) * GVK_SWAP_BUFFER_LIMIT); 
				memset(m_VkFramebuffer, 0, sizeof(VkFramebuffer) * GVK_SWAP_BUFFER_LIMIT); 
				memset(m_VkCommandBuffer, 0, sizeof(VkCommandBuffer) * GVK_SWAP_BUFFER_LIMIT); 
				memset(m_VkSemaphoreImageAvailable, 0, sizeof(VkSemaphore) * GVK_SWAP_BUFFER_LIMIT); 
				memset(m_VkSemaphoreRenderFinished, 0, sizeof(VkSemaphore) * GVK_SWAP_BUFFER_LIMIT); 
				memset(m_VkFenceRendering, 0, sizeof(VkFence) * GVK_SWAP_BUFFER_LIMIT); 

				//Vulkan Properties Setup
				m_QueueFamilyIndices[0] = -1;
				m_QueueFamilyIndices[1] = -1;
				m_CanCompute = VK_FALSE;
				m_MSAA = VK_SAMPLE_COUNT_1_BIT;
				m_VkQueueGraphics = {};
				m_VkQueuePresent = {};
				m_VkSurfaceCapabilitiesKHR = {};
				m_VkPresentModeKHRSurface = {};
				m_VkExtent2DSurface = {};
				m_VkFormatSurface = {};
				m_VkFormatDepth = {};
				m_VkRenderPass = {};
				m_FrameLocked = false;

				//Helper Method Setup  
				m_AllInstanceLayerCount = 0;
				m_AllInstanceExtensionCount = 0;
				m_AllDeviceExtensionCount = 0;
				m_AllSurfaceFormatCount = 0;
				m_AllPresentModeCount = 0;
				m_AllPhysicalDevices = nullptr;			m_AllPhysicalDeviceCount = 0;
				m_AllQueueFamilyProperties = nullptr;	m_AllQueueFamilyPropertyCount = 0;

				//Event Setup
				m_EventResponder.Create([&](const GW::GEvent& event) {
					GW::SYSTEM::GWindow::Events windowEvent;
					GW::SYSTEM::GWindow::EVENT_DATA windowEventData;
					if(+event.Read(windowEvent, windowEventData))
                    {
                        switch (windowEvent) {
                            case GW::SYSTEM::GWindow::Events::MINIMIZE: {
                                m_NoDrawing = true;
                            } break;
                            case GW::SYSTEM::GWindow::Events::DESTROY: {
                                //Notify Observers its time to release any Vulkan resources
                                GEvent shutdown;
                                EVENT_DATA sdata = { // wasn't actually lost but its about to be
                                    VK_ERROR_SURFACE_LOST_KHR, { m_VkExtent2DSurface.width, m_VkExtent2DSurface.height }
                                };
                                shutdown.Write(Events::RELEASE_RESOURCES, sdata);
                                Push(shutdown);
                                //Cleanup the whole surface
                                m_VulkanHelperOS.PlatformDestroyGVulkanSurface([&](){CleanupVulkanSurface();});
                            } break;
                            case GW::SYSTEM::GWindow::Events::DISPLAY_CLOSED: {
                                //Cleanup Instance
                                if (m_VkInstance) {
                                    vkDestroyInstance(m_VkInstance, VK_NULL_HANDLE);
                                    m_VkInstance = VK_NULL_HANDLE;
                                }
                            } break;
                            case GW::SYSTEM::GWindow::Events::MAXIMIZE:
                            case GW::SYSTEM::GWindow::Events::RESIZE: {
                                if (windowEventData.width < 1 || windowEventData.height < 1)
                                    m_NoDrawing = true;
                                else {
                                    //Lock the Thread
                                    LockSyncWrite();

                                    //Reset the Swapchain
                                    GReturn g = ResetSwapchain();

                                    //Unlock The Thread
                                    UnlockSyncWrite();

                                    if (G_PASS(g))
                                    {
                                        //Notify Observers a new swapchain was created
                                        EVENT_DATA edata = { VK_ERROR_OUT_OF_DATE_KHR, {m_VkExtent2DSurface.width, m_VkExtent2DSurface.height} };
                                        GEvent e;
                                        e.Write(Events::REBUILD_PIPELINE, edata);
                                        g = Push(e);

                                        //Reset Minimization
                                        m_NoDrawing = false;
                                    }
                                }
                            } break;
                            case GW::SYSTEM::GWindow::Events::MOVE: {
                                //Set Window TopLeft
                                m_GWindow.GetClientTopLeft(m_WindowTopLeft.width, m_WindowTopLeft.height);
                            } break;
                            default:
                                break;
                        }
                    }
				});
				return m_GWindow.Register(m_EventResponder);
			}

			VkResult CreateVkInstance() {
				//Application Information (Will come back to this for Gateware Version. Maybe used for RenderDoc)
				VkApplicationInfo app_info = {};
				app_info.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
				app_info.apiVersion = VK_API_VERSION_1_1;
				app_info.pApplicationName = m_WindowName;
				app_info.applicationVersion = 1;
				app_info.pEngineName = "Gateware";
				app_info.engineVersion = VK_MAKE_VERSION(GATEWARE_MAJOR, GATEWARE_MINOR, GATEWARE_PATCH);
				app_info.pNext = nullptr;

				//Application Create Info [Basics]
				VkInstanceCreateInfo create_info = {};
				create_info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
				create_info.pApplicationInfo = &app_info;

				//Extensions
				create_info.enabledExtensionCount = m_InstanceExtensionCount;
				create_info.ppEnabledExtensionNames = m_InstanceExtensions;
				create_info.enabledLayerCount = m_InstanceLayerCount;
				create_info.ppEnabledLayerNames = m_InstanceLayers;

				VkResult r = vkCreateInstance(&create_info, nullptr, &m_VkInstance);
				return r;
			}

			VkResult FindVkPhysicalDevice() {
				//Get all GPUs
				VkResult r = GetAllPhysicalDevices();
				if (r) return VK_ERROR_INITIALIZATION_FAILED;

				//Pick Best GPU
				r = GetBestGPU();

				//Get Family Queue
				r = GetQueueFamilyIndices();
				if (r) return VK_ERROR_FEATURE_NOT_PRESENT;

				//Get MSAA
				unsigned long long msaa_init = m_InitMask & ((GRAPHICS::MSAA_64X_SUPPORT - GRAPHICS::MSAA_2X_SUPPORT) | GRAPHICS::MSAA_64X_SUPPORT);
				if (msaa_init) {
					//Turn on MSAA support
					m_MSAAOn = true;

					//Set the flag to the proper one (-1 since i skip MSAA_1X_SUPPORT, since thats default)
					m_MSAA = static_cast<VkSampleCountFlagBits>( msaa_init >> static_cast<int>(__log2(static_cast<float>(GRAPHICS::MSAA_2X_SUPPORT)) - 1) );

					//Find Support
					VkPhysicalDeviceProperties physical_device_properties;
					vkGetPhysicalDeviceProperties(m_VkPhysicalDevice, &physical_device_properties);

					//Set a flag based on the minimum
					VkSampleCountFlagBits flags;
					if (m_InitMask & GRAPHICS::DEPTH_BUFFER_SUPPORT) {
						flags = static_cast<VkSampleCountFlagBits>(G_SMALLER(
						static_cast<int32_t>(physical_device_properties.limits.framebufferColorSampleCounts),
						static_cast<int32_t>(physical_device_properties.limits.framebufferDepthSampleCounts)
						));
					}
					else
						flags = static_cast<VkSampleCountFlagBits>(physical_device_properties.limits.framebufferColorSampleCounts);

					//Return if bad
					if (m_MSAA & ~(flags)) return VK_ERROR_FORMAT_NOT_SUPPORTED;
				}
				
				//Cleanup
				return r;
			}

			VkResult CreateVkDevice() {
				//Setup Unique Queue Family
				uint32_t qf_createsize = 0;					
				if (m_QueueFamilyIndices[0] ^ m_QueueFamilyIndices[1])
					qf_createsize = 2;						
				else										
					qf_createsize = 1;						
				VkDeviceQueueCreateInfo* queue_create_info_array = new VkDeviceQueueCreateInfo[qf_createsize];

				//Set up Create Info for all unique queue families
				float priority = 1.0f;
				for (uint32_t i = 0; i < qf_createsize; ++i) {
					VkDeviceQueueCreateInfo create_info = {};

					create_info.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
					create_info.queueFamilyIndex = m_QueueFamilyIndices[i];
					create_info.queueCount = 1;
					create_info.pQueuePriorities = &priority;
					queue_create_info_array[i] = create_info;
				}

				//Get all available device features
				VkPhysicalDeviceFeatures all_device_features;
				vkGetPhysicalDeviceFeatures(m_VkPhysicalDevice, &all_device_features);

				//Set the needed (or all) device features
				VkPhysicalDeviceFeatures device_features = {};
				if (m_AllPhysicalDeviceFeatures)
					device_features = all_device_features;
				else {
					if (all_device_features.tessellationShader)	device_features.tessellationShader = VK_TRUE;
					if (all_device_features.geometryShader)		device_features.geometryShader = VK_TRUE;
					if (all_device_features.fillModeNonSolid)	device_features.fillModeNonSolid = VK_TRUE;
					if (m_MSAAOn) {
						if (all_device_features.samplerAnisotropy)	device_features.samplerAnisotropy = VK_TRUE; //MSAA
						if (all_device_features.sampleRateShading)	device_features.sampleRateShading = VK_TRUE; //MSAA
					}
				}
				
				//Setup Logical device create info [*: Two different Queue Indices Check Needed]
				VkDeviceCreateInfo create_info = {};
				create_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
				create_info.pQueueCreateInfos = queue_create_info_array;
				create_info.queueCreateInfoCount = qf_createsize;
				create_info.pEnabledFeatures = &device_features;

				create_info.enabledExtensionCount = m_DeviceExtensionCount;
				create_info.ppEnabledExtensionNames = m_DeviceExtensions;

				//Create the Surface (With Results) [VK_SUCCESS = 0]
				VkResult r = vkCreateDevice(m_VkPhysicalDevice, &create_info, nullptr, &m_VkDevice);

				//If Device has been created, Setup the Device Queue for graphics and present family
				vkGetDeviceQueue(m_VkDevice, m_QueueFamilyIndices[0], 0, &m_VkQueueGraphics);
				vkGetDeviceQueue(m_VkDevice, m_QueueFamilyIndices[1], 0, &m_VkQueuePresent);

				//Device has been created successfully!
				delete[] queue_create_info_array;
				return r;
			}

			VkResult CreateVkCommandPool() {
				//Command Pool's Create Info
				VkCommandPoolCreateInfo create_info = {};
				create_info.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
				create_info.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
				create_info.queueFamilyIndex = m_QueueFamilyIndices[0];

				VkResult r = vkCreateCommandPool(m_VkDevice, &create_info, nullptr, &m_VkCommandPool);
				return r;
			}

			VkResult GetSurfaceData() {
				//Gather The Surface Capabilities
				VkResult r = vkGetPhysicalDeviceSurfaceCapabilitiesKHR(m_VkPhysicalDevice, m_VkSurfaceKHR, &m_VkSurfaceCapabilitiesKHR);
				if (r) return r;

				//Get the best Surface Format
				if (m_VkFormatSurface.format == VK_FORMAT_UNDEFINED) {
					r = GetSurfaceFormat();
					if (r) return r;
				}

				//Get the best present mode
				r = GetSurfacePresentMode();
				if (r) return r;

				//Get the surface extent
				r = GetSurfaceExtent();
				if (r) return r;

				if ( (m_InitMask & GRAPHICS::DEPTH_BUFFER_SUPPORT) && m_VkFormatDepth == VK_FORMAT_UNDEFINED)
					r = GetDepthFormat();

				return r;
			}

			GReturn CreateSwapchain() {
				//Create The Swapchain
				GATEWARE_VK_FAIL(CreateVkSwapchainKHR(), GReturn::FAILURE);

				//Create the RenderPass
				GATEWARE_VK_FAIL(CreateVkRenderPass(), GReturn::FAILURE);

				//Create the MSAA Buffer (If Needed)
				if (m_MSAAOn) GATEWARE_VK_FAIL(CreateMSAABuffer(), GReturn::FAILURE);

				//Create the Depth Buffer (If Needed)
				if (m_InitMask & GRAPHICS::DEPTH_BUFFER_SUPPORT) GATEWARE_VK_FAIL(CreateDepthBuffer(), GReturn::FAILURE);

				//Create the Framebuffer
				GATEWARE_VK_FAIL(CreateVkFramebuffer(), GReturn::FAILURE);

				//Create the Command Buffer
				GATEWARE_VK_FAIL(CreateVkCommandBuffer(), GReturn::FAILURE);

				return GReturn::SUCCESS;
			}

			VkResult CreateSyncObjects() {
				//Semaphore Info Create
				VkSemaphoreCreateInfo semaphore_create_info = {};
				semaphore_create_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;

				//Fence Info Create
				VkFenceCreateInfo fence_create_info = {};
				fence_create_info.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
				fence_create_info.flags = VK_FENCE_CREATE_SIGNALED_BIT;

				//Create the Semaphores and Fences
				VkResult r{};
				for (unsigned int i = 0; i < m_MaxFrameCount; ++i) {
					r = vkCreateSemaphore(m_VkDevice, &semaphore_create_info, nullptr, &m_VkSemaphoreImageAvailable[i]);
					if (r) {
						return r;
					}
					r = vkCreateSemaphore(m_VkDevice, &semaphore_create_info, nullptr, &m_VkSemaphoreRenderFinished[i]);
					if (r) {
						return r;
					}
					r = vkCreateFence(m_VkDevice, &fence_create_info, nullptr, &m_VkFenceRendering[i]);
					if (r) {
						return r;
					}
				}

				//Semaphores and Fences has been created successfully!
				return r;
			}

			//Create Methods for Swapchain
			VkResult CreateVkSwapchainKHR() {
				//Gather Swapchain Count
				unsigned int newFrameCount = (m_InitMask & GRAPHICS::TRIPLE_BUFFER) ? 3u : 2u;
				if (m_VkSurfaceCapabilitiesKHR.minImageCount > 0 && newFrameCount < m_VkSurfaceCapabilitiesKHR.minImageCount)
					newFrameCount = m_VkSurfaceCapabilitiesKHR.minImageCount;
				if (m_VkSurfaceCapabilitiesKHR.maxImageCount > 0 && newFrameCount > m_VkSurfaceCapabilitiesKHR.maxImageCount)
					newFrameCount = m_VkSurfaceCapabilitiesKHR.maxImageCount;
					
				//Create Info for SwapchainKHR [Part 1]
				VkSwapchainCreateInfoKHR create_info = {};
				create_info.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
				create_info.surface = m_VkSurfaceKHR;
				create_info.minImageCount = newFrameCount;
				create_info.imageFormat = m_VkFormatSurface.format;
				create_info.imageColorSpace = m_VkFormatSurface.colorSpace;
				create_info.imageExtent = m_VkExtent2DSurface;
				create_info.imageArrayLayers = 1;
				create_info.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT;
				create_info.preTransform = m_VkSurfaceCapabilitiesKHR.currentTransform;
				create_info.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
				create_info.presentMode = m_VkPresentModeKHRSurface;
				create_info.clipped = VK_TRUE;
				create_info.oldSwapchain = m_VkSwapchainKHR; // supposed to help/optimize transitions

				//Setup Correct Queue Family Indices
				if (m_QueueFamilyIndices[0] ^ m_QueueFamilyIndices[1]) {
					create_info.queueFamilyIndexCount = 2;
					create_info.pQueueFamilyIndices = reinterpret_cast<uint32_t*>(&m_QueueFamilyIndices[0]);
					create_info.imageSharingMode = VK_SHARING_MODE_CONCURRENT;
				}
				else {
					create_info.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;
				}

				//Create Swapchain
				VkSwapchainKHR newSwapchain = nullptr;
				VkResult r = vkCreateSwapchainKHR(m_VkDevice, &create_info, nullptr, &newSwapchain);
				if (r >= 0) // on success free the old swapchain and replace with the new one
				{
					//Destroy old Swapchain & sync
					CleanupSwapchain();
					CleanupSyncObjects();
					m_VkSwapchainKHR = newSwapchain;
				}

				//Swapchain Image Setup
				unsigned required_images = 0; 
				r = vkGetSwapchainImagesKHR(m_VkDevice, m_VkSwapchainKHR, &required_images, VK_NULL_HANDLE);
				// possible we may get more Images than requested and we must handle it
				if (required_images > GVK_SWAP_BUFFER_LIMIT)
					return VkResult::VK_ERROR_INITIALIZATION_FAILED;
				if (required_images != m_MaxFrameCount)
					m_MaxFrameCount = required_images; // we must cycle all buffers required
				// **IMPORTANT** Currently the amount of "in-flight" frames is linked to the requested/provided number of images 
				// provided by the swap chain based on our selected modes. However, it is possible to limit this below that number.
				r = vkGetSwapchainImagesKHR(m_VkDevice, m_VkSwapchainKHR, &m_MaxFrameCount, m_VkImageSwapchain);

				//Obtain the Image and Image Views
				for (uint32_t i = 0; i < m_MaxFrameCount; ++i)
					r = CreateImageView(m_VkImageSwapchain[i], m_VkFormatSurface.format, VK_IMAGE_ASPECT_COLOR_BIT, &m_VkImageViewSwapchain[i]);

				//Set Current Frame to 0
				m_CurrentFrame = 0;
				m_TargetImage = 0;
		
				return r;
			}

			VkResult CreateVkRenderPass() {
				//Preliminary Setup
				uint32_t count = 0;
				VkAttachmentDescription* attachments = new VkAttachmentDescription[3];

				//Primary Swapchain Description and Swapchain
				VkAttachmentDescription color_attachment_description = {};
				color_attachment_description.format = m_VkFormatSurface.format;
				color_attachment_description.samples = m_MSAA;
				color_attachment_description.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
				color_attachment_description.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
				color_attachment_description.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
				color_attachment_description.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
				color_attachment_description.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
				color_attachment_description.finalLayout = (m_MSAAOn) ? VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL : VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;

				VkAttachmentReference color_attachment_reference = {};
				color_attachment_reference.attachment = count;
				color_attachment_reference.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

				attachments[count++] = color_attachment_description;

				//Depth Swapchain Attachment & Reference
				VkAttachmentDescription depth_attachment_description = {};
				VkAttachmentReference depth_attachment_reference = {};
				if (m_InitMask & GRAPHICS::DEPTH_BUFFER_SUPPORT) {
					depth_attachment_description.format = m_VkFormatDepth;
					depth_attachment_description.samples = m_MSAA;
					depth_attachment_description.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
					depth_attachment_description.storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
					depth_attachment_description.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
					depth_attachment_description.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
					depth_attachment_description.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
					depth_attachment_description.finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;

					depth_attachment_reference.attachment = count;
					depth_attachment_reference.layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;

					attachments[count++] = depth_attachment_description;
				}

				//Backup Swapchain Attachment & Reference (Need it for MSAA)
				VkAttachmentDescription color_attachment_resolve = {};
				VkAttachmentReference color_attachment_resolve_reference = {};
				if (m_MSAAOn) {
					color_attachment_resolve.format = m_VkFormatSurface.format;
					color_attachment_resolve.samples = VK_SAMPLE_COUNT_1_BIT;
					color_attachment_resolve.loadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
					color_attachment_resolve.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
					color_attachment_resolve.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
					color_attachment_resolve.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
					color_attachment_resolve.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
					color_attachment_resolve.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;

					color_attachment_resolve_reference.attachment = count;
					color_attachment_resolve_reference.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

					attachments[count++] = color_attachment_resolve;
				}

				//Setup the Subpass and Dependency
				VkSubpassDescription subpass_description = {};
				subpass_description.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
				subpass_description.colorAttachmentCount = 1;
				subpass_description.pColorAttachments = &color_attachment_reference;
				subpass_description.pDepthStencilAttachment = (m_InitMask & GRAPHICS::DEPTH_BUFFER_SUPPORT) ? &depth_attachment_reference : nullptr;
				subpass_description.pResolveAttachments = (m_MSAAOn) ? &color_attachment_resolve_reference : nullptr;

				VkSubpassDependency subpass_dependency = {};
				subpass_dependency.srcSubpass = VK_SUBPASS_EXTERNAL;
				subpass_dependency.dstSubpass = 0;
				subpass_dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
				subpass_dependency.srcAccessMask = 0;
				subpass_dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
				subpass_dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;

				//Setup and Create the RenderPass
				VkRenderPassCreateInfo render_pass_create_info = {};
				render_pass_create_info.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
				render_pass_create_info.attachmentCount = count;
				render_pass_create_info.pAttachments = attachments;
				render_pass_create_info.subpassCount = 1;
				render_pass_create_info.pSubpasses = &subpass_description;
				render_pass_create_info.dependencyCount = 1;
				render_pass_create_info.pDependencies = &subpass_dependency;

				VkResult r = vkCreateRenderPass(m_VkDevice, &render_pass_create_info, nullptr, &m_VkRenderPass);

				delete[] attachments;
				return r;
			}

			VkResult CreateMSAABuffer() {
				//Create the image and image view for MSAA
				VkResult r = CreateImage(m_VkFormatSurface.format, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, &m_GVkImageMSAA.image, &m_GVkImageMSAA.memory);
				if (r) {
					if (m_GVkImageMSAA.memory)
						vkFreeMemory(m_VkDevice, m_GVkImageMSAA.memory, VK_NULL_HANDLE);
					if (m_GVkImageMSAA.image)
						vkDestroyImage(m_VkDevice, m_GVkImageMSAA.image, VK_NULL_HANDLE);
					return r;
				}

				r = CreateImageView(m_GVkImageMSAA.image, m_VkFormatSurface.format, VK_IMAGE_ASPECT_COLOR_BIT, &m_GVkImageMSAA.view);
				if (r) {
					if (m_GVkImageMSAA.memory)
						vkFreeMemory(m_VkDevice, m_GVkImageMSAA.memory, VK_NULL_HANDLE);
					if (m_GVkImageMSAA.view)
						vkDestroyImageView(m_VkDevice, m_GVkImageMSAA.view, VK_NULL_HANDLE);
					if (m_GVkImageMSAA.image)
						vkDestroyImage(m_VkDevice, m_GVkImageMSAA.image, VK_NULL_HANDLE);
					return r;
				}

				//Transition the image layout from Undefined to Color Attachment (Optimal)
				r = TransitionImageLayout(m_GVkImageMSAA.image, m_VkFormatSurface.format, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL);
				return r;
			}

			VkResult CreateDepthBuffer() {
				//Create the image and image view for Depth Buffer
				VkResult r = CreateImage(m_VkFormatDepth, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, &m_GVkImageDepth.image, &m_GVkImageDepth.memory);

				if (r) {
					if (m_GVkImageDepth.image)
						vkDestroyImage(m_VkDevice, m_GVkImageDepth.image, VK_NULL_HANDLE);
					if (m_GVkImageDepth.memory)
						vkFreeMemory(m_VkDevice, m_GVkImageDepth.memory, VK_NULL_HANDLE);

					m_GVkImageDepth.image = VK_NULL_HANDLE;
					m_GVkImageDepth.memory = VK_NULL_HANDLE;
					return r;
				}

				r = CreateImageView(m_GVkImageDepth.image, m_VkFormatDepth, VK_IMAGE_ASPECT_DEPTH_BIT, &m_GVkImageDepth.view);
				if (r) {
					if (m_GVkImageDepth.view)
						vkDestroyImageView(m_VkDevice, m_GVkImageDepth.view, VK_NULL_HANDLE);
					if (m_GVkImageDepth.image)
						vkDestroyImage(m_VkDevice, m_GVkImageDepth.image, VK_NULL_HANDLE);
					if (m_GVkImageDepth.memory)
						vkFreeMemory(m_VkDevice, m_GVkImageDepth.memory, VK_NULL_HANDLE);

					m_GVkImageDepth.view = VK_NULL_HANDLE;
					m_GVkImageDepth.image = VK_NULL_HANDLE;
					return r;
				}

				//Transition the image layout from Undefined to Color Attachment (Optimal)
				r = TransitionImageLayout(m_GVkImageDepth.image, m_VkFormatDepth, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL);

				return r;
			}
		
			VkResult CreateVkFramebuffer() {
				//Setup Variables
				VkResult r{};
				uint32_t count = 0;
				VkImageView image_attachments[GVK_SWAP_BUFFER_LIMIT];

				//Loop through the Swapchain Frame Buffers and set their create info
				for (unsigned int i = 0; i < m_MaxFrameCount; ++i) {
					// Create an array of image attachments for create info (NOTE: There is only 1 Color Image View and Depth Buffer!)
					count = 0;
					if (m_MSAAOn) {
						image_attachments[count++] = m_GVkImageMSAA.view;
						if (m_InitMask & GRAPHICS::DEPTH_BUFFER_SUPPORT)
							image_attachments[count++] = m_GVkImageDepth.view;
						image_attachments[count++] = m_VkImageViewSwapchain[i];
					}
					else {
						image_attachments[count++] = m_VkImageViewSwapchain[i];
						if (m_InitMask & GRAPHICS::DEPTH_BUFFER_SUPPORT)
							image_attachments[count++] = m_GVkImageDepth.view;
					}

					//Frame Buffer's Create Info
					VkFramebufferCreateInfo frame_buffer_create_info = {};
					frame_buffer_create_info.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
					frame_buffer_create_info.renderPass = m_VkRenderPass;
					frame_buffer_create_info.attachmentCount = count;
					frame_buffer_create_info.pAttachments = image_attachments;
					frame_buffer_create_info.width = m_VkExtent2DSurface.width;
					frame_buffer_create_info.height = m_VkExtent2DSurface.height;
					frame_buffer_create_info.layers = 1;

					//Create the Surface (With Results) [VK_SUCCESS = 0]
					r = vkCreateFramebuffer(m_VkDevice, &frame_buffer_create_info, nullptr, &m_VkFramebuffer[i]);
				}

				//delete[] image_attachments;
				return r;
			}

			VkResult CreateVkCommandBuffer() {
				//Allocate Command buffer Information
				VkCommandBufferAllocateInfo command_buffer_allocate_info = {};
				command_buffer_allocate_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
				command_buffer_allocate_info.commandPool = m_VkCommandPool;
				command_buffer_allocate_info.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
				command_buffer_allocate_info.commandBufferCount = m_MaxFrameCount;

				//Create Command Buffer
				VkResult r = vkAllocateCommandBuffers(m_VkDevice, &command_buffer_allocate_info, &m_VkCommandBuffer[0]);

				//Return Result
				return r;
			}

			//Cleanup & Error Check Methods
			GReturn ResetSwapchain() {
				//if (m_VkDevice == nullptr)
                //    return GReturn::FAILURE;
                
                //Wait for Device to finish
				vkDeviceWaitIdle(m_VkDevice);

				//Update Swapchain Surface Data
				m_GWindow.GetClientWidth(m_WindowExtent.width);
				m_GWindow.GetClientHeight(m_WindowExtent.height);
				m_AspectRatio = m_WindowExtent.width / static_cast<float>(m_WindowExtent.height);
				GetSurfaceData();

				//Recreate Swapchain
				return (+CreateSwapchain() && CreateSyncObjects() == VK_SUCCESS)
					? GReturn::SUCCESS : GReturn::UNEXPECTED_RESULT; //How would this fail if it was created before......
			}

			void CleanupSwapchain() {
				//Cleanup Command Buffers
				if (m_VkCommandBuffer[0]) {
					vkFreeCommandBuffers(m_VkDevice, m_VkCommandPool, m_MaxFrameCount, &m_VkCommandBuffer[0]);
					for (uint32_t i = 0; i < GVK_SWAP_BUFFER_LIMIT; ++i)
						m_VkCommandBuffer[i] = VK_NULL_HANDLE;
				}

				//Cleanup Frame Buffers
				for (uint32_t i = 0; i < GVK_SWAP_BUFFER_LIMIT; ++i) {
					if (m_VkFramebuffer[i]) {
						vkDestroyFramebuffer(m_VkDevice, m_VkFramebuffer[i], VK_NULL_HANDLE);
					}
					m_VkFramebuffer[i] = VK_NULL_HANDLE;
				}

				//Cleanup Depth Buffer
				if (m_GVkImageDepth.image) {
					vkDestroyImageView(m_VkDevice, m_GVkImageDepth.view, VK_NULL_HANDLE);
					vkDestroyImage(m_VkDevice, m_GVkImageDepth.image, VK_NULL_HANDLE);
					vkFreeMemory(m_VkDevice, m_GVkImageDepth.memory, VK_NULL_HANDLE);
					m_GVkImageDepth = {};
				}

				//Cleanup MSAA Image
				if (m_GVkImageMSAA.image) {
					vkDestroyImageView(m_VkDevice, m_GVkImageMSAA.view, VK_NULL_HANDLE);
					vkDestroyImage(m_VkDevice, m_GVkImageMSAA.image, VK_NULL_HANDLE);
					vkFreeMemory(m_VkDevice, m_GVkImageMSAA.memory, VK_NULL_HANDLE);
					m_GVkImageMSAA = {};
				}

				//Cleanup Render Pass
				if (m_VkRenderPass) {
					vkDestroyRenderPass(m_VkDevice, m_VkRenderPass, VK_NULL_HANDLE);
					m_VkRenderPass = VK_NULL_HANDLE;
				}

				//Cleanup Swapchain's Image View
				for (uint32_t i = 0; i < GVK_SWAP_BUFFER_LIMIT; ++i) {
					if (m_VkImageViewSwapchain[i]) {
						vkDestroyImageView(m_VkDevice, m_VkImageViewSwapchain[i], VK_NULL_HANDLE);
					}
					m_VkImageViewSwapchain[i] = VK_NULL_HANDLE;
				}

				//Cleanup Swapchain
				if (m_VkSwapchainKHR) {
					vkDestroySwapchainKHR(m_VkDevice, m_VkSwapchainKHR, VK_NULL_HANDLE);
					m_VkSwapchainKHR = VK_NULL_HANDLE;
				}
			}
			
			void CleanupSyncObjects() {
				//Cleanup Fence (Rendering)
				for (uint32_t i = 0; i < GVK_SWAP_BUFFER_LIMIT; ++i) {
					if (m_VkFenceRendering[i]) {
						vkWaitForFences(m_VkDevice, 1, &m_VkFenceRendering[i], VK_TRUE, ~(static_cast<uint64_t>(0)));
						vkDestroyFence(m_VkDevice, m_VkFenceRendering[i], VK_NULL_HANDLE);
					}
					m_VkFenceRendering[i] = VK_NULL_HANDLE;
				}

				//Cleanup Semaphore (Render Finished)
				for (uint32_t i = 0; i < GVK_SWAP_BUFFER_LIMIT; ++i) {
					if (m_VkSemaphoreRenderFinished[i]) {
						vkDestroySemaphore(m_VkDevice, m_VkSemaphoreRenderFinished[i], VK_NULL_HANDLE);
					}
					m_VkSemaphoreRenderFinished[i] = VK_NULL_HANDLE;
				}

				//Cleanup Semaphore (Image Available)
				for (uint32_t i = 0; i < GVK_SWAP_BUFFER_LIMIT; ++i) {
					if (m_VkSemaphoreImageAvailable[i]) {
						vkDestroySemaphore(m_VkDevice, m_VkSemaphoreImageAvailable[i], VK_NULL_HANDLE);
					}
					m_VkSemaphoreImageAvailable[i] = VK_NULL_HANDLE;
				}
			}

			void CleanupVulkanSurface() {
				//Wait for Device to finish
				if (m_VkDevice)
					vkDeviceWaitIdle(m_VkDevice);

				//Cleanup Sync primitives
				CleanupSyncObjects();

				//Cleanup Swapchain
				CleanupSwapchain();

				//Cleanup Command Pool
				if (m_VkCommandPool) {
					vkDestroyCommandPool(m_VkDevice, m_VkCommandPool, VK_NULL_HANDLE);
					m_VkCommandPool = VK_NULL_HANDLE;
				}

				//Cleanup Device
				if (m_VkDevice) {
					vkDestroyDevice(m_VkDevice, VK_NULL_HANDLE);
					m_VkDevice = VK_NULL_HANDLE;
				}

				//Cleanup Surface
				if (m_VkSurfaceKHR) {
					vkDestroySurfaceKHR(m_VkInstance, m_VkSurfaceKHR, VK_NULL_HANDLE);
					m_VkSurfaceKHR = VK_NULL_HANDLE;
				}

				//Other Allocated Memory 
				if (m_WindowName) {
					delete[] m_WindowName;
					m_WindowName = nullptr;
				}

				if (m_AllPhysicalDevices)		{ delete[] m_AllPhysicalDevices; m_AllPhysicalDevices = nullptr;}
				if (m_AllQueueFamilyProperties) { delete[] m_AllQueueFamilyProperties; m_AllQueueFamilyProperties = nullptr; }
				if (m_DeviceExtensions)			{ delete[] m_DeviceExtensions; m_DeviceExtensions = nullptr; }
				if (m_InstanceExtensions)		{ delete[] m_InstanceExtensions; m_InstanceExtensions = nullptr; }
				if (m_InstanceLayers)			{ delete[] m_InstanceLayers; m_InstanceLayers = nullptr; }

				m_Deallocated = true;
			}

			VkResult CheckCompatibility(const char** _instanceExtensions, const char** _deviceExtensions) {
				//Setup Variables for checks
				const char* use_surface = VK_KHR_SURFACE_EXTENSION_NAME;
				const char* use_swapchain = VK_KHR_SWAPCHAIN_EXTENSION_NAME;
				const char* platform_surface = m_VulkanHelperOS.GetPlatformSurfaceExtension();
                const char* platform_device = m_VulkanHelperOS.GetPlatformDeviceExtension();

				//Check for Compatibility
				if (CheckInstanceExtensionName(use_surface))
					return VK_ERROR_EXTENSION_NOT_PRESENT;
				if (CheckInstanceExtensionName(platform_surface))
					return VK_ERROR_EXTENSION_NOT_PRESENT;
                // device level compatibility is not checked here since the
                // vkPhysical device has not been selected yet.
                // this code may be rearranged and reworked as it seems brittle.

				//Check if the extensions are already in the extensions
				uint32_t gotExtFlag = 15; //Flag Magic Numbers: 1 = Vulkan surface, 2 = platform surface, 4 = swapchain, 8 = platform device
				for (uint32_t i = 0; i < m_InstanceExtensionCount; ++i) {
					if (!strcmp(_instanceExtensions[i], use_surface))
						gotExtFlag &= ~(1u);
					if (!strcmp(_instanceExtensions[i], platform_surface))
						gotExtFlag &= ~(2u);
				}

				//And in Device Extension
                for (uint32_t i = 0; i < m_DeviceExtensionCount; ++i) {
					if (!strcmp(_deviceExtensions[i], use_swapchain))
						gotExtFlag &= ~(4u);
					if (platform_device && // providing a platform device extension is optional
                        !strcmp(_deviceExtensions[i], platform_device))
                        gotExtFlag &= ~(8u);
                }

				//Find the true number you need:
				uint32_t instExtAdded = 0;
				if (gotExtFlag & 1) ++instExtAdded;
				if (gotExtFlag & 2) ++instExtAdded;
                uint32_t devExtAdded = 0;
                if (gotExtFlag & 4) ++devExtAdded;
                if (gotExtFlag & 8) ++devExtAdded;

				//Create the new arrays for the extensions
				m_InstanceExtensions = new const char* [static_cast<size_t>(m_InstanceExtensionCount) + instExtAdded];
				m_DeviceExtensions = new const char* [static_cast<size_t>(m_DeviceExtensionCount) + devExtAdded];
				for (uint32_t i = 0; i < m_InstanceExtensionCount; ++i)
					m_InstanceExtensions[i] = _instanceExtensions[i];
				for (uint32_t i = 0; i < m_DeviceExtensionCount; ++i)
					m_DeviceExtensions[i] = _deviceExtensions[i];

				//Add in the adds if needed
				if (gotExtFlag & 2) {
					m_InstanceExtensions[m_InstanceExtensionCount + instExtAdded - 1] = platform_surface;
					--instExtAdded;
				}

				if (gotExtFlag & 1) {
					m_InstanceExtensions[m_InstanceExtensionCount + instExtAdded - 1] = use_surface;
					--instExtAdded;
				}

				if (gotExtFlag & 4) {
					m_DeviceExtensions[m_DeviceExtensionCount] = use_swapchain;
					++m_DeviceExtensionCount;
				}
				// providing a platform device extension is optional
                if (platform_device && gotExtFlag & 8) {
                    m_DeviceExtensions[m_DeviceExtensionCount] = platform_device;
                    ++m_DeviceExtensionCount;
                }
                
				//Add up the instance extension (since there was more than 1)
				if (gotExtFlag & 1) ++m_InstanceExtensionCount;
				if (gotExtFlag & 2) ++m_InstanceExtensionCount;

				//Return Successful
				return VK_SUCCESS;
			}

			VkResult CheckInstanceVectors() {
				for (uint32_t i = 0; i < m_InstanceLayerCount; ++i)
					if (CheckInstanceLayerName(m_InstanceLayers[i]))
						return VK_ERROR_LAYER_NOT_PRESENT;
				for (uint32_t i = 0; i < m_InstanceExtensionCount; ++i)
					if (CheckInstanceExtensionName(m_InstanceExtensions[i]))
						return VK_ERROR_EXTENSION_NOT_PRESENT;

				return VK_SUCCESS;
			}

			VkResult CheckDeviceVector() {
				for (uint32_t i = 0; i < m_DeviceExtensionCount; ++i)
					if (CheckDeviceExtensionName(m_DeviceExtensions[i]))
						return VK_ERROR_EXTENSION_NOT_PRESENT;

				return VK_SUCCESS;
			}

			//Error Checking Helper Methods & Variables
			std::vector<VkLayerProperties> m_AllInstanceLayers;			uint32_t m_AllInstanceLayerCount = 0;
			std::vector<VkExtensionProperties> m_AllInstanceExtensions;	uint32_t m_AllInstanceExtensionCount = 0;
			std::vector<VkExtensionProperties>	m_AllDeviceExtensions;	uint32_t m_AllDeviceExtensionCount = 0;
			VkResult CheckInstanceLayerName(const char* _layer) {
				//Check to see if this was already created
				if (m_AllInstanceLayers.empty()) {
					//Get the Size
					VkResult r = vkEnumerateInstanceLayerProperties(&m_AllInstanceLayerCount, VK_NULL_HANDLE);
					if (m_AllInstanceLayerCount < 1) { return VK_ERROR_FEATURE_NOT_PRESENT; }
					if (r) return r;

					//Resize Vector and Put the contents in it.
					m_AllInstanceLayers.resize(m_AllInstanceLayerCount);
					r = vkEnumerateInstanceLayerProperties(&m_AllInstanceLayerCount, m_AllInstanceLayers.data());
					if (r) return r;
				}

				//Compare all instance layers with the parameter
				for (int i = 0; i < m_AllInstanceLayers.size(); i++)
					if (!strcmp(m_AllInstanceLayers[i].layerName, _layer))
						return VK_SUCCESS;

				return VK_ERROR_LAYER_NOT_PRESENT;
			}

			VkResult CheckInstanceExtensionName(const char* _extensions) {
				//Check to see if this was already created
				if (m_AllInstanceExtensions.empty()) {
					//Get the Size
					VkResult r = vkEnumerateInstanceExtensionProperties(nullptr, &m_AllInstanceExtensionCount, VK_NULL_HANDLE);
					if (m_AllInstanceExtensionCount < 1) { return VK_ERROR_FEATURE_NOT_PRESENT; }
					if (r) return r;

					//Resize Vector and Put the contents in it.
					m_AllInstanceExtensions.resize(m_AllInstanceExtensionCount);
					r = vkEnumerateInstanceExtensionProperties(nullptr, &m_AllInstanceExtensionCount, m_AllInstanceExtensions.data());
					if (r) return r;
				}

				//Compare all instance extensions with the parameter
				for (int i = 0; i < m_AllInstanceExtensions.size(); ++i)
					if (!strcmp(m_AllInstanceExtensions[i].extensionName, _extensions))
						return VK_SUCCESS;

				return VK_ERROR_EXTENSION_NOT_PRESENT;
			}

			VkResult CheckDeviceExtensionName(const char* _extensions) {
				//Check to see if this was already created
				if (m_AllDeviceExtensions.empty()) {
					//Get the Size
					VkResult r = vkEnumerateDeviceExtensionProperties(m_VkPhysicalDevice, nullptr, &m_AllDeviceExtensionCount, VK_NULL_HANDLE);
					if (m_AllDeviceExtensionCount < 1) { return VK_ERROR_FEATURE_NOT_PRESENT; }
					if (r) return r;

					//Resize Vector and Put the contents in it.
					m_AllDeviceExtensions.resize(m_AllDeviceExtensionCount);
					r = vkEnumerateDeviceExtensionProperties(m_VkPhysicalDevice, nullptr, &m_AllDeviceExtensionCount, m_AllDeviceExtensions.data());
					if (r) return r;
				}

				//Compare all device extensions with the parameter
				for (int i = 0; i < m_AllDeviceExtensions.size(); ++i)
					if (!strcmp(m_AllDeviceExtensions[i].extensionName, _extensions))
						return VK_SUCCESS;

				return VK_ERROR_EXTENSION_NOT_PRESENT;
			}

			//Gathering Helper Methods
			VkPhysicalDevice* m_AllPhysicalDevices = nullptr;				uint32_t m_AllPhysicalDeviceCount = 0;
			VkQueueFamilyProperties* m_AllQueueFamilyProperties = nullptr;	uint32_t m_AllQueueFamilyPropertyCount = 0;
			VkResult GetAllPhysicalDevices() {
				//Check to see if this was already created
				if (!m_AllPhysicalDevices) {
					//Get the Size
					VkResult r = vkEnumeratePhysicalDevices(m_VkInstance, &m_AllPhysicalDeviceCount, VK_NULL_HANDLE);
					if (m_AllPhysicalDeviceCount < 1) { return VK_ERROR_FEATURE_NOT_PRESENT; }
					if (r) return r;

					//Resize Vector and Put the contents in it.
					m_AllPhysicalDevices = new VkPhysicalDevice[m_AllPhysicalDeviceCount];
					r = vkEnumeratePhysicalDevices(m_VkInstance, &m_AllPhysicalDeviceCount, m_AllPhysicalDevices);
					if (r) return r;
				}

				//Return Success
				return VK_SUCCESS;
			}
		
			VkResult GetBestGPU() {
				/* What will determine the best GPU:
				* 1.) Compatibility [DQ] {Swapchain, Queue Family, Device Extensions}
				* 2.) Device Type [^N] (Dedicated, Virtual, Integrated, Other, CPU)
				* 3.) Added Memory [x(N/1024)]
				* 4.) Features [+N * size]
				*/

				//Of course, don't do this if there is only 1 device......
				if (m_AllPhysicalDeviceCount == 1) {
					m_VkPhysicalDevice = m_AllPhysicalDevices[0];
					return VK_SUCCESS;
				}

				//Setup
				uint32_t gpuPow = 0;
				uint64_t gpuMult = 1;
				uint32_t gpuAdd = 0;

				uint64_t BestIndex = 0;
				uint64_t BestScore = 0;

				//Loop through each of the Physical Devices
				for (size_t i = 0; i < m_AllPhysicalDeviceCount; ++i) {
					//Setup: Set Physical Device as if this is the chosen device
					m_VkPhysicalDevice = m_AllPhysicalDevices[i];

					//Compatibility Setup: Device Extension Check: (PS: Swapchain support should be here at this point)
					bool _reset = false;
					for (uint32_t j = 0; j < m_DeviceExtensionCount; ++j)
						if (CheckDeviceExtensionName(m_DeviceExtensions[j])) {
							_reset = true;
							break;
						}
					if (_reset) continue;

					//Compatibility Setup: Queue Family Indices
					m_QueueFamilyIndices[0] = m_QueueFamilyIndices[1] = -1;
					if (m_AllQueueFamilyProperties) {
						delete[] m_AllQueueFamilyProperties;
						m_AllQueueFamilyProperties = nullptr;
						m_AllQueueFamilyPropertyCount = 0;
					}
					VkResult r = GetQueueFamilyIndices();
					if (r) continue;

					//Device Type: Best Type [Discrete, Virtual, Integrated, CPU/OTHER] in order
					VkPhysicalDeviceProperties pDevProps;
					vkGetPhysicalDeviceProperties(m_VkPhysicalDevice, &pDevProps);
					switch (pDevProps.deviceType) {
						case VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU:
							gpuPow = 3;
							break;
						case VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU:
							gpuPow = 2;
							break;
						default:
							gpuPow = 1;
							break;
					}

					//Physical Device Memory
					VkPhysicalDeviceMemoryProperties mem_prop = {};
					vkGetPhysicalDeviceMemoryProperties(m_VkPhysicalDevice, &mem_prop);
					for (uint32_t j = 0; j < mem_prop.memoryHeapCount; ++j)
						if (mem_prop.memoryHeaps[j].flags & VkMemoryHeapFlagBits::VK_MEMORY_HEAP_DEVICE_LOCAL_BIT)
						{
							gpuMult = mem_prop.memoryHeaps[j].size / 0x40000000;
							break;
						}

					//Lastly: Features
					VkPhysicalDeviceFeatures device_feature;
					vkGetPhysicalDeviceFeatures(m_VkPhysicalDevice, &device_feature);
					int32_t pDevFeatSize = sizeof(VkPhysicalDeviceFeatures);
					const VkBool32 IMTRUE = VK_TRUE;
					while (pDevFeatSize > -1) {
						pDevFeatSize -= sizeof(VkBool32);
						if (!memcmp(reinterpret_cast<char*>(&device_feature) + pDevFeatSize, &IMTRUE, sizeof(VkBool32)))
							gpuAdd += 100;
					}

					//Tally up Score:
					uint64_t score = 0;
					score += gpuAdd;
					score *= gpuMult;
					uint64_t cScore = score;
					for (uint32_t j = 0; j < gpuPow; ++j) score *= cScore;

					//Check Best Score
					if (score > BestScore) {
						BestIndex = i;
						BestScore = score;
					}
				}
				m_VkPhysicalDevice = m_AllPhysicalDevices[BestIndex];


				return VK_SUCCESS;
			}

			VkResult GetQueueFamilyIndices() {
				//Check to see if this was already created
				if (!m_AllQueueFamilyProperties) {
					vkGetPhysicalDeviceQueueFamilyProperties(m_VkPhysicalDevice, &m_AllQueueFamilyPropertyCount, VK_NULL_HANDLE);
					if (m_AllQueueFamilyPropertyCount < 1) { return VK_ERROR_FEATURE_NOT_PRESENT; }

					//Resize Vector and Put the contents in it.
					m_AllQueueFamilyProperties = new VkQueueFamilyProperties[m_AllQueueFamilyPropertyCount];
					vkGetPhysicalDeviceQueueFamilyProperties(m_VkPhysicalDevice, &m_AllQueueFamilyPropertyCount, m_AllQueueFamilyProperties);
				}

				//Setup Variable Usage
				VkBool32 presentSupport = VK_FALSE;
				VkResult r = VK_SUCCESS;

				//Loop through each Queue Properties and find a queue that works together. [WITH COMPUTER SHADER]
				for (uint32_t i = 0; i < m_AllQueueFamilyPropertyCount; ++i) {
					//Set current Queue property
					VkQueueFamilyProperties* cur = &m_AllQueueFamilyProperties[i];

					//Check to see if flags meet
					if (cur->queueCount && (cur->queueFlags & (VK_QUEUE_GRAPHICS_BIT | VK_QUEUE_COMPUTE_BIT))) {
						//Figure out if surface can present with queue index
						r = vkGetPhysicalDeviceSurfaceSupportKHR(m_VkPhysicalDevice, i, m_VkSurfaceKHR, &presentSupport);
						if (r) continue;

						//If found, set the indices
						if (presentSupport) {
							m_QueueFamilyIndices[0] = m_QueueFamilyIndices[1] = i;
							m_CanCompute = VK_TRUE;
							return r;
						}
					}
				}

				//Loop through each Queue Properties and find a queue that works together. [WITHOUT COMPUTER SHADER]
				for (uint32_t i = 0; i < m_AllQueueFamilyPropertyCount; ++i) {
					//Set current Queue property
					VkQueueFamilyProperties* cur = &m_AllQueueFamilyProperties[i];

					//Check to see if flags meet
					if (cur->queueCount && (cur->queueFlags & VK_QUEUE_GRAPHICS_BIT)) {
						//Figure out if surface can present with queue index
						r = vkGetPhysicalDeviceSurfaceSupportKHR(m_VkPhysicalDevice, i, m_VkSurfaceKHR, &presentSupport);
						if (r) continue;

						//If found, set the indices
						if (presentSupport) {
							m_QueueFamilyIndices[0] = m_QueueFamilyIndices[1] = i;
							m_CanCompute = VK_FALSE;
							return r;
						}
					}
				}

				//Couldn't find anything.
				m_QueueFamilyIndices[0] = m_QueueFamilyIndices[1] = -1;
				return VK_ERROR_FEATURE_NOT_PRESENT;
			}

			//Gathering Surface Data
			std::vector<VkSurfaceFormatKHR> m_AllSurfaceFormats;	uint32_t m_AllSurfaceFormatCount = 0;
			std::vector<VkPresentModeKHR> m_AllPresentModes;		uint32_t m_AllPresentModeCount = 0;
			VkResult GetSurfaceFormat() {
				if (m_AllSurfaceFormats.empty()) {
					//Gather all the surface formats
					VkResult r = vkGetPhysicalDeviceSurfaceFormatsKHR(m_VkPhysicalDevice, m_VkSurfaceKHR, &m_AllSurfaceFormatCount, VK_NULL_HANDLE);
					if (m_AllSurfaceFormatCount < 1) return VK_ERROR_FEATURE_NOT_PRESENT;
					if (r) return r;

					//Resize and fill in surface formats
					m_AllSurfaceFormats.resize(m_AllSurfaceFormatCount);
					r = vkGetPhysicalDeviceSurfaceFormatsKHR(m_VkPhysicalDevice, m_VkSurfaceKHR, &m_AllSurfaceFormatCount, m_AllSurfaceFormats.data());
					if (r) return r;
				}

				//If Format is undefined, set it to best automatically
				if (m_AllSurfaceFormatCount == 1 && m_AllSurfaceFormats[0].format == VK_FORMAT_UNDEFINED) {
					m_VkFormatSurface = { VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR };
					return VK_SUCCESS;
				}

				//Find the best
				for (int i = 0; i < m_AllSurfaceFormats.size(); ++i)
					if (m_AllSurfaceFormats[i].format == VK_FORMAT_B8G8R8A8_UNORM && m_AllSurfaceFormats[i].colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {
						m_VkFormatSurface = { VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR };
						return VK_SUCCESS;
					}

				//Best wasn't found, take [0]
				m_VkFormatSurface = m_AllSurfaceFormats[0];
				return VK_SUCCESS;
			}

			VkResult GetSurfacePresentMode() {
				//Check to see if this was already created
				if (m_AllPresentModes.empty()) {
					//Get the Size
					VkResult r = vkGetPhysicalDeviceSurfacePresentModesKHR(m_VkPhysicalDevice, m_VkSurfaceKHR, &m_AllPresentModeCount, VK_NULL_HANDLE);
					if (m_AllPresentModeCount < 1) { return VK_ERROR_FEATURE_NOT_PRESENT; }
					if (r) return r;

					//Resize Vector and Put the contents in it.
					m_AllPresentModes.resize(m_AllPresentModeCount);
					r = vkGetPhysicalDeviceSurfacePresentModesKHR(m_VkPhysicalDevice, m_VkSurfaceKHR, &m_AllPresentModeCount, m_AllPresentModes.data());
					if (r) return r;
				}

				//Find the best mode (best: Mailbox, runner-up: Immediate, Default: FIFO)
				VkPresentModeKHR VSyncModes[2] = { VK_PRESENT_MODE_IMMEDIATE_KHR , VK_PRESENT_MODE_MAILBOX_KHR };
				VkPresentModeKHR best_mode = VK_PRESENT_MODE_FIFO_KHR;//	//This is best by default. It is because Vulkan requires this to be supported, and not any of others.
				for (uint32_t i = 0; i < m_AllPresentModeCount; ++i) {	//So if any of these fail (Mailbox, Immediate, Shared), FIFO is guaranteed to work!
					if (m_AllPresentModes[i] == VSyncModes[m_VSync]) {
						best_mode = VSyncModes[m_VSync];
						m_VkPresentModeKHRSurface = best_mode;
						break;
					}
					else if (m_AllPresentModes[i] == VSyncModes[!m_VSync])
						m_VkPresentModeKHRSurface = VSyncModes[!m_VSync];
				}

				return VK_SUCCESS;
			}

			VkResult GetSurfaceExtent() {
				//Gather all surface capabilities
				VkSurfaceCapabilitiesKHR surface_capabilities;
				VkResult r = vkGetPhysicalDeviceSurfaceCapabilitiesKHR(m_VkPhysicalDevice, m_VkSurfaceKHR, &surface_capabilities);
				if (r) return r;

				//If Capabilities's extent is not MAX, Set to those extents
				if (surface_capabilities.currentExtent.width != 0xFFFFFFFF)
					m_VkExtent2DSurface = { surface_capabilities.currentExtent.width, surface_capabilities.currentExtent.height };
				else //Otherwise set it to window's width and height.
					m_VkExtent2DSurface = { m_WindowExtent.width, m_WindowExtent.height };

				return r;
			}

			VkResult GetDepthFormat() {
				//Setup Depth Format
				VkFormat depth_formats[3];

				//Order Formats
				if (m_InitMask & GRAPHICS::DEPTH_STENCIL_SUPPORT) {
					depth_formats[0] = VK_FORMAT_D32_SFLOAT_S8_UINT;
					depth_formats[1] = VK_FORMAT_D24_UNORM_S8_UINT;
					depth_formats[2] = VK_FORMAT_D32_SFLOAT;
				}
				else {
					depth_formats[0] = VK_FORMAT_D32_SFLOAT;
					depth_formats[1] = VK_FORMAT_D32_SFLOAT_S8_UINT;
					depth_formats[2] = VK_FORMAT_D24_UNORM_S8_UINT;
				}

				//Find the best compatible format for Depth
				for (uint32_t i = 0; i < 3; ++i) {
					VkFormatProperties format_properties;
					vkGetPhysicalDeviceFormatProperties(m_VkPhysicalDevice, depth_formats[i], &format_properties);

					if ( (format_properties.linearTilingFeatures & VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT) == VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT) {
						m_VkFormatDepth = depth_formats[i];
						return VK_SUCCESS;
					}
					else if ((format_properties.optimalTilingFeatures & VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT) == VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT) {
						m_VkFormatDepth = depth_formats[i];
						return VK_SUCCESS;
					}
				}

				//Format not found, set to [0]
				m_VkFormatDepth = depth_formats[0];
				return VK_SUCCESS;
			}

			//Image Creation Helper Methods
			VkResult CreateImage(const VkFormat& _format, const VkImageTiling& _tiling, const VkImageUsageFlags& _usageFlags, const VkMemoryPropertyFlags& _memoryPropertyFlags, VkImage* _outImage, VkDeviceMemory* _outImageMemory) {
				//Create image info
				VkImageCreateInfo create_info = {};
				create_info.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
				create_info.imageType = VK_IMAGE_TYPE_2D;
				create_info.extent = { m_VkExtent2DSurface.width, m_VkExtent2DSurface.height, 1 };
				create_info.mipLevels = 1;
				create_info.arrayLayers = 1;
				create_info.format = _format;
				create_info.tiling = _tiling;
				create_info.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
				create_info.usage = _usageFlags;
				create_info.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
				create_info.samples = m_MSAA;
				create_info.flags = 0;

				//Create the image
				VkResult r = vkCreateImage(m_VkDevice, &create_info, VK_NULL_HANDLE, _outImage);
				if (r) return r;

				//Gather Memory Information from image & Physical Device
				VkMemoryRequirements memory_requirements;
				vkGetImageMemoryRequirements(m_VkDevice, *_outImage, &memory_requirements);
				VkPhysicalDeviceMemoryProperties memory_properties;
				vkGetPhysicalDeviceMemoryProperties(m_VkPhysicalDevice, &memory_properties);

				//Loop through the memory type count and see if there is a match with both the filter and property flags
				int32_t memory_type_index = -1;
				for (uint32_t i = 0; i < memory_properties.memoryTypeCount; ++i) {
					if ((memory_requirements.memoryTypeBits & (1 << i)) &&
						(memory_properties.memoryTypes[i].propertyFlags & _memoryPropertyFlags) == _memoryPropertyFlags) {
						memory_type_index = i;
						break;
					}
				}
				if (memory_type_index == -1)
					return VK_ERROR_NOT_PERMITTED_EXT;


				//Memory Allocate Info
				VkMemoryAllocateInfo memory_allocate_info = {};
				memory_allocate_info.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
				memory_allocate_info.allocationSize = memory_requirements.size;
				memory_allocate_info.memoryTypeIndex = memory_type_index;

				//Allocate the memory created
				r = vkAllocateMemory(m_VkDevice, &memory_allocate_info, VK_NULL_HANDLE, _outImageMemory);
				if (r) {
					vkDestroyImage(m_VkDevice, *_outImage, VK_NULL_HANDLE);
					return r;
				}

				//Bind the memory created
				r = vkBindImageMemory(m_VkDevice, *_outImage, *_outImageMemory, 0);
				if (r) {
					vkDestroyImage(m_VkDevice, *_outImage, VK_NULL_HANDLE);
					vkFreeMemory(m_VkDevice, *_outImageMemory, VK_NULL_HANDLE);
					return r;
				}

				//Image Creation has been successful!
				return r;
			}

			VkResult CreateImageView(const VkImage& _image, const VkFormat& _format, const VkImageAspectFlags& _imageAspectFlags, VkImageView* _outImageView) {
				//Image View Create Info
				VkImageViewCreateInfo create_info = {};
				create_info.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
				create_info.image = _image;
				create_info.viewType = VK_IMAGE_VIEW_TYPE_2D;
				create_info.format = _format;
				create_info.subresourceRange.aspectMask = _imageAspectFlags;
				create_info.subresourceRange.baseMipLevel = 0;
				create_info.subresourceRange.levelCount = 1;
				create_info.subresourceRange.baseArrayLayer = 0;
				create_info.subresourceRange.layerCount = 1;

				//Create the Surface (With Results) [VK_SUCCESS = 0]
				VkResult r = vkCreateImageView(m_VkDevice, &create_info, nullptr, _outImageView);

				//Image View has been created successfully, return it
				return r;
			}

			VkResult TransitionImageLayout(const VkImage& _image, const VkFormat& _format, const VkImageLayout& _previousLayout, const VkImageLayout& _currentLayout) {
				//Setup the Command Buffer's Allocation Information
				VkCommandBufferAllocateInfo command_buffer_allocate_info = {};
				command_buffer_allocate_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
				command_buffer_allocate_info.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
				command_buffer_allocate_info.commandPool = m_VkCommandPool;
				command_buffer_allocate_info.commandBufferCount = 1;

				//Allocate the Command Buffer
				VkCommandBuffer command_buffer = VK_NULL_HANDLE;
				VkResult r = vkAllocateCommandBuffers(m_VkDevice, &command_buffer_allocate_info, &command_buffer);
				if (r) return r;

				//Start the command buffer's begin info
				VkCommandBufferBeginInfo command_buffer_begin_info = {};
				command_buffer_begin_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
				command_buffer_begin_info.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;

				//Begin the Command Buffer's recording process
				r = vkBeginCommandBuffer(command_buffer, &command_buffer_begin_info);
				if (r) return r;

				//Create the image memory barrier
				VkImageMemoryBarrier image_memory_barrier = {};
				image_memory_barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
				image_memory_barrier.image = _image;
				image_memory_barrier.oldLayout = _previousLayout;
				image_memory_barrier.newLayout = _currentLayout;
				image_memory_barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
				image_memory_barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
				image_memory_barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
				image_memory_barrier.subresourceRange.baseMipLevel = 0;
				image_memory_barrier.subresourceRange.levelCount = 1;
				image_memory_barrier.subresourceRange.layerCount = 1;
				image_memory_barrier.subresourceRange.baseArrayLayer = 0;

				//Setup the source and destination stage flags. Will be set based on the Old and New Layout set from outside
				VkPipelineStageFlags source_stage = 0;
				VkPipelineStageFlags destrination_stage = 0;

				if (_currentLayout == VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL)
				{
					image_memory_barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT;
					if (_format == VK_FORMAT_D24_UNORM_S8_UINT || _format == VK_FORMAT_D32_SFLOAT_S8_UINT)
						image_memory_barrier.subresourceRange.aspectMask |= VK_IMAGE_ASPECT_STENCIL_BIT;
				}

				if (_previousLayout == VK_IMAGE_LAYOUT_UNDEFINED)
				{
					if (_currentLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL)
					{
						image_memory_barrier.srcAccessMask = 0;
						image_memory_barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;

						source_stage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
						destrination_stage = VK_PIPELINE_STAGE_TRANSFER_BIT;
					}
					else if (_currentLayout == VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL)
					{
						image_memory_barrier.srcAccessMask = 0;
						image_memory_barrier.dstAccessMask = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;

						source_stage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
						destrination_stage = VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;
					}
					else if (_currentLayout == VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL)
					{
						image_memory_barrier.srcAccessMask = 0;
						image_memory_barrier.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;

						source_stage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
						destrination_stage = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
					}
				}
				else if (_previousLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL && _currentLayout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL)
				{
					image_memory_barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
					image_memory_barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

					source_stage = VK_PIPELINE_STAGE_TRANSFER_BIT;
					destrination_stage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
				}

				vkCmdPipelineBarrier(command_buffer, source_stage, destrination_stage, 0, 0, nullptr, 0, nullptr, 1, &image_memory_barrier);

				//End the Command Buffer's recording Process
				r = vkEndCommandBuffer(command_buffer);
				if (r) return r;

				//Create the submit info
				VkSubmitInfo submit_info = {};
				submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
				submit_info.commandBufferCount = 1;
				submit_info.pCommandBuffers = &command_buffer;

				//Submit The Commands Recorded into the Queue. Then wait for the Graphics Queue to be idle
				r = vkQueueSubmit(m_VkQueueGraphics, 1, &submit_info, VK_NULL_HANDLE);
				if (r) return r;

				r = vkQueueWaitIdle(m_VkQueueGraphics);
				if (r) return r;

				//Free the command buffer from memory
				vkFreeCommandBuffers(m_VkDevice, m_VkCommandPool, 1, &command_buffer);

				//The Command Buffer has ended successfully!
				return VK_SUCCESS;
			}

			//Math Helper Function (Credit: https://graphics.stanford.edu/~seander/bithacks.html)
			//Title: Find integer log base 2 of a 32-bit IEEE float
			uint32_t __log2(const float& v) {
				int32_t c; // 32-bit int c gets the result;
				int32_t x;
				memcpy(&x, &v, sizeof(x)); //[OR, not for portability: int x = *(const int *) &v;]
				c = x >> 23;
				c -= 127;
				return c;
			}

			//Destroy Query Info
			void DestroyQueryVariable() {
				if (m_VkQueryInfo) {
				//Delete Const Chars
				if (m_VkQueryInfo->instanceLayers)			 	delete[] m_VkQueryInfo->instanceLayers;
				if (m_VkQueryInfo->instanceExtensions)			delete[] m_VkQueryInfo->instanceExtensions;	
				if (m_VkQueryInfo->deviceExtensions)			delete[] m_VkQueryInfo->deviceExtensions;

				//Delete Void*
				if (m_VkQueryInfo->instanceLayerProperties)		delete static_cast<VkLayerProperties*>(m_VkQueryInfo->instanceLayerProperties);
				if (m_VkQueryInfo->instanceExtensionProperties)	delete static_cast<VkExtensionProperties*>(m_VkQueryInfo->instanceExtensionProperties);
				if (m_VkQueryInfo->deviceExtensionProperties)	delete static_cast<VkExtensionProperties*>(m_VkQueryInfo->deviceExtensionProperties);
				if (m_VkQueryInfo->physicalDeviceFeatures)		delete static_cast<VkPhysicalDeviceFeatures*>(m_VkQueryInfo->physicalDeviceFeatures);

				//Delete Itself
				delete[] m_VkQueryInfo; m_VkQueryInfo = nullptr;
				}
			}

			//Construct Query Info
			void CreateQueryVariable() {
				m_VkQueryInfo = new GVulkanSurfaceQueryInfo();
				memset(m_VkQueryInfo, 0, sizeof(GVulkanSurfaceQueryInfo));
			}

		private:
			//GVulkan Structs
			GVulkanSurfaceQueryInfo* m_VkQueryInfo = nullptr;
			GVulkanSurfacePlatformFucts m_VulkanHelperOS;

			//GWindow Properties
			SYSTEM::GWindow m_GWindow;
			SYSTEM::UNIVERSAL_WINDOW_HANDLE m_WindowHandle = { nullptr, nullptr };
			VkExtent2D m_WindowTopLeft = {0, 0};
			VkExtent2D m_WindowExtent = {0, 0};
			GW::CORE::GEventResponder m_EventResponder;
			char* m_WindowName = nullptr;
			float m_AspectRatio = 0;
			bool m_Deallocated = false;
			bool m_NoDrawing = false;

			//Main Vulkan Objects
			VkInstance m_VkInstance = VK_NULL_HANDLE;
			VkSurfaceKHR m_VkSurfaceKHR = VK_NULL_HANDLE;
			VkPhysicalDevice m_VkPhysicalDevice = VK_NULL_HANDLE;
			VkDevice m_VkDevice = VK_NULL_HANDLE;
			VkCommandPool m_VkCommandPool = VK_NULL_HANDLE;
			VkSwapchainKHR m_VkSwapchainKHR = VK_NULL_HANDLE;

			//Feature-Based Objects & Properties
			struct GVkImage {
				VkImage image = VK_NULL_HANDLE;
				VkImageView view = VK_NULL_HANDLE;
				VkDeviceMemory memory = VK_NULL_HANDLE;
				VkDeviceSize size = 0;
			};
			GVkImage m_GVkImageMSAA;
			GVkImage m_GVkImageDepth;
			bool m_VSync;
			bool m_MSAAOn;

			//Frame-Based Vulkan Objects & Properties
			uint32_t m_MaxFrameCount = 0;
			uint32_t m_CurrentFrame = 0;
			uint32_t m_TargetImage = 0;
			static constexpr unsigned GVK_SWAP_BUFFER_LIMIT = 8; 
			VkImage m_VkImageSwapchain[GVK_SWAP_BUFFER_LIMIT]{}; 
			VkImageView m_VkImageViewSwapchain[GVK_SWAP_BUFFER_LIMIT]{};
			VkFramebuffer m_VkFramebuffer[GVK_SWAP_BUFFER_LIMIT]{}; 
			VkCommandBuffer m_VkCommandBuffer[GVK_SWAP_BUFFER_LIMIT]{};
			VkSemaphore m_VkSemaphoreImageAvailable[GVK_SWAP_BUFFER_LIMIT]{}; 
			VkSemaphore m_VkSemaphoreRenderFinished[GVK_SWAP_BUFFER_LIMIT]{}; 
			VkFence m_VkFenceRendering[GVK_SWAP_BUFFER_LIMIT]{};
			
			//Other Vulkan Objects/Properties
			const char** m_InstanceLayers = nullptr;		uint32_t m_InstanceLayerCount = 0;
			const char** m_InstanceExtensions = nullptr;	uint32_t m_InstanceExtensionCount = 0;
			const char** m_DeviceExtensions = nullptr;		uint32_t m_DeviceExtensionCount = 0;
			uint64_t m_InitMask = 0;
			bool m_AllPhysicalDeviceFeatures = false;
			int m_QueueFamilyIndices[2] = {-1, -1};
			VkBool32 m_CanCompute = VK_FALSE;
			VkSampleCountFlagBits m_MSAA = VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM;
			VkQueue m_VkQueueGraphics = VK_NULL_HANDLE;
			VkQueue m_VkQueuePresent = VK_NULL_HANDLE;
			VkSurfaceCapabilitiesKHR m_VkSurfaceCapabilitiesKHR = { 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR, VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR, VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR, VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM };
			VkPresentModeKHR m_VkPresentModeKHRSurface = VK_PRESENT_MODE_MAX_ENUM_KHR;
			VkExtent2D m_VkExtent2DSurface = {0, 0};
			VkSurfaceFormatKHR m_VkFormatSurface = {VK_FORMAT_UNDEFINED, VK_COLOR_SPACE_MAX_ENUM_KHR};
			VkFormat m_VkFormatDepth = VK_FORMAT_UNDEFINED;
			VkRenderPass m_VkRenderPass = VK_NULL_HANDLE;
			bool m_FrameLocked = false;
        };
	} // end I namespace
} // end GW namespace

 // every implementation besides dummy use this
#else
    #undef GVULKANSURFACE_DUMMY_INCLUDED
#endif


namespace GW
{
	namespace GRAPHICS
	{
		class GVulkanSurface final
			: public I::GProxy<I::GVulkanSurfaceInterface, I::GVulkanSurfaceImplementation, GW::SYSTEM::GWindow, unsigned long long>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GVulkanSurface)
			GATEWARE_TYPEDEF(Events)
			GATEWARE_TYPEDEF(EVENT_DATA)
			GATEWARE_TYPEDEF(GVulkanSurfaceQueryInfo)
			GATEWARE_CONST_FUNCTION(GetAspectRatio)
			GATEWARE_CONST_FUNCTION(GetSwapchainImageCount)
			GATEWARE_CONST_FUNCTION(GetSwapchainCurrentImage)
			GATEWARE_CONST_FUNCTION(GetQueueFamilyIndices)
			GATEWARE_CONST_FUNCTION(GetGraphicsQueue)
			GATEWARE_CONST_FUNCTION(GetPresentQueue)
			GATEWARE_CONST_FUNCTION(GetSwapchainImage)
			GATEWARE_CONST_FUNCTION(GetSwapchainView)
			GATEWARE_CONST_FUNCTION(GetSwapchainFramebuffer)
			GATEWARE_CONST_FUNCTION(GetInstance)
			GATEWARE_CONST_FUNCTION(GetSurface)
			GATEWARE_CONST_FUNCTION(GetPhysicalDevice)
			GATEWARE_CONST_FUNCTION(GetDevice)
			GATEWARE_CONST_FUNCTION(GetCommandPool)
			GATEWARE_CONST_FUNCTION(GetSwapchain)
			GATEWARE_CONST_FUNCTION(GetRenderPass)
			GATEWARE_CONST_FUNCTION(GetCommandBuffer)
			GATEWARE_CONST_FUNCTION(GetImageAvailableSemaphore)
			GATEWARE_CONST_FUNCTION(GetRenderFinishedSemaphore)
			GATEWARE_CONST_FUNCTION(GetRenderFence)
			GATEWARE_FUNCTION(StartFrame)
			GATEWARE_FUNCTION(EndFrame)

			// reimplemented functions
			// from GEventResponderInterface
			GATEWARE_FUNCTION(Assign)
			GATEWARE_CONST_FUNCTION(Invoke)

			// from GEventGeneratorInterface
			GATEWARE_FUNCTION(Register)
			GATEWARE_CONST_FUNCTION(Observers)
			GATEWARE_FUNCTION(Push)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GVULKANSURFACE_H

/*---------------------------------
|	End of GVulkanSurface.h
----------------------------------*/


/*---------------------------------
|	Begin of GAudio.h
----------------------------------*/
#ifndef GAUDIO_H
#define GAUDIO_H




namespace GW
{
	namespace I
	{
		class GAudioInterface : public virtual GEventGeneratorInterface
		{
		public:
			enum class Events
			{
				DESTROY,
				PLAY_SOUNDS,
				PAUSE_SOUNDS,
				RESUME_SOUNDS,
				STOP_SOUNDS,
				PLAY_MUSIC,
				PAUSE_MUSIC,
				RESUME_MUSIC,
				STOP_MUSIC,
				MASTER_VOLUME_CHANGED,
				SOUNDS_VOLUME_CHANGED,
				MUSIC_VOLUME_CHANGED,
				SOUND_CHANNEL_VOLUMES_CHANGED,
				MUSIC_CHANNEL_VOLUMES_CHANGED
			};

			struct EVENT_DATA
			{
				float channelVolumes[6];
				unsigned int numOfChannels;
			};

			virtual GReturn SetMasterVolume(float _value) = 0;
			virtual GReturn SetGlobalSoundVolume(float _value) = 0;
			virtual GReturn SetGlobalMusicVolume(float _value) = 0;
			virtual GReturn SetSoundsChannelVolumes(const float* _values, unsigned int _numChannels) = 0;
			virtual GReturn SetMusicChannelVolumes(const float* _values, unsigned int _numChannels) = 0;
			virtual GReturn PlaySounds() = 0;
			virtual GReturn PauseSounds() = 0;
			virtual GReturn ResumeSounds() = 0;
			virtual GReturn StopSounds() = 0;
			virtual GReturn PlayMusic() = 0;
			virtual GReturn PauseMusic() = 0;
			virtual GReturn ResumeMusic() = 0;
			virtual GReturn StopMusic() = 0;
		};
	}
}

// Implementaion for GAudio.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_AUDIO) || defined(GATEWARE_DISABLE_GAUDIO) || \
    (defined(GATEWARE_ENABLE_AUDIO) && !defined(GATEWARE_DISABLE_GAUDIO) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
    namespace I
    {
        class GAudioImplementation :    public virtual GAudioInterface,
                                        public GEventGeneratorImplementation
        {
        public:
            // Main class
            GReturn Create()
            {
                return GReturn::INTERFACE_UNSUPPORTED;
            }
            GReturn SetMasterVolume(float _value) override
            {
                return GReturn::FAILURE;
            }
            GReturn SetGlobalSoundVolume(float _value) override
            {
                return GReturn::FAILURE;
            }
            GReturn SetGlobalMusicVolume(float _value) override
            {
                return GReturn::FAILURE;
            }
            GReturn SetSoundsChannelVolumes(const float* _values, unsigned int _numChannels) override
            {
                return GReturn::FAILURE;
            }
            GReturn SetMusicChannelVolumes(const float* _values, unsigned int _numChannels) override
            {
                return GReturn::FAILURE;
            }
            GReturn PlaySounds() override
            {
                return GReturn::FAILURE;
            }
            GReturn PauseSounds() override
            {
                return GReturn::FAILURE;
            }
            GReturn ResumeSounds() override
            {
                return GReturn::FAILURE;
            }
            GReturn StopSounds() override
            {
                return GReturn::FAILURE;
            }
            GReturn PlayMusic() override
            {
                return GReturn::FAILURE;
            }
            GReturn PauseMusic() override
            {
                return GReturn::FAILURE;
            }
            GReturn ResumeMusic() override
            {
                return GReturn::FAILURE;
            }
            GReturn StopMusic() override
            {
                return GReturn::FAILURE;
            }
        };
    }
}


#elif defined(__APPLE__)
    #ifdef __OBJC__
#import <Foundation/Foundation.h>
#import <Cocoa/Cocoa.h>
#import <AVFoundation/AVFoundation.h>
#import <AVFoundation/AVFAudio.h>
#import <AudioToolbox/AudioToolbox.h>
#endif

#include <atomic>
#include <math.h>
#define G_NUM_OF_OUTPUTS 6

namespace internal_gw
{
    class GMacAudio
    {
    public:
        AVAudioEngine* engine;
        AVAudioPlayerNode* player;
        AVAudioUnit* mainMatrixMixerNode;

        bool Init()
        {
            bool result = false;

            engine = [[AVAudioEngine alloc]init];
            player = [[AVAudioPlayerNode alloc]init];
            [engine attachNode : player] ;
             
            
            AudioComponentDescription mixerDesc;
            mixerDesc.componentType = kAudioUnitType_Mixer;
            mixerDesc.componentSubType = kAudioUnitSubType_MatrixMixer;
            mixerDesc.componentManufacturer = kAudioUnitManufacturer_Apple;
            mixerDesc.componentFlags = kAudioComponentFlag_SandboxSafe;
            mixerDesc.componentFlagsMask = 0;

            mainMatrixMixerNode = nullptr;
            [AVAudioUnit instantiateWithComponentDescription : mixerDesc options : kAudioComponentInstantiation_LoadInProcess completionHandler :
            ^ (__kindof AVAudioUnit * _Nullable mixerUnit, NSError * _Nullable error)
            {
                mainMatrixMixerNode = mixerUnit;
                [engine attachNode : mainMatrixMixerNode] ;
            }] ;

            while (!mainMatrixMixerNode)
            {
                usleep(100); // waiting for the completionHandler to finish
            }

            /* NOTE: This code currently does not do anything. */
            /* It is supposed to adjust the output channels to 6 but fails. */
            /* The mixer and busses create ok but the channel setting code fails*/
            /*
            // Give the mixer one input bus and one output bus
            UInt32 inBuses = 1;
            UInt32 outBuses = 1;
            OSStatus os =
            AudioUnitSetProperty(mainMatrixMixerNode.audioUnit, kAudioUnitProperty_ElementCount, kAudioUnitScope_Input, 0, &inBuses, sizeof(UInt32));
            if (os != errSecSuccess)
                return result;
            os = AudioUnitSetProperty(mainMatrixMixerNode.audioUnit, kAudioUnitProperty_ElementCount, kAudioUnitScope_Output, 0, &outBuses, sizeof(UInt32));
            if (os != errSecSuccess)
                return result;
            
            // Set the mixer's input format to have the correct number of channels
            UInt32 size;
            AudioStreamBasicDescription mixerFormatIn;
            os = AudioUnitGetProperty(mainMatrixMixerNode.audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &mixerFormatIn, &size);
            if (os != errSecSuccess)
                return result;
            
            mixerFormatIn.mChannelsPerFrame = G_NUM_OF_OUTPUTS;
            os = AudioUnitSetProperty(mainMatrixMixerNode.audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &mixerFormatIn, size);
            if (os != errSecSuccess)
                return result;
            
            // Set the mixer's output format to have the correct number of channels
            AudioStreamBasicDescription mixerFormatOut;
            os = AudioUnitGetProperty(mainMatrixMixerNode.audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, 0, &mixerFormatOut, &size);
            if (os != errSecSuccess)
                return result;
            
            mixerFormatOut.mChannelsPerFrame = G_NUM_OF_OUTPUTS;
            os = AudioUnitSetProperty(mainMatrixMixerNode.audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, 0, &mixerFormatOut, size);
            if (os != errSecSuccess)
                return result;
            */
            [engine connect : player to : engine.mainMixerNode format : nil] ;
            [engine connect : engine.mainMixerNode to : engine.outputNode format : nil] ;
            
            [engine startAndReturnError : nil] ;

            return result = engine.isRunning;
        }

        bool Unload()
        {
            // Detaches AVplayer from the AVengine
            [engine disconnectNodeInput : player] ;
            [engine detachNode : player] ;

            [player release] ;
            player = nil;

            // Cleans up memory
            if (engine != nil)
            {
                [engine release] ;
                engine = nil;
            }

            return true;
        }
    };
}

namespace GW
{
    namespace I
    {
        class GAudioImplementation :    public virtual GAudioInterface,
                                        public GEventGeneratorImplementation
        {
        public:
            float masterVolume = 1.0f;
            float soundsVolume = 1.0f;
            float musicVolume = 1.0f;
            float soundsChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f };
            float musicChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f };
            internal_gw::GMacAudio* mac_audio = nullptr;

            virtual ~GAudioImplementation()
            {
                // Broadcast DESTROY here
                GEvent gEvent;
                // EVENT_DATA is not required for this event
                gEvent.Write(Events::DESTROY, nullptr_t());
                this->Push(gEvent);

                // Cleanup Objective C data
                mac_audio->Unload();
                delete mac_audio;
                mac_audio = nullptr;
            }

            // Main class
            GReturn Create()
            {
                mac_audio = new internal_gw::GMacAudio();
                bool success = mac_audio->Init();
                if (success == false)
                    return GReturn::HARDWARE_UNAVAILABLE;
                // Initalize GAudio's volumes
                masterVolume = 1.0f;
                soundsVolume = 1.0f;
                musicVolume = 1.0f;

                return GEventGeneratorImplementation::Create();
            }

            GReturn SetMasterVolume(float _value) override
            {
                if (_value < 0.0f)
                    return GReturn::INVALID_ARGUMENT;

                if (fabsf(_value - masterVolume) < FLT_EPSILON)
                    return GReturn::REDUNDANT;

                masterVolume = (_value > 1.0f) ? 1.0f : _value;

                GEvent gEvent;
                EVENT_DATA eventData;
                // Set the first value of a passed array to our actual master volume
                eventData.channelVolumes[0] = masterVolume;
                eventData.numOfChannels = 0; // we are not using channels in this event
                gEvent.Write(Events::MASTER_VOLUME_CHANGED, eventData);

                return this->Push(gEvent);
            }

            GReturn SetGlobalSoundVolume(float _value) override
            {
                if (_value < 0.0f)
                    return GReturn::INVALID_ARGUMENT;

                if (fabsf(_value - soundsVolume) < FLT_EPSILON)
                    return GReturn::REDUNDANT;

                soundsVolume = (_value > 1.0f) ? 1.0f : _value;

                GEvent gEvent;
                EVENT_DATA eventData;
                // Set the first value of a passed array to our actual master volume
                eventData.channelVolumes[0] = soundsVolume;
                eventData.numOfChannels = 0; // we are not using channels in this event
                gEvent.Write(Events::SOUNDS_VOLUME_CHANGED, eventData);

                return this->Push(gEvent);
            }

            GReturn SetGlobalMusicVolume(float _value) override
            {
                if (_value < 0.0f)
                    return GReturn::INVALID_ARGUMENT;

                if (fabsf(_value - musicVolume) < FLT_EPSILON)
                    return GReturn::REDUNDANT;

                musicVolume = (_value > 1.0f) ? 1.0f : _value;

                GEvent gEvent;
                EVENT_DATA eventData;
                // Set the first value of a passed array to our actual master volume
                eventData.channelVolumes[0] = musicVolume;
                eventData.numOfChannels = 0; // we are not using channels in this event
                gEvent.Write(Events::MUSIC_VOLUME_CHANGED, eventData);

                return this->Push(gEvent);
            }

            GReturn SetSoundsChannelVolumes(const float* _values, unsigned int _numChannels) override
            {
                if (_values == nullptr)
                    return GReturn::INVALID_ARGUMENT;

                if (_numChannels == 0 || _numChannels > 6)
                    return GReturn::INVALID_ARGUMENT;

                for (unsigned int i = 0; i < 6; ++i)
                {
                    soundsChannelVolumes[i] = (i < _numChannels) ? _values[i] : 0.0f;
                }

                GEvent gEvent;
                EVENT_DATA eventData;
                memcpy(eventData.channelVolumes, soundsChannelVolumes, 6 * sizeof(float));
                eventData.numOfChannels = _numChannels;
                gEvent.Write(Events::SOUND_CHANNEL_VOLUMES_CHANGED, eventData);

                return this->Push(gEvent);
            }

            GReturn SetMusicChannelVolumes(const float* _values, unsigned int _numChannels) override
            {
                if (_values == nullptr)
                    return GReturn::INVALID_ARGUMENT;

                if (_numChannels == 0 || _numChannels > 6)
                    return GReturn::INVALID_ARGUMENT;

                for (unsigned int i = 0; i < 6; ++i)
                {
                    musicChannelVolumes[i] = (i < _numChannels) ? _values[i] : 0.0f;
                }

                GEvent gEvent;
                EVENT_DATA eventData;
                memcpy(eventData.channelVolumes, musicChannelVolumes, 6 * sizeof(float));
                eventData.numOfChannels = _numChannels;
                gEvent.Write(Events::MUSIC_CHANNEL_VOLUMES_CHANGED, eventData);

                return this->Push(gEvent);
            }

            // Sound Events
            GReturn PlaySounds() override
            {
                GEvent gEvent;
                // EVENT_DATA is not required for this event
                gEvent.Write(Events::PLAY_SOUNDS, nullptr_t());

                return this->Push(gEvent);
            }
            GReturn PauseSounds() override
            {
                GEvent gEvent;
                // EVENT_DATA is not required for this event
                gEvent.Write(Events::PAUSE_SOUNDS, nullptr_t());

                return this->Push(gEvent);
            }
            GReturn ResumeSounds() override
            {
                GEvent gEvent;
                // EVENT_DATA is not required for this event
                gEvent.Write(Events::RESUME_SOUNDS, nullptr_t());

                return this->Push(gEvent);
            }
            GReturn StopSounds() override
            {
                GEvent gEvent;
                // EVENT_DATA is not required for this event
                gEvent.Write(Events::STOP_SOUNDS, nullptr_t());

                return this->Push(gEvent);
            }

            // Music Events
            GReturn PlayMusic() override
            {
                GEvent gEvent;
                // EVENT_DATA is not required for this event
                gEvent.Write(Events::PLAY_MUSIC, nullptr_t());

                return this->Push(gEvent);
            }
            GReturn PauseMusic() override
            {
                GEvent gEvent;
                // EVENT_DATA is not required for this event
                gEvent.Write(Events::PAUSE_MUSIC, nullptr_t());

                return this->Push(gEvent);
            }
            GReturn ResumeMusic() override
            {
                GEvent gEvent;
                // EVENT_DATA is not required for this event
                gEvent.Write(Events::RESUME_MUSIC, nullptr_t());

                return this->Push(gEvent);
            }
            GReturn StopMusic() override
            {
                GEvent gEvent;
                // EVENT_DATA is not required for this event
                gEvent.Write(Events::STOP_MUSIC, nullptr_t());

                return this->Push(gEvent);
            }
        };
    }// end I
}// end GW

#undef G_NUM_OF_OUTPUTS


#elif defined(__linux__)
    #include <atomic>
#include <math.h>
#include <cfloat>
#include <cstring>
#include <pulse/thread-mainloop.h>
#include <pulse/mainloop-api.h>
#include <pulse/context.h>

namespace GW
{
    namespace I
    {
        class GAudioImplementation :	public virtual GAudioInterface,
										public GEventGeneratorImplementation
        {
        public:
			float masterVolume = 1.0f;
			float soundsVolume = 1.0f;
			float musicVolume = 1.0f;
			float soundsChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f };
			float musicChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f };

			virtual ~GAudioImplementation()
			{
				// Broadcast DESTROY here
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::DESTROY, nullptr_t());
				this->Push(gEvent);
			}

            // Main class
            GReturn Create()
            {	
				// check for available hardware
				pa_threaded_mainloop* myMainLoop = pa_threaded_mainloop_new();
				if (myMainLoop == NULL)
					return GReturn::HARDWARE_UNAVAILABLE;
					
				pa_threaded_mainloop_lock(myMainLoop);
				{
					pa_context* myContext = pa_context_new(pa_threaded_mainloop_get_api(myMainLoop), "AudioHardware");
					if (myContext == NULL)
					{
						pa_threaded_mainloop_unlock(myMainLoop);
						pa_threaded_mainloop_free(myMainLoop);
						return GReturn::HARDWARE_UNAVAILABLE;
					}
					if (pa_context_connect(myContext, NULL, PA_CONTEXT_NOFLAGS, NULL) < 0)
					{
						pa_context_unref(myContext);
						pa_threaded_mainloop_unlock(myMainLoop);
						pa_threaded_mainloop_free(myMainLoop);
						return GReturn::HARDWARE_UNAVAILABLE;
					}
					
					pa_context_disconnect(myContext);
					pa_context_unref(myContext);
				}
				pa_threaded_mainloop_unlock(myMainLoop);				
				pa_threaded_mainloop_free(myMainLoop);
				
				// Initalize GAudio's volumes
				masterVolume = 1.0f;
				soundsVolume = 1.0f;
				musicVolume = 1.0f;

				return GEventGeneratorImplementation::Create();
            }

            GReturn SetMasterVolume(float _value) override
            {
				if (_value < 0.0f)
					return GReturn::INVALID_ARGUMENT;

				if (fabsf(_value - masterVolume) < FLT_EPSILON)
					return GReturn::REDUNDANT;

				masterVolume = (_value > 1.0f) ? 1.0f : _value;

				GEvent gEvent;
				EVENT_DATA eventData;
				// Set the first value of a passed array to our actual master volume
				eventData.channelVolumes[0] = masterVolume;
				eventData.numOfChannels = 0; // we are not using channels in this event
				gEvent.Write(Events::MASTER_VOLUME_CHANGED, eventData);

				return this->Push(gEvent);
            }

			GReturn SetGlobalSoundVolume(float _value) override
			{
				if (_value < 0.0f)
					return GReturn::INVALID_ARGUMENT;

				if (fabsf(_value - soundsVolume) < FLT_EPSILON)
					return GReturn::REDUNDANT;

				soundsVolume = (_value > 1.0f) ? 1.0f : _value;

				GEvent gEvent;
				EVENT_DATA eventData;
				// Set the first value of a passed array to our actual master volume
				eventData.channelVolumes[0] = soundsVolume;
				eventData.numOfChannels = 0; // we are not using channels in this event
				gEvent.Write(Events::SOUNDS_VOLUME_CHANGED, eventData);

				return this->Push(gEvent);
			}

			GReturn SetGlobalMusicVolume(float _value) override
			{
				if (_value < 0.0f)
					return GReturn::INVALID_ARGUMENT;

				if (fabsf(_value - musicVolume) < FLT_EPSILON)
					return GReturn::REDUNDANT;

				musicVolume = (_value > 1.0f) ? 1.0f : _value;

				GEvent gEvent;
				EVENT_DATA eventData;
				// Set the first value of a passed array to our actual master volume
				eventData.channelVolumes[0] = musicVolume;
				eventData.numOfChannels = 0; // we are not using channels in this event
				gEvent.Write(Events::MUSIC_VOLUME_CHANGED, eventData);

				return this->Push(gEvent);
			}

            GReturn SetSoundsChannelVolumes(const float* _values, unsigned int _numChannels) override
            {
				if (_values == nullptr)
					return GReturn::INVALID_ARGUMENT;

				if (_numChannels == 0 || _numChannels > 6)
					return GReturn::INVALID_ARGUMENT;

				for (unsigned int i = 0; i < 6; ++i)
				{
					soundsChannelVolumes[i] = (i < _numChannels) ? _values[i] : 0.0f;
				}

				GEvent gEvent;
				EVENT_DATA eventData;
				memcpy(eventData.channelVolumes, soundsChannelVolumes, 6 * sizeof(float));
				eventData.numOfChannels = _numChannels;
				gEvent.Write(Events::SOUND_CHANNEL_VOLUMES_CHANGED, eventData);

				return this->Push(gEvent);
            }

			GReturn SetMusicChannelVolumes(const float* _values, unsigned int _numChannels) override
			{
				if (_values == nullptr)
					return GReturn::INVALID_ARGUMENT;

				if (_numChannels == 0 || _numChannels > 6)
					return GReturn::INVALID_ARGUMENT;

				for (unsigned int i = 0; i < 6; ++i)
				{
					musicChannelVolumes[i] = (i < _numChannels) ? _values[i] : 0.0f;
				}

				GEvent gEvent;
				EVENT_DATA eventData;
				memcpy(eventData.channelVolumes, musicChannelVolumes, 6 * sizeof(float));
				eventData.numOfChannels = _numChannels;
				gEvent.Write(Events::MUSIC_CHANNEL_VOLUMES_CHANGED, eventData);

				return this->Push(gEvent);
			}

			// Sound Events
			GReturn PlaySounds() override
			{
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::PLAY_SOUNDS, nullptr_t());

				return this->Push(gEvent);
			}
            GReturn PauseSounds() override
            {
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::PAUSE_SOUNDS, nullptr_t());
				
                return this->Push(gEvent);
            }
			GReturn ResumeSounds() override
			{
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::RESUME_SOUNDS, nullptr_t());

				return this->Push(gEvent);
			}
            GReturn StopSounds() override
            {
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::STOP_SOUNDS, nullptr_t());

				return this->Push(gEvent);
            }

			// Music Events
			GReturn PlayMusic() override
			{
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::PLAY_MUSIC, nullptr_t());

				return this->Push(gEvent);
			}
			GReturn PauseMusic() override
			{
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::PAUSE_MUSIC, nullptr_t());

				return this->Push(gEvent);
			}
			GReturn ResumeMusic() override
			{
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::RESUME_MUSIC, nullptr_t());

				return this->Push(gEvent);
			}
			GReturn StopMusic() override
			{
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::STOP_MUSIC, nullptr_t());

				return this->Push(gEvent);
			}
        };
    }// end I
}// end GW

#elif defined(_WIN32)
    #if _MSC_VER >= 1700
	#pragma comment(lib, "xaudio2.lib")
#endif

#include <xaudio2.h>
#include <xaudio2fx.h>
#include <atomic>
#include <math.h>

namespace GW
{
    namespace I
    {
        class GAudioImplementation :	public virtual GAudioInterface,
										public GEventGeneratorImplementation
        {
			struct PlatformAudio
			{
				IXAudio2* myAudio = nullptr;
				IXAudio2MasteringVoice* theMasterVoice = nullptr;
			};
        public:
			float masterVolume = 1.0f;
			float soundsVolume = 1.0f;
			float musicVolume = 1.0f;
			float soundsChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f };
			float musicChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f };
			PlatformAudio XAudioData;

			virtual ~GAudioImplementation()
			{
				// Broadcast DESTROY here
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::DESTROY, nullptr_t());
				this->Push(gEvent);

				if (XAudioData.theMasterVoice)
					XAudioData.theMasterVoice->DestroyVoice();

				if (XAudioData.myAudio)
				{
					XAudioData.myAudio->StopEngine();
					XAudioData.myAudio->Release();
				}
			}

            // Main class
            GReturn Create()
            {
				if (XAudioData.myAudio != nullptr)
					return GReturn::FAILURE;

				HRESULT theResult = CoInitialize(NULL);
				if (FAILED(theResult = XAudio2Create(&XAudioData.myAudio)))
					return GReturn::HARDWARE_UNAVAILABLE;

				if (FAILED(theResult = XAudioData.myAudio->CreateMasteringVoice(&XAudioData.theMasterVoice)))
					return GReturn::HARDWARE_UNAVAILABLE;

				// Initalize GAudio's volumes
				masterVolume = 1.0f;
				soundsVolume = 1.0f;
				musicVolume = 1.0f;

				return GEventGeneratorImplementation::Create();
            }

            GReturn SetMasterVolume(float _value) override
            {
				if (_value < 0.0f)
					return GReturn::INVALID_ARGUMENT;

				if (fabsf(_value - masterVolume) < FLT_EPSILON)
					return GReturn::REDUNDANT;

				masterVolume = (_value > 1.0f) ? 1.0f : _value;

				GEvent gEvent;
				EVENT_DATA eventData;
				// Set the first value of a passed array to our actual master volume
				eventData.channelVolumes[0] = masterVolume;
				eventData.numOfChannels = 0; // we are not using channels in this event
				gEvent.Write(Events::MASTER_VOLUME_CHANGED, eventData);

				return this->Push(gEvent);
            }

			GReturn SetGlobalSoundVolume(float _value) override
			{
				if (_value < 0.0f)
					return GReturn::INVALID_ARGUMENT;

				if (fabsf(_value - soundsVolume) < FLT_EPSILON)
					return GReturn::REDUNDANT;

				soundsVolume = (_value > 1.0f) ? 1.0f : _value;

				GEvent gEvent;
				EVENT_DATA eventData;
				// Set the first value of a passed array to our actual master volume
				eventData.channelVolumes[0] = soundsVolume;
				eventData.numOfChannels = 0; // we are not using channels in this event
				gEvent.Write(Events::SOUNDS_VOLUME_CHANGED, eventData);

				return this->Push(gEvent);
			}

			GReturn SetGlobalMusicVolume(float _value) override
			{
				if (_value < 0.0f)
					return GReturn::INVALID_ARGUMENT;

				if (fabsf(_value - musicVolume) < FLT_EPSILON)
					return GReturn::REDUNDANT;

				musicVolume = (_value > 1.0f) ? 1.0f : _value;

				GEvent gEvent;
				EVENT_DATA eventData;
				// Set the first value of a passed array to our actual master volume
				eventData.channelVolumes[0] = musicVolume;
				eventData.numOfChannels = 0; // we are not using channels in this event
				gEvent.Write(Events::MUSIC_VOLUME_CHANGED, eventData);

				return this->Push(gEvent);
			}

            GReturn SetSoundsChannelVolumes(const float* _values, unsigned int _numChannels) override
            {
				if (_values == nullptr)
					return GReturn::INVALID_ARGUMENT;

				if (_numChannels == 0 || _numChannels > 6)
					return GReturn::INVALID_ARGUMENT;

				for (unsigned int i = 0; i < 6; ++i)
				{
					soundsChannelVolumes[i] = (i < _numChannels) ? _values[i] : 0.0f;
				}

				GEvent gEvent;
				EVENT_DATA eventData;
				memcpy(eventData.channelVolumes, soundsChannelVolumes, 6 * sizeof(float));
				eventData.numOfChannels = _numChannels;
				gEvent.Write(Events::SOUND_CHANNEL_VOLUMES_CHANGED, eventData);

				return this->Push(gEvent);
            }

			GReturn SetMusicChannelVolumes(const float* _values, unsigned int _numChannels) override
			{
				if (_values == nullptr)
					return GReturn::INVALID_ARGUMENT;

				if (_numChannels == 0 || _numChannels > 6)
					return GReturn::INVALID_ARGUMENT;

				for (unsigned int i = 0; i < 6; ++i)
				{
					musicChannelVolumes[i] = (i < _numChannels) ? _values[i] : 0.0f;
				}

				GEvent gEvent;
				EVENT_DATA eventData;
				memcpy(eventData.channelVolumes, musicChannelVolumes, 6 * sizeof(float));
				eventData.numOfChannels = _numChannels;
				gEvent.Write(Events::MUSIC_CHANNEL_VOLUMES_CHANGED, eventData);

				return this->Push(gEvent);
			}

			// Sound Events
			GReturn PlaySounds() override
			{
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::PLAY_SOUNDS, nullptr_t());

				return this->Push(gEvent);
			}
            GReturn PauseSounds() override
            {
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::PAUSE_SOUNDS, nullptr_t());
				
                return this->Push(gEvent);
            }
			GReturn ResumeSounds() override
			{
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::RESUME_SOUNDS, nullptr_t());

				return this->Push(gEvent);
			}
            GReturn StopSounds() override
            {
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::STOP_SOUNDS, nullptr_t());

				return this->Push(gEvent);
            }

			// Music Events
			GReturn PlayMusic() override
			{
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::PLAY_MUSIC, nullptr_t());

				return this->Push(gEvent);
			}
			GReturn PauseMusic() override
			{
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::PAUSE_MUSIC, nullptr_t());

				return this->Push(gEvent);
			}
			GReturn ResumeMusic() override
			{
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::RESUME_MUSIC, nullptr_t());

				return this->Push(gEvent);
			}
			GReturn StopMusic() override
			{
				GEvent gEvent;
				// EVENT_DATA is not required for this event
				gEvent.Write(Events::STOP_MUSIC, nullptr_t());

				return this->Push(gEvent);
			}
        };
    }// end I
}// end GW

#endif


namespace GW
{
	namespace AUDIO
	{
		class GAudio final 
			: public I::GProxy<I::GAudioInterface, I::GAudioImplementation>
		{
			// All Gateware API interfaces contain no variables & are pure virtual.
		public:
			GATEWARE_PROXY_CLASS(GAudio)
			GATEWARE_TYPEDEF(Events)
			GATEWARE_TYPEDEF(EVENT_DATA)
			GATEWARE_FUNCTION(SetMasterVolume)
			GATEWARE_FUNCTION(SetGlobalSoundVolume)
			GATEWARE_FUNCTION(SetGlobalMusicVolume)
			GATEWARE_FUNCTION(SetSoundsChannelVolumes)
			GATEWARE_FUNCTION(SetMusicChannelVolumes)
			GATEWARE_FUNCTION(PlaySounds)
			GATEWARE_FUNCTION(PauseSounds)
			GATEWARE_FUNCTION(ResumeSounds)
			GATEWARE_FUNCTION(StopSounds)
			GATEWARE_FUNCTION(PlayMusic)
			GATEWARE_FUNCTION(PauseMusic)
			GATEWARE_FUNCTION(ResumeMusic)
			GATEWARE_FUNCTION(StopMusic)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		}; 
	}
}

#endif // GAUDIO_H

/*---------------------------------
|	End of GAudio.h
----------------------------------*/


/*---------------------------------
|	Begin of GAudio3D.h
----------------------------------*/
#ifndef GAUDIO3D_H
#define GAUDIO3D_H







namespace GW
{
	namespace I
	{
		class GAudio3DInterface : public virtual GAudioInterface
		{
		public:
			enum class Events
			{
				UPDATE_LISTENER,
				UPDATE_TRANSFORM_AND_SPATIALIZE
			};

			struct EVENT_DATA
			{
				GW::MATH::GVECTORF position;
				GW::MATH::GQUATERNIONF quaternion;
			};

			virtual GReturn Update3DListener(GW::MATH::GVECTORF _position, GW::MATH::GQUATERNIONF _orientation) = 0;
		};
	}
}

// Implementaion for GAudio3D.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_AUDIO) || defined(GATEWARE_DISABLE_GAUDIO3D) || \
    (defined(GATEWARE_ENABLE_AUDIO) && !defined(GATEWARE_DISABLE_GAUDIO3D) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
	namespace I
	{
		class GAudio3DImplementation :	public virtual GAudio3DInterface,
										public GAudioImplementation
		{
		public:
			GReturn Create() { return GReturn::INTERFACE_UNSUPPORTED; }
			GReturn Update3DListener(GW::MATH::GVECTORF _position, GW::MATH::GQUATERNIONF _orientation) override { return GReturn::FAILURE; }
		};
	}
}

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
    #include <math.h>

namespace GW
{
	namespace I
	{
		class GAudio3DImplementation :	public virtual GAudio3DInterface,
										public GAudioImplementation
		{
		public:
			CORE::GEventGenerator gEventGen;
			GReturn Create()
			{
				GReturn result = gEventGen.Create();
				if (result != GReturn::SUCCESS)
					return result;

				return GAudioImplementation::Create();
			}

			GReturn Update3DListener(GW::MATH::GVECTORF _position, GW::MATH::GQUATERNIONF _orientation) override
			{
				MATH::GMATRIXF listener = MATH::GIdentityMatrixF;
				MATH::GMATRIXF transform = MATH::GIdentityMatrixF;
				MATH::GQUATERNIONF orientation;
				orientation.x = _orientation.x;
				orientation.y = _orientation.y;
				orientation.z = _orientation.z;
				orientation.w = _orientation.w;

				MATH::GMatrix::ConvertQuaternionF(orientation, listener);

				listener.row4.x = _position.x;
				listener.row4.y = _position.y;
				listener.row4.z = _position.z;
				listener.row4.w = 1.0f;

				if (MATH::GMatrix::InverseF(listener, transform) != GReturn::SUCCESS)
					return GReturn::FAILURE;
				
				GEvent gEvent;
				EVENT_DATA eventData;
				eventData.position = listener.row4;
				eventData.quaternion = _orientation;
				gEvent.Write(Events::UPDATE_LISTENER, eventData);
				gEventGen.Push(gEvent);

				eventData.position = transform.row4;
				MATH::GQuaternion::SetByMatrixF(transform, eventData.quaternion);
				gEvent.Write(Events::UPDATE_TRANSFORM_AND_SPATIALIZE, eventData);

				return gEventGen.Push(gEvent);
			}
		};
	}
}

#endif


namespace GW
{
	namespace AUDIO
	{
		class GAudio3D final 
			: public I::GProxy<I::GAudio3DInterface, I::GAudio3DImplementation>
		{
		public:
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GAudio3D)
			GATEWARE_TYPEDEF(Events)
			GATEWARE_TYPEDEF(EVENT_DATA)
			GATEWARE_FUNCTION(Update3DListener)

			// reimplemented from base class
			GATEWARE_FUNCTION(SetMasterVolume)
			GATEWARE_FUNCTION(SetGlobalSoundVolume)
			GATEWARE_FUNCTION(SetGlobalMusicVolume)
			GATEWARE_FUNCTION(SetSoundsChannelVolumes)
			GATEWARE_FUNCTION(SetMusicChannelVolumes)
			GATEWARE_FUNCTION(PlaySounds)
			GATEWARE_FUNCTION(PauseSounds)
			GATEWARE_FUNCTION(ResumeSounds)
			GATEWARE_FUNCTION(StopSounds)
			GATEWARE_FUNCTION(PlayMusic)
			GATEWARE_FUNCTION(PauseMusic)
			GATEWARE_FUNCTION(ResumeMusic)
			GATEWARE_FUNCTION(StopMusic)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GAUDIO3D_H

/*---------------------------------
|	End of GAudio3D.h
----------------------------------*/


/*---------------------------------
|	Begin of GSound.h
----------------------------------*/
#ifndef GSOUND_H
#define GSOUND_H






namespace GW
{
    namespace I
    {
        class GSoundInterface : public virtual GInterfaceInterface
        {
        public:
            virtual GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) = 0;
            virtual GReturn SetVolume(float _newVolume) = 0;
            virtual GReturn Play() = 0;
            virtual GReturn Pause() = 0;
            virtual GReturn Resume() = 0;
            virtual GReturn Stop() = 0;
            virtual GReturn GetSourceChannels(unsigned int& _returnedChannelNum) const = 0;
            virtual GReturn GetOutputChannels(unsigned int& _returnedChannelNum) const = 0;
            virtual GReturn isPlaying(bool& _returnedBool) const = 0;
            //virtual GReturn SetPCMShader(const char* _data) = 0; // not implemented yet
        };
    }
}

// Implementaion for GSound.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_AUDIO) || defined(GATEWARE_DISABLE_GSOUND) || \
    (defined(GATEWARE_ENABLE_AUDIO) && !defined(GATEWARE_DISABLE_GSOUND) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
    namespace I
    {
        class GSoundImplementation : public virtual GSoundInterface
        {
        public:
            // Main class
            GReturn Create(const char* _path, GW::AUDIO::GAudio _audio, float _value)
            {
                return GReturn::INTERFACE_UNSUPPORTED;
            }
            GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) override
            {
                return GReturn::FAILURE;
            }
            GReturn SetVolume(float _newVolume) override
            {
                return GReturn::FAILURE;
            }
            GReturn Play() override
            {
                return GReturn::FAILURE;
            }
            GReturn Pause() override
            {
                return GReturn::FAILURE;
            }
            GReturn Resume() override
            {
                return GReturn::FAILURE;
            }
            GReturn Stop() override
            {
                return GReturn::FAILURE;
            }
            GReturn GetSourceChannels(unsigned int& returnedChannelNum) const override
            {
                return GReturn::FAILURE;
            }
            GReturn GetOutputChannels(unsigned int& returnedChannelNum) const override
            {
                return GReturn::FAILURE;
            }
            GReturn isPlaying(bool& _returnedBool) const override
            {
                return GReturn::FAILURE;
            }
            //// ThreadShared
            //GReturn LockAsyncRead() const override
            //{
            //    return GReturn::FAILURE;
            //}
            //GReturn UnlockAsyncRead() const override
            //{
            //    return GReturn::FAILURE;
            //}
            //GReturn LockSyncWrite() override
            //{
            //    return GReturn::FAILURE;
            //}
            //GReturn UnlockSyncWrite() override
            //{
            //    return GReturn::FAILURE;
            //}
            //// Events
            //GReturn Append(const GEvent& _inEvent) override
            //{
            //    return GReturn::FAILURE;
            //}
            //GReturn Waiting(unsigned int& _outCount) const override
            //{
            //    return GReturn::FAILURE;
            //}
            //GReturn Pop(GEvent& _outEvent) override
            //{
            //    return GReturn::FAILURE;
            //}
            //GReturn Peek(GEvent& _outEvent) const override
            //{
            //    return GReturn::FAILURE;
            //}
            //GReturn Missed(unsigned int& _outCount) const override
            //{
            //    return GReturn::FAILURE;
            //}
            //GReturn Clear() override
            //{
            //    return GReturn::FAILURE;
            //}
            //GReturn Invoke() const override
            //{
            //    return GReturn::FAILURE;
            //}
        };
    }
}

#elif defined(__APPLE__)
    #define G_NUM_OF_OUTPUTS 6

namespace GW
{
    namespace I
    {
        class GSoundImplementation;
    }
}

namespace internal_gw
{
    class GMacSound
    {
    public:
        GW::I::GSoundImplementation* gSound;
        GMacAudio* audio;

        AVAudioPlayerNode* player;
        AVAudioUnit* matrixMixerNode;

        AVAudioFile* file;
        AVAudioPCMBuffer* buffer;

        std::atomic<bool> isPlaying;
        std::atomic<bool> isPaused;

        GMacSound* initWithPath(NSString* _path)
        {
            NSError* testError;
            // setting up player
            player = [[AVAudioPlayerNode alloc]init];
            [audio->engine attachNode : player] ;

            // setting up buffer
            NSURL* filePath = [[NSURL alloc]initFileURLWithPath:_path];
            file = [[AVAudioFile alloc]initForReading:filePath commonFormat : AVAudioPCMFormatFloat32 interleaved : false error : &testError];
            [filePath release] ;
            buffer = [[AVAudioPCMBuffer alloc]initWithPCMFormat:[file processingFormat] frameCapacity : [file length] ];
            bool success = [file readIntoBuffer : buffer error : &testError];
            if (!success)
                NSCAssert(success, @"could not read file into buffer", [testError localizedDescription]);

                    AudioComponentDescription mixerDesc;
            mixerDesc.componentType = kAudioUnitType_Mixer;
            mixerDesc.componentSubType = kAudioUnitSubType_MatrixMixer;
            mixerDesc.componentManufacturer = kAudioUnitManufacturer_Apple;
            mixerDesc.componentFlags = kAudioComponentFlag_SandboxSafe;
            mixerDesc.componentFlagsMask = 0;

            matrixMixerNode = nullptr;
            [AVAudioUnit instantiateWithComponentDescription : mixerDesc options : kAudioComponentInstantiation_LoadInProcess completionHandler :
            ^ (__kindof AVAudioUnit * _Nullable mixerUnit, NSError * _Nullable error)
            {
                matrixMixerNode = mixerUnit;
                [audio->engine attachNode : matrixMixerNode] ;
            }] ;

            while (!matrixMixerNode)
            {
                usleep(100); // waiting for the completionHandler to finish
            }

            // Give the mixer one input bus and one output bus
            UInt32 inBuses = 1;
            UInt32 outBuses = 1;
            AudioUnitSetProperty(matrixMixerNode.audioUnit, kAudioUnitProperty_ElementCount, kAudioUnitScope_Input, 0, &inBuses, sizeof(UInt32));
            AudioUnitSetProperty(matrixMixerNode.audioUnit, kAudioUnitProperty_ElementCount, kAudioUnitScope_Output, 0, &outBuses, sizeof(UInt32));

            // Set the mixer's input format to have the correct number of channels
            UInt32 size;
            AudioStreamBasicDescription mixerFormatIn;
            AudioUnitGetProperty(matrixMixerNode.audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &mixerFormatIn, &size);
            mixerFormatIn.mChannelsPerFrame = G_NUM_OF_OUTPUTS;
            AudioUnitSetProperty(matrixMixerNode.audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &mixerFormatIn, size);

            // Set the mixer's output format to have the correct number of channels
            AudioStreamBasicDescription mixerFormatOut;
            AudioUnitGetProperty(matrixMixerNode.audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, 0, &mixerFormatOut, &size);
            mixerFormatOut.mChannelsPerFrame = G_NUM_OF_OUTPUTS;
            AudioUnitSetProperty(matrixMixerNode.audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, 0, &mixerFormatOut, size);

            AVAudioFormat* audioFormat;
            if (buffer.format.channelCount == 1) // for mono sounds
                audioFormat = [[AVAudioFormat alloc]
                initWithCommonFormat:AVAudioPCMFormatFloat32 sampleRate : buffer.format.sampleRate channels : 1 interleaved : false];
            // Attempt to use more than 2 channels instead of default format
            else
                audioFormat = [[AVAudioFormat alloc]
                initWithCommonFormat:AVAudioPCMFormatFloat32 sampleRate : buffer.format.sampleRate channels : G_NUM_OF_OUTPUTS interleaved : false];

            [audio->engine connect : player to : audio->engine.mainMixerNode format : audioFormat] ;
            [audioFormat release] ;

            isPlaying = false;
            isPaused = false;

            return this;
        }

        unsigned int GetChannels()
        {
            if (!player)
                return 0;
            return[file processingFormat].channelCount;
        }

        bool SetChannelVolumes(float* _volumes, unsigned int _numChannels)
        {
            if (!player)
                return false;

            if (_numChannels > 1)
            {
                float newVal = 0.0f;
                float sumChannels = 0.0f;
                for (int i = 0; i < _numChannels; i++)
                {
                    // total of all channels
                    sumChannels += _volumes[i];
                    // channels 0 and 4 are left channels which have pan of -1
                    if (i == 0 || i == 4)
                        newVal += _volumes[i] * -1.0f;
                    // skip 2 and 3, since center channels have pan of 0
                    else if (i == 1 || i == 5)
                        newVal += _volumes[i];
                }

                // obtain average and set the panning (sum has to be greater than 1 to apply clamping)
                player.pan = (sumChannels > 1.0f) ? (newVal / sumChannels) : newVal;
            }
            else
            {
                player.pan = -1 * _volumes[0];
            }

            return true;
        }

        bool SetVolume(float _newVolume)
        {
            if (!player)
                return false;

            [player setVolume : (_newVolume)] ;
            float check = [player volume];

            if (check == _newVolume)
                return true;

            return false;
        }

        bool Play()
        {
            if (!player)
                return false;

            [player play] ;
            [player scheduleBuffer : buffer atTime : nil options : AVAudioPlayerNodeBufferInterrupts completionHandler :
            ^ {
                isPlaying = false;
                isPaused = false;
            }] ;

            isPlaying = true;
            isPaused = false;

            return[player isPlaying];
        }

        bool Pause()
        {
            if (!player)
                return false;

            [player pause] ;
            isPlaying = false;
            isPaused = true;

            return ![player isPlaying];
        }

        bool Resume()
        {
            if (!player)
                return false;

            [player playAtTime : nil] ;
            isPlaying = true;
            isPaused = false;

            return[player isPlaying];
        }

        bool Stop()
        {
            if (!player)
                return false;

            [player stop] ;
            isPlaying = false;
            isPaused = false;

            return ![player isPlaying];
        }

        bool Unload()
        {
            bool macresult = false;
            if (player != nil)
            {
                [player stop] ;
                [player release] ;
                player = nil;
                macresult = true;
            }

            // Cleans up memory in the autorelease pool
            if (file != nil)
            {
                [file release] ;
                file = nil;
            }

            if (buffer != nil)
            {
                [buffer release] ;
                buffer = nil;
            }

            return macresult;
        }
    };
}

namespace GW
{
    namespace I
    {
        class GSoundImplementation : public virtual GSoundInterface,
            protected GThreadSharedImplementation
        {
            float masterVolume = 1.0f; // global master volume
            float globalSoundsVolume = 1.0f; // global sounds volume
            float volume = 1.0f; // volume of this sound

            float       channelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f }; // channel volumes of this sound
            float masterChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f }; // global master volumes
            internal_gw::GMacSound* mac_snd = nullptr;
            GW::AUDIO::GAudio gAudio;
            GW::CORE::GEventReceiver gReceiver;

            void Destroy()
            {
                LockSyncWrite();
                if (mac_snd)
                {
                    mac_snd->Unload();
                    delete mac_snd;
                    mac_snd = nullptr;
                }
                UnlockSyncWrite();
            }
        public:
            virtual ~GSoundImplementation()
            {
                // Objective C cleanup
                Destroy();
            }

            GReturn Create(const char* _path, GW::AUDIO::GAudio _audio, float _volume = 1.0f)
            {
                if (!_path || !_audio)
                    return GReturn::INVALID_ARGUMENT;

                if (_volume < 0.0f || _volume > 1.0f)
                    return GReturn::INVALID_ARGUMENT;

                gAudio = _audio;
                auto audioImplementation = std::dynamic_pointer_cast<GW::I::GAudioImplementation>(*_audio);

                mac_snd = new internal_gw::GMacSound();
                mac_snd->gSound = this;
                mac_snd->audio = audioImplementation->mac_audio;
                NSString* nsPath = [[[NSString alloc]initWithUTF8String:_path] autorelease];
                mac_snd->initWithPath(nsPath);

                globalSoundsVolume = audioImplementation->soundsVolume;
                masterVolume = audioImplementation->masterVolume;
                memcpy(masterChannelVolumes, audioImplementation->soundsChannelVolumes, 6 * sizeof(float));

                GReturn result = SetVolume(_volume);
                if (result != GReturn::SUCCESS)
                    return result;

                result = SetChannelVolumes(channelVolumes, 6);
                if (result != GReturn::SUCCESS)
                    return result;

                result = GThreadSharedImplementation::Create();
                if (result != GReturn::SUCCESS)
                    return result;

                return gReceiver.Create(_audio, [&]()
                {
                    GW::GEvent gEvent;
                    GW::AUDIO::GAudio::Events audioEvent;
                    GW::AUDIO::GAudio::EVENT_DATA audioEventData;
                    // Process the event message
                    gReceiver.Pop(gEvent);
                    gEvent.Read(audioEvent);

                    switch (audioEvent)
                    {
                    case GW::AUDIO::GAudio::Events::DESTROY:
                    {
                        //printf("DESTROY RECEIVED IN SOUND\n");
                        // If GAudio is destroyed, the sound is no longer operational
                        Destroy();
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::PLAY_SOUNDS:
                    {
                        Play();
                        //bool playing;
                        //isPlaying(playing);
                        //printf("SOUND PLAY %d\n", playing);
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::PAUSE_SOUNDS:
                    {
                        Pause();
                        //bool playing;
                        //isPlaying(playing);
                        //printf("SOUND PAUSE %d\n", !playing);
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::RESUME_SOUNDS:
                    {
                        Resume();
                        //bool playing;
                        //isPlaying(playing);
                        //printf("SOUND RESUME %d\n", playing);
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::STOP_SOUNDS:
                    {
                        Stop();
                        //bool playing;
                        //isPlaying(playing);
                        //printf("SOUND STOP: %d\n", !playing);
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::MASTER_VOLUME_CHANGED:
                    {
                        gEvent.Read(audioEventData);
                        masterVolume = audioEventData.channelVolumes[0];
                        // Update the current volume with a new master volume
                        SetVolume(volume);
                        //printf("MASTER_VOLUME: %f | VOLUME: %f\n", masterVolume, volume * globalSoundsVolume * masterVolume);
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::SOUNDS_VOLUME_CHANGED:
                    {
                        gEvent.Read(audioEventData);
                        globalSoundsVolume = audioEventData.channelVolumes[0];
                        // Update the current volume with a new master volume
                        SetVolume(volume);
                        //printf("GLOBAL SOUND VOLUME: %f | VOLUME: %f\n", globalSoundsVolume, volume * globalSoundsVolume * masterVolume);
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::SOUND_CHANNEL_VOLUMES_CHANGED:
                    {
                        gEvent.Read(audioEventData);
                        memcpy(masterChannelVolumes, audioEventData.channelVolumes, audioEventData.numOfChannels * sizeof(float));
                        SetChannelVolumes(channelVolumes, audioEventData.numOfChannels);
                        //printf("SOUND CHANNEL VOLUMES: { %f, %f, %f, %f, %f, %f }\n", channelVolumes[0] * masterChannelVolumes[0], channelVolumes[1] * masterChannelVolumes[1], channelVolumes[2] * masterChannelVolumes[2], channelVolumes[3] * masterChannelVolumes[3], channelVolumes[4] * masterChannelVolumes[4], channelVolumes[5] * masterChannelVolumes[5]);
                        break;
                    }
                    default:
                    {
                        break;
                    }
                    }
                });
            }

            GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                if (_numChannels == 0 || _numChannels > 6 || _values == nullptr)
                    return GReturn::INVALID_ARGUMENT;

                float resultChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f };
                for (unsigned int i = 0; i < _numChannels; i++)
                {
                    if (_values[i] < 0.0f)
                        return GReturn::INVALID_ARGUMENT;

                    // apply clamping
                    channelVolumes[i] = (_values[i] > 1.0f) ? 1.0f : _values[i];
                    // apply master channel volumes
                    resultChannelVolumes[i] = channelVolumes[i] * masterChannelVolumes[i];
                }

                if (!mac_snd->player)
                    return GReturn::FAILURE;

                LockSyncWrite();
                bool result = mac_snd->SetChannelVolumes(resultChannelVolumes, _numChannels);
                UnlockSyncWrite();

                return result == true ? GReturn::SUCCESS : GReturn::FAILURE;
            }

            GReturn SetVolume(float _newVolume) override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                if (_newVolume < 0.0f)
                    return GReturn::INVALID_ARGUMENT;

                // Clip the passed volume to max
                volume = (_newVolume > 1.0f) ? 1.0f : _newVolume;

                if (!mac_snd->player)
                    return GReturn::FAILURE;

                // Apply master volume ratios to the sound volume (Doesn't need to be normalized, since result is always < 1.0f)
                LockSyncWrite();
                bool result = mac_snd->SetVolume(volume * globalSoundsVolume * masterVolume);
                UnlockSyncWrite();

                return result == true ? GReturn::SUCCESS : GReturn::FAILURE;
            }

            GReturn Play() override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                bool result = mac_snd->Play();

                return result == true ? GReturn::SUCCESS : GReturn::FAILURE;
            }

            GReturn Pause() override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                bool result = mac_snd->Pause();

                return result == true ? GReturn::SUCCESS : GReturn::FAILURE;
            }

            GReturn Resume() override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                bool result = mac_snd->Resume();

                return result == true ? GReturn::SUCCESS : GReturn::FAILURE;
            }

            GReturn Stop() override
            {
                bool result = mac_snd->Stop();

                // Critical function, all the code must be executed even in PREMATURE_DEALLOCATION state
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                return result == true ? GReturn::SUCCESS : GReturn::FAILURE;
            }

            GReturn GetSourceChannels(unsigned int& returnedChannelNum) const override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                returnedChannelNum = mac_snd->GetChannels();
                return GReturn::SUCCESS;
            }

            GReturn GetOutputChannels(unsigned int& returnedChannelNum) const override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                returnedChannelNum = G_NUM_OF_OUTPUTS;
                return GReturn::SUCCESS;
            }

            GReturn isPlaying(bool& _returnedBool) const override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                _returnedBool = mac_snd->isPlaying;
                return GReturn::SUCCESS;
            }

            // ThreadShared
            GReturn LockAsyncRead() const override
            {
                return GThreadSharedImplementation::LockAsyncRead();
            }

            GReturn UnlockAsyncRead() const override
            {
                return GThreadSharedImplementation::UnlockAsyncRead();
            }

            GReturn LockSyncWrite() override
            {
                return GThreadSharedImplementation::LockSyncWrite();
            }

            GReturn UnlockSyncWrite() override
            {
                return GThreadSharedImplementation::UnlockSyncWrite();
            }
        };
    }// end I
}// end GW

#undef G_NUM_OF_OUTPUTS


#elif defined(__linux__)
    #include <pulse/mainloop.h>
#include <pulse/thread-mainloop.h>
#include <pulse/mainloop-api.h>
#include <pulse/channelmap.h>
#include <pulse/context.h>
#include <pulse/volume.h>
#include <pulse/stream.h>
#include <pulse/error.h>
#include <pulse/scache.h>
#include <pulse/introspect.h>
#include <pulse/subscribe.h>

#include <thread>

#define G_NUM_OF_OUTPUTS 2 // Currently set to forced Stereo



namespace GW
{
    namespace I
    {
        class GSoundImplementation : public virtual GSoundInterface,
            protected GThreadSharedImplementation
        {
			/* this enum is here to prevent compiler warning -Wmultichar
			 * previously, this file used a series of #defines that caused
			 * the warning to occur in a switch statement later on. So instead
			 * of the #defines (initiallizing an int to a series of 4 chars), 
			 * i just declare them here to be the integer they would be 
			 * interpreted as by the compiler internally. */
			enum WaveTag {
				RIFF = 1179011410, // = 'FFIR'
				DATA = 1635017060, // = 'atad'
				FMT  =  544501094, // = ' tmf'
				WAVE = 1163280727, // = 'EVAW'
				JUNK = 1263424842, // = 'KNUJ'
				XWMA = 1095587672, // = 'AMWX'
				DPDS = 1935962212  // = 'sdpd'
			};
			
            struct PCM_FORMAT_INFO
            {
                unsigned short mFormatTag = 0;
                unsigned short mNumChannels = 0;
                unsigned int mSamples = 0;
                unsigned int mAvgBytesPerSec = 0;
                unsigned short mBlockAlign = 0;
                unsigned short mBitsPerSample = 0;
                unsigned short mCbSize = 22;
            };

            struct PCM_BUFFER
            {
                uint32_t byteSize = 0;
                uint8_t* bytes = nullptr;
            };

            struct WAVE_FILE
            {
                PCM_FORMAT_INFO myFormat;
                PCM_BUFFER myBuffer;
                bool isSigned = false;
            };

            std::atomic<int> pa_ready;
            std::atomic_bool atomic_isPlaying;
            std::atomic_bool atomic_isPaused;
            std::atomic_bool atomic_isComplete;
            std::atomic_bool atomic_stopFlag;
            float masterVolume = 1.0f; // global master volume
            float globalSoundsVolume = 1.0f; // global sounds volume
            float volume = 1.0f; // volume of this sound
            uint32_t sinkIndex = UINT32_MAX;
            pa_context* myContext = nullptr;
            pa_channel_map* myMap = nullptr;
            pa_stream* myStream = nullptr;
            pa_threaded_mainloop* myMainLoop = nullptr;

            pa_sample_format myPulseFormat;
            pa_cvolume vol;

            float       channelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f }; // channel volumes of this sound
            float masterChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f }; // global master volumes
            GW::AUDIO::GAudio gAudio;
            GW::CORE::GEventReceiver gReceiver;
            GW::SYSTEM::GConcurrent gConcurrent;
            WAVE_FILE myFile;

            void Destroy()
            {
                if (myMainLoop) pa_threaded_mainloop_lock(myMainLoop);
				 {
					// Disconnects and decrements/unreferences the stream
					if (myStream)
					{
						pa_stream_disconnect(myStream);
						pa_stream_unref(myStream);
						myStream = nullptr;
					}

					// Disconnects and decrements/unreferences the context
					if (myContext)
					{
						pa_context_kill_sink_input(myContext, sinkIndex, NULL, NULL);
						pa_context_disconnect(myContext);
						pa_context_unref(myContext);
						myContext = nullptr;
					}
				}
                if (myMainLoop) pa_threaded_mainloop_unlock(myMainLoop);

                // Stops the mainloop (after the context is disconnected) and releases memory
                if (myMainLoop)
                {
                    pa_threaded_mainloop_stop(myMainLoop);
                    pa_threaded_mainloop_free(myMainLoop);
                    myMainLoop = nullptr;
                }

                if (myMainLoop) pa_threaded_mainloop_lock(myMainLoop);
				{
					if (myMap)
					{
						delete myMap;
						myMap = nullptr;
					}
				}
                if (myMainLoop) pa_threaded_mainloop_unlock(myMainLoop);

                if (myFile.myBuffer.bytes)
                {
                    delete[] myFile.myBuffer.bytes;
                    myFile.myBuffer.bytes = nullptr;
                }
            }

            GReturn LoadWav(const char* path, WAVE_FILE& returnedWave)
            {
				// default the return value
				GReturn result = GReturn::SUCCESS;

				// create our gfile object
				GW::SYSTEM::GFile file;
				file.Create();

				// open the audio file in binary read mode. wav is a binary format with tags that can be interpreted as text
				if (-file.OpenBinaryRead(path)) {
					result = GReturn::FILE_NOT_FOUND;
					return result;
				}
				
				// variables for determinning data information
                unsigned long dwChunktype = 0;
                unsigned long dwChunkDataSize = 0;
                unsigned long dwRiffDataSize = 0;
                unsigned long dwFileType = 0;
				unsigned long dwIsWave = 0;
                unsigned long throwAwayValue = 0;
				bool foundAudioData = false;
                
                while (result == GReturn::SUCCESS && foundAudioData == false)
                {
					if (-file.Read(reinterpret_cast<char*>(&dwChunktype), 4)) {
						// could not aquire chunk type
						result = GReturn::FAILURE;
						break;
					}

					if (-file.Read(reinterpret_cast<char*>(&dwChunkDataSize), 4)) {
						// could not aquire chunk size
						result = GReturn::FAILURE;
						break;
					}

                    switch (dwChunktype) {
                        case WaveTag::RIFF:
                        {
                            dwRiffDataSize = dwChunkDataSize;
                            dwChunkDataSize = 4;

                            if (-file.Read(reinterpret_cast<char*>(&dwFileType), dwChunkDataSize)) {
								// could not aquire the file type
								result = GReturn::FAILURE;
								break;
							}
							break;
                        }
						
                        case WaveTag::WAVE:
                        {

                            if (-file.Read(reinterpret_cast<char*>(&dwIsWave), dwChunkDataSize)) {
								// the file is not a wav file
								result = GReturn::FAILURE;
								break;
							}
							break;
                        }
						
                        case WaveTag::FMT:
                        {
                            if (-file.Read(reinterpret_cast<char*>(&returnedWave.myFormat.mFormatTag), dwChunkDataSize)) {
								// could not read the chunk data
								result = GReturn::FAILURE;
								break;
							}
							break;
                        }
						
                        case WaveTag::DATA:
                        {
							returnedWave.myBuffer.bytes = new uint8_t[dwChunkDataSize];
							if (-file.Read(reinterpret_cast<char*>(returnedWave.myBuffer.bytes), dwChunkDataSize)) {
								// could not read the audio data
								result = GReturn::FAILURE;
								break;
							}

							returnedWave.myBuffer.byteSize = dwChunkDataSize;	// contains size of the audio buffer in bytes
							foundAudioData = true;
							break;
                        }
						
                        default:
                        {
                            char* pThrowawayDataBuffer = new char[dwChunkDataSize];
							if (-file.Read(pThrowawayDataBuffer, dwChunkDataSize)) {
								// something unknown happened that caused the data to not be read
								result = GReturn::FAILURE;
							}

							delete[] pThrowawayDataBuffer;
							break;
                        }
                    }
                }
                file.CloseFile();
				returnedWave.isSigned = (returnedWave.myFormat.mBitsPerSample != 8);
				return result;
            }

            static void OnStateChange(pa_context* c, void* userdata)
            {
                std::atomic<int>* pa_ready = (std::atomic<int>*)userdata;

                switch (pa_context_get_state(c))
                {
                    case PA_CONTEXT_UNCONNECTED:
                    {
                        break;
                    }
                    case PA_CONTEXT_CONNECTING:
                    {
                        break;
                    }
                    case PA_CONTEXT_AUTHORIZING:
                    {
                        break;
                    }
                    case PA_CONTEXT_SETTING_NAME:
                    {
                        break;
                    }
                    case PA_CONTEXT_FAILED:
                    {
                        *pa_ready = -1;
                        break;
                    }
                    case PA_CONTEXT_TERMINATED:
                    {
                        *pa_ready = -1;
                        break;
                    }
                    case PA_CONTEXT_READY:
                    {
                        * pa_ready = 1;
                        break;
                    }
                }
            }

            static void FinishedDrainOp(pa_stream* s, int success, void* userdata)
            {
                GSoundImplementation* impl = reinterpret_cast<GSoundImplementation*>(userdata);
                impl->atomic_isComplete = true;
            }

        public:
            virtual ~GSoundImplementation()
            {
                Stop();
                LockSyncWrite();
                Destroy();
                UnlockSyncWrite();
            }

            GReturn Create(const char* _path, GW::AUDIO::GAudio _audio, float _volume = 1.0f)
            {
                if (!_path || !_audio)
                    return GReturn::INVALID_ARGUMENT;

                if (_volume < 0.0f || _volume > 1.0f)
                    return GReturn::INVALID_ARGUMENT;

                GReturn result = GThreadSharedImplementation::Create();
                if (result != GReturn::SUCCESS)
                    return result;

                gAudio = _audio;
                auto audioImplementation = std::dynamic_pointer_cast<GW::I::GAudioImplementation>(*_audio);

                if (-LoadWav(_path, myFile))
                    return GReturn::FILE_NOT_FOUND;

                myMainLoop = pa_threaded_mainloop_new();

                if (myMainLoop == NULL)
                    return GReturn::FAILURE;

				pa_threaded_mainloop_lock(myMainLoop);
				{
					myContext = pa_context_new(pa_threaded_mainloop_get_api(myMainLoop), "Sound");

					if (myContext == NULL)
					{
						pa_threaded_mainloop_unlock(myMainLoop);					
						return GReturn::FAILURE;
					}

					pa_ready = 0;
					pa_context_connect(myContext, NULL, PA_CONTEXT_NOFLAGS, NULL);
					pa_context_set_state_callback(myContext, OnStateChange, &pa_ready);
				}
				pa_threaded_mainloop_unlock(myMainLoop);

                pa_threaded_mainloop_start(myMainLoop);

                while (pa_ready == 0)
                    std::this_thread::yield();
                
                if (pa_ready != 1)
                    return GReturn::FAILURE;

				switch (myFile.myFormat.mBitsPerSample)
				{
					case 8:
						myPulseFormat = PA_SAMPLE_U8;
						break;
					case 16:
						myPulseFormat = PA_SAMPLE_S16LE;
						break;
					case 24:
						myPulseFormat = PA_SAMPLE_S24LE;
						break;
					case 32:
						myPulseFormat = (myFile.myFormat.mFormatTag > 1) ? PA_SAMPLE_FLOAT32LE : PA_SAMPLE_S32LE; // Float type for IEEE and Signed 32int for PCM
						break;
					default:
						myPulseFormat = PA_SAMPLE_INVALID;
						return GReturn::FAILURE;
						break;
				}

				pa_sample_spec mySampleSpec;
				mySampleSpec.format = myPulseFormat;
				mySampleSpec.rate = myFile.myFormat.mSamples;
				mySampleSpec.channels = myFile.myFormat.mNumChannels;
			
				if (pa_channels_valid(mySampleSpec.channels) == 0)
					return GReturn::FAILURE;
				
				pa_threaded_mainloop_lock(myMainLoop);
				{
					myMap = new pa_channel_map();
					myMap = pa_channel_map_init_extend(myMap, mySampleSpec.channels, PA_CHANNEL_MAP_WAVEEX);
					if (myMap == nullptr)
					{
						pa_threaded_mainloop_unlock(myMainLoop);						
						return GReturn::FAILURE;
					}
					
					myStream = pa_stream_new(myContext, "GSound", &mySampleSpec, myMap);
					if (myStream == nullptr)
					{						
						pa_threaded_mainloop_unlock(myMainLoop);
						return GReturn::FAILURE;
					}

					if (pa_stream_connect_playback(myStream, NULL, NULL, (pa_stream_flags_t)0, NULL, NULL) != 0)
					{
						pa_threaded_mainloop_unlock(myMainLoop);						
						return GReturn::FAILURE;
					}
				}
				pa_threaded_mainloop_unlock(myMainLoop);
				
                globalSoundsVolume = audioImplementation->soundsVolume;
                masterVolume = audioImplementation->masterVolume;
                memcpy(masterChannelVolumes, audioImplementation->soundsChannelVolumes, 6 * sizeof(float));

				pa_cvolume_init(&vol);
				
                result = SetVolume(_volume);
                if (result != GReturn::SUCCESS)
                    return result;

                result = gConcurrent.Create(true);
                if (result != GReturn::SUCCESS) // Events are suppressed
                    return result;

                return gReceiver.Create(_audio, [&]()
                {
                    GW::GEvent gEvent;
                    GW::AUDIO::GAudio::Events audioEvent;
                    GW::AUDIO::GAudio::EVENT_DATA audioEventData;
                    // Process the event message
                    gReceiver.Pop(gEvent);
                    gEvent.Read(audioEvent);

                    switch (audioEvent)
                    {
                        case GW::AUDIO::GAudio::Events::DESTROY:
                        {
                            Stop();
                            LockSyncWrite();
                            Destroy();
                            UnlockSyncWrite();
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::PLAY_SOUNDS:
                        {
                            Play();
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::PAUSE_SOUNDS:
                        {
                            Pause();
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::RESUME_SOUNDS:
                        {
                            Resume();
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::STOP_SOUNDS:
                        {
                            Stop();
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::MASTER_VOLUME_CHANGED:
                        {
                            gEvent.Read(audioEventData);
                            masterVolume = audioEventData.channelVolumes[0];
                            // Update the current volume with a new master volume
                            SetVolume(volume);
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::SOUNDS_VOLUME_CHANGED:
                        {
                            gEvent.Read(audioEventData);
                            globalSoundsVolume = audioEventData.channelVolumes[0];
                            // Update the current volume with a new master volume
                            SetVolume(volume);
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::SOUND_CHANNEL_VOLUMES_CHANGED:
                        {
                            gEvent.Read(audioEventData);
                            memcpy(masterChannelVolumes, audioEventData.channelVolumes, audioEventData.numOfChannels * sizeof(float));
                            SetChannelVolumes(channelVolumes, audioEventData.numOfChannels);
                            break;
                        }
                        default:
                        {
                            break;
                        }
                    }
                });
            }

            GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                if (_numChannels == 0 || _numChannels > 6 || _values == nullptr)
                    return GReturn::INVALID_ARGUMENT;

                float adjustedVolume = volume * masterVolume * globalSoundsVolume;
                for (unsigned int i = 0; i < _numChannels; i++)
                {
                    if (_values[i] < 0.0f)
                        return GReturn::INVALID_ARGUMENT;

                    // 5.1 to stereo fallback
                    if (_numChannels > G_NUM_OF_OUTPUTS)
                    {
                        channelVolumes[i] = (_values[i] > 1.0f) ? 1.0f : _values[i];

                        switch (i)
                        {
                            case 2: // Front Center
                            {
                                channelVolumes[0] += channelVolumes[2] * 0.5f;
                                channelVolumes[1] += channelVolumes[2] * 0.5f;
                                break;
                            }
                            case 3: // LFE
                            {
                                channelVolumes[0] += channelVolumes[3] * 0.3f;
                                channelVolumes[1] += channelVolumes[3] * 0.3f;
                                break;
                            }
                            case 4: // Rear Left
                            {
                                channelVolumes[0] += channelVolumes[4] * 0.7f;
                                break;
                            }
                            case 5: //Rear Right
                            {
                                channelVolumes[1] += channelVolumes[5] * 0.7f;
                                break;
                            }
                        }

                        // clamp stereo to max of 1.0f
                        if (i == _numChannels - 1)
                        {
                            channelVolumes[0] = (channelVolumes[0] > 1.0f) ? 1.0f : channelVolumes[0];
                            channelVolumes[1] = (channelVolumes[1] > 1.0f) ? 1.0f : channelVolumes[1];
							vol.values[0] = pa_sw_volume_from_linear(adjustedVolume * channelVolumes[0] * masterChannelVolumes[0]);
							vol.values[1] = pa_sw_volume_from_linear(adjustedVolume * channelVolumes[1] * masterChannelVolumes[1]);	
                            break;
                        }
                    }
                    else
                    {
                        channelVolumes[i] = (_values[i] > 1.0f) ? 1.0f : _values[i];

                        // apply clamping and master volume multiplier
						vol.values[i] = pa_sw_volume_from_linear(adjustedVolume * channelVolumes[i] * masterChannelVolumes[i]);
                    }
                }

                LockSyncWrite();
				while (sinkIndex == UINT32_MAX)
				{
					pa_threaded_mainloop_lock(myMainLoop);
						sinkIndex = pa_stream_get_index(myStream); //Returns the sink resp. source output index this stream is identified in the server with
					pa_threaded_mainloop_unlock(myMainLoop);
				}
                UnlockSyncWrite();

				vol.channels = G_NUM_OF_OUTPUTS;
                
				//Set the volume of a sink input stream.
				pa_threaded_mainloop_lock(myMainLoop);
				{
					pa_operation* o = pa_context_set_sink_input_volume(myContext, sinkIndex, &vol, NULL, NULL);

					if (!o)
					{						
						pa_threaded_mainloop_unlock(myMainLoop);
						return GReturn::FAILURE;
					}

					pa_operation_unref(o);
				}
				pa_threaded_mainloop_unlock(myMainLoop);

                return GReturn::SUCCESS;
            }

            GReturn SetVolume(float _newVolume) override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                if (_newVolume < 0.0f)
                    return GReturn::INVALID_ARGUMENT;

                // Clip the passed volume to max
                _newVolume = (_newVolume > 1.0f) ? 1.0f : _newVolume;
                volume = _newVolume;

                // Apply master volume ratio to the sound volume (Doesn't need to be normalized, since masterVolume is always < 1.0f)
                _newVolume *= masterVolume * globalSoundsVolume;				
				vol.channels = G_NUM_OF_OUTPUTS;
				for (int i = 0; i < vol.channels; ++i)
					vol.values[i] = pa_sw_volume_from_linear(_newVolume * channelVolumes[i] * masterChannelVolumes[i]);

                LockSyncWrite();
				while (sinkIndex == UINT32_MAX)
				{
					pa_threaded_mainloop_lock(myMainLoop);
						sinkIndex = pa_stream_get_index(myStream); //Returns the sink resp. source output index this stream is identified in the server with
					pa_threaded_mainloop_unlock(myMainLoop);
				}
                UnlockSyncWrite();
                
				pa_threaded_mainloop_lock(myMainLoop);
				{					
					//Set the volume of a sink input stream.
					pa_operation* o = pa_context_set_sink_input_volume(myContext, sinkIndex, &vol, NULL, NULL);

					if (!o)
					{
						pa_threaded_mainloop_unlock(myMainLoop);					
						return GReturn::FAILURE;
					}

					pa_operation_unref(o);
				}
				pa_threaded_mainloop_unlock(myMainLoop);

                return GReturn::SUCCESS;
            }

            GReturn Play() override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                if (atomic_isPlaying || atomic_isComplete)
                {
                    GReturn result = Stop();

                    if (result != GReturn::SUCCESS)
                        return result;
                }

                if (atomic_isPlaying == false)
                {
                    atomic_stopFlag = false;
                    atomic_isPaused = false;
                    atomic_isPlaying = true;
                    gConcurrent.BranchSingular([&]()
                    {
                        unsigned int playBackPt = 0;
                        pa_stream_state_t state;
                        while (true)
                        {
                            if (atomic_stopFlag == true)
                            {
								pa_threaded_mainloop_lock(myMainLoop);
									pa_stream_cancel_write(myStream);
								pa_threaded_mainloop_unlock(myMainLoop);
                                break;
                            }
                            else if (atomic_isPlaying == true)
                            {
                                pa_threaded_mainloop_lock(myMainLoop);
									state = pa_stream_get_state(myStream); // synchronous call, requires locking
                                pa_threaded_mainloop_unlock(myMainLoop);

                                if (state == PA_STREAM_READY)
                                {
									pa_threaded_mainloop_lock(myMainLoop);
										const size_t writeableSize = pa_stream_writable_size(myStream);
									pa_threaded_mainloop_unlock(myMainLoop);
									
                                    const size_t sizeRemain = myFile.myBuffer.byteSize - playBackPt;
                                    const size_t writeSize = (sizeRemain < writeableSize ? sizeRemain : writeableSize);

                                    if (writeSize > 0)
                                    {
										pa_threaded_mainloop_lock(myMainLoop);
											pa_stream_write(myStream, myFile.myBuffer.bytes + playBackPt, writeSize, nullptr, 0, PA_SEEK_RELATIVE);
										pa_threaded_mainloop_unlock(myMainLoop);
										
                                        playBackPt += writeSize;
                                    }
                                    else if (writeableSize > 0 && atomic_isComplete == false)
                                    {
										pa_threaded_mainloop_lock(myMainLoop);
										{											
											pa_operation* o = pa_stream_drain(myStream, FinishedDrainOp, this);

											if (o)
												pa_operation_unref(o);
										}
										pa_threaded_mainloop_unlock(myMainLoop);
                                        break;
                                    }
                                }
                            }
                        }
                    });
                }

                return GReturn::SUCCESS;
            }

            GReturn Pause() override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                if (atomic_isPaused == false)
                {
                    pa_threaded_mainloop_lock(myMainLoop);
						int value = pa_stream_is_corked(myStream); // 1 = paused, 0 = resumed
                    pa_threaded_mainloop_unlock(myMainLoop);

                    if (value == 0) // if not paused
                    {
						pa_threaded_mainloop_lock(myMainLoop);
						{
							pa_operation* o = pa_stream_cork(myStream, 1, [](pa_stream*, int, void*) {}, NULL);

							if (!o)
							{
								pa_threaded_mainloop_unlock(myMainLoop);
								return GReturn::FAILURE;
							}

							pa_operation_unref(o);
						}
						pa_threaded_mainloop_unlock(myMainLoop);
                    }

                    atomic_isPaused = true;
                    atomic_isPlaying = false;
                }

                return GReturn::SUCCESS;
            }

            GReturn Resume() override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                if (atomic_isPaused == true)
                {
                    pa_threaded_mainloop_lock(myMainLoop);
						int value = pa_stream_is_corked(myStream); // 1 = paused, 0 = resumed
                    pa_threaded_mainloop_unlock(myMainLoop);

                    if (value == 1) // if paused
                    {
                        pa_threaded_mainloop_lock(myMainLoop);
						{
							pa_operation* o = pa_stream_cork(myStream, 0, [](pa_stream*, int, void*) {}, NULL);

							if (!o)
							{
								pa_threaded_mainloop_unlock(myMainLoop);
								return GReturn::FAILURE;
							}

							pa_operation_unref(o);							
						}
                        pa_threaded_mainloop_unlock(myMainLoop);
                    }

                    atomic_isPlaying = true;
                    atomic_isPaused = false;
                }
                else
                    return GReturn::REDUNDANT;

                return GReturn::SUCCESS;
            }

            GReturn Stop() override
            {
                atomic_isPlaying = false;
                atomic_isPaused = false;
                atomic_isComplete = false;
                atomic_stopFlag = true;

                gConcurrent.Converge(0);

                // Converge has to run before return
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                return GReturn::SUCCESS;
            }

            GReturn GetSourceChannels(unsigned int& returnedChannelNum) const override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                returnedChannelNum = myFile.myFormat.mNumChannels;
                return GReturn::SUCCESS;
            }

            GReturn GetOutputChannels(unsigned int& returnedChannelNum) const override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                returnedChannelNum = G_NUM_OF_OUTPUTS; // forced Stereo
                return GReturn::SUCCESS;
            }

            GReturn isPlaying(bool& _returnedBool) const override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                _returnedBool = atomic_isPlaying;
                return GReturn::SUCCESS;
            }

        protected:
            // ThreadShared
            GReturn LockAsyncRead() const override
            {
                return GThreadSharedImplementation::LockAsyncRead();
            }

            GReturn UnlockAsyncRead() const override
            {
                return GThreadSharedImplementation::UnlockAsyncRead();
            }

            GReturn LockSyncWrite() override
            {
                return GThreadSharedImplementation::LockSyncWrite();
            }

            GReturn UnlockSyncWrite() override
            {
                return GThreadSharedImplementation::UnlockSyncWrite();
            }
        };
    }// end I
}// end GW

#undef G_NUM_OF_OUTPUTS


#elif defined(_WIN32)
    #define G_NUM_OF_OUTPUTS 6

namespace GW
{
	namespace I
	{
		class GSoundImplementation : public virtual GSoundInterface,
			protected GThreadSharedImplementation,
			protected IXAudio2VoiceCallback
		{
			// This enum exists for parity with Linux. See GMusic_Linux.hpp for more info
			enum WaveTag {
				RIFF = 1179011410, // = 'FFIR'
				DATA = 1635017060, // = 'atad'
				FMT = 544501094, // = ' tmf'
				WAVE = 1163280727, // = 'EVAW'
				JUNK = 1263424842, // = 'KNUJ'
				XWMA = 1095587672, // = 'AMWX'
				DPDS = 1935962212  // = 'sdpd'
			};

			GReturn LoadWaveData(const char* path, WAVEFORMATEXTENSIBLE& myWFX, XAUDIO2_BUFFER& _myAudioBuffer)
			{
				// default the return value
				GReturn result = GReturn::SUCCESS;

				// create our gfile object
				GW::SYSTEM::GFile file;
				file.Create();

				// open the audio file in binary read mode. wav is a binary format with tags that can be interpreted as text
				if (-file.OpenBinaryRead(path)) {
					result = GReturn::FILE_NOT_FOUND;
					return result;
				}

				// variables for determinning data information
				unsigned long dwChunktype = 0;
				unsigned long dwChunkDataSize = 0;
				unsigned long dwRiffDataSize = 0;
				unsigned long dwFileType = 0;
				unsigned long dwIsWave = 0;
				bool foundAudioData = false;

				while (result == GReturn::SUCCESS && foundAudioData == false)
				{
					if (-file.Read(reinterpret_cast<char*>(&dwChunktype), 4)) {
						// could not aquire chunk type
						result = GReturn::FAILURE;
						break;
					}

					if (-file.Read(reinterpret_cast<char*>(&dwChunkDataSize), 4)) {
						// could not aquire chunk size
						result = GReturn::FAILURE;
						break;
					}

					switch (dwChunktype) {
						case WaveTag::RIFF:
						{
							dwRiffDataSize = dwChunkDataSize;
							dwChunkDataSize = 4;
							if (-file.Read(reinterpret_cast<char*>(&dwFileType), 4) || dwFileType != WaveTag::WAVE) {
								// could not aquire the file type
								result = GReturn::FAILURE;
								break;
							}
							break;
						}
						
						case WaveTag::WAVE:
						{
							if (-file.Read(reinterpret_cast<char*>(&dwIsWave), 4)) {
								// the file is not a wav file
								result = GReturn::FAILURE;
								break;
							}
							break;
						}

						case WaveTag::FMT:
						{
							if (-file.Read(reinterpret_cast<char*>(&myWFX), dwChunkDataSize)) {
								// could not read the chunk data
								result = GReturn::FAILURE;
								break;
							}
							break;
						}

						case WaveTag::DATA:
						{
							BYTE* pDataBuffer = new BYTE[dwChunkDataSize];
							if (-file.Read(reinterpret_cast<char*>(pDataBuffer), dwChunkDataSize)) {
								// could not read the audio data
								result = GReturn::FAILURE;
								delete[] pDataBuffer;
								break;
							}

							_myAudioBuffer.AudioBytes = dwChunkDataSize;	// contains size of the audio buffer in bytes
							_myAudioBuffer.pAudioData = pDataBuffer;		// this buffer contains all audio data
							_myAudioBuffer.Flags = XAUDIO2_END_OF_STREAM;	// tells source this is EOF and should stop
							foundAudioData = true;
							break;
						}

						default:
						{
							char* pBogusData = new char[dwChunkDataSize];
							if (-file.Read(pBogusData, dwChunkDataSize)) {
								// something unknown happened that caused the data to not be read
								result = GReturn::FAILURE;
								delete[] pBogusData;
								break;
							}
							delete[] pBogusData;
							break;
						}
					}
				}
				file.CloseFile();
				return result;
			}

			void STDMETHODCALLTYPE OnStreamEnd()
			{
				// When stream ends, the sound gets flagged as complete
				atomic_isComplete = true;
				atomic_isPaused = false;
				atomic_isPlaying = false;
				SetEvent(hStreamEndEvent);
			}
			// Required studs as IXAudio2VoiceCallback is an abstract class
			void STDMETHODCALLTYPE OnBufferEnd(void*) {}
			void STDMETHODCALLTYPE OnBufferStart(void*) {}
			void STDMETHODCALLTYPE OnVoiceProcessingPassStart(UINT32) {}
			void STDMETHODCALLTYPE OnVoiceProcessingPassEnd() {}
			void STDMETHODCALLTYPE OnVoiceError(void*, HRESULT) {}
			void STDMETHODCALLTYPE OnLoopEnd(void*) {}

			std::atomic_bool atomic_isPlaying = false;
			std::atomic_bool atomic_isPaused = false;
			std::atomic_bool atomic_isComplete = false;
			float masterVolume = 1.0f; // global master volume
			float globalSoundsVolume = 1.0f; // global sounds volume
			float volume = 1.0f; // volume of this sound
			unsigned int numOfChannels = 0;

			IXAudio2SourceVoice* mySourceVoice = nullptr;
			IXAudio2SubmixVoice* mySubmixVoice = nullptr;
			HANDLE hStreamEndEvent;

			float       channelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f }; // channel volumes of this sound
			float masterChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f }; // global master volumes
			GW::AUDIO::GAudio gAudio;
			GW::CORE::GEventReceiver gReceiver;
			XAUDIO2_BUFFER myAudioBuffer = { 0 };

		public:
			virtual ~GSoundImplementation()
			{
				Stop();

				// We do not need to check for GAudio proxy here, since those handles would get cleaned up 
				// in the event callback if GAudio gets deleted first
				LockSyncWrite();
				if (mySourceVoice)
					mySourceVoice->DestroyVoice();

				if (mySubmixVoice)
					mySubmixVoice->DestroyVoice();
				UnlockSyncWrite();

				if (myAudioBuffer.pAudioData)
					delete[] myAudioBuffer.pAudioData;

				if (hStreamEndEvent)
					CloseHandle(hStreamEndEvent);
			}

			GReturn Create(const char* _path, GW::AUDIO::GAudio _audio, float _volume = 1.0f)
			{
				if (!_path || !_audio)
					return GReturn::INVALID_ARGUMENT;

				if (_volume < 0.0f || _volume > 1.0f)
					return GReturn::INVALID_ARGUMENT;

				hStreamEndEvent = CreateEventEx(nullptr, nullptr, CREATE_EVENT_MANUAL_RESET, EVENT_MODIFY_STATE | SYNCHRONIZE);
				if (!hStreamEndEvent)
					return GReturn::FAILURE;

				WAVEFORMATEXTENSIBLE wfmx;
				if (-LoadWaveData(_path, wfmx, myAudioBuffer))
					return GReturn::FAILURE;

				//if (wfmx.Format.nChannels > maxChannels)
				//    maxChannels = wfmx.Format.nChannels;

				gAudio = _audio;
				auto audioImplementation = std::dynamic_pointer_cast<GW::I::GAudioImplementation>(*_audio);

				if (audioImplementation->XAudioData.myAudio->CreateSubmixVoice(&mySubmixVoice, G_NUM_OF_OUTPUTS, wfmx.Format.nSamplesPerSec) != S_OK)
					return GReturn::FAILURE;

				XAUDIO2_SEND_DESCRIPTOR sndSendDcsp = { 0, mySubmixVoice };
				XAUDIO2_VOICE_SENDS sndSendList = { 1, &sndSendDcsp };

				// Size, in bytes, of extra format information appended to the end of the WAVEFORMATEX structure. (for non-PCM formats)
				wfmx.Format.cbSize = (wfmx.Format.wFormatTag > 1) ? 22 : 0;
				numOfChannels = static_cast<unsigned int>(wfmx.Format.nChannels);
				if (audioImplementation->XAudioData.myAudio->CreateSourceVoice(&mySourceVoice, &wfmx.Format, 0, XAUDIO2_DEFAULT_FREQ_RATIO, this, &sndSendList) != S_OK)
					return GReturn::FAILURE;

				if (FAILED(mySourceVoice->SubmitSourceBuffer(&myAudioBuffer)))
					return GReturn::FAILURE;

				globalSoundsVolume = audioImplementation->soundsVolume;
				masterVolume = audioImplementation->masterVolume;
				memcpy(masterChannelVolumes, audioImplementation->soundsChannelVolumes, 6 * sizeof(float));

				GReturn result = SetVolume(_volume);
				if (result != GReturn::SUCCESS)
					return result;

				result = SetChannelVolumes(channelVolumes, 6);
				if (result != GReturn::SUCCESS)
					return result;

				result = GThreadSharedImplementation::Create();
				if (result != GReturn::SUCCESS)
					return result;

				return gReceiver.Create(_audio, [&]()
				{
					GW::GEvent gEvent;
					GW::AUDIO::GAudio::Events audioEvent;
					GW::AUDIO::GAudio::EVENT_DATA audioEventData;
					// Process the event message
					gReceiver.Pop(gEvent);
					gEvent.Read(audioEvent);

					switch (audioEvent)
					{
						case GW::AUDIO::GAudio::Events::DESTROY:
						{
							//printf("DESTROY RECEIVED IN SOUND\n");
							Stop();
							// Need to cleanup XAudio handles before GAudio is deleted
							LockSyncWrite();
							if (mySourceVoice)
							{
								mySourceVoice->DestroyVoice();
								mySourceVoice = nullptr;
							}

							if (mySubmixVoice)
							{
								mySubmixVoice->DestroyVoice();
								mySubmixVoice = nullptr;
							}
							UnlockSyncWrite();
							break;
						}
						case GW::AUDIO::GAudio::Events::PLAY_SOUNDS:
						{
							Play();
							//bool playing;
							//isPlaying(playing);
							//printf("SOUND PLAY %d\n", playing);
							break;
						}
						case GW::AUDIO::GAudio::Events::PAUSE_SOUNDS:
						{
							Pause();
							//bool playing;
							//isPlaying(playing);
							//printf("SOUND PAUSE %d\n", !playing);
							break;
						}
						case GW::AUDIO::GAudio::Events::RESUME_SOUNDS:
						{
							Resume();
							//bool playing;
							//isPlaying(playing);
							//printf("SOUND RESUME %d\n", playing);
							break;
						}
						case GW::AUDIO::GAudio::Events::STOP_SOUNDS:
						{
							Stop();
							//bool playing;
							//isPlaying(playing);
							//printf("SOUND STOP: %d\n", !playing);
							break;
						}
						case GW::AUDIO::GAudio::Events::MASTER_VOLUME_CHANGED:
						{
							gEvent.Read(audioEventData);
							masterVolume = audioEventData.channelVolumes[0];
							// Update the current volume with a new master volume
							SetVolume(volume);
							//printf("MASTER_VOLUME: %f | VOLUME: %f\n", masterVolume, volume * globalSoundsVolume * masterVolume);
							break;
						}
						case GW::AUDIO::GAudio::Events::SOUNDS_VOLUME_CHANGED:
						{
							gEvent.Read(audioEventData);
							globalSoundsVolume = audioEventData.channelVolumes[0];
							// Update the current volume with a new master volume
							SetVolume(volume);
							//printf("GLOBAL SOUND VOLUME: %f | VOLUME: %f\n", globalSoundsVolume, volume * globalSoundsVolume * masterVolume);
							break;
						}
						case GW::AUDIO::GAudio::Events::SOUND_CHANNEL_VOLUMES_CHANGED:
						{
							gEvent.Read(audioEventData);
							memcpy(masterChannelVolumes, audioEventData.channelVolumes, audioEventData.numOfChannels * sizeof(float));
							SetChannelVolumes(channelVolumes, audioEventData.numOfChannels);
							//printf("SOUND CHANNEL VOLUMES: { %f, %f, %f, %f, %f, %f }\n", channelVolumes[0] * masterChannelVolumes[0], channelVolumes[1] * masterChannelVolumes[1], channelVolumes[2] * masterChannelVolumes[2], channelVolumes[3] * masterChannelVolumes[3], channelVolumes[4] * masterChannelVolumes[4], channelVolumes[5] * masterChannelVolumes[5]);
							break;
						}
						default:
						{
							break;
						}
					}
				});
			}

			GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				if (_numChannels == 0 || _numChannels > 6 || _values == nullptr)
					return GReturn::INVALID_ARGUMENT;

				for (unsigned int i = 0; i < _numChannels; i++)
				{
					if (_values[i] < 0.0f)
						return GReturn::INVALID_ARGUMENT;

					// apply clamping and master volume multiplier
					channelVolumes[i] = (_values[i] > 1.0f) ? 1.0f : _values[i];
				}

				// can only support up to 6 outputs
				float matrix[12] = { 0 };
				unsigned int trueIndex = 0;
				for (unsigned int i = 0; i < 12;)
				{
					if (trueIndex < _numChannels)
					{
						float matrixVolume = channelVolumes[trueIndex] * masterChannelVolumes[trueIndex];
						matrix[i] = matrixVolume;
						matrix[i + 1] = matrixVolume;
						trueIndex++;
						i += 2;
					}
					else
					{
						matrix[i] = 0;
						i++;
					}
				}

				LockSyncWrite();
				if (mySourceVoice == nullptr || FAILED(mySourceVoice->SetOutputMatrix(mySubmixVoice, numOfChannels, G_NUM_OF_OUTPUTS, matrix)))
				{
					UnlockSyncWrite();
					return GReturn::FAILURE;
				}
				UnlockSyncWrite();

				return GReturn::SUCCESS;
			}

			GReturn SetVolume(float _newVolume) override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				if (_newVolume < 0.0f)
					return GReturn::INVALID_ARGUMENT;

				// Clip the passed volume to max
				volume = (_newVolume > 1.0f) ? 1.0f : _newVolume;

				// Apply master volume ratio to the sound volume (Doesn't need to be normalized, since masterVolume is always < 1.0f)
				LockSyncWrite();
				if (mySourceVoice == nullptr || FAILED(mySourceVoice->SetVolume(volume * globalSoundsVolume * masterVolume)))
				{
					UnlockSyncWrite();
					return GReturn::FAILURE;
				}
				UnlockSyncWrite();

				return GReturn::SUCCESS;
			}

			GReturn Play() override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				if (atomic_isPlaying || atomic_isComplete)
				{
					GReturn result = Stop();

					if (result != GReturn::SUCCESS)
						return result;
				}

				if (atomic_isPlaying == false)
				{
					LockSyncWrite();
					if (mySourceVoice == nullptr || FAILED(mySourceVoice->Start()))
					{
						UnlockSyncWrite();
						return GReturn::FAILURE;
					}
					UnlockSyncWrite();

					atomic_isPlaying = true;
					atomic_isPaused = false;
				}

				return GReturn::SUCCESS;
			}

			GReturn Pause() override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				if (atomic_isPaused == false)
				{
					LockSyncWrite();
					if (mySourceVoice == nullptr || FAILED(mySourceVoice->Stop()))
					{
						UnlockSyncWrite();
						return GReturn::FAILURE;
					}
					UnlockSyncWrite();

					atomic_isPlaying = false;
					atomic_isPaused = true;
				}

				return GReturn::SUCCESS;
			}

			GReturn Resume() override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				if (atomic_isPaused == true)
				{
					LockSyncWrite();
					if (mySourceVoice == nullptr || FAILED(mySourceVoice->Start()))
					{
						UnlockSyncWrite();
						return GReturn::FAILURE;
					}
					UnlockSyncWrite();

					atomic_isPlaying = true;
					atomic_isPaused = false;
				}
				else
					return GReturn::REDUNDANT;

				return GReturn::SUCCESS;
			}

			GReturn Stop() override
			{
				atomic_isPlaying = false;
				atomic_isPaused = false;
				atomic_isComplete = false;

				LockSyncWrite();
				if (mySourceVoice == nullptr || FAILED(mySourceVoice->Stop()))
				{
					UnlockSyncWrite();
					return GReturn::FAILURE;
				}
				mySourceVoice->FlushSourceBuffers();
				if (FAILED(mySourceVoice->SubmitSourceBuffer(&myAudioBuffer)))
				{
					UnlockSyncWrite();
					return GReturn::FAILURE;
				}
				UnlockSyncWrite();

				// Critical function, all the code must be executed even in PREMATURE_DEALLOCATION state
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				return GReturn::SUCCESS;
			}

			GReturn GetSourceChannels(unsigned int& returnedChannelNum) const override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				returnedChannelNum = numOfChannels;
				return GReturn::SUCCESS;
			}

			GReturn GetOutputChannels(unsigned int& returnedChannelNum) const override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				returnedChannelNum = G_NUM_OF_OUTPUTS;
				return GReturn::SUCCESS;
			}

			GReturn isPlaying(bool& _returnedBool) const override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				_returnedBool = atomic_isPlaying;
				return GReturn::SUCCESS;
			}

		protected:
			// ThreadShared
			GReturn LockAsyncRead() const override
			{
				return GThreadSharedImplementation::LockAsyncRead();
			}

			GReturn UnlockAsyncRead() const override
			{
				return GThreadSharedImplementation::UnlockAsyncRead();
			}

			GReturn LockSyncWrite() override
			{
				return GThreadSharedImplementation::LockSyncWrite();
			}

			GReturn UnlockSyncWrite() override
			{
				return GThreadSharedImplementation::UnlockSyncWrite();
			}
		};
	}// end I
}// end GW

#undef G_RIFFcc
#undef G_DATAcc
#undef G_FMTcc 
#undef G_WAVEcc
//#undef G_JUNKcc
//#undef G_XWMAcc
//#undef G_DPDScc
#undef G_NUM_OF_OUTPUTS

#endif



namespace GW
{
    namespace AUDIO
    {
        class GSound final 
			: public I::GProxy<I::GSoundInterface, I::GSoundImplementation, const char*, GAudio, float>
        {
			// End users please feel free to ignore this struct, it is temporary and only used for internal API wiring.
			struct init_callback
			{
				init_callback()
				{
					internal_gw::event_receiver_callback = internal_gw::event_receiver_logic<CORE::GEventReceiver>;
				}
			}init; // hopefully your compiler will optimize this out

            // All Gateware API interfaces contain no variables & are pure virtual.
        public:
			GATEWARE_PROXY_CLASS(GSound)
			GATEWARE_FUNCTION(SetChannelVolumes)
			GATEWARE_FUNCTION(SetVolume)
			GATEWARE_FUNCTION(Play)
			GATEWARE_FUNCTION(Pause)
			GATEWARE_FUNCTION(Resume)
			GATEWARE_FUNCTION(Stop)
			GATEWARE_CONST_FUNCTION(GetSourceChannels)
			GATEWARE_CONST_FUNCTION(GetOutputChannels)
			GATEWARE_CONST_FUNCTION(isPlaying)
           
            // This area does not contain actual code, it is only for the benefit of documentation generation.
        };
    }
}

#endif // GSOUND_H

/*---------------------------------
|	End of GSound.h
----------------------------------*/


/*---------------------------------
|	Begin of GMusic.h
----------------------------------*/
#ifndef GMUSIC_H
#define GMUSIC_H







namespace GW
{
    namespace I
    {
        class GMusicInterface : public virtual GInterfaceInterface
        {
        public:
			virtual GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) = 0;
			virtual GReturn SetVolume(float _newVolume) = 0;
			virtual GReturn Play(bool _loop = false) = 0;
			virtual GReturn Pause() = 0;
			virtual GReturn Resume() = 0;
			virtual GReturn Stop() = 0;
			virtual GReturn GetSourceChannels(unsigned int& returnedChannelNum) const = 0;
			virtual GReturn GetOutputChannels(unsigned int& returnedChannelNum) const = 0;
			virtual GReturn isPlaying(bool& _returnedBool) const = 0;
            //virtual GReturn SetPCMShader(const char* _data) = 0; // not implemented yet
        };
    }
}

// Implementaion for GMusic.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_AUDIO) || defined(GATEWARE_DISABLE_GMUSIC) || \
    (defined(GATEWARE_ENABLE_AUDIO) && !defined(GATEWARE_DISABLE_GMUSIC) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
    namespace I
    {
        class GMusicImplementation : public virtual GMusicInterface
        {
        public:
            // Main class
            GReturn Create(const char* _path, GW::AUDIO::GAudio _audio, float _value)
            {
                return GReturn::INTERFACE_UNSUPPORTED;
            }
            GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) override
            {
                return GReturn::FAILURE;
            }
            GReturn SetVolume(float _newVolume) override
            {
                return GReturn::FAILURE;
            }
            GReturn Play(bool _loop = false) override
            {
                return GReturn::FAILURE;
            }
            GReturn Pause() override
            {
                return GReturn::FAILURE;
            }
            GReturn Resume() override
            {
                return GReturn::FAILURE;
            }
            GReturn Stop() override
            {
                return GReturn::FAILURE;
            }
            GReturn GetSourceChannels(unsigned int& returnedChannelNum) const override
            {
                return GReturn::FAILURE;
            }
            GReturn GetOutputChannels(unsigned int& returnedChannelNum) const override
            {
                return GReturn::FAILURE;
            }
            GReturn isPlaying(bool& _returnedBool) const override
            {
                return GReturn::FAILURE;
            }
        };
    }
}

#elif defined(__APPLE__)
    #define G_NUM_OF_OUTPUTS 6
#define G_STREAMING_BUFFER_SIZE 63553
#define G_MAX_BUFFER_COUNT 3



namespace GW
{
    namespace I
    {
        class GMusicImplementation;
    }
}

namespace internal_gw
{
    // GMacMusic Interface

    // Data members of GMacMusic
    G_OBJC_DATA_MEMBERS_STRUCT(GMacMusic)
    {
        int currentBufferIndex;
        int index;

        std::atomic<int> buffersQueued;
        std::atomic<bool> stopFlag;
        std::atomic<bool> loops;
        std::atomic<bool> isPlaying;
        std::atomic<bool> isPaused;

        AVAudioFrameCount CurrentPosition;
        AVAudioFrameCount MaxPosition;

        GW::I::GMusicImplementation* gMusic;
        GMacAudio* audio;

        AVAudioPlayerNode* player;

        AVAudioUnit* matrixMixerNode;
        AVAudioFormat* audioFormat;

        AVAudioFile* file;
        AVAudioPCMBuffer* buffers[G_MAX_BUFFER_COUNT];
        NSThread* scheduler;
        NSCondition* bufferCondition;
    };

    // Forward declarations of GMacMusic methods
    G_OBJC_HEADER_DATA_MEMBERS_PROPERTY_METHOD(GMacMusic);

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacMusic, id, initWithPath, NSString* _path);
    G_OBJC_HEADER_INSTANCE_METHOD(GMacMusic, unsigned int, GetChannels);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacMusic, bool, SetChannelVolumes, float* _volumes, unsigned int _numChannels);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacMusic, bool, SetVolume, float _newVolume);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacMusic, bool, Play, bool _loops);
    G_OBJC_HEADER_INSTANCE_METHOD(GMacMusic, bool, Pause);
    G_OBJC_HEADER_INSTANCE_METHOD(GMacMusic, bool, Resume);
    G_OBJC_HEADER_INSTANCE_METHOD(GMacMusic, bool, Stop);
    G_OBJC_HEADER_INSTANCE_METHOD(GMacMusic, void, Stream);
    G_OBJC_HEADER_INSTANCE_METHOD(GMacMusic, bool, Unload);

    // Creates the GMacMusic class at runtime when G_OBJC_GET_CLASS(GMacMusic) is called.
    G_OBJC_CLASS_BEGIN(GMacMusic, NSObject)
    {
        G_OBJC_CLASS_DATA_MEMBERS_PROPERTY(GMacMusic);

        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GMacMusic, initWithPath, "@@:@", :);
        G_OBJC_CLASS_METHOD(GMacMusic, GetChannels, "I@:");
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GMacMusic, SetChannelVolumes, "B@:@I", ::);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GMacMusic, SetVolume, "B@:f", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GMacMusic, Play, "B@:B", :);
        G_OBJC_CLASS_METHOD(GMacMusic, Pause, "B@:");
        G_OBJC_CLASS_METHOD(GMacMusic, Resume, "B@:");
        G_OBJC_CLASS_METHOD(GMacMusic, Stop, "B@:");
        G_OBJC_CLASS_METHOD(GMacMusic, Stream, "v@:");
        G_OBJC_CLASS_METHOD(GMacMusic, Unload, "B@:");
    }
    G_OBJC_CLASS_END(GMacMusic)

    // GMacMusic Interface End
}

namespace GW
{
    namespace I
    {
        class GMusicImplementation : public virtual GMusicInterface,
            protected GThreadSharedImplementation
        {
            float masterVolume = 1.0f; // global master volume
            float globalMusicVolume = 1.0f; // global sounds volume
            float volume = 1.0f; // volume of this sound

            float       channelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f }; // channel volumes of this sound
            float masterChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f }; // global master volumes
            id mac_msc = nullptr;
            GW::AUDIO::GAudio gAudio;
            GW::CORE::GEventReceiver gReceiver;

            void Destroy()
            {
                LockSyncWrite();
                if (mac_msc)
                {
                    internal_gw::G_OBJC_CALL_METHOD(GMacMusic, mac_msc, Unload);
                    mac_msc = nullptr;
                }
                UnlockSyncWrite();
            }
        public:
            GW::SYSTEM::GConcurrent gConcurrent;
            virtual ~GMusicImplementation()
            {
                // Objective C cleanup
                Destroy();
            }

            GReturn Create(const char* _path, GW::AUDIO::GAudio _audio, float _volume = 1.0f)
            {
                if (!_path || !_audio)
                    return GReturn::INVALID_ARGUMENT;

                if (_volume < 0.0f || _volume > 1.0f)
                    return GReturn::INVALID_ARGUMENT;

                gAudio = _audio;
                auto audioImplementation = std::dynamic_pointer_cast<GW::I::GAudioImplementation>(*_audio);

                mac_msc = [internal_gw::G_OBJC_GET_CLASS(GMacMusic) alloc];

                internal_gw::G_OBJC_DATA_MEMBERS_TYPE(GMacMusic)& mac_mscDataMembers = internal_gw::G_OBJC_GET_DATA_MEMBERS(GMacMusic, mac_msc);
                mac_mscDataMembers.gMusic = this;
                mac_mscDataMembers.audio = audioImplementation->mac_audio;

                NSString* nsPath = [[[NSString alloc]initWithUTF8String:_path] autorelease];
                internal_gw::G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GMacMusic, mac_msc, initWithPath, nsPath);

                globalMusicVolume = audioImplementation->musicVolume;
                masterVolume = audioImplementation->masterVolume;
                memcpy(masterChannelVolumes, audioImplementation->musicChannelVolumes, 6 * sizeof(float));

                GReturn result = SetVolume(_volume);
                if (result != GReturn::SUCCESS)
                    return result;

                result = SetChannelVolumes(channelVolumes, 6);
                if (result != GReturn::SUCCESS)
                    return result;

                result = GThreadSharedImplementation::Create();
                if (result != GReturn::SUCCESS)
                    return result;

                result = gConcurrent.Create(true);
                if (result != GReturn::SUCCESS) // Events are suppressed
                    return result;

                return gReceiver.Create(_audio, [&]()
                {
                    GW::GEvent gEvent;
                    GW::AUDIO::GAudio::Events audioEvent;
                    GW::AUDIO::GAudio::EVENT_DATA audioEventData;
                    // Process the event message
                    gReceiver.Pop(gEvent);
                    gEvent.Read(audioEvent);

                    switch (audioEvent)
                    {
                    case GW::AUDIO::GAudio::Events::DESTROY:
                    {
                        //printf("DESTROY RECEIVED IN MUSIC\n");
                        // If GAudio is destroyed, the sound is no longer operational
                        Destroy();
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::PLAY_MUSIC:
                    {
                        Play();
                        //bool playing;
                        //isPlaying(playing);
                        //printf("MUSIC PLAY %d\n", playing);
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::PAUSE_MUSIC:
                    {
                        Pause();
                        //bool playing;
                        //isPlaying(playing);
                        //printf("MUSIC PAUSE %d\n", !playing);
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::RESUME_MUSIC:
                    {
                        Resume();
                        //bool playing;
                        //isPlaying(playing);
                        //printf("MUSIC RESUME %d\n", playing);
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::STOP_MUSIC:
                    {
                        Stop();
                        //bool playing;
                        //isPlaying(playing);
                        //printf("MUSIC STOP: %d\n", !playing);
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::MASTER_VOLUME_CHANGED:
                    {
                        gEvent.Read(audioEventData);
                        masterVolume = audioEventData.channelVolumes[0];
                        // Update the current volume with a new master volume
                        SetVolume(volume);
                        //printf("MASTER_VOLUME: %f | VOLUME: %f\n", masterVolume, volume * globalMusicVolume * masterVolume);
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::MUSIC_VOLUME_CHANGED:
                    {
                        gEvent.Read(audioEventData);
                        globalMusicVolume = audioEventData.channelVolumes[0];
                        // Update the current volume with a new master volume
                        SetVolume(volume);
                        //printf("GLOBAL MUSIC VOLUME: %f | VOLUME: %f\n", globalMusicVolume, volume * globalMusicVolume * masterVolume);
                        break;
                    }
                    case GW::AUDIO::GAudio::Events::MUSIC_CHANNEL_VOLUMES_CHANGED:
                    {
                        gEvent.Read(audioEventData);
                        memcpy(masterChannelVolumes, audioEventData.channelVolumes, audioEventData.numOfChannels * sizeof(float));
                        SetChannelVolumes(channelVolumes, audioEventData.numOfChannels);
                        //printf("MUSIC CHANNEL VOLUMES: { %f, %f, %f, %f, %f, %f }\n", channelVolumes[0] * masterChannelVolumes[0], channelVolumes[1] * masterChannelVolumes[1], channelVolumes[2] * masterChannelVolumes[2], channelVolumes[3] * masterChannelVolumes[3], channelVolumes[4] * masterChannelVolumes[4], channelVolumes[5] * masterChannelVolumes[5]);
                        break;
                    }
                    default:
                    {
                        break;
                    }
                    }
                });
            }

            GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                if (_numChannels == 0 || _numChannels > 6 || _values == nullptr)
                    return GReturn::INVALID_ARGUMENT;

                float resultChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f };
                for (unsigned int i = 0; i < _numChannels; i++)
                {
                    if (_values[i] < 0.0f)
                        return GReturn::INVALID_ARGUMENT;

                    // apply clamping
                    channelVolumes[i] = (_values[i] > 1.0f) ? 1.0f : _values[i];
                    // apply master channel volumes
                    resultChannelVolumes[i] = channelVolumes[i] * masterChannelVolumes[i];
                }

                bool result = internal_gw::G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GMacMusic, mac_msc, SetChannelVolumes, resultChannelVolumes, _numChannels);

                return result == true ? GReturn::SUCCESS : GReturn::FAILURE;
            }

            GReturn SetVolume(float _newVolume) override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                if (_newVolume < 0.0f)
                    return GReturn::INVALID_ARGUMENT;

                // Clip the passed volume to max
                volume = (_newVolume > 1.0f) ? 1.0f : _newVolume;

                // Apply master volume ratios to the music volume (Doesn't need to be normalized, since result is always < 1.0f)
                bool result = internal_gw::G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GMacMusic, mac_msc, SetVolume, volume * globalMusicVolume * masterVolume);

                return result == true ? GReturn::SUCCESS : GReturn::FAILURE;
            }

            GReturn Play(bool _loop = false) override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                internal_gw::G_OBJC_DATA_MEMBERS_TYPE(GMacMusic)& mac_mscDataMembers = internal_gw::G_OBJC_GET_DATA_MEMBERS(GMacMusic, mac_msc);
                if (mac_mscDataMembers.isPlaying == true)
                {
                    if (-Stop())
                        return GReturn::FAILURE;
                }

                if (internal_gw::G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GMacMusic, mac_msc, Play, _loop) == false)
                    return GReturn::FAILURE;


                gConcurrent.BranchSingular([&]()
                {
                    if (mac_msc)
                        internal_gw::G_OBJC_CALL_METHOD(GMacMusic, mac_msc, Stream);
                    else return;
                });

                return GReturn::SUCCESS;
            }

            GReturn Pause() override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                bool result = internal_gw::G_OBJC_CALL_METHOD(GMacMusic, mac_msc, Pause);

                return result == true ? GReturn::SUCCESS : GReturn::FAILURE;
            }

            GReturn Resume() override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                bool result = internal_gw::G_OBJC_CALL_METHOD(GMacMusic, mac_msc, Resume);

                return result == true ? GReturn::SUCCESS : GReturn::FAILURE;
            }

            GReturn Stop() override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                bool result = internal_gw::G_OBJC_CALL_METHOD(GMacMusic, mac_msc, Stop);

                return result == true ? GReturn::SUCCESS : GReturn::FAILURE;
            }

            GReturn GetSourceChannels(unsigned int& returnedChannelNum) const override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                returnedChannelNum = internal_gw::G_OBJC_CALL_METHOD(GMacMusic, mac_msc, GetChannels);
                return GReturn::SUCCESS;
            }

            GReturn GetOutputChannels(unsigned int& returnedChannelNum) const override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                returnedChannelNum = G_NUM_OF_OUTPUTS;
                return GReturn::SUCCESS;
            }

            GReturn isPlaying(bool& _returnedBool) const override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                internal_gw::G_OBJC_DATA_MEMBERS_TYPE(GMacMusic)& mac_mscDataMembers = internal_gw::G_OBJC_GET_DATA_MEMBERS(GMacMusic, mac_msc);
                _returnedBool = mac_mscDataMembers.isPlaying;
                return GReturn::SUCCESS;
            }

            // ThreadShared
            GReturn LockAsyncRead() const override
            {
                return GThreadSharedImplementation::LockAsyncRead();
            }

            GReturn UnlockAsyncRead() const override
            {
                return GThreadSharedImplementation::UnlockAsyncRead();
            }

            GReturn LockSyncWrite() override
            {
                return GThreadSharedImplementation::LockSyncWrite();
            }

            GReturn UnlockSyncWrite() override
            {
                return GThreadSharedImplementation::UnlockSyncWrite();
            }
        };
    }// end I
}// end GW

namespace internal_gw
{
    // GMacMusic Implementation

    G_OBJC_IMPLEMENTATION_DATA_MEMBERS_PROPERTY_METHOD(GMacMusic);

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacMusic, id, initWithPath, NSString* _path)
    {
        self = [self init];

        if (self)
        {
            G_OBJC_DATA_MEMBERS_TYPE(GMacMusic)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GMacMusic, self);
            selfDataMembers.player = [[AVAudioPlayerNode alloc]init];
            [selfDataMembers.audio->engine attachNode : selfDataMembers.player] ;

            NSURL* filePath = [[NSURL alloc]initFileURLWithPath:_path];
            selfDataMembers.file = [[AVAudioFile alloc]initForReading:filePath commonFormat : AVAudioPCMFormatFloat32 interleaved : false error : nil];
            [filePath release] ;
            selfDataMembers.buffers[0] = [[AVAudioPCMBuffer alloc]initWithPCMFormat:[selfDataMembers.file processingFormat] frameCapacity : G_STREAMING_BUFFER_SIZE];
            selfDataMembers.buffers[1] = [[AVAudioPCMBuffer alloc]initWithPCMFormat:[selfDataMembers.file processingFormat] frameCapacity : G_STREAMING_BUFFER_SIZE];
            selfDataMembers.buffers[2] = [[AVAudioPCMBuffer alloc]initWithPCMFormat:[selfDataMembers.file processingFormat] frameCapacity : G_STREAMING_BUFFER_SIZE];

            AudioComponentDescription mixerDesc;
            mixerDesc.componentType = kAudioUnitType_Mixer;
            mixerDesc.componentSubType = kAudioUnitSubType_MatrixMixer;
            mixerDesc.componentManufacturer = kAudioUnitManufacturer_Apple;
            mixerDesc.componentFlags = kAudioComponentFlag_SandboxSafe;
            mixerDesc.componentFlagsMask = 0;

            selfDataMembers.matrixMixerNode = nullptr;
            [AVAudioUnit instantiateWithComponentDescription : mixerDesc options : kAudioComponentInstantiation_LoadInProcess completionHandler :
            ^ (__kindof AVAudioUnit * _Nullable mixerUnit, NSError * _Nullable error)
            {
                selfDataMembers.matrixMixerNode = mixerUnit;
                [selfDataMembers.audio->engine attachNode : selfDataMembers.matrixMixerNode] ;
            }] ;

            while (!selfDataMembers.matrixMixerNode)
            {
                usleep(100); // waiting for the completionHandler to finish
            }

            // Give the mixer one input bus and one output bus
            UInt32 inBuses = 1;
            UInt32 outBuses = 1;
            AudioUnitSetProperty(selfDataMembers.matrixMixerNode.audioUnit, kAudioUnitProperty_ElementCount, kAudioUnitScope_Input, 0, &inBuses, sizeof(UInt32));
            AudioUnitSetProperty(selfDataMembers.matrixMixerNode.audioUnit, kAudioUnitProperty_ElementCount, kAudioUnitScope_Output, 0, &outBuses, sizeof(UInt32));

            // Set the mixer's input format to have the correct number of channels
            AudioStreamBasicDescription mixerFormatIn;
            UInt32 size;
            AudioUnitGetProperty(selfDataMembers.matrixMixerNode.audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &mixerFormatIn, &size);
            mixerFormatIn.mChannelsPerFrame = G_NUM_OF_OUTPUTS;
            AudioUnitSetProperty(selfDataMembers.matrixMixerNode.audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &mixerFormatIn, size);

            // Set the mixer's output format to have the correct number of channels
            AudioStreamBasicDescription mixerFormatOut;
            AudioUnitGetProperty(selfDataMembers.matrixMixerNode.audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, 0, &mixerFormatOut, &size);
            mixerFormatOut.mChannelsPerFrame = G_NUM_OF_OUTPUTS;
            AudioUnitSetProperty(selfDataMembers.matrixMixerNode.audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, 0, &mixerFormatOut, size);

            AVAudioFormat* audioFormat;
            if (selfDataMembers.buffers[0].format.channelCount == 1) // for mono sounds
                audioFormat = [[AVAudioFormat alloc]
                initWithCommonFormat:AVAudioPCMFormatFloat32 sampleRate : selfDataMembers.buffers[0].format.sampleRate channels : 1 interleaved : false];
            // Attempt to use more than 2 channels instead of default format
            else
                audioFormat = [[AVAudioFormat alloc]
                initWithCommonFormat:AVAudioPCMFormatFloat32 sampleRate : selfDataMembers.buffers[0].format.sampleRate channels : G_NUM_OF_OUTPUTS interleaved : false];

            [selfDataMembers.audio->engine connect : selfDataMembers.player to : selfDataMembers.audio->engine.mainMixerNode format : audioFormat] ;
            [audioFormat release] ;

            selfDataMembers.bufferCondition = [[NSCondition alloc]init];
            selfDataMembers.CurrentPosition = 0;
            selfDataMembers.MaxPosition = 0;
            selfDataMembers.currentBufferIndex = 0;
            selfDataMembers.index = 0;
            selfDataMembers.buffersQueued = 0;
            selfDataMembers.stopFlag = false;
            selfDataMembers.loops = false;
            selfDataMembers.isPlaying = false;
            selfDataMembers.isPaused = false;
            selfDataMembers.MaxPosition = selfDataMembers.file.length;
        }

        return self;
    }

    G_OBJC_HEADER_INSTANCE_METHOD(GMacMusic, unsigned int, GetChannels)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GMacMusic)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GMacMusic, self);

        if (!selfDataMembers.player)
            return 0;

        return[selfDataMembers.file processingFormat].channelCount;
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacMusic, bool, SetChannelVolumes, float* _volumes, unsigned int _numChannels)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GMacMusic)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GMacMusic, self);

        if (!selfDataMembers.player)
            return false;

        if (_numChannels > 1)
        {
            float newVal = 0.0f;
            float sumChannels = 0.0f;
            for (int i = 0; i < _numChannels; i++)
            {
                // total of all channels
                sumChannels += _volumes[i];
                // channels 0 and 4 are left channels which have pan of -1
                if (i == 0 || i == 4)
                    newVal += _volumes[i] * -1.0f;
                // skip 2 and 3, since center channels have pan of 0
                else if (i == 1 || i == 5)
                    newVal += _volumes[i];
            }
            selfDataMembers.gMusic->LockSyncWrite();
            // obtain average and set the panning (sum has to be greater than 1 to apply clamping)
            selfDataMembers.player.pan = (sumChannels > 1.0f) ? (newVal / sumChannels) : newVal;
            selfDataMembers.gMusic->UnlockSyncWrite();
        }
        else
        {
            selfDataMembers.gMusic->LockSyncWrite();
            selfDataMembers.player.pan = -1 * _volumes[0];
            selfDataMembers.gMusic->UnlockSyncWrite();
        }

        return true;
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacMusic, bool, SetVolume, float _newVolume)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GMacMusic)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GMacMusic, self);

        if (!selfDataMembers.player)
            return false;

        selfDataMembers.gMusic->LockSyncWrite();
        [selfDataMembers.player setVolume : (_newVolume)] ;
        float check = [selfDataMembers.player volume];
        selfDataMembers.gMusic->UnlockSyncWrite();

        if (check == _newVolume)
            return true;

        return false;
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GMacMusic, bool, Play, bool _loops)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GMacMusic)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GMacMusic, self);

        if (!selfDataMembers.player)
            return false;

        selfDataMembers.loops = _loops;
        if (selfDataMembers.isPlaying == false)
        {
            selfDataMembers.CurrentPosition = 0;
            selfDataMembers.file.framePosition = 0;
            [selfDataMembers.player playAtTime : 0] ;
        }

        selfDataMembers.isPlaying = true;
        selfDataMembers.isPaused = false;
        selfDataMembers.stopFlag = false;

        return[selfDataMembers.player isPlaying];
    }

    G_OBJC_HEADER_INSTANCE_METHOD(GMacMusic, bool, Pause)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GMacMusic)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GMacMusic, self);

        if (!selfDataMembers.player)
            return false;

        [selfDataMembers.player pause] ;
        selfDataMembers.isPlaying = false;
        selfDataMembers.isPaused = true;

        return ![selfDataMembers.player isPlaying];
    }

    G_OBJC_HEADER_INSTANCE_METHOD(GMacMusic, bool, Resume)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GMacMusic)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GMacMusic, self);

        if (!selfDataMembers.player)
            return false;

        if (selfDataMembers.isPaused == true)
            [selfDataMembers.player play];

        selfDataMembers.isPlaying = true;
        selfDataMembers.isPaused = false;

        return[selfDataMembers.player isPlaying];
    }

    G_OBJC_HEADER_INSTANCE_METHOD(GMacMusic, bool, Stop)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GMacMusic)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GMacMusic, self);

        if (!selfDataMembers.player)
            return false;

        selfDataMembers.stopFlag = true;
        [selfDataMembers.player stop] ;
        [selfDataMembers.player prepareWithFrameCount : G_STREAMING_BUFFER_SIZE] ;
        // Reset to the start of the sample
        selfDataMembers.CurrentPosition = 0;
        selfDataMembers.buffersQueued = 0;

        selfDataMembers.isPlaying = false;
        selfDataMembers.isPaused = false;

        selfDataMembers.gMusic->gConcurrent.Converge(0);
        return ![selfDataMembers.player isPlaying];
    }

    G_OBJC_HEADER_INSTANCE_METHOD(GMacMusic, void, Stream)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GMacMusic)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GMacMusic, self);

        while (selfDataMembers.stopFlag == false)
        {
            NSError* testError = nil;
            AVAudioFrameCount valid = MIN(G_STREAMING_BUFFER_SIZE, selfDataMembers.MaxPosition - selfDataMembers.CurrentPosition > 0 ? selfDataMembers.MaxPosition - selfDataMembers.CurrentPosition : selfDataMembers.CurrentPosition);
            selfDataMembers.CurrentPosition += valid;

            AVAudioPCMBuffer* currentBuffer = selfDataMembers.buffers[selfDataMembers.currentBufferIndex];
            [selfDataMembers.file readIntoBuffer : currentBuffer frameCount : valid error : &testError] ;

            [selfDataMembers.bufferCondition lock] ;
            while (selfDataMembers.stopFlag == false && selfDataMembers.buffersQueued >= 2)
            {
                //sleep(1); // slows down the thread during waiting time
                [selfDataMembers.bufferCondition wait] ;
            }
            ++selfDataMembers.buffersQueued;
            [selfDataMembers.bufferCondition unlock] ;


            [selfDataMembers.player scheduleBuffer : currentBuffer completionHandler : ^ {
                [selfDataMembers.bufferCondition lock] ;
                --selfDataMembers.buffersQueued;
                if (selfDataMembers.stopFlag == true || selfDataMembers.buffersQueued < 2)
                    [selfDataMembers.bufferCondition signal];
                [selfDataMembers.bufferCondition unlock] ;
            }] ;

            if (++selfDataMembers.currentBufferIndex >= G_MAX_BUFFER_COUNT)
                selfDataMembers.currentBufferIndex = 0;

            //This following code is similar to needed code down below in an attempt to stop
            if (valid != G_STREAMING_BUFFER_SIZE)
            {
                if (selfDataMembers.loops)
                {
                    selfDataMembers.CurrentPosition = 0;
                    selfDataMembers.file.framePosition = 0;
                }
            }

            //checks if we are at end of the song
            if (selfDataMembers.CurrentPosition >= selfDataMembers.MaxPosition)
            {
                //if looping reset file pointer and our current position
                if (selfDataMembers.loops)
                {
                    selfDataMembers.CurrentPosition = 0;
                    selfDataMembers.file.framePosition = 0;
                }
                else if (selfDataMembers.buffersQueued == 0 && selfDataMembers.stopFlag == false)
                {
                    G_OBJC_CALL_METHOD(GMacMusic, self, Stop);
                    return;
                }
            }
        }
    }

    G_OBJC_HEADER_INSTANCE_METHOD(GMacMusic, bool, Unload)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GMacMusic)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GMacMusic, self);

        bool macresult = false;
        if (selfDataMembers.player != nil)
        {
            G_OBJC_CALL_METHOD(GMacMusic, self, Stop);
            [selfDataMembers.player release] ;
            selfDataMembers.player = nil;
            macresult = true;
        }

        // Cleans up memory in the autorelease pool
        [self autorelease] ;
        return macresult;
    }

    // GMacMusic Implementation End
}

#undef G_NUM_OF_OUTPUTS
#undef G_STREAMING_BUFFER_SIZE
#undef G_MAX_BUFFER_COUNT


#elif defined(__linux__)
    #include <pulse/mainloop.h>
#include <pulse/thread-mainloop.h>
#include <pulse/mainloop-api.h>
#include <pulse/channelmap.h>
#include <pulse/context.h>
#include <pulse/volume.h>
#include <pulse/stream.h>
#include <pulse/error.h>
#include <pulse/scache.h>
#include <pulse/introspect.h>

#include <thread>

#define G_NUM_OF_OUTPUTS 2 // Currently set to forced Stereo
#define G_STREAMING_BUFFER_SIZE 65536
#define G_MAX_BUFFER_COUNT 3

namespace GW
{
    namespace I
    {
        class GMusicImplementation : public virtual GMusicInterface,
            protected GThreadSharedImplementation
        {
			/* this enum is here to prevent compiler warning -Wmultichar
			 * previously, this file used a series of #defines that caused
			 * the warning to occur in a switch statement later on. So instead
			 * of the #defines (initiallizing an int to a series of 4 chars), 
			 * i just declare them here to be the integer they would be 
			 * interpreted as by the compiler internally. */
			enum WaveTag {
				RIFF = 1179011410, // = 'FFIR'
				DATA = 1635017060, // = 'atad'
				FMT  =  544501094, // = ' tmf'
				WAVE = 1163280727, // = 'EVAW'
				JUNK = 1263424842, // = 'KNUJ'
				XWMA = 1095587672, // = 'AMWX'
				DPDS = 1935962212  // = 'sdpd'
			};
			
            struct PCM_FORMAT_INFO
            {
                unsigned short mFormatTag = 0;
                unsigned short mNumChannels = 0;
                unsigned int mSamples = 0;
                unsigned int mAvgBytesPerSec = 0;
                unsigned short mBlockAlign = 0;
                unsigned short mBitsPerSample = 0;
                unsigned short mCbSize = 22;
            };

            std::atomic_bool atomic_isPlaying;
            std::atomic_bool atomic_isPaused;
            std::atomic_bool atomic_isComplete;
            std::atomic_bool atomic_stopFlag;
            std::atomic_bool atomic_loops;
            std::atomic<int> pa_ready;
            float masterVolume = 1.0f; // global master volume
            float globalMusicVolume = 1.0f; // global music volume
            float volume = 1.0f; // volume of this music
            uint32_t sinkIndex = UINT32_MAX;
            unsigned int numOfChannels = 0;
            unsigned long fileSize = 0;
			unsigned long audioDataOffset = 0;

            pa_channel_map* myMap = nullptr;
            pa_stream* myStream = nullptr;
            pa_threaded_mainloop* myMainLoop = nullptr;
            pa_context* myContext = nullptr;
            pa_sample_format myPulseFormat;
            pa_cvolume vol;

            char* filePath = nullptr;
            float       channelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f }; // channel volumes of this sound
            float masterChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f }; // global master volumes
            GW::AUDIO::GAudio gAudio;
            GW::CORE::GEventReceiver gReceiver;
            GW::SYSTEM::GConcurrent gConcurrent;
            PCM_FORMAT_INFO myPCMFormat;
            char buffers[G_MAX_BUFFER_COUNT][G_STREAMING_BUFFER_SIZE];

            void Destroy()
            {
                if (myMainLoop) pa_threaded_mainloop_lock(myMainLoop);
				{
					// Disconnects and decrements/unreferences the stream
					if (myStream)
					{
						pa_stream_disconnect(myStream);
						pa_stream_unref(myStream);
						myStream = nullptr;
					}
					
					// Disconnects and decrements/unreferences the context
					if (myContext)
					{
						pa_context_disconnect(myContext);
						pa_context_unref(myContext);
						myContext = nullptr;
					}					
				}
				if (myMainLoop) pa_threaded_mainloop_unlock(myMainLoop);

                // Stops the mainloop (after the context is disconnected) and releases memory
                if (myMainLoop)
                {
                    pa_threaded_mainloop_stop(myMainLoop);
                    pa_threaded_mainloop_free(myMainLoop);
                    myMainLoop = nullptr;
                }

                if (filePath)
                {
                    delete[] filePath;
                    filePath = nullptr;
                }
            }

            GReturn LoadOnlyWaveHeaderData(const char* path, PCM_FORMAT_INFO& returnedInfo)
            {
				// default the return value
				GReturn result = GReturn::SUCCESS;
				
				// create our gfile object
				GW::SYSTEM::GFile file;
				file.Create();

				// open the audio file in binary read mode. wav is a binary format with tags that can be interpreted as text
				if (-file.OpenBinaryRead(path)) {
					result = GReturn::FILE_NOT_FOUND;
					return result;
				}
				
				// variables for determinning data information
                unsigned long dwChunktype = 0;
                unsigned long dwChunkDataSize = 0;
                unsigned long dwRiffDataSize = 0;
                unsigned long dwFileType = 0;
				unsigned long dwIsWave = 0;
                unsigned long throwAwayValue = 0;
				bool foundAudioData = false;

                while (result == GReturn::SUCCESS && foundAudioData == false)
				{
					if (-file.Read(reinterpret_cast<char*>(&dwChunktype), 4)) {
						// could not aquire chunk type
						result = GReturn::FAILURE;
						break;
					}

					if (-file.Read(reinterpret_cast<char*>(&dwChunkDataSize), 4)) {
						// could not aquire chunk size
						result = GReturn::FAILURE;
						break;
					}

					switch (dwChunktype) {
						case WaveTag::RIFF:
						{
							dwRiffDataSize = dwChunkDataSize;
							dwChunkDataSize = 4;
							if (-file.Read(reinterpret_cast<char*>(&dwFileType), dwChunkDataSize)) {
								// could not aquire the file type
								result = GReturn::FAILURE;
								break;
							}
							break;
						}
						
						case WaveTag::WAVE:
						{
							if (-file.Read(reinterpret_cast<char*>(&dwIsWave), dwChunkDataSize)) {
								// the file is not a wav file
								result = GReturn::FAILURE;
								break;
							}
							break;
						}
						
						case WaveTag::FMT:
						{
							if (-file.Read(reinterpret_cast<char*>(&returnedInfo.mFormatTag), dwChunkDataSize)) {
								// could not read the chunk data
								result = GReturn::FAILURE;
								break;
							}
							break;
						}
						
						case WaveTag::DATA:
						{
							foundAudioData = true; // audio data is the last part of the file. stop looping
							break;
						}
						
						default:
						{
							char* pBogusData = new char[dwChunkDataSize];
							if (-file.Read(pBogusData, dwChunkDataSize)) {
								// something unknown happened that caused the data to not be read
								result = GReturn::FAILURE;
							}
							delete[] pBogusData;
							break;
						}
					}
				}
				file.CloseFile();
				return result;
			}
			
			GReturn FindStreamData(const char* path, unsigned long& outDataChunkSize, unsigned long& outOffset)
			{
				// default the return value
				GReturn result = GReturn::SUCCESS;

				// create our gfile object
				GW::SYSTEM::GFile file;
				file.Create();

				// open the audio file in binary read mode. wav is a binary format with tags that can be interpreted as text
				if (-file.OpenBinaryRead(path)) {
					result = GReturn::FILE_NOT_FOUND;
					return result;
				}

				unsigned long dwChunkType = 0;
				unsigned long dwChunkDataSize = 0;
				unsigned long bytesRead = 0;
				bool foundAudioData = false;

				while (result == GReturn::SUCCESS && foundAudioData == false) {
					if (-file.Read(reinterpret_cast<char*>(&dwChunkType), 4)) {
						// could not aquire chunk type
						result = GReturn::FAILURE;
						break;
					}
					bytesRead += 4;

					if (-file.Read(reinterpret_cast<char*>(&dwChunkDataSize), 4)) {
						// could not aquire chunk size
						result = GReturn::FAILURE;
						break;
					}
					bytesRead += 4;

					switch (dwChunkType) {
						case WaveTag::DATA:
						{
							outDataChunkSize = dwChunkDataSize;	// contains size of the audio buffer in bytes
							outOffset = bytesRead;				// Sets the offset to where we are
							foundAudioData = true;				// We found the data, now exit the function
							break;
						}
						
						case WaveTag::RIFF:
							dwChunkDataSize = 4;
						default:
						{
							char* pBogusData = new char[dwChunkDataSize];
							if (-file.Read(pBogusData, dwChunkDataSize)) {
								// could not read
								result = GReturn::FAILURE;
							}
							delete[] pBogusData;
							bytesRead += dwChunkDataSize;
							break;
						}
					}
				}

				file.CloseFile();
				return result;
			}


            // PA Callbacks
            static void OnStateChange(pa_context* _c, void* _data)
            {
                pa_context_state_t state;
                std::atomic<int>* pa_ready = (std::atomic<int>*)_data;
				
                state = pa_context_get_state(_c);

                switch (state)
                {
                    case PA_CONTEXT_UNCONNECTED:
                    {
                        break;
                    }
                    case PA_CONTEXT_CONNECTING:
                    {
                        break;
                    }
                    case PA_CONTEXT_AUTHORIZING:
                    {
                        break;
                    }
                    case PA_CONTEXT_SETTING_NAME:
                    {
                        break;
                    }
                    case PA_CONTEXT_FAILED:
                    {
                        *pa_ready = -1;
                        break;
                    }
                    case PA_CONTEXT_TERMINATED:
                    {
                        *pa_ready = -1;
                        break;
                    }
                    case PA_CONTEXT_READY:
                    {
                        *pa_ready = 1;
                        break;
                    }
                }
            }

            static void FinishedDrainOp(pa_stream* s, int success, void* userdata)
            {
                GMusicImplementation* impl = reinterpret_cast<GMusicImplementation*>(userdata);
                impl->atomic_isComplete = true;
            }
			
			char* CreateFilePath(const char* _constCharArray)
			{
				int size = 0;
				for (; size < 1024; ++size)
				{
					if (_constCharArray[size] == '\0')
					{
						++size;
						break;
					}
				}

				if (size >= 1024)
					return nullptr;

				char* charArray = new char[size];
				memcpy(charArray, _constCharArray, size); // char is 1 byte

				return charArray;
			}

        public:
            virtual ~GMusicImplementation()
            {
                Stop();
                LockSyncWrite();
                Destroy();
                UnlockSyncWrite();
            }

            GReturn Create(const char* _path, GW::AUDIO::GAudio _audio, float _volume = 1.0f)
            {
                if (!_path || !_audio)
                    return GReturn::INVALID_ARGUMENT;

                if (_volume < 0.0f || _volume > 1.0f)
                    return GReturn::INVALID_ARGUMENT;
					
				filePath = CreateFilePath(_path);
				// if _path is > 1024 chars
				if (filePath == nullptr)
					return GReturn::INVALID_ARGUMENT;

                GReturn result = GThreadSharedImplementation::Create();
                if (result != GReturn::SUCCESS)
                    return result;

                gAudio = _audio;
                auto audioImplementation = std::dynamic_pointer_cast<GW::I::GAudioImplementation>(*_audio);

                if (-LoadOnlyWaveHeaderData(_path, myPCMFormat))
                    return GReturn::FAILURE;

                int len = strlen(_path) + 1;
                filePath = new char[len];
                strncpy(filePath, _path, len);

                myMainLoop = pa_threaded_mainloop_new();

                if (myMainLoop == NULL)
                    return GReturn::FAILURE;

				pa_threaded_mainloop_lock(myMainLoop);
				{
					myContext = pa_context_new(pa_threaded_mainloop_get_api(myMainLoop), "Sound");

					if (myContext == NULL)
					{
						pa_threaded_mainloop_unlock(myMainLoop);
						return GReturn::FAILURE;
					}
					
					pa_ready = 0;
					pa_context_connect(myContext, NULL, PA_CONTEXT_NOFLAGS, NULL);
					pa_context_set_state_callback(myContext, OnStateChange, &pa_ready);				
				}
				pa_threaded_mainloop_unlock(myMainLoop);

                pa_threaded_mainloop_start(myMainLoop);

                while (pa_ready == 0)
                    std::this_thread::yield();

                if (pa_ready != 1)
                    return GReturn::FAILURE;

				switch (myPCMFormat.mBitsPerSample)
				{
					case 8:
						myPulseFormat = PA_SAMPLE_U8;
						break;
					case 16:
						myPulseFormat = PA_SAMPLE_S16LE;
						break;
					case 24:
						myPulseFormat = PA_SAMPLE_S24LE;
						break;
					case 32:
						myPulseFormat = (myPCMFormat.mFormatTag > 1) ? PA_SAMPLE_FLOAT32LE : PA_SAMPLE_S32LE; // Float type for IEEE and Signed 32int for PCM
						break;
					default:
						myPulseFormat = PA_SAMPLE_INVALID;
						return GReturn::FAILURE;
						break;
				}

				pa_sample_spec mySampleSpec;
				mySampleSpec.format = myPulseFormat;
				mySampleSpec.rate = myPCMFormat.mSamples;
				mySampleSpec.channels = myPCMFormat.mNumChannels;;
				if (pa_channels_valid(mySampleSpec.channels) == 0)				
					return GReturn::FAILURE;
					
				pa_threaded_mainloop_lock(myMainLoop);
				{
					myMap = new pa_channel_map();
					myMap = pa_channel_map_init_extend(myMap, mySampleSpec.channels, PA_CHANNEL_MAP_WAVEEX);
					if (myMap == nullptr)
					{
						pa_threaded_mainloop_unlock(myMainLoop);
						return GReturn::FAILURE;
					}
					
					myStream = pa_stream_new(myContext, "GMusic", &mySampleSpec, myMap); //myMap
					if (myStream == nullptr)
					{
						pa_threaded_mainloop_unlock(myMainLoop);
						return GReturn::FAILURE;
					}

					if (pa_stream_connect_playback(myStream, NULL, NULL, (pa_stream_flags_t)0, NULL, NULL) != 0)
					{
						pa_threaded_mainloop_unlock(myMainLoop);
						return GReturn::FAILURE;
					}					
				}
				pa_threaded_mainloop_unlock(myMainLoop);

                globalMusicVolume = audioImplementation->musicVolume;
                masterVolume = audioImplementation->masterVolume;
                memcpy(masterChannelVolumes, audioImplementation->musicChannelVolumes, 6 * sizeof(float));

				pa_cvolume_init(&vol);
				
                result = SetVolume(_volume);
                if (result != GReturn::SUCCESS)
                    return result;

                result = gConcurrent.Create(true);
                if (result != GReturn::SUCCESS) // Events are suppressed
                    return result;

                atomic_isComplete = false;

                return gReceiver.Create(_audio, [&]()
                {
                    GW::GEvent gEvent;
                    GW::AUDIO::GAudio::Events audioEvent;
                    GW::AUDIO::GAudio::EVENT_DATA audioEventData;
                    // Process the event message
                    gReceiver.Pop(gEvent);
                    gEvent.Read(audioEvent);

                    switch (audioEvent)
                    {
                        case GW::AUDIO::GAudio::Events::DESTROY:
                        {
                            Stop();
                            LockSyncWrite();
                            Destroy();
                            UnlockSyncWrite();
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::PLAY_MUSIC:
                        {
                            Play();
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::PAUSE_MUSIC:
                        {
                            Pause();
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::RESUME_MUSIC:
                        {
                            Resume();
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::STOP_MUSIC:
                        {
                            Stop();
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::MASTER_VOLUME_CHANGED:
                        {
                            gEvent.Read(audioEventData);
                            masterVolume = audioEventData.channelVolumes[0];
                            // Update the current volume with a new master volume
                            SetVolume(volume);
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::MUSIC_VOLUME_CHANGED:
                        {
                            gEvent.Read(audioEventData);
                            globalMusicVolume = audioEventData.channelVolumes[0];
                            // Update the current volume with a new master volume
                            SetVolume(volume);
                            break;
                        }
                        case GW::AUDIO::GAudio::Events::MUSIC_CHANNEL_VOLUMES_CHANGED:
                        {
                            gEvent.Read(audioEventData);
                            memcpy(masterChannelVolumes, audioEventData.channelVolumes, audioEventData.numOfChannels * sizeof(float));
                            SetChannelVolumes(channelVolumes, audioEventData.numOfChannels);
                            break;
                        }
                        default:
                        {
                            break;
                        }
                    }
                });
            }

            GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                if (_numChannels == 0 || _numChannels > 6 || _values == nullptr)
                    return GReturn::INVALID_ARGUMENT;

                float adjustedVolume = volume * masterVolume * globalMusicVolume;
                for (unsigned int i = 0; i < _numChannels; i++)
                {
                    if (_values[i] < 0.0f)
                        return GReturn::INVALID_ARGUMENT;

                    // 5.1 to stereo fallback
                    if (_numChannels > G_NUM_OF_OUTPUTS)
                    {
                        channelVolumes[i] = (_values[i] > 1.0f) ? 1.0f : _values[i];

                        switch (i)
                        {
                            case 2: // Front Center
                            {
                                channelVolumes[0] += channelVolumes[2] * 0.5f;
                                channelVolumes[1] += channelVolumes[2] * 0.5f;
                                break;
                            }
                            case 3: // LFE
                            {
                                channelVolumes[0] += channelVolumes[3] * 0.3f;
                                channelVolumes[1] += channelVolumes[3] * 0.3f;
                                break;
                            }
                            case 4: // Rear Left
                            {
                                channelVolumes[0] += channelVolumes[4] * 0.7f;
                                break;
                            }
                            case 5: //Rear Right
                            {
                                channelVolumes[1] += channelVolumes[5] * 0.7f;
                                break;
                            }
                        }

                        // clamp stereo to max of 1.0f
                        if (i == _numChannels - 1)
                        {
                            channelVolumes[0] = (channelVolumes[0] > 1.0f) ? 1.0f : channelVolumes[0];
                            channelVolumes[1] = (channelVolumes[1] > 1.0f) ? 1.0f : channelVolumes[1];
							vol.values[0] = pa_sw_volume_from_linear(adjustedVolume * channelVolumes[0] * masterChannelVolumes[0]);
							vol.values[1] = pa_sw_volume_from_linear(adjustedVolume * channelVolumes[1] * masterChannelVolumes[1]);
                            break;
                        }
                    }
                    else
                    {
                        channelVolumes[i] = (_values[i] > 1.0f) ? 1.0f : _values[i];

                        // apply clamping and master volume multiplier
						vol.values[i] = pa_sw_volume_from_linear(adjustedVolume * channelVolumes[i] * masterChannelVolumes[i]);
                    }
                }

                LockSyncWrite();
				while (sinkIndex == UINT32_MAX)
				{
					pa_threaded_mainloop_lock(myMainLoop);
						sinkIndex = pa_stream_get_index(myStream); //Returns the sink resp. source output index this stream is identified in the server with	
					pa_threaded_mainloop_unlock(myMainLoop);
				}
                UnlockSyncWrite();

				vol.channels = G_NUM_OF_OUTPUTS;
					
				pa_threaded_mainloop_lock(myMainLoop);
				{
					//Set the volume of a sink input stream.
					pa_operation* o = pa_context_set_sink_input_volume(myContext, sinkIndex, &vol, NULL, NULL);

					if (!o)
					{
						pa_threaded_mainloop_unlock(myMainLoop);
						return GReturn::FAILURE;
					}

					pa_operation_unref(o);
				}
				pa_threaded_mainloop_unlock(myMainLoop);

                return GReturn::SUCCESS;
            }

            GReturn SetVolume(float _newVolume) override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                if (_newVolume < 0.0f)
                    return GReturn::INVALID_ARGUMENT;

                // Clip the passed volume to max
                _newVolume = (_newVolume > 1.0f) ? 1.0f : _newVolume;
                volume = _newVolume;

                // Apply master volume ratio to the sound volume (Doesn't need to be normalized, since masterVolume is always < 1.0f)
                _newVolume *= masterVolume * globalMusicVolume;			
				vol.channels = G_NUM_OF_OUTPUTS;
				for (int i = 0; i < vol.channels; ++i)
					vol.values[i] = pa_sw_volume_from_linear(_newVolume * channelVolumes[i] * masterChannelVolumes[i]);

                LockSyncWrite();
				while (sinkIndex == UINT32_MAX)
				{
					pa_threaded_mainloop_lock(myMainLoop);
						sinkIndex = pa_stream_get_index(myStream); //Returns the sink resp. source output index this stream is identified in the server with
					pa_threaded_mainloop_unlock(myMainLoop);
				}					
                UnlockSyncWrite();
                
                //Set the volume of a sink input stream.
				pa_threaded_mainloop_lock(myMainLoop);
				{
					pa_operation* o = pa_context_set_sink_input_volume(myContext, sinkIndex, &vol, NULL, NULL);

					if (!o)
					{						
						pa_threaded_mainloop_unlock(myMainLoop);
						return GReturn::FAILURE;
					}

					pa_operation_unref(o);
				}
				pa_threaded_mainloop_unlock(myMainLoop);

                return GReturn::SUCCESS;
            }

            GReturn Play(bool _loop = false) override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;
                    
                atomic_loops = _loop;

                if (atomic_isPlaying || atomic_isComplete)
                {
                    GReturn result = Stop();

                    if (result != GReturn::SUCCESS)
                        return result;
                }

                if (atomic_isPlaying == false)
                {
                    atomic_stopFlag = false;
                    atomic_isPaused = false;
                    atomic_isPlaying = true;
					
                    gConcurrent.BranchSingular([&]() {
                        unsigned short CurrentDiskReadBuffer = 0;
						unsigned long CurrentPosition = 0;

						if (-FindStreamData(filePath, fileSize, audioDataOffset))
							return GReturn::FAILURE;
						
                        // probably safer to do this after the call to FindStreamData because that function creates its own GFile from the same path
						GW::SYSTEM::GFile gfile;
						gfile.Create();
						
						if (-gfile.OpenBinaryRead(filePath)) {
							// file could not be opened
							return GReturn::FAILURE;
						}

						// seek to the start of the audio stream data
						unsigned int unusedPosition; // unused variable but needed for the next function
						gfile.Seek(0, audioDataOffset, unusedPosition);
						
                        pa_stream_state_t state;
						
                        while (CurrentPosition < fileSize) {
                            if (atomic_stopFlag == true) {
								pa_threaded_mainloop_lock(myMainLoop);
									pa_stream_cancel_write(myStream);
								pa_threaded_mainloop_unlock(myMainLoop);
                                break;
                            }
                            else {
                                pa_threaded_mainloop_lock(myMainLoop);
									state = pa_stream_get_state(myStream);
                                pa_threaded_mainloop_unlock(myMainLoop);

                                if (state == PA_STREAM_READY)
                                {
									unsigned long cbValid = (G_STREAMING_BUFFER_SIZE < (fileSize - CurrentPosition))
										? G_STREAMING_BUFFER_SIZE // if less
										: (fileSize - CurrentPosition); // if greater or equal
										
									// should already be at the correct offset. just have to read the data in now
									if (-gfile.Read(buffers[CurrentDiskReadBuffer], cbValid))
										continue;
									
									CurrentPosition += cbValid;
									
									if (CurrentPosition >= fileSize)
                                    {
										if (atomic_loops)
										{
											pa_threaded_mainloop_lock(myMainLoop);
												pa_stream_write(myStream, buffers[CurrentDiskReadBuffer], cbValid, nullptr, 0, PA_SEEK_RELATIVE);
											pa_threaded_mainloop_unlock(myMainLoop);
											
											++CurrentDiskReadBuffer %= G_MAX_BUFFER_COUNT;
											CurrentPosition = 0;
											
											// read until we get to the start of the audio stream data
											gfile.Seek(0, audioDataOffset, unusedPosition);
											
											continue;
										}
										else
										{
											pa_threaded_mainloop_lock(myMainLoop);
											{
												pa_operation* o = pa_stream_drain(myStream, FinishedDrainOp, this);

												if (o)
													pa_operation_unref(o);												
											}
											pa_threaded_mainloop_unlock(myMainLoop);
											break;
										}
                                    }
                                    else
                                    {
										pa_threaded_mainloop_lock(myMainLoop);
											pa_stream_write(myStream, buffers[CurrentDiskReadBuffer], cbValid, nullptr, 0, PA_SEEK_RELATIVE);
										pa_threaded_mainloop_unlock(myMainLoop);
										
										++CurrentDiskReadBuffer %= G_MAX_BUFFER_COUNT;
                                    }
                                }
                            }
                        }
                        gfile.CloseFile();

                        // This needs to be reset so it doesn't remember where it left off playing
                        audioDataOffset = 0;

                        // Updates information about playback state
                        atomic_isPlaying = false;
                        atomic_isPaused = false;
                        atomic_isComplete = true;

                        return GReturn::SUCCESS;
                    });
                }
                return GReturn::SUCCESS;
            }

            GReturn Pause() override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                atomic_isPaused = true;
                atomic_isPlaying = false;

                return GReturn::SUCCESS;
            }

            GReturn Resume() override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                atomic_isPaused = false;
                atomic_isPlaying = true;

                return GReturn::SUCCESS;
            }

            GReturn Stop() override
            {
                atomic_isPlaying = false;
                atomic_isPaused = false;
                atomic_isComplete = false;
                atomic_stopFlag = true;

                gConcurrent.Converge(0);

                // Converge has to run before return
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                return GReturn::SUCCESS;
            }

            GReturn GetSourceChannels(unsigned int& returnedChannelNum) const override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                returnedChannelNum = myPCMFormat.mNumChannels;
                return GReturn::SUCCESS;
            }

            GReturn GetOutputChannels(unsigned int& returnedChannelNum) const override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                returnedChannelNum = G_NUM_OF_OUTPUTS; // forced Stereo
                return GReturn::SUCCESS;
            }

            GReturn isPlaying(bool& _returnedBool) const override
            {
                if (!gAudio)
                    return GReturn::PREMATURE_DEALLOCATION;

                _returnedBool = atomic_isPlaying;
                return GReturn::SUCCESS;
            }

        protected:
            // ThreadShared
            GReturn LockAsyncRead() const override
            {
                return GThreadSharedImplementation::LockAsyncRead();
            }

            GReturn UnlockAsyncRead() const override
            {
                return GThreadSharedImplementation::UnlockAsyncRead();
            }

            GReturn LockSyncWrite() override
            {
                return GThreadSharedImplementation::LockSyncWrite();
            }

            GReturn UnlockSyncWrite() override
            {
                return GThreadSharedImplementation::UnlockSyncWrite();
            }
        };
    };// end I
}// end GW

#undef G_NUM_OF_OUTPUTS
#undef G_STREAMING_BUFFER_SIZE
#undef G_MAX_BUFFER_COUNT

#elif defined(_WIN32)
    #define G_NUM_OF_OUTPUTS 6
#define G_STREAMING_BUFFER_SIZE 65536
#define G_MAX_BUFFER_COUNT 3

namespace GW
{
	namespace I
	{
		class GMusicImplementation : public virtual GMusicInterface,
			protected GThreadSharedImplementation,
			protected IXAudio2VoiceCallback
		{
			// This enum exists for parity with Linux. See GMusic_Linux.hpp for more info
			enum WaveTag {
				RIFF = 1179011410, // = 'FFIR'
				DATA = 1635017060, // = 'atad'
				FMT  =  544501094, // = ' tmf'
				WAVE = 1163280727, // = 'EVAW'
				JUNK = 1263424842, // = 'KNUJ'
				XWMA = 1095587672, // = 'AMWX'
				DPDS = 1935962212  // = 'sdpd'
			};

			GReturn LoadOnlyWaveHeaderData(const char* path, WAVEFORMATEXTENSIBLE& myWFX)
			{
				// default the return value
				GReturn result = GReturn::SUCCESS;

				// create our gfile object
				GW::SYSTEM::GFile file;
				file.Create();

				// open the audio file in binary read mode. wav is a binary format with tags that can be interpreted as text
				if (-file.OpenBinaryRead(path)) {
					result = GReturn::FILE_NOT_FOUND;
					return result;
				}
				
				// variables for determinning data information
				unsigned long dwChunktype = 0;
				unsigned long dwChunkDataSize = 0;
				unsigned long dwRiffDataSize = 0;
				unsigned long dwFileType = 0;
				unsigned long dwIsWave = 0;
				bool foundAudioData = false;

				while (result == GReturn::SUCCESS && foundAudioData == false)
				{
					if (-file.Read(reinterpret_cast<char*>(&dwChunktype), 4)) {
						// could not aquire chunk type
						result = GReturn::FAILURE;
						break;
					}

					if (-file.Read(reinterpret_cast<char*>(&dwChunkDataSize), 4)) {
						// could not aquire chunk size
						result = GReturn::FAILURE;
						break;
					}

					switch (dwChunktype) {
						case WaveTag::RIFF:
						{
							dwRiffDataSize = dwChunkDataSize;
							dwChunkDataSize = 4;
							if (-file.Read(reinterpret_cast<char*>(&dwFileType), 4) || dwFileType != WaveTag::WAVE) {
								// could not aquire the file type
								result = GReturn::FAILURE;
								break;
							}
							break;
						}

						case WaveTag::WAVE:
						{
							if (-file.Read(reinterpret_cast<char*>(&dwIsWave), 4)) {
								// the file is not a wav file
								result = GReturn::FAILURE;
								break;
							}
							break;
						}
						
						case WaveTag::FMT:
						{
							if (-file.Read(reinterpret_cast<char*>(&myWFX), dwChunkDataSize)) {
								// could not read the chunk data
								result = GReturn::FAILURE;
								break;
							}
							break;
						}

						case WaveTag::DATA:
						{
							foundAudioData = true; // audio data is the last part of the file. stop looping
							break;
						}

						default:
						{
							char* pBogusData = new char[dwChunkDataSize];
							if (-file.Read(pBogusData, dwChunkDataSize)) {
								// something unknown happened that caused the data to not be read
								result = GReturn::FAILURE;
							}
							delete[] pBogusData;
							break;
						}
					}
				}
				file.CloseFile();
				return result;
			}

			GReturn FindStreamData(const char* path, unsigned long& outDataChunkSize, OVERLAPPED& overlap)
			{
				// default the return value
				GReturn result = GReturn::SUCCESS;

				// create our gfile object
				GW::SYSTEM::GFile file;
				file.Create();

				// open the audio file in binary read mode. wav is a binary format with tags that can be interpreted as text
				if (-file.OpenBinaryRead(path)) {
					result = GReturn::FILE_NOT_FOUND;
					return result;
				}

				unsigned long dwChunkType = 0;
				unsigned long dwChunkDataSize = 0;
				unsigned long bytesRead = 0;
				bool foundAudioData = false;

				while (result == GReturn::SUCCESS && foundAudioData == false) {
					if (-file.Read(reinterpret_cast<char*>(&dwChunkType), 4)) {
						// could not aquire chunk type
						result = GReturn::FAILURE;
						break;
					}
					bytesRead += 4;

					if (-file.Read(reinterpret_cast<char*>(&dwChunkDataSize), 4)) {
						// could not aquire chunk size
						result = GReturn::FAILURE;
						break;
					}
					bytesRead += 4;

					switch (dwChunkType) {
						case WaveTag::DATA:
						{
							outDataChunkSize = dwChunkDataSize;	// contains size of the audio buffer in bytes
							overlap.Offset = bytesRead;			// Sets the offset to where we are
							foundAudioData = true;				// We found the data, now exit the function
							break;
						}

						case WaveTag::RIFF:
							dwChunkDataSize = 4;
						default:
						{
							char* pBogusData = new char[dwChunkDataSize];
							if (-file.Read(pBogusData, dwChunkDataSize)) {
								// could not read
								result = GReturn::FAILURE;
							}
							delete[] pBogusData;
							bytesRead += dwChunkDataSize;
							break;
						}
					}
				}

				file.CloseFile();
				return result;
			}

			void STDMETHODCALLTYPE OnBufferStart(void*) { ResetEvent(hBufferEndEvent); }
			void STDMETHODCALLTYPE OnBufferEnd(void*) { SetEvent(hBufferEndEvent); }
			// Required studs as IXAudio2VoiceCallback is an abstract class
			void STDMETHODCALLTYPE OnVoiceProcessingPassStart(UINT32) {}
			void STDMETHODCALLTYPE OnVoiceProcessingPassEnd() {}
			void STDMETHODCALLTYPE OnVoiceError(void*, HRESULT) {}
			void STDMETHODCALLTYPE OnStreamEnd() {}
			void STDMETHODCALLTYPE OnLoopEnd(void*) {}

			std::atomic_bool atomic_isPlaying = false;
			std::atomic_bool atomic_isPaused = false;
			std::atomic_bool atomic_isComplete = false;
			std::atomic_bool atomic_isLooping = false;
			std::atomic_bool atomic_stopFlag = false;
			float masterVolume = 1.0f; // global master volume
			float globalMusicVolume = 1.0f; // global music volume
			float volume = 1.0f; // volume of this sound
			unsigned int numOfChannels = 0;
			unsigned long fileSize = 0;
			OVERLAPPED overlap = { 0 };

			IXAudio2SourceVoice* mySourceVoice = nullptr;
			IXAudio2SubmixVoice* mySubmixVoice = nullptr;
			char* filePath;
			HANDLE hBufferEndEvent;

			float       channelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f }; // channel volumes of this sound
			float masterChannelVolumes[6] = { 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f }; // global master volumes
			GW::AUDIO::GAudio gAudio;
			GW::CORE::GEventReceiver gReceiver;
			GW::SYSTEM::GConcurrent gConcurrent;
			BYTE buffers[G_MAX_BUFFER_COUNT][G_STREAMING_BUFFER_SIZE];

			char* CreateFilePath(const char* _constCharArray)
			{
				int size = 0;
				for (; size < 1024; ++size)
				{
					if (_constCharArray[size] == '\0')
					{
						++size;
						break;
					}
				}

				if (size >= 1024)
					return nullptr;

				char* charArray = new char[size];
				memcpy(charArray, _constCharArray, size); // char is 1 byte

				return charArray;
			}

		public:
			virtual ~GMusicImplementation()
			{
				Stop();

				// We do not need to check for GAudio proxy here, since those handles would get cleaned up 
				// in the event callback if GAudio gets deleted first
				LockSyncWrite();
				if (mySourceVoice)
					mySourceVoice->DestroyVoice();

				if (mySubmixVoice)
					mySubmixVoice->DestroyVoice();
				UnlockSyncWrite();

				if (filePath)
					delete[] filePath;

				if (hBufferEndEvent)
					CloseHandle(hBufferEndEvent);
			}

			GReturn Create(const char* _path, GW::AUDIO::GAudio _audio, float _volume = 1.0f)
			{
				if (!_path || !_audio)
					return GReturn::INVALID_ARGUMENT;

				if (_volume < 0.0f || _volume > 1.0f)
					return GReturn::INVALID_ARGUMENT;

				filePath = CreateFilePath(_path);
				// if _path is > 1024 chars
				if (filePath == nullptr)
					return GReturn::INVALID_ARGUMENT;

				gAudio = _audio;
				auto audioImplementation = std::dynamic_pointer_cast<GW::I::GAudioImplementation>(*_audio);
				hBufferEndEvent = CreateEventEx(nullptr, nullptr, CREATE_EVENT_MANUAL_RESET, EVENT_MODIFY_STATE | SYNCHRONIZE);
				if (!hBufferEndEvent)
					return GReturn::FAILURE;

				WAVEFORMATEXTENSIBLE wfmx;
				if (-LoadOnlyWaveHeaderData(filePath, wfmx))
					return GReturn::FAILURE;

				// Size, in bytes, of extra format information appended to the end of the WAVEFORMATEX structure. (for non-PCM formats)
				wfmx.Format.cbSize = (wfmx.Format.wFormatTag > 1) ? 22 : 0;
				numOfChannels = static_cast<unsigned int>(wfmx.Format.nChannels);
				if (audioImplementation->XAudioData.myAudio->CreateSubmixVoice(&mySubmixVoice, G_NUM_OF_OUTPUTS, wfmx.Format.nSamplesPerSec) != S_OK)
					return GReturn::FAILURE;

				XAUDIO2_SEND_DESCRIPTOR mscSendDcsp = { 0, mySubmixVoice };
				XAUDIO2_VOICE_SENDS mscSendList = { 1, &mscSendDcsp };

				if (audioImplementation->XAudioData.myAudio->CreateSourceVoice(&mySourceVoice, &wfmx.Format, 0, XAUDIO2_DEFAULT_FREQ_RATIO, this, &mscSendList) != S_OK)
					return GReturn::FAILURE;

				globalMusicVolume = audioImplementation->musicVolume;
				masterVolume = audioImplementation->masterVolume;
				memcpy(masterChannelVolumes, audioImplementation->musicChannelVolumes, 6 * sizeof(float));

				GReturn result = SetVolume(_volume);
				if (result != GReturn::SUCCESS)
					return result;

				result = SetChannelVolumes(channelVolumes, 6);
				if (result != GReturn::SUCCESS)
					return result;

				result = GThreadSharedImplementation::Create();
				if (result != GReturn::SUCCESS)
					return result;

				result = gConcurrent.Create(true);
				if (result != GReturn::SUCCESS) // Events are suppressed
					return result;

				overlap.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

				return gReceiver.Create(_audio, [&]()
				{
					GW::GEvent gEvent;
					GW::AUDIO::GAudio::Events audioEvent;
					GW::AUDIO::GAudio::EVENT_DATA audioEventData;
					// Process the event message
					gReceiver.Pop(gEvent);
					gEvent.Read(audioEvent);

					switch (audioEvent)
					{
						case GW::AUDIO::GAudio::Events::DESTROY:
						{
							//printf("DESTROY RECEIVED IN MUSIC\n");
							Stop();
							// Need to cleanup XAudio handles before GAudio is deleted
							LockSyncWrite();
							if (mySourceVoice)
							{
								mySourceVoice->DestroyVoice();
								mySourceVoice = nullptr;
							}

							if (mySubmixVoice)
							{
								mySubmixVoice->DestroyVoice();
								mySubmixVoice = nullptr;
							}
							UnlockSyncWrite();
							break;
						}
						case GW::AUDIO::GAudio::Events::PLAY_MUSIC:
						{
							Play();
							//bool playing;
							//isPlaying(playing);
							//printf("MUSIC PLAY %d\n", playing);
							break;
						}
						case GW::AUDIO::GAudio::Events::PAUSE_MUSIC:
						{
							Pause();
							//bool playing;
							//isPlaying(playing);
							//printf("MUSIC PAUSE %d\n", !playing);
							break;
						}
						case GW::AUDIO::GAudio::Events::RESUME_MUSIC:
						{
							Resume();
							//bool playing;
							//isPlaying(playing);
							//printf("MUSIC RESUME %d\n", playing);
							break;
						}
						case GW::AUDIO::GAudio::Events::STOP_MUSIC:
						{
							Stop();
							//bool playing;
							//isPlaying(playing);
							//printf("MUSIC STOP: %d\n", !playing);
							break;
						}
						case GW::AUDIO::GAudio::Events::MASTER_VOLUME_CHANGED:
						{
							gEvent.Read(audioEventData);
							masterVolume = audioEventData.channelVolumes[0];
							// Update the current volume with a new master volume
							SetVolume(volume);
							//printf("MASTER_VOLUME: %f | VOLUME: %f\n", masterVolume, volume * globalMusicVolume * masterVolume);
							break;
						}
						case GW::AUDIO::GAudio::Events::MUSIC_VOLUME_CHANGED:
						{
							gEvent.Read(audioEventData);
							globalMusicVolume = audioEventData.channelVolumes[0];
							// Update the current volume with a new master volume
							SetVolume(volume);
							//printf("GLOBAL MUSIC VOLUME: %f | VOLUME: %f\n", globalMusicVolume, volume * globalMusicVolume * masterVolume);
							break;
						}
						case GW::AUDIO::GAudio::Events::MUSIC_CHANNEL_VOLUMES_CHANGED:
						{
							gEvent.Read(audioEventData);
							memcpy(masterChannelVolumes, audioEventData.channelVolumes, audioEventData.numOfChannels * sizeof(float));
							SetChannelVolumes(channelVolumes, audioEventData.numOfChannels);
							//printf("MUSIC CHANNEL VOLUMES: { %f, %f, %f, %f, %f, %f }\n", channelVolumes[0] * masterChannelVolumes[0], channelVolumes[1] * masterChannelVolumes[1], channelVolumes[2] * masterChannelVolumes[2], channelVolumes[3] * masterChannelVolumes[3], channelVolumes[4] * masterChannelVolumes[4], channelVolumes[5] * masterChannelVolumes[5]);
							break;
						}
						default:
						{
							break;
						}
					}
				});
			}

			GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				if (_numChannels == 0 || _numChannels > 6 || _values == nullptr)
					return GReturn::INVALID_ARGUMENT;

				for (unsigned int i = 0; i < _numChannels; i++)
				{
					if (_values[i] < 0.0f)
						return GReturn::INVALID_ARGUMENT;

					// apply clamping and master volume multiplier
					channelVolumes[i] = (_values[i] > 1.0f) ? 1.0f : _values[i];
				}

				unsigned int sourceChannels = 0;
				GetSourceChannels(sourceChannels);

				// can only support up to 6 outputs
				float matrix[12] = { 0 };
				unsigned int trueIndex = 0;
				for (unsigned int i = 0; i < 12;)
				{
					if (trueIndex < _numChannels)
					{
						float matrixVolume = channelVolumes[trueIndex] * masterChannelVolumes[trueIndex];
						matrix[i] = matrixVolume;
						matrix[i + 1] = matrixVolume;
						trueIndex++;
						i += 2;
					}
					else
					{
						matrix[i] = 0;
						i++;
					}
				}

				LockSyncWrite();
				if (mySourceVoice == nullptr || FAILED(mySourceVoice->SetOutputMatrix(mySubmixVoice, sourceChannels, G_NUM_OF_OUTPUTS, matrix)))
				{
					UnlockSyncWrite();
					return GReturn::FAILURE;
				}
				UnlockSyncWrite();

				return GReturn::SUCCESS;
			}

			GReturn SetVolume(float _newVolume) override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				if (_newVolume < 0.0f)
					return GReturn::INVALID_ARGUMENT;

				// Clip the passed volume to max
				_newVolume = (_newVolume > 1.0f) ? 1.0f : _newVolume;
				volume = _newVolume;

				// Apply master volume ratio to the sound volume (Doesn't need to be normalized, since masterVolume is always < 1.0f)
				LockSyncWrite();
				if (mySourceVoice == nullptr || FAILED(mySourceVoice->SetVolume(volume * globalMusicVolume * masterVolume)))
				{
					UnlockSyncWrite();
					return GReturn::FAILURE;
				}
				UnlockSyncWrite();

				return GReturn::SUCCESS;
			}

			GReturn Play(bool _loop = false) override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				atomic_isLooping = _loop;

				if (atomic_isPlaying || atomic_isComplete)
				{
					GReturn result = Stop();

					if (result != GReturn::SUCCESS)
						return result;
				}

				if (atomic_isPlaying == false)
				{
					LockSyncWrite();
					if (mySourceVoice == nullptr || FAILED(mySourceVoice->Start(0, 0)))
					{
						UnlockSyncWrite();
						return GReturn::FAILURE;
					}
					UnlockSyncWrite();

					atomic_stopFlag = false;
					atomic_isPaused = false;
					atomic_isPlaying = true;

					gConcurrent.BranchSingular([&]() {
						unsigned short CurrentDiskReadBuffer = 0;
						unsigned long CurrentPosition = 0;

						if (-FindStreamData(filePath, fileSize, overlap))
							return GReturn::FAILURE;

						// probably safer to do this after the call to FindStreamData because that function creates its own GFile from the same path
						GW::SYSTEM::GFile gfile;
						gfile.Create();

						if (-gfile.OpenBinaryRead(filePath)) {
							// file could not be opened
							return GReturn::FAILURE;
						}

						// seek to start of the audio stream data
						unsigned int unusedPosition; // unused variable but needed for the next function
						gfile.Seek(0, overlap.Offset, unusedPosition);

						while (CurrentPosition < fileSize && atomic_stopFlag == false)
						{
							if (atomic_isPlaying)
							{
								unsigned long cbValid = (G_STREAMING_BUFFER_SIZE < (fileSize - CurrentPosition))
									? G_STREAMING_BUFFER_SIZE // if less
									: (fileSize - CurrentPosition); // if greater or equal

								// should already be at the correct offset. just have to read the data in now
								if (-gfile.Read(reinterpret_cast<char*>(buffers[CurrentDiskReadBuffer]), cbValid))
									continue;

								// update the file position to where it will be once the read finishes
								CurrentPosition += cbValid;

								XAUDIO2_VOICE_STATE state = { 0 };

								while (atomic_isPlaying)
								{
									LockAsyncRead();
									if (mySourceVoice == nullptr)
									{
										UnlockAsyncRead();
										return GReturn::FAILURE;
									}
									mySourceVoice->GetState(&state);
									UnlockAsyncRead();

									if (state.BuffersQueued >= G_MAX_BUFFER_COUNT - 1)
									{
										if (WaitForSingleObjectEx(hBufferEndEvent, INFINITE, TRUE) == WAIT_FAILED)
											break; // if deadlocks on pause check here <REMINDER>
									}
									else break;
								}

								/*
								FOR FUTURE AUDIO DEVELOPER
								PCM FUNTION POINTER GOES HERE
								for(int i = 0; i < cbValid; i++)
								{
									dataFunction(buffers[CurrentDiskReadBuffer][i]);
								}
								*/

								XAUDIO2_BUFFER buf = { 0 };
								buf.AudioBytes = cbValid;
								buf.pAudioData = buffers[CurrentDiskReadBuffer];

								if (CurrentPosition >= fileSize)
								{
									if (atomic_isLooping)
									{
										LockSyncWrite();
										if (mySourceVoice == nullptr || FAILED(mySourceVoice->SubmitSourceBuffer(&buf)))
										{
											UnlockSyncWrite();
											return GReturn::FAILURE;
										}
										UnlockSyncWrite();

										++CurrentDiskReadBuffer %= G_MAX_BUFFER_COUNT;
										CurrentPosition = 0;
										
										// seek back to the start of the audio stream data
										gfile.Seek(0, overlap.Offset, unusedPosition);

										continue;
									}
									else
										buf.Flags = XAUDIO2_END_OF_STREAM;
								}

								LockSyncWrite();
								if (mySourceVoice == nullptr || FAILED(mySourceVoice->SubmitSourceBuffer(&buf)))
								{
									UnlockSyncWrite();
									return GReturn::FAILURE;
								}
								UnlockSyncWrite();

								++CurrentDiskReadBuffer %= G_MAX_BUFFER_COUNT;
							}
						}
						// Close the gfile since we are no longer using it
						gfile.CloseFile();

						XAUDIO2_VOICE_STATE state;
						LockAsyncRead();
						if (mySourceVoice == nullptr)
						{
							UnlockAsyncRead();
							return GReturn::FAILURE;
						}
						mySourceVoice->GetState(&state);
						UnlockAsyncRead();

						// Waits for last buffers to finish playing
						while (state.BuffersQueued > 0)
						{
							if (atomic_stopFlag == true)
								break;

							LockAsyncRead();
							if (mySourceVoice == nullptr)
							{
								UnlockAsyncRead();
								return GReturn::FAILURE;
							}
							mySourceVoice->GetState(&state);
							UnlockAsyncRead();

							// [TODO:] needs testing
							if (WaitForSingleObjectEx(hBufferEndEvent, INFINITE, TRUE) == WAIT_FAILED)
								break;
						}

						// Stops the voice from producing more sound
						LockSyncWrite();
						if (mySourceVoice == nullptr || FAILED(mySourceVoice->Stop()))
						{
							UnlockSyncWrite();
							return GReturn::FAILURE;
						}
						UnlockSyncWrite();

						// This needs to be reset so XAudio2 doesn't remember where it left off playing
						overlap.Offset = 0;

						// Updates information about playback state
						atomic_isPlaying = false;
						atomic_isPaused = false;
						atomic_isComplete = true;

						return GReturn::SUCCESS;
					});
				}

				return GReturn::SUCCESS;
			}

			GReturn Pause() override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				if (atomic_isPaused == false)
				{
					LockSyncWrite();
					if (mySourceVoice == nullptr || FAILED(mySourceVoice->Stop()))
					{
						UnlockSyncWrite();
						return GReturn::FAILURE;
					}
					UnlockSyncWrite();
				}

				atomic_isPlaying = false;
				atomic_isPaused = true;
				SetEvent(hBufferEndEvent);

				return GReturn::SUCCESS;
			}

			GReturn Resume() override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				if (atomic_isPaused == true)
				{
					LockSyncWrite();
					if (mySourceVoice == nullptr || FAILED(mySourceVoice->Start()))
					{
						UnlockSyncWrite();
						return GReturn::FAILURE;
					}
					UnlockSyncWrite();

					atomic_isPlaying = true;
					atomic_isPaused = false;
				}
				else
					return GReturn::REDUNDANT;

				return GReturn::SUCCESS;
			}

			GReturn Stop() override
			{
				atomic_isPlaying = false;
				atomic_isPaused = false;
				atomic_isComplete = false;
				atomic_stopFlag = true;

				LockSyncWrite();
				if (mySourceVoice != nullptr)
					mySourceVoice->FlushSourceBuffers();
				UnlockSyncWrite();

				gConcurrent.Converge(0);

				// Critical function, all the code must be executed even in PREMATURE_DEALLOCATION state
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				return GReturn::SUCCESS;
			}

			GReturn GetSourceChannels(unsigned int& returnedChannelNum) const override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				returnedChannelNum = numOfChannels;
				return GReturn::SUCCESS;
			}

			GReturn GetOutputChannels(unsigned int& returnedChannelNum) const override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				returnedChannelNum = G_NUM_OF_OUTPUTS;
				return GReturn::SUCCESS;
			}

			GReturn isPlaying(bool& _returnedBool) const override
			{
				if (!gAudio)
					return GReturn::PREMATURE_DEALLOCATION;

				_returnedBool = atomic_isPlaying;
				return GReturn::SUCCESS;
			}

		protected:
			// ThreadShared
			GReturn LockAsyncRead() const override
			{
				return GThreadSharedImplementation::LockAsyncRead();
			}

			GReturn UnlockAsyncRead() const override
			{
				return GThreadSharedImplementation::UnlockAsyncRead();
			}

			GReturn LockSyncWrite() override
			{
				return GThreadSharedImplementation::LockSyncWrite();
			}

			GReturn UnlockSyncWrite() override
			{
				return GThreadSharedImplementation::UnlockSyncWrite();
			}
		};
	}// end I
}// end GW

#undef G_RIFFcc
#undef G_DATAcc
#undef G_FMTcc 
#undef G_WAVEcc
#undef G_JUNKcc
//#undef G_XWMAcc
//#undef G_DPDScc
#undef G_NUM_OF_OUTPUTS
#undef G_STREAMING_BUFFER_SIZE
#undef G_MAX_BUFFER_COUNT


#endif



namespace GW
{
    namespace AUDIO
    {
        class GMusic final 
			: public I::GProxy<I::GMusicInterface,  I::GMusicImplementation, const char*, GAudio, float>
        {
			// End users please feel free to ignore this struct, it is temporary and only used for internal API wiring.
			struct init_callback
			{
				init_callback()
				{
					internal_gw::event_receiver_callback = internal_gw::event_receiver_logic<CORE::GEventReceiver>;
				}
			}init; // hopefully your compiler will optimize this out

            // All Gateware API interfaces contain no variables & are pure virtual.
        public:
			GATEWARE_PROXY_CLASS(GMusic)
			GATEWARE_FUNCTION(SetChannelVolumes)
			GATEWARE_FUNCTION(SetVolume)
			GATEWARE_FUNCTION(Play)
			GATEWARE_FUNCTION(Pause)
			GATEWARE_FUNCTION(Resume)
			GATEWARE_FUNCTION(Stop)
			GATEWARE_CONST_FUNCTION(GetSourceChannels)
			GATEWARE_CONST_FUNCTION(GetOutputChannels)
			GATEWARE_CONST_FUNCTION(isPlaying)

            // This area does not contain actual code, it is only for the benefit of documentation generation.
        };
    }
}

#endif // GMUSIC_H


/*---------------------------------
|	End of GMusic.h
----------------------------------*/


/*---------------------------------
|	Begin of GSound3D.h
----------------------------------*/
#ifndef GSOUND3D_H
#define GSOUND3D_H






namespace GW
{
	namespace I
	{
		class GSound3DInterface : public virtual GSoundInterface
		{
		public:
			virtual GReturn UpdatePosition(GW::MATH::GVECTORF _position) = 0;
			virtual GReturn UpdateAttenuation(float _minRadius, float _maxRadius, GW::AUDIO::GATTENUATION _attenuation) = 0;
		};
	}
}

// Implementaion for GSound3D.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_AUDIO) || defined(GATEWARE_DISABLE_GSOUND3D) || \
    (defined(GATEWARE_ENABLE_AUDIO) && !defined(GATEWARE_DISABLE_GSOUND3D) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
	namespace I
	{
		class GSound3DImplementation : public virtual GSound3DInterface
		{
		public:
			GReturn Create(const char* _path, float _minRadius, float _maxRadius, GW::AUDIO::GATTENUATION _attenuation, GW::AUDIO::GAudio3D _audio3D) { return GReturn::INTERFACE_UNSUPPORTED; }
			GReturn UpdatePosition(GW::MATH::GVECTORF _position) override { return GReturn::FAILURE; }
			GReturn UpdateAttenuation(float _minRadius, float _maxRadius, GW::AUDIO::GATTENUATION _attenuation) override { return GReturn::FAILURE; }
			GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) override { return GReturn::FAILURE; }
			GReturn SetVolume(float _newVolume) override { return GReturn::FAILURE; }
			GReturn Play() override { return GReturn::FAILURE; }
			GReturn Pause() override { return GReturn::FAILURE; }
			GReturn Resume() override { return GReturn::FAILURE; }
			GReturn Stop() override { return GReturn::FAILURE; }
			GReturn GetSourceChannels(unsigned int& _returnedChannelNum) const override { return GReturn::FAILURE; }
			GReturn GetOutputChannels(unsigned int& _returnedChannelNum) const override { return GReturn::FAILURE; }
			GReturn isPlaying(bool& _returnedBool) const override { return GReturn::FAILURE; }
		};
	}
}

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
    #include <math.h>

namespace GW
{
	namespace I
	{
		class GSound3DImplementation : public virtual GSound3DInterface,
			protected GSoundImplementation
		{
		private:
			GW::AUDIO::GAudio3D gAudio3D;
			GW::CORE::GEventReceiver gReceiver;

			MATH::GVECTORF position = MATH::GIdentityVectorF;
			MATH::GMATRIXF listener = MATH::GIdentityMatrixF;
			MATH::GMATRIXF transform = MATH::GIdentityMatrixF;
			GW::AUDIO::GATTENUATION attenuation = GW::AUDIO::GATTENUATION::LINEAR;
			float minRadius = 0.0f;
			float maxRadius = 50.0f;
			float volume = 1.0f;

			GReturn CalculateRatio(float theta, float spread, float start, float end, float& outRatio)
			{
				if (start >= end)
					return GReturn::FAILURE;

				if (spread > 180.0f)
					return GReturn::FAILURE;

				float startBound = theta - spread;
				float endBound = theta + spread;
				float deltaSection = end - start;

				float RrR = (endBound - start) / deltaSection;
				float RlR = (startBound - start) / deltaSection;

				float clampR = G_CLAMP(RrR, 0.0f, 1.0f);
				float clampL = G_CLAMP(RlR, 0.0f, 1.0f);

				outRatio = clampR - clampL;

				return GReturn::SUCCESS;
			}

			GReturn GetSpatializedChannelVolumes(GW::MATH::GVECTORF _position, float _volume,
				float _minRadius, float _maxRadius, GW::AUDIO::GATTENUATION _attenuation, unsigned int _channelNum,
				float* _outChannelVolumes)
			{
				if ((int)_attenuation > G_IMPLEMENTED_ATTENUATIONS || (int)_attenuation < 0)
					return GReturn::INVALID_ARGUMENT;

				GW::MATH::GVECTORF localPosition;
				GReturn result = GW::MATH::GMatrix::VectorXMatrixF(transform, _position, localPosition);

				if (result != GReturn::SUCCESS)
					return result;

				// D = |local|                              -float distance [0, MAX_DISTANCE]
				float distance;
				GW::MATH::GVector::MagnitudeF(localPosition, distance);

				GW::MATH::GVECTORF pFlat = { {{ localPosition.x, 0, localPosition.z, localPosition.w }} };

				float dFlat;
				GW::MATH::GVector::MagnitudeF(pFlat, dFlat);

				localPosition = pFlat;
				GW::MATH::GVector::NormalizeF(localPosition, localPosition);

				// Here is where the different attenuation shapes will be implemented.
				switch (_attenuation)
				{
				case GW::AUDIO::GATTENUATION::LINEAR:
					// V = volume = 1 - D / Dmax                -float volume [0, 1]

					// maps x [0, 1] => 1 - x [0, 1]
					_volume *= (1 - G_CLAMP(G_CLAMP(distance - _minRadius, 0, 1) / _maxRadius, 0, 1));
					break;
					/*case LOGARITHMIC:
						// TODO: map volume x [0, 1] => Log(x) [0, 1]
					break;*/
					/*case LOGREVERSE:
						// TODO: map volume x [0, 1] => Log-1(x) [0, 1]
					break;*/
					/*case INVERSE:
						// TODO: map volume x [0, 1] => 1/x [0, 1]
					break;*/
					/*case NATURAL:
						// TODO: map volume x [0, 1] => 10^((x-dB)/20) [0, 1]
					break;*/
				}

				// spread = (1 - DFlat / DFlatMax) * 180    -float spread [0, 180]
				float spread = (1 - G_CLAMP(dFlat / _maxRadius, 0, 1)) * 180;

				GW::MATH::GVECTORF cross;
				GW::MATH::GVECTORF forward = {{{0.0f, 0.0f, 1.0f, 0.0f}}};
				result = GW::MATH::GVector::CrossVector3F(forward, localPosition, cross);

				if (result != GReturn::SUCCESS)
					return result;

				float theta;
				result = GW::MATH::GVector::DotF(forward, localPosition, theta);

				if (result != GReturn::SUCCESS)
					return result;

				theta = (cross.y > 0) ? acosf(theta) : -1 * acosf(theta);
				theta = static_cast<float>(G_RADIAN_TO_DEGREE(theta));

				if (result != GReturn::SUCCESS)
					return result;

				float ratio = 0;
				//float channelVolumes[6] = { 0, 0, 0, 0, 0, 0 };
				for (unsigned int i = 0; i < _channelNum; i++)
				{
					switch (i + 1)
					{
					case 1: // FRONT_LEFT
						result = CalculateRatio(theta, spread, -114, -38, ratio);

						if (result != GReturn::SUCCESS)
							return result;

						if (ratio == 0.0f)
						{
							result = CalculateRatio(theta, spread, 246, 322, ratio);

							if (result != GReturn::SUCCESS)
								return result;
						}
						break;
					case 2: // FRONT_RIGHT
						result = CalculateRatio(theta, spread, 38, 114, ratio);

						if (result != GReturn::SUCCESS)
							return result;

						if (ratio == 0.0f)
						{
							result = CalculateRatio(theta, spread, -322, -246, ratio);

							if (result != GReturn::SUCCESS)
								return result;
						}
						break;
					case 3: // FRONT_CENTER
						result = CalculateRatio(theta, spread, -38, 38, ratio);

						if (result != GReturn::SUCCESS)
							return result;

						if (ratio == 0.0f)
						{
							result = CalculateRatio(theta, spread, 322, 398, ratio);

							if (result != GReturn::SUCCESS)
								return result;
						}
						break;
					case 5: // SURROUND_LEFT
						result = CalculateRatio(theta, spread, 180, 246, ratio);

						if (result != GReturn::SUCCESS)
							return result;

						if (ratio == 0.0f)
						{
							result = CalculateRatio(theta, spread, -180, -114, ratio);

							if (result != GReturn::SUCCESS)
								return result;
						}
						break;
					case 6: // SURROUND_RIGHT
						result = CalculateRatio(theta, spread, 114, 180, ratio);

						if (result != GReturn::SUCCESS)
							return result;

						if (ratio == 0.0f)
						{
							result = CalculateRatio(theta, spread, -246, -180, ratio);

							if (result != GReturn::SUCCESS)
								return result;
						}
						break;
					}

					_outChannelVolumes[i] = ratio * _volume;
					_outChannelVolumes[4] = _outChannelVolumes[i] > _outChannelVolumes[4] ? _outChannelVolumes[i] : _outChannelVolumes[4];
				}

				return result;
			}

			GReturn Spatialize()
			{
				if (!gAudio3D)
					return GReturn::PREMATURE_DEALLOCATION;

				float volumes[6] = { 0, 0, 0, 0, 0, 0 };
				GReturn result = GetSpatializedChannelVolumes(position, volume, minRadius, maxRadius, attenuation, 6, volumes);

				if (result != GReturn::SUCCESS)
					return result;

				return SetChannelVolumes(volumes, 6);
			}
		public:
			GReturn Create(const char* _path, float _minRadius, float _maxRadius, GW::AUDIO::GATTENUATION _attenuation, GW::AUDIO::GAudio3D _audio3D, float _volume = 1.0f)
			{
				if (!_path || !_audio3D)
					return GReturn::INVALID_ARGUMENT;

				if (_volume < 0.0f || _volume > 1.0f)
					return GReturn::INVALID_ARGUMENT;

				attenuation = _attenuation;
				minRadius = _minRadius;
				maxRadius = _maxRadius;
				gAudio3D = _audio3D;
				volume = _volume;

				GReturn result = GSoundImplementation::Create(_path, _audio3D, _volume);
				if (result != GReturn::SUCCESS)
					return result;
				
				auto audio3DImplementation = std::dynamic_pointer_cast<GW::I::GAudio3DImplementation>(*_audio3D);
				return gReceiver.Create(audio3DImplementation->gEventGen, [&]()
				{
					GW::GEvent event;
					if (+gReceiver.Pop(event))
					{
						GW::AUDIO::GAudio3D::Events audio3devent;
						if (+event.Read(audio3devent))
						{
							switch (audio3devent)
							{
							case GW::AUDIO::GAudio3D::Events::UPDATE_LISTENER:
							{
								GW::AUDIO::GAudio3D::EVENT_DATA eventData;
								event.Read(eventData);
								GW::MATH::GMATRIXF eventMatrix;
								GW::MATH::GMatrix::ConvertQuaternionF(eventData.quaternion, eventMatrix);
								eventMatrix.row4 = eventData.position;
								listener = eventMatrix;
								break;
							}
							case GW::AUDIO::GAudio3D::Events::UPDATE_TRANSFORM_AND_SPATIALIZE:
							{
								GW::AUDIO::GAudio3D::EVENT_DATA eventData;
								event.Read(eventData);
								GW::MATH::GMATRIXF eventMatrix;
								GW::MATH::GMatrix::ConvertQuaternionF(eventData.quaternion, eventMatrix);
								eventMatrix.row4 = eventData.position;
								transform = eventMatrix;
								Spatialize();
								break;
							}
							default:
								break;
							}
						}
					}
				});
			}

			GReturn UpdatePosition(GW::MATH::GVECTORF _position) override
			{
				if (!gAudio3D)
					return GReturn::PREMATURE_DEALLOCATION;

				position = _position;
				return Spatialize();
			}

			GReturn UpdateAttenuation(float _minRadius, float _maxRadius, GW::AUDIO::GATTENUATION _attenuation) override
			{
				if (!gAudio3D)
					return GReturn::PREMATURE_DEALLOCATION;

				if ((int)_attenuation > G_IMPLEMENTED_ATTENUATIONS || (int)_attenuation < 0)
					return GReturn::INVALID_ARGUMENT;

				if (_minRadius > _maxRadius)
					return GReturn::INVALID_ARGUMENT;

				minRadius = _minRadius;
				maxRadius = _maxRadius;
				attenuation = _attenuation;

				return Spatialize();
			}

			GReturn SetVolume(float _newVolume) override
			{
				if (_newVolume < 0.0f)
					return GReturn::INVALID_ARGUMENT;

				volume = (_newVolume > 1.0f) ? 1.0f : _newVolume;
				return GSoundImplementation::SetVolume(volume);
			}

			GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) override { return GSoundImplementation::SetChannelVolumes(_values, _numChannels); }
			GReturn Play() override { return GSoundImplementation::Play(); }
			GReturn Pause() override { return GSoundImplementation::Pause(); }
			GReturn Resume() override { return GSoundImplementation::Resume(); }
			GReturn Stop() override { return GSoundImplementation::Stop(); }
			GReturn GetSourceChannels(unsigned int& _returnedChannelNum) const override { return GSoundImplementation::GetSourceChannels(_returnedChannelNum); }
			GReturn GetOutputChannels(unsigned int& _returnedChannelNum) const override { return GSoundImplementation::GetOutputChannels(_returnedChannelNum); }
			GReturn isPlaying(bool& _returnedBool) const override { return GSoundImplementation::isPlaying(_returnedBool); }
		};
	}
}


#endif


namespace GW
{
	namespace AUDIO
	{
		class GSound3D final 
			: public I::GProxy<I::GSound3DInterface, I::GSound3DImplementation, const char*, float, float, GW::AUDIO::GATTENUATION, GW::AUDIO::GAudio3D>
		{
		public:
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GSound3D);
			GATEWARE_FUNCTION(UpdatePosition);
			GATEWARE_FUNCTION(UpdateAttenuation);

			// reimplemented 
			GATEWARE_FUNCTION(SetChannelVolumes);
			GATEWARE_FUNCTION(SetVolume);
			GATEWARE_FUNCTION(Play);
			GATEWARE_FUNCTION(Pause);
			GATEWARE_FUNCTION(Resume);
			GATEWARE_FUNCTION(Stop);
			GATEWARE_CONST_FUNCTION(GetSourceChannels);
			GATEWARE_CONST_FUNCTION(GetOutputChannels);
			GATEWARE_CONST_FUNCTION(isPlaying);

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GSOUND3D_H

/*---------------------------------
|	End of GSound3D.h
----------------------------------*/


/*---------------------------------
|	Begin of GMusic3D.h
----------------------------------*/
#ifndef GMUSIC3D_H
#define GMUSIC3D_H






namespace GW
{
	namespace I
	{
		class GMusic3DInterface : public virtual GMusicInterface
		{
		public:
			virtual GReturn UpdatePosition(GW::MATH::GVECTORF _position) = 0;
			virtual GReturn UpdateAttenuation(float _minRadius, float _maxRadius, GW::AUDIO::GATTENUATION _attenuation) = 0;
		};
	}
}

// Implementaion for GMusic3D.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_AUDIO) || defined(GATEWARE_DISABLE_GMUSIC3D) || \
    (defined(GATEWARE_ENABLE_AUDIO) && !defined(GATEWARE_DISABLE_GMUSIC3D) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
	namespace I
	{
		class GMusic3DImplementation : public virtual GMusic3DInterface
		{
		public:
			GReturn Create(const char* _path, float _minRadius, float _maxRadius, GW::AUDIO::GATTENUATION _attenuation, GW::AUDIO::GAudio3D _audio3D) { return GReturn::INTERFACE_UNSUPPORTED; }
			GReturn UpdatePosition(GW::MATH::GVECTORF _position) override { return GReturn::FAILURE; }
			GReturn UpdateAttenuation(float _minRadius, float _maxRadius, GW::AUDIO::GATTENUATION _attenuation) override { return GReturn::FAILURE; }
			GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) override { return GReturn::FAILURE; }
			GReturn SetVolume(float _newVolume) override { return GReturn::FAILURE; }
			GReturn Play(bool _loop = false) override { return GReturn::FAILURE; }
			GReturn Pause() override { return GReturn::FAILURE; }
			GReturn Resume() override { return GReturn::FAILURE; }
			GReturn Stop() override { return GReturn::FAILURE; }
			GReturn GetSourceChannels(unsigned int& _returnedChannelNum) const override { return GReturn::FAILURE; }
			GReturn GetOutputChannels(unsigned int& _returnedChannelNum) const override { return GReturn::FAILURE; }
			GReturn isPlaying(bool& _returnedBool) const override { return GReturn::FAILURE; }
		};
	}
}

#elif defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
    #include <math.h>

namespace GW
{
	namespace I
	{
		class GMusic3DImplementation : public virtual GMusic3DInterface,
			protected GMusicImplementation
		{
		private:
			GW::AUDIO::GAudio3D gAudio3D;
			GW::CORE::GEventReceiver gReceiver;

			MATH::GVECTORF position = MATH::GIdentityVectorF;
			MATH::GMATRIXF listener = MATH::GIdentityMatrixF;
			MATH::GMATRIXF transform = MATH::GIdentityMatrixF;
			GW::AUDIO::GATTENUATION attenuation = GW::AUDIO::GATTENUATION::LINEAR;
			float minRadius = 0.0f;
			float maxRadius = 50.0f;
			float volume = 1.0f;

			GReturn CalculateRatio(float theta, float spread, float start, float end, float& outRatio)
			{
				if (start >= end)
					return GReturn::FAILURE;

				if (spread > 180.0f)
					return GReturn::FAILURE;

				float startBound = theta - spread;
				float endBound = theta + spread;
				float deltaSection = end - start;

				float RrR = (endBound - start) / deltaSection;
				float RlR = (startBound - start) / deltaSection;

				float clampR = G_CLAMP(RrR, 0.0f, 1.0f);
				float clampL = G_CLAMP(RlR, 0.0f, 1.0f);

				outRatio = clampR - clampL;

				return GReturn::SUCCESS;
			}

			GReturn GetSpatializedChannelVolumes(GW::MATH::GVECTORF _position, float _volume,
				float _minRadius, float _maxRadius, GW::AUDIO::GATTENUATION _attenuation, unsigned int _channelNum,
				float* _outChannelVolumes)
			{
				if ((int)_attenuation > G_IMPLEMENTED_ATTENUATIONS || (int)_attenuation < 0)
					return GReturn::INVALID_ARGUMENT;

				GW::MATH::GVECTORF localPosition;
				GReturn result = GW::MATH::GMatrix::VectorXMatrixF(transform, _position, localPosition);

				if (result != GReturn::SUCCESS)
					return result;

				// D = |local|                              -float distance [0, MAX_DISTANCE]
				float distance;
				GW::MATH::GVector::MagnitudeF(localPosition, distance);

				GW::MATH::GVECTORF pFlat = { {{ localPosition.x, 0, localPosition.z, localPosition.w }} };

				float dFlat;
				GW::MATH::GVector::MagnitudeF(pFlat, dFlat);

				localPosition = pFlat;
				GW::MATH::GVector::NormalizeF(localPosition, localPosition);

				// Here is where the different attenuation shapes will be implemented.
				switch (_attenuation)
				{
				case GW::AUDIO::GATTENUATION::LINEAR:
					// V = volume = 1 - D / Dmax                -float volume [0, 1]

					// maps x [0, 1] => 1 - x [0, 1]
					_volume *= (1 - G_CLAMP(G_CLAMP(distance - _minRadius, 0, 1) / _maxRadius, 0, 1));
					break;
					/*case LOGARITHMIC:
						// TODO: map volume x [0, 1] => Log(x) [0, 1]
					break;*/
					/*case LOGREVERSE:
						// TODO: map volume x [0, 1] => Log-1(x) [0, 1]
					break;*/
					/*case INVERSE:
						// TODO: map volume x [0, 1] => 1/x [0, 1]
					break;*/
					/*case NATURAL:
						// TODO: map volume x [0, 1] => 10^((x-dB)/20) [0, 1]
					break;*/
				}

				// spread = (1 - DFlat / DFlatMax) * 180    -float spread [0, 180]
				float spread = (1 - G_CLAMP(dFlat / _maxRadius, 0, 1)) * 180;

				GW::MATH::GVECTORF cross;
				GW::MATH::GVECTORF forward = {{{0.0f, 0.0f, 1.0f, 0.0f}}};
				result = GW::MATH::GVector::CrossVector3F(forward, localPosition, cross);

				if (result != GReturn::SUCCESS)
					return result;

				float theta;
				result = GW::MATH::GVector::DotF(forward, localPosition, theta);

				if (result != GReturn::SUCCESS)
					return result;

				theta = (cross.y > 0) ? acosf(theta) : -1 * acosf(theta);
				theta = static_cast<float>(G_RADIAN_TO_DEGREE(theta));

				if (result != GReturn::SUCCESS)
					return result;

				float ratio = 0;
				//float channelVolumes[6] = { 0, 0, 0, 0, 0, 0 };
				for (unsigned int i = 0; i < _channelNum; i++)
				{
					switch (i + 1)
					{
					case 1: // FRONT_LEFT
						result = CalculateRatio(theta, spread, -114, -38, ratio);

						if (result != GReturn::SUCCESS)
							return result;

						if (ratio == 0.0f)
						{
							result = CalculateRatio(theta, spread, 246, 322, ratio);

							if (result != GReturn::SUCCESS)
								return result;
						}
						break;
					case 2: // FRONT_RIGHT
						result = CalculateRatio(theta, spread, 38, 114, ratio);

						if (result != GReturn::SUCCESS)
							return result;

						if (ratio == 0.0f)
						{
							result = CalculateRatio(theta, spread, -322, -246, ratio);

							if (result != GReturn::SUCCESS)
								return result;
						}
						break;
					case 3: // FRONT_CENTER
						result = CalculateRatio(theta, spread, -38, 38, ratio);

						if (result != GReturn::SUCCESS)
							return result;

						if (ratio == 0.0f)
						{
							result = CalculateRatio(theta, spread, 322, 398, ratio);

							if (result != GReturn::SUCCESS)
								return result;
						}
						break;
					case 5: // SURROUND_LEFT
						result = CalculateRatio(theta, spread, 180, 246, ratio);

						if (result != GReturn::SUCCESS)
							return result;

						if (ratio == 0.0f)
						{
							result = CalculateRatio(theta, spread, -180, -114, ratio);

							if (result != GReturn::SUCCESS)
								return result;
						}
						break;
					case 6: // SURROUND_RIGHT
						result = CalculateRatio(theta, spread, 114, 180, ratio);

						if (result != GReturn::SUCCESS)
							return result;

						if (ratio == 0.0f)
						{
							result = CalculateRatio(theta, spread, -246, -180, ratio);

							if (result != GReturn::SUCCESS)
								return result;
						}
						break;
					}

					_outChannelVolumes[i] = ratio * _volume;
					_outChannelVolumes[4] = _outChannelVolumes[i] > _outChannelVolumes[4] ? _outChannelVolumes[i] : _outChannelVolumes[4];
				}

				return result;
			}

			GReturn Spatialize()
			{
				if (!gAudio3D)
					return GReturn::PREMATURE_DEALLOCATION;

				float volumes[6] = { 0, 0, 0, 0, 0, 0 };
				GReturn result = GetSpatializedChannelVolumes(position, volume, minRadius, maxRadius, attenuation, 6, volumes);

				if (result != GReturn::SUCCESS)
					return result;

				return SetChannelVolumes(volumes, 6);
			}
		public:
			GReturn Create(const char* _path, float _minRadius, float _maxRadius, GW::AUDIO::GATTENUATION _attenuation, GW::AUDIO::GAudio3D _audio3D, float _volume = 1.0f)
			{
				if (!_path || !_audio3D)
					return GReturn::INVALID_ARGUMENT;

				if (_volume < 0.0f || _volume > 1.0f)
					return GReturn::INVALID_ARGUMENT;

				attenuation = _attenuation;
				minRadius = _minRadius;
				maxRadius = _maxRadius;
				gAudio3D = _audio3D;
				volume = _volume;

				GReturn result = GMusicImplementation::Create(_path, _audio3D, _volume);
				if (result != GReturn::SUCCESS)
					return result;

				auto audio3DImplementation = std::dynamic_pointer_cast<GW::I::GAudio3DImplementation>(*_audio3D);
				return gReceiver.Create(audio3DImplementation->gEventGen, [&]()
				{
					GW::GEvent event;
					if (+gReceiver.Pop(event))
					{
						GW::AUDIO::GAudio3D::Events audio3devent;
						if (+event.Read(audio3devent))
						{
							switch (audio3devent)
							{
								case GW::AUDIO::GAudio3D::Events::UPDATE_LISTENER:
								{
									GW::AUDIO::GAudio3D::EVENT_DATA eventData;
									event.Read(eventData);

									GW::MATH::GMATRIXF eventMatrix;
									GW::MATH::GMatrix::ConvertQuaternionF(eventData.quaternion, eventMatrix);
									eventMatrix.row4 = eventData.position;
									listener = eventMatrix;

									break;
								}
								case GW::AUDIO::GAudio3D::Events::UPDATE_TRANSFORM_AND_SPATIALIZE:
								{
									GW::AUDIO::GAudio3D::EVENT_DATA eventData;
									event.Read(eventData);

									GW::MATH::GMATRIXF eventMatrix;
									GW::MATH::GMatrix::ConvertQuaternionF(eventData.quaternion, eventMatrix);
									eventMatrix.row4 = eventData.position;
									transform = eventMatrix;

									Spatialize();
									break;
								}
								default:
									break;
							}
						}
					}
				});
			}

			GReturn UpdatePosition(GW::MATH::GVECTORF _position) override
			{
				if (!gAudio3D)
					return GReturn::PREMATURE_DEALLOCATION;

				position = _position;
				return Spatialize();
			}

			GReturn UpdateAttenuation(float _minRadius, float _maxRadius, GW::AUDIO::GATTENUATION _attenuation) override
			{
				if (!gAudio3D)
					return GReturn::PREMATURE_DEALLOCATION;

				if ((int)_attenuation > G_IMPLEMENTED_ATTENUATIONS || (int)_attenuation < 0)
					return GReturn::INVALID_ARGUMENT;

				if (_minRadius > _maxRadius)
					return GReturn::INVALID_ARGUMENT;

				minRadius = _minRadius;
				maxRadius = _maxRadius;
				attenuation = _attenuation;

				return Spatialize();
			}

			GReturn SetVolume(float _newVolume) override
			{
				if (_newVolume < 0.0f)
					return GReturn::INVALID_ARGUMENT;

				volume = (_newVolume > 1.0f) ? 1.0f : _newVolume;
				return GMusicImplementation::SetVolume(volume);
			}

			GReturn SetChannelVolumes(const float* _values, unsigned int _numChannels) override { return GMusicImplementation::SetChannelVolumes(_values, _numChannels); }
			GReturn Play(bool _loop = false) override { return GMusicImplementation::Play(_loop); }
			GReturn Pause() override { return GMusicImplementation::Pause(); }
			GReturn Resume() override { return GMusicImplementation::Resume(); }
			GReturn Stop() override { return GMusicImplementation::Stop(); }
			GReturn GetSourceChannels(unsigned int& _returnedChannelNum) const override { return GMusicImplementation::GetSourceChannels(_returnedChannelNum); }
			GReturn GetOutputChannels(unsigned int& _returnedChannelNum) const override { return GMusicImplementation::GetOutputChannels(_returnedChannelNum); }
			GReturn isPlaying(bool& _returnedBool) const override { return GMusicImplementation::isPlaying(_returnedBool); }
		};
	}
}


#endif


namespace GW
{
	namespace AUDIO
	{
		class GMusic3D final 
			: public I::GProxy<I::GMusic3DInterface, I::GMusic3DImplementation, const char*, float, float, GW::AUDIO::GATTENUATION, GW::AUDIO::GAudio3D>
		{
		public:
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GMusic3D)
			GATEWARE_FUNCTION(UpdatePosition)
			GATEWARE_FUNCTION(UpdateAttenuation)

			// reimplemented from base class
			GATEWARE_FUNCTION(SetChannelVolumes)
			GATEWARE_FUNCTION(SetVolume)
			GATEWARE_FUNCTION(Play)
			GATEWARE_FUNCTION(Pause)
			GATEWARE_FUNCTION(Resume)
			GATEWARE_FUNCTION(Stop)
			GATEWARE_CONST_FUNCTION(GetSourceChannels)
			GATEWARE_CONST_FUNCTION(GetOutputChannels)
			GATEWARE_CONST_FUNCTION(isPlaying)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GMUSIC3D_H

/*---------------------------------
|	End of GMusic3D.h
----------------------------------*/


/*---------------------------------
|	Begin of GBufferedInput.h
----------------------------------*/
#ifndef GBUFFEREDINPUT_H
#define GBUFFEREDINPUT_H






namespace GW
{
	namespace I
	{
		class GBufferedInputInterface : public virtual GEventGeneratorInterface
		{
		public:
			enum class Events
			{
				Invalid,
				KEYPRESSED,
				KEYRELEASED,
				BUTTONPRESSED,
				BUTTONRELEASED,
				MOUSEMOVE,
				MOUSESCROLL
			};

			struct EVENT_DATA
			{
				int data;
				int x;
				int y;
				int screenX;
				int screenY;
				unsigned int keyMask;
			};
		};
	}
}

// Implementaion for GBufferedInput.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#if !defined(GATEWARE_ENABLE_INPUT) || defined(GATEWARE_DISABLE_GBUFFEREDINPUT) || \
    (defined(GATEWARE_ENABLE_INPUT) && !defined(GATEWARE_DISABLE_GBUFFEREDINPUT) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    namespace GW
{
	namespace I
	{
		class GBufferedInputImplementation :	public virtual GBufferedInputInterface,
												public GEventGeneratorImplementation
		{
		public:
			GReturn Create(GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE _uwh) { 
				return GReturn::INTERFACE_UNSUPPORTED; 
			}
			GReturn Create(GW::SYSTEM::GWindow _window) { 
				return GReturn::INTERFACE_UNSUPPORTED; 
			}
		};
	}
}

#elif defined(__APPLE__)
    #ifdef __OBJC__
@import Foundation;
@import Cocoa;
#endif
// Need include guard for this because GInput and GBufferedInput uses this file
#ifndef GINPUTTABLEROUTING_HPP
#define GINPUTTABLEROUTING_HPP

// Defines platform specific key codes that is shared between
// GInput and GBufferedInput
namespace GW
{
	namespace I
	{
#if defined(_WIN32)
		constexpr unsigned int Keycodes[128] =
		{
			G_KEY_UNKNOWN,				// 0
			G_KEY_ESCAPE,				// 1
			G_KEY_1,					// 2
			G_KEY_2,					// 3
			G_KEY_3,					// 4
			G_KEY_4,					// 5
			G_KEY_5,					// 6
			G_KEY_6,					// 7
			G_KEY_7,					// 8
			G_KEY_8,					// 9
			G_KEY_9,					// 10
			G_KEY_0,					// 11
			G_KEY_MINUS,				// 12
			G_KEY_EQUALS,				// 13
			G_KEY_BACKSPACE,			// 14
			G_KEY_TAB,					// 15
			G_KEY_Q,					// 16
			G_KEY_W,					// 17
			G_KEY_E,					// 18
			G_KEY_R,					// 19
			G_KEY_T,					// 20
			G_KEY_Y,					// 21
			G_KEY_U,					// 22
			G_KEY_I,					// 23
			G_KEY_O,					// 24
			G_KEY_P,					// 25
			G_KEY_BRACKET_OPEN,			// 26
			G_KEY_BRACKET_CLOSE,		// 27
			G_KEY_ENTER,				// 28
			G_KEY_LEFTCONTROL,			// 29
			G_KEY_A,					// 30
			G_KEY_S,					// 31
			G_KEY_D,					// 32
			G_KEY_F,					// 33
			G_KEY_G,					// 34
			G_KEY_H,					// 35
			G_KEY_J,					// 36
			G_KEY_K,					// 37
			G_KEY_L,					// 38
			G_KEY_SEMICOLON,			// 39
			G_KEY_QUOTE,				// 40
			G_KEY_TILDE,				// 41
			G_KEY_LEFTSHIFT,			// 42
			G_KEY_BACKSLASH,			// 43
			G_KEY_Z,					// 44
			G_KEY_X,					// 45
			G_KEY_C,					// 46
			G_KEY_V,					// 47
			G_KEY_B,					// 48
			G_KEY_N,					// 49
			G_KEY_M,					// 50
			G_KEY_COMMA,				// 51
			G_KEY_PERIOD,				// 52
			G_KEY_FORWARDSLASH,			// 53
			G_KEY_RIGHTSHIFT,			// 54
			G_KEY_NUMPAD_MULTIPLY,		// 55
			G_KEY_LEFTALT,				// 56
			G_KEY_SPACE,				// 57
			G_KEY_CAPSLOCK,				// 58
			G_KEY_F1,					// 59
			G_KEY_F2,					// 60
			G_KEY_F3,					// 61
			G_KEY_F4,					// 62
			G_KEY_F5,					// 63
			G_KEY_F6,					// 64
			G_KEY_F7,					// 65
			G_KEY_F8,					// 66
			G_KEY_F9,					// 67
			G_KEY_F10,					// 68
			G_KEY_NUMLOCK,				// 69
			G_KEY_SCROLL_LOCK,			// 70
			G_KEY_NUMPAD_7,				// 71
			G_KEY_NUMPAD_8,				// 72
			G_KEY_NUMPAD_9,				// 73
			G_KEY_NUMPAD_SUBTRACT,		// 74
			G_KEY_NUMPAD_4,				// 75
			G_KEY_NUMPAD_5,				// 76
			G_KEY_NUMPAD_6,				// 77
			G_KEY_NUMPAD_ADD,			// 78
			G_KEY_NUMPAD_1,				// 79
			G_KEY_NUMPAD_2,				// 80
			G_KEY_NUMPAD_3,				// 81
			G_KEY_NUMPAD_0,				// 82
			G_KEY_NUMPAD_PERIOD,		// 83
			G_KEY_UNKNOWN,				// 84
			G_KEY_UNKNOWN,				// 85
			G_KEY_UNKNOWN,				// 86
			G_KEY_F11,					// 87
			G_KEY_F12,					// 88
			G_KEY_UNKNOWN,				// 89
			G_KEY_UNKNOWN,				// 90
			G_KEY_UNKNOWN,				// 91
			G_KEY_UNKNOWN,				// 92
			G_KEY_UNKNOWN,				// 93
			G_KEY_UNKNOWN,				// 94
			G_KEY_UNKNOWN,				// 95
			G_KEY_UNKNOWN,				// 96
			G_KEY_UNKNOWN,				// 97
			G_KEY_UNKNOWN,				// 98
			G_KEY_UNKNOWN,				// 99
			G_KEY_UNKNOWN,				// 100
			G_KEY_UNKNOWN,				// 101
			G_KEY_UNKNOWN,				// 102
			G_KEY_UNKNOWN,				// 103
			G_KEY_UNKNOWN,				// 104
			G_KEY_UNKNOWN,				// 105
			G_KEY_UNKNOWN,				// 106
			G_KEY_UNKNOWN,				// 107
			G_KEY_UNKNOWN,				// 108
			G_KEY_UNKNOWN,				// 109
			G_KEY_UNKNOWN,				// 110
			G_KEY_UNKNOWN,				// 111
			G_KEY_UNKNOWN,				// 112
			G_KEY_UNKNOWN,				// 113
			G_KEY_UNKNOWN,				// 114
			G_KEY_UNKNOWN,				// 115
			G_KEY_UNKNOWN,				// 116
			G_KEY_UNKNOWN,				// 117
			G_KEY_UNKNOWN,				// 118
			G_KEY_UNKNOWN,				// 119
			G_KEY_UNKNOWN,				// 120
			G_KEY_UNKNOWN,				// 121
			G_KEY_UNKNOWN,				// 122
			G_KEY_UNKNOWN,				// 123
			G_KEY_UNKNOWN,				// 124
			G_KEY_UNKNOWN,				// 125
			G_KEY_UNKNOWN,				// 126
			G_KEY_UNKNOWN				// 127
		};
#elif defined(__linux__)
		constexpr unsigned int Keycodes[128] =
		{
			G_KEY_UNKNOWN,			// 0
			G_KEY_UNKNOWN,			// 1
			G_KEY_UNKNOWN,			// 2
			G_KEY_UNKNOWN,			// 3
			G_KEY_UNKNOWN,			// 4
			G_KEY_UNKNOWN,			// 5
			G_KEY_UNKNOWN,			// 6
			G_KEY_UNKNOWN,			// 7
			G_KEY_UNKNOWN,			// 8
			G_KEY_ESCAPE,			// 9
			G_KEY_1,				// 10
			G_KEY_2,				// 11
			G_KEY_3,				// 12
			G_KEY_4,				// 13
			G_KEY_5,				// 14
			G_KEY_6,				// 15
			G_KEY_7,				// 16
			G_KEY_8,				// 17
			G_KEY_9,				// 18
			G_KEY_0,				// 19
			G_KEY_MINUS,			// 20
			G_KEY_EQUALS,			// 21
			G_KEY_BACKSPACE,		// 22
			G_KEY_TAB,				// 23
			G_KEY_Q,				// 24
			G_KEY_W,				// 25
			G_KEY_E,				// 26
			G_KEY_R,				// 27
			G_KEY_T,				// 28
			G_KEY_Y,				// 29
			G_KEY_U,				// 30
			G_KEY_I,				// 31
			G_KEY_O,				// 32
			G_KEY_P,				// 33
			G_KEY_BRACKET_OPEN,		// 34
			G_KEY_BRACKET_CLOSE,	// 35
			G_KEY_ENTER,			// 36
			G_KEY_LEFTCONTROL,		// 37
			G_KEY_A,				// 38
			G_KEY_S,				// 39
			G_KEY_D,				// 40
			G_KEY_F,				// 41
			G_KEY_G,				// 42
			G_KEY_H,				// 43
			G_KEY_J,				// 44
			G_KEY_K,				// 45
			G_KEY_L,				// 46
			G_KEY_SEMICOLON,		// 47
			G_KEY_QUOTE,			// 48
			G_KEY_TILDE,			// 49
			G_KEY_LEFTSHIFT,		// 50
			G_KEY_BACKSLASH,		// 51
			G_KEY_Z,				// 52
			G_KEY_X,				// 53
			G_KEY_C,				// 54
			G_KEY_V,				// 55
			G_KEY_B,				// 56
			G_KEY_N,				// 57
			G_KEY_M,				// 58
			G_KEY_COMMA,			// 59
			G_KEY_PERIOD,			// 60
			G_KEY_FORWARDSLASH,		// 61
			G_KEY_RIGHTSHIFT,		// 62
			G_KEY_NUMPAD_MULTIPLY,	// 63
			G_KEY_LEFTALT,			// 64
			G_KEY_SPACE,			// 65
			G_KEY_CAPSLOCK,			// 66
			G_KEY_F1,				// 67
			G_KEY_F2,				// 68
			G_KEY_F3,				// 69
			G_KEY_F4,				// 70
			G_KEY_F5,				// 71
			G_KEY_F6,				// 72
			G_KEY_F7,				// 73
			G_KEY_F8,				// 74
			G_KEY_F9,				// 75
			G_KEY_F10,				// 76
			G_KEY_NUMLOCK,			// 77
			G_KEY_SCROLL_LOCK,		// 78
			G_KEY_NUMPAD_7,			// 79
			G_KEY_NUMPAD_8,			// 80
			G_KEY_NUMPAD_9,			// 81
			G_KEY_NUMPAD_SUBTRACT,	// 82
			G_KEY_NUMPAD_4,			// 83
			G_KEY_NUMPAD_5,			// 84
			G_KEY_NUMPAD_6,			// 85
			G_KEY_NUMPAD_ADD,		// 86
			G_KEY_NUMPAD_1,			// 87
			G_KEY_NUMPAD_2,			// 88
			G_KEY_NUMPAD_3,			// 89
			G_KEY_NUMPAD_0,			// 90
			G_KEY_NUMPAD_PERIOD,	// 91
			G_KEY_UNKNOWN,			// 92
			G_KEY_UNKNOWN,			// 93
			G_KEY_UNKNOWN,			// 94
			G_KEY_F11,				// 95
			G_KEY_F12,				// 96
			G_KEY_UNKNOWN,			// 97
			G_KEY_UNKNOWN,			// 98
			G_KEY_UNKNOWN,			// 99
			G_KEY_UNKNOWN,			// 100
			G_KEY_UNKNOWN,			// 101
			G_KEY_UNKNOWN,			// 102
			G_KEY_UNKNOWN,			// 103
			G_KEY_NUMPAD_ENTER,		// 104
			G_KEY_UNKNOWN,			// 105
			G_KEY_NUMPAD_DIVIDE,	// 106
			G_KEY_PRINTSCREEN,		// 107
			G_KEY_RIGHTALT,			// 108
			G_KEY_UNKNOWN,			// 109
			G_KEY_HOME,				// 110
			G_KEY_UP,				// 111
			G_KEY_PAGEUP,			// 112
			G_KEY_LEFT,				// 113
			G_KEY_RIGHT,			// 114
			G_KEY_END,				// 115
			G_KEY_DOWN,				// 116
			G_KEY_PAGEDOWN,			// 117
			G_KEY_INSERT,			// 118
			G_KEY_DELETE,			// 119
			G_KEY_UNKNOWN,			// 120
			G_KEY_UNKNOWN,			// 121
			G_KEY_UNKNOWN,			// 122
			G_KEY_UNKNOWN,			// 123
			G_KEY_UNKNOWN,			// 124
			G_KEY_UNKNOWN,			// 125
			G_KEY_UNKNOWN,			// 126
			G_KEY_PAUSE				// 127
			
		};
#elif defined(__APPLE__)
		constexpr unsigned int Keycodes[128] =
		{
			G_KEY_A,				// 0
			G_KEY_S,				// 1
			G_KEY_D,				// 2
			G_KEY_F,				// 3
			G_KEY_H,				// 4
			G_KEY_G,				// 5
			G_KEY_Z,				// 6
			G_KEY_X,				// 7
			G_KEY_C,				// 8
			G_KEY_V,				// 9
			G_KEY_UNKNOWN,			// 10
			G_KEY_B,				// 11
			G_KEY_Q,				// 12
			G_KEY_W,				// 13
			G_KEY_E,				// 14
			G_KEY_R,				// 15
			G_KEY_Y,				// 16
			G_KEY_T,				// 17
			G_KEY_1,				// 18
			G_KEY_2,				// 19
			G_KEY_3,				// 20
			G_KEY_4,				// 21
			G_KEY_6,				// 22
			G_KEY_5,				// 23
			G_KEY_EQUALS,			// 24
			G_KEY_9,				// 25
			G_KEY_7,				// 26
			G_KEY_MINUS,			// 27
			G_KEY_8,				// 28
			G_KEY_0,				// 29
			G_KEY_BRACKET_CLOSE,	// 30
			G_KEY_O,				// 31
			G_KEY_U,				// 32
			G_KEY_BRACKET_OPEN,		// 33
			G_KEY_I,				// 34
			G_KEY_P,				// 35
			G_KEY_ENTER,			// 36
			G_KEY_L,				// 37
			G_KEY_J,				// 38
			G_KEY_QUOTE,			// 39
			G_KEY_K,				// 40
			G_KEY_SEMICOLON,		// 41
			G_KEY_BACKSLASH,		// 42
			G_KEY_COMMA,			// 43
			G_KEY_FORWARDSLASH,		// 44
			G_KEY_N,				// 45
			G_KEY_M,				// 46
			G_KEY_PERIOD,			// 47
			G_KEY_TAB,				// 48
			G_KEY_SPACE,			// 49
			G_KEY_TILDE,			// 50
			G_KEY_DELETE,			// 51
			G_KEY_UNKNOWN,			// 52
			G_KEY_ESCAPE,			// 53
			G_KEY_UNKNOWN,			// 54
			G_KEY_COMMAND,		    // 55
			G_KEY_LEFTSHIFT,		// 56
			G_KEY_CAPSLOCK,			// 57
			G_KEY_LEFTALT,			// 58
			G_KEY_LEFTCONTROL,		// 59
			G_KEY_RIGHTSHIFT,		// 60
			G_KEY_RIGHTALT,			// 61
			G_KEY_RIGHTCONTROL,		// 62
			G_KEY_UNKNOWN,			// 63
			G_KEY_UNKNOWN,			// 64
			G_KEY_NUMPAD_PERIOD,	// 65
			G_KEY_UNKNOWN,			// 66
			G_KEY_NUMPAD_MULTIPLY,	// 67
			G_KEY_UNKNOWN,			// 68
			G_KEY_NUMPAD_ADD,		// 69
			G_KEY_UNKNOWN,			// 70
			G_KEY_NUMLOCK,			// 71
			G_KEY_UNKNOWN,			// 72
			G_KEY_UNKNOWN,			// 73
			G_KEY_UNKNOWN,			// 74
			G_KEY_NUMPAD_DIVIDE,	// 75
			G_KEY_NUMPAD_ENTER,		// 76
			G_KEY_UNKNOWN,			// 77
			G_KEY_NUMPAD_SUBTRACT,	// 78
			G_KEY_UNKNOWN,			// 79
			G_KEY_UNKNOWN,			// 80
			G_KEY_EQUALS,			// 81
			G_KEY_NUMPAD_0,			// 82
			G_KEY_NUMPAD_1,			// 83
			G_KEY_NUMPAD_2,			// 84
			G_KEY_NUMPAD_3,			// 85
			G_KEY_NUMPAD_4,			// 86
			G_KEY_NUMPAD_5,			// 87
			G_KEY_NUMPAD_6,			// 88
			G_KEY_NUMPAD_7,			// 89
			G_KEY_UNKNOWN,			// 90
			G_KEY_NUMPAD_8,			// 91
			G_KEY_NUMPAD_9,			// 92
			G_KEY_UNKNOWN,			// 93
			G_KEY_UNKNOWN,			// 94
			G_KEY_UNKNOWN,			// 95
			G_KEY_F5,				// 96
			G_KEY_F6,				// 97
			G_KEY_F7,				// 98
			G_KEY_F3,				// 99
			G_KEY_F8,				// 100
			G_KEY_F9,				// 101
			G_KEY_UNKNOWN,			// 102
			G_KEY_F11,				// 103
			G_KEY_UNKNOWN,			// 104
			G_KEY_UNKNOWN,			// 105
			G_KEY_UNKNOWN,			// 106
			G_KEY_UNKNOWN,			// 107
			G_KEY_UNKNOWN,			// 108
			G_KEY_F10,				// 109
			G_KEY_UNKNOWN,			// 110
			G_KEY_F12,				// 111
			G_KEY_UNKNOWN,			// 112
			G_KEY_UNKNOWN,			// 113
			G_KEY_INSERT,			// 114
			G_KEY_HOME,				// 115
			G_KEY_PAGEUP,			// 116
			G_KEY_DELETE,			// 117
			G_KEY_F4,				// 118
			G_KEY_END,				// 119
			G_KEY_F2,				// 120
			G_KEY_PAGEDOWN,			// 121
			G_KEY_F1,				// 122
			G_KEY_LEFT,				// 123
			G_KEY_RIGHT,			// 124
			G_KEY_DOWN,				// 125
			G_KEY_UP,				// 126
            G_KEY_UNKNOWN           // 127
		};
#endif
	}
}
#endif




namespace GW
{
    namespace I
    {
        class GBufferedInputImplementation;
    }
}

namespace internal_gw
{
    // GResponder Interface

    // Data members of GResponder
    G_OBJC_DATA_MEMBERS_STRUCT(GResponder)
    {
        unsigned int keyMask;
        int lastMouseX = 0, lastMouseY = 0;
        int screenMouseX = 0, screenMouseY = 0;
        int relativeMouseX = 0, relativeMouseY = 0;
        GW::I::GBufferedInputImplementation* pBufferedInput;
        NSWindow* targetWindow; // so we can get the height of the client area
        GW::GEvent gevent;
        char pressed[256] = { 0, }; // since isARepeat doesn't seem to work...
    };

    // Forward declarations of GResponder methods
    G_OBJC_HEADER_DATA_MEMBERS_PROPERTY_METHOD(GResponder);

    G_OBJC_HEADER_INSTANCE_METHOD(GResponder, bool, acceptFirstResponder);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, bool, acceptsFirstMouse, NSEvent* event);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, flagsChanged, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, keyDown, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, keyUp, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, mouseDown, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, mouseUp, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, mouseMoved, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, mouseDragged, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, rightMouseDragged, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, otherMouseDragged, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, rightMouseDown, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, rightMouseUp, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, otherMouseDown, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, otherMouseUp, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, scrollWheel, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, GetKeyMask, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, GetMouseLocation, NSEvent* theEvent);

    // Creates the GResponder class at runtime when G_OBJC_GET_CLASS(GResponder) is called
    G_OBJC_CLASS_BEGIN(GResponder, NSResponder)
    {
        G_OBJC_CLASS_DATA_MEMBERS_PROPERTY(GResponder);

        G_OBJC_CLASS_METHOD(GResponder, acceptFirstResponder, "B@:");
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, acceptsFirstMouse, "B@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, flagsChanged, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, keyDown, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, keyUp, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, mouseDown, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, mouseUp, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, mouseMoved, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, mouseDragged, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, rightMouseDragged, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, otherMouseDragged, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, rightMouseDown, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, rightMouseUp, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, otherMouseDown, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, otherMouseUp, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, scrollWheel, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, GetKeyMask, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GResponder, GetMouseLocation, "v@:@", :);
    }
    G_OBJC_CLASS_END(GResponder)

    // GResponder Interface End
}

namespace GW
{
    namespace I
    {
        class GBufferedInputImplementation :    public virtual GBufferedInputInterface,
                                                public GEventGeneratorImplementation
        {
        private:
            NSWindow* currentResponder;
            id responder = [internal_gw::G_OBJC_GET_CLASS(GResponder) alloc];
        public:
            ~GBufferedInputImplementation()
            {
                if (responder)
                {
                    [responder release] ;
                    responder = nil;
                }
            }

            GReturn Create(GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE _uwh)
            {
                if (!_uwh.window)
                    return GReturn::INVALID_ARGUMENT;
                //Need to convert _data back into an NSWindow*.
                //NSWindow* currentResponder = ((__bridge NSWindow*)_data);
                currentResponder = ((__bridge NSWindow*)_uwh.window);

                //We only want to process the message and pass it on. So if there is already
                //a responder we set our responders next responder to be the current next responder.
                [responder setNextResponder : currentResponder.nextResponder];

                //We then set out responder to the next responder of the window.
                [currentResponder setNextResponder : responder] ;

                //We also need to make our responder the first responder of the window.
                [currentResponder makeFirstResponder : responder] ;

                internal_gw::G_OBJC_DATA_MEMBERS_TYPE(GResponder)& responderDataMembers = internal_gw::G_OBJC_GET_DATA_MEMBERS(GResponder, responder);
                responderDataMembers.pBufferedInput = this;
                responderDataMembers.targetWindow = currentResponder;

                RUN_ON_UI_THREAD(^ {
                    //In order to get mouse button presses we need to set our responder to be
                    //The next responder in the contentView as well.
                    [currentResponder.contentView setNextResponder : responder] ;
                    });
                
                //Enable responder to accept mouse move events. By default it doesn't.
                [currentResponder setAcceptsMouseMovedEvents:YES];

                return GReturn::SUCCESS;
            }

            GReturn Create(GW::SYSTEM::GWindow _window)
            {
                if (!_window)
                    return GReturn::INVALID_ARGUMENT;

                GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE uwh;
                GReturn code = _window.GetWindowHandle(uwh);
                if (G_FAIL(code))
                    return code;

                return Create(uwh);
            }
        };
    }
}

namespace internal_gw
{
    // GResponder Implementation

    G_OBJC_IMPLEMENTATION_DATA_MEMBERS_PROPERTY_METHOD(GResponder);

    G_OBJC_HEADER_INSTANCE_METHOD(GResponder, bool, acceptFirstResponder) { return YES; }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, bool, acceptsFirstMouse, NSEvent* event) { return YES; }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, flagsChanged, NSEvent* theEvent)
    {
        // these keys are treated a bit differently and need a custom handler
        NSUInteger code = [theEvent keyCode];
        NSUInteger gwcode = GW::I::Keycodes[code];
        NSUInteger xflags = [theEvent modifierFlags];
        int send_event = 0; // only send if non-zero
        
        if (gwcode == G_KEY_LEFTSHIFT || gwcode == G_KEY_RIGHTSHIFT)
             send_event = (xflags & NSEventModifierFlagShift) ? 1 : -1;
        else if (gwcode == G_KEY_LEFTALT || gwcode == G_KEY_RIGHTALT)
             send_event = (xflags & NSEventModifierFlagOption) ? 1 : -1;
        else if (gwcode == G_KEY_LEFTCONTROL || gwcode == G_KEY_RIGHTCONTROL)
             send_event = (xflags & NSEventModifierFlagControl) ? 1 : -1;
        else if (gwcode == G_KEY_NUMLOCK)
             send_event = (xflags & NSEventModifierFlagNumericPad) ? 1 : -1;
        else if (gwcode == G_KEY_COMMAND)
             send_event = (xflags & NSEventModifierFlagCommand) ? 1 : -1;
        else if (gwcode == G_KEY_FUNCTION)
             send_event = (xflags & NSEventModifierFlagFunction) ? 1 : -1;
        else if (gwcode == G_KEY_CAPSLOCK) // key up not sent until pressed again
             send_event = (xflags & NSEventModifierFlagCapsLock) ? 1 : -1;
        // filter repeated key press
        G_OBJC_DATA_MEMBERS_TYPE(GResponder)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GResponder, self);
        if (send_event == 1 && selfDataMembers.pressed[gwcode] == 0)
            selfDataMembers.pressed[gwcode] = 1; // this is going to be sent for the first time
        else if (send_event == 1 && selfDataMembers.pressed[gwcode] == 1)
            send_event = 0; // ignore this repeat
        else if(send_event == -1 && selfDataMembers.pressed[gwcode] == 1)
            selfDataMembers.pressed[gwcode] = 0; // allow this message to be resent
        
        if (send_event != 0)
        {
            GW::I::GBufferedInputImplementation::EVENT_DATA _dataStruct;
            //Get the key from the static list of keys.
            _dataStruct.data = gwcode;
            //Call the GetKeyMask Function passing the event passed to this functions.
            G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetKeyMask, theEvent);
            //Set the keymask.
            _dataStruct.keyMask = selfDataMembers.keyMask;
            //Get the mouse position relative to the window.
            G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetMouseLocation, theEvent);
            _dataStruct.x = selfDataMembers.relativeMouseX;
            _dataStruct.y = selfDataMembers.relativeMouseY;
            _dataStruct.screenX = selfDataMembers.screenMouseX;
            _dataStruct.screenY = selfDataMembers.screenMouseY;
            
            //Send off the event.
            GW::GEvent& gevent = selfDataMembers.gevent;
            gevent.Write(
                (send_event > 0) ?  GW::I::GBufferedInputInterface::Events::KEYPRESSED
                                 :  GW::I::GBufferedInputInterface::Events::KEYRELEASED,
                _dataStruct);

            GW::I::GBufferedInputImplementation* pBufferedInput = selfDataMembers.pBufferedInput;
            pBufferedInput->Push(gevent);
        }

        if ([self nextResponder] != nil)
            [[self nextResponder]keyDown:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, keyDown, NSEvent* theEvent)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GResponder)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GResponder, self);
        GW::I::GBufferedInputImplementation::EVENT_DATA _dataStruct;
        //Get the key from the static list of keys.
        _dataStruct.data = GW::I::Keycodes [[theEvent keyCode]];
        // ignore repeats
        if (selfDataMembers.pressed[_dataStruct.data] == 0)
        {
            //Call the GetKeyMask Function passing the event passed to this functions.
            G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetKeyMask, theEvent);
            //Set the keymask.
            _dataStruct.keyMask = selfDataMembers.keyMask;
            //Get the mouse position relative to the window.
            G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetMouseLocation, theEvent);
            _dataStruct.x = selfDataMembers.relativeMouseX;
            _dataStruct.y = selfDataMembers.relativeMouseY;
            _dataStruct.screenX = selfDataMembers.screenMouseX;
            _dataStruct.screenY = selfDataMembers.screenMouseY;
            //Send off the event.
            GW::GEvent& gevent = selfDataMembers.gevent;
            gevent.Write(GW::I::GBufferedInputInterface::Events::KEYPRESSED, _dataStruct);
            GW::I::GBufferedInputImplementation* pBufferedInput = selfDataMembers.pBufferedInput;
            selfDataMembers.pressed[_dataStruct.data] = 1; // filter repeats
            pBufferedInput->Push(gevent);
        }
        
        if ([self nextResponder] != nil)
            [[self nextResponder]keyDown:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, keyUp, NSEvent* theEvent)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GResponder)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GResponder, self);
        GW::I::GBufferedInputImplementation::EVENT_DATA _dataStruct;
        _dataStruct.data = GW::I::Keycodes [[theEvent keyCode]];
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetKeyMask, theEvent);
        _dataStruct.keyMask = selfDataMembers.keyMask;
        //Get the mouse position relative to the window.
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetMouseLocation, theEvent);
        _dataStruct.x = selfDataMembers.relativeMouseX;
        _dataStruct.y = selfDataMembers.relativeMouseY;
        _dataStruct.screenX = selfDataMembers.screenMouseX;
        _dataStruct.screenY = selfDataMembers.screenMouseY;

        //Send off the event.
        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(GW::I::GBufferedInputInterface::Events::KEYRELEASED, _dataStruct);
        GW::I::GBufferedInputImplementation* pBufferedInput = selfDataMembers.pBufferedInput;
        pBufferedInput->Push(gevent);
        // allow this event to be re-triggered
        selfDataMembers.pressed[_dataStruct.data] = 0;

        if ([self nextResponder] != nil)
            [[self nextResponder]keyUp:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, mouseDown, NSEvent* theEvent)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GResponder)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GResponder, self);
        GW::I::GBufferedInputImplementation::EVENT_DATA _dataStruct;
        _dataStruct.data = G_BUTTON_LEFT;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetKeyMask, theEvent);
        _dataStruct.keyMask = selfDataMembers.keyMask;
        //Get the mouse position relative to the window.
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetMouseLocation, theEvent);
        _dataStruct.x = selfDataMembers.relativeMouseX;
        _dataStruct.y = selfDataMembers.relativeMouseY;
        _dataStruct.screenX = selfDataMembers.screenMouseX;
        _dataStruct.screenY = selfDataMembers.screenMouseY;

        //Send off the event.
        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(GW::I::GBufferedInputInterface::Events::BUTTONPRESSED, _dataStruct);

        GW::I::GBufferedInputImplementation* pBufferedInput = selfDataMembers.pBufferedInput;
        pBufferedInput->Push(gevent);

        if ([self nextResponder] != nil)
            [[self nextResponder]mouseDown:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, mouseUp, NSEvent* theEvent)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GResponder)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GResponder, self);
        GW::I::GBufferedInputImplementation::EVENT_DATA _dataStruct;
        _dataStruct.data = G_BUTTON_LEFT;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetKeyMask, theEvent);
        _dataStruct.keyMask = selfDataMembers.keyMask;
        //Get the mouse position relative to the window.
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetMouseLocation, theEvent);
        _dataStruct.x = selfDataMembers.relativeMouseX;
        _dataStruct.y = selfDataMembers.relativeMouseY;
        _dataStruct.screenX = selfDataMembers.screenMouseX;
        _dataStruct.screenY = selfDataMembers.screenMouseY;

        //Send off the event.
        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(GW::I::GBufferedInputInterface::Events::BUTTONRELEASED, _dataStruct);

        GW::I::GBufferedInputImplementation* pBufferedInput = selfDataMembers.pBufferedInput;
        pBufferedInput->Push(gevent);

        if ([self nextResponder] != nil)
            [[self nextResponder]mouseUp:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, mouseMoved, NSEvent* theEvent)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GResponder)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GResponder, self);
        GW::I::GBufferedInputImplementation::EVENT_DATA _dataStruct;
        _dataStruct.data = G_KEY_UNKNOWN;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetKeyMask, theEvent);
        _dataStruct.keyMask = selfDataMembers.keyMask;
        //Get the mouse position relative to the window.
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetMouseLocation, theEvent);
        _dataStruct.x = selfDataMembers.relativeMouseX;
        _dataStruct.y = selfDataMembers.relativeMouseY;
        _dataStruct.screenX = selfDataMembers.screenMouseX;
        _dataStruct.screenY = selfDataMembers.screenMouseY;

        if ((_dataStruct.x - selfDataMembers.lastMouseX) != 0 ||
            (_dataStruct.y - selfDataMembers.lastMouseY) != 0)
        {
            //Send off the event.
            GW::GEvent& gevent = selfDataMembers.gevent;
            gevent.Write(GW::I::GBufferedInputInterface::Events::MOUSEMOVE, _dataStruct);
            
            GW::I::GBufferedInputImplementation* pBufferedInput = selfDataMembers.pBufferedInput;
            pBufferedInput->Push(gevent);
            
            selfDataMembers.lastMouseX = _dataStruct.x;
            selfDataMembers.lastMouseY = _dataStruct.y;
        }
        
        if ([self nextResponder] != nil)
            [[self nextResponder]mouseMoved:theEvent];
    }
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, mouseDragged, NSEvent* theEvent)
    {
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, mouseMoved, theEvent);
    }
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, rightMouseDragged, NSEvent* theEvent)
    {
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, mouseMoved, theEvent);
    }
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, otherMouseDragged, NSEvent* theEvent)
    {
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, mouseMoved, theEvent);
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, rightMouseDown, NSEvent* theEvent)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GResponder)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GResponder, self);
        GW::I::GBufferedInputImplementation::EVENT_DATA _dataStruct;
        _dataStruct.data = G_BUTTON_RIGHT;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetKeyMask, theEvent);
        _dataStruct.keyMask = selfDataMembers.keyMask;
        //Get the mouse position relative to the window.
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetMouseLocation, theEvent);
        _dataStruct.x = selfDataMembers.relativeMouseX;
        _dataStruct.y = selfDataMembers.relativeMouseY;
        _dataStruct.screenX = selfDataMembers.screenMouseX;
        _dataStruct.screenY = selfDataMembers.screenMouseY;

        //Send off the event.
        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(GW::I::GBufferedInputInterface::Events::BUTTONPRESSED, _dataStruct);

        GW::I::GBufferedInputImplementation* pBufferedInput = selfDataMembers.pBufferedInput;
        pBufferedInput->Push(gevent);

        if ([self nextResponder] != nil)
            [[self nextResponder]rightMouseDown:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, rightMouseUp, NSEvent* theEvent)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GResponder)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GResponder, self);
        GW::I::GBufferedInputImplementation::EVENT_DATA _dataStruct;
        _dataStruct.data = G_BUTTON_RIGHT;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetKeyMask, theEvent);
        _dataStruct.keyMask = selfDataMembers.keyMask;
        //Get the mouse position relative to the window.
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetMouseLocation, theEvent);
        _dataStruct.x = selfDataMembers.relativeMouseX;
        _dataStruct.y = selfDataMembers.relativeMouseY;
        _dataStruct.screenX = selfDataMembers.screenMouseX;
        _dataStruct.screenY = selfDataMembers.screenMouseY;

        //Send off the event.
        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(GW::I::GBufferedInputInterface::Events::BUTTONRELEASED, _dataStruct);

        GW::I::GBufferedInputImplementation* pBufferedInput = selfDataMembers.pBufferedInput;
        pBufferedInput->Push(gevent);

        if ([self nextResponder] != nil)
            [[self nextResponder]rightMouseUp:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, otherMouseDown, NSEvent* theEvent)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GResponder)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GResponder, self);
        GW::I::GBufferedInputImplementation::EVENT_DATA _dataStruct;
        _dataStruct.data = G_BUTTON_MIDDLE;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetKeyMask, theEvent);
        _dataStruct.keyMask = selfDataMembers.keyMask;
        //Get the mouse position relative to the window.
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetMouseLocation, theEvent);
        _dataStruct.x = selfDataMembers.relativeMouseX;
        _dataStruct.y = selfDataMembers.relativeMouseY;
        _dataStruct.screenX = selfDataMembers.screenMouseX;
        _dataStruct.screenY = selfDataMembers.screenMouseY;

        //Send off the event.
        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(GW::I::GBufferedInputInterface::Events::BUTTONPRESSED, _dataStruct);

        GW::I::GBufferedInputImplementation* pBufferedInput = selfDataMembers.pBufferedInput;
        pBufferedInput->Push(gevent);

        if ([self nextResponder] != nil)
            [[self nextResponder]otherMouseDown:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, otherMouseUp, NSEvent* theEvent)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GResponder)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GResponder, self);
        GW::I::GBufferedInputImplementation::EVENT_DATA _dataStruct;
        _dataStruct.data = G_BUTTON_MIDDLE;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetKeyMask, theEvent);
        _dataStruct.keyMask = selfDataMembers.keyMask;
        //Get the mouse position relative to the window.
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetMouseLocation, theEvent);
        _dataStruct.x = selfDataMembers.relativeMouseX;
        _dataStruct.y = selfDataMembers.relativeMouseY;
        _dataStruct.screenX = selfDataMembers.screenMouseX;
        _dataStruct.screenY = selfDataMembers.screenMouseY;

        //Send off the event.
        GW::GEvent& gevent = selfDataMembers.gevent;
        gevent.Write(GW::I::GBufferedInputInterface::Events::BUTTONRELEASED, _dataStruct);

        GW::I::GBufferedInputImplementation* pBufferedInput = selfDataMembers.pBufferedInput;
        pBufferedInput->Push(gevent);

        if ([self nextResponder] != nil)
            [[self nextResponder]otherMouseUp:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, scrollWheel, NSEvent* theEvent)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GResponder)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GResponder, self);
        GW::I::GBufferedInputImplementation::EVENT_DATA _dataStruct;
        _dataStruct.data = 0;
        //Check wether the its a scroll up or down event.
        if ([theEvent scrollingDeltaY] > 0)
        {
            _dataStruct.data = G_MOUSE_SCROLL_UP;
        }
        if ([theEvent scrollingDeltaY] < 0)
        {
            _dataStruct.data = G_MOUSE_SCROLL_DOWN;
        }
        //Get the keymask using the getkeymask function/
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetKeyMask, theEvent);
        //Set the keymask.
        _dataStruct.keyMask = selfDataMembers.keyMask;
        //Get the mouse position relative to the window.
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GResponder, self, GetMouseLocation, theEvent);
        _dataStruct.x = selfDataMembers.relativeMouseX;
        _dataStruct.y = selfDataMembers.relativeMouseY;
        _dataStruct.screenX = selfDataMembers.screenMouseX;
        _dataStruct.screenY = selfDataMembers.screenMouseY;
        //Make sure theres data to send and send the data to all registered listeners.
        if (_dataStruct.data)
        {
            //Send off the event.
            GW::GEvent& gevent = selfDataMembers.gevent;
            gevent.Write(GW::I::GBufferedInputInterface::Events::MOUSESCROLL, _dataStruct);

            GW::I::GBufferedInputImplementation* pBufferedInput = selfDataMembers.pBufferedInput;
            pBufferedInput->Push(gevent);

        }
        if ([self nextResponder] != nil)
            [[self nextResponder]scrollWheel:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, GetKeyMask, NSEvent* theEvent)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GResponder)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GResponder, self);
        unsigned int& keyMask = selfDataMembers.keyMask;
        keyMask = 0;
        //Get the unsigned int of all the modifier flags.
        NSUInteger flags = [theEvent modifierFlags];
        //Check individual modifier flags and turn them on respectivly to our keymask(unsigned int).
        if (flags & NSEventModifierFlagShift)
        {
            G_TURNON_BIT(keyMask, G_MASK_SHIFT);
        }
        if (flags & NSEventModifierFlagOption)
        {
            G_TURNON_BIT(keyMask, G_MASK_ALT);
        }
        if (flags & NSEventModifierFlagCommand)
        {
            G_TURNON_BIT(keyMask, G_MASK_COMMAND);
        }
        if (flags & NSEventModifierFlagControl)
        {
            G_TURNON_BIT(keyMask, G_MASK_CONTROL);
        }
        if (flags & NSEventModifierFlagCapsLock)
        {
            G_TURNON_BIT(keyMask, G_MASK_CAPS_LOCK);
        }
        if (flags & NSEventModifierFlagFunction)
        {
            G_TURNON_BIT(keyMask, G_MASK_FUNCTION);
        }
        if (flags & NSEventModifierFlagNumericPad)
        {
            G_TURNON_BIT(keyMask, G_MASK_NUM_LOCK);
        }
    }
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GResponder, void, GetMouseLocation, NSEvent* theEvent)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GResponder)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GResponder, self);
        NSRect rect = selfDataMembers.targetWindow.frame;
        NSRect contentRect = [selfDataMembers.targetWindow contentRectForFrameRect : rect];
        NSPoint mousePosition = [theEvent locationInWindow];
        selfDataMembers.relativeMouseX = mousePosition.x;
        selfDataMembers.relativeMouseY = contentRect.size.height - mousePosition.y;
        //Get the mouse position relative to the screen.
        CGSize screenSize = [[NSScreen mainScreen] frame].size;
        NSPoint screenMousePosition = [NSEvent mouseLocation];
        selfDataMembers.screenMouseX = screenMousePosition.x;
        selfDataMembers.screenMouseY = screenSize.height - screenMousePosition.y;
    }

    // GResponder Implementation End
}


#elif defined(__linux__)
    #include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xresource.h>
// Need include guard for this because GInput and GBufferedInput uses this file
#ifndef GINPUTTABLEROUTING_HPP
#define GINPUTTABLEROUTING_HPP

// Defines platform specific key codes that is shared between
// GInput and GBufferedInput
namespace GW
{
	namespace I
	{
#if defined(_WIN32)
		constexpr unsigned int Keycodes[128] =
		{
			G_KEY_UNKNOWN,				// 0
			G_KEY_ESCAPE,				// 1
			G_KEY_1,					// 2
			G_KEY_2,					// 3
			G_KEY_3,					// 4
			G_KEY_4,					// 5
			G_KEY_5,					// 6
			G_KEY_6,					// 7
			G_KEY_7,					// 8
			G_KEY_8,					// 9
			G_KEY_9,					// 10
			G_KEY_0,					// 11
			G_KEY_MINUS,				// 12
			G_KEY_EQUALS,				// 13
			G_KEY_BACKSPACE,			// 14
			G_KEY_TAB,					// 15
			G_KEY_Q,					// 16
			G_KEY_W,					// 17
			G_KEY_E,					// 18
			G_KEY_R,					// 19
			G_KEY_T,					// 20
			G_KEY_Y,					// 21
			G_KEY_U,					// 22
			G_KEY_I,					// 23
			G_KEY_O,					// 24
			G_KEY_P,					// 25
			G_KEY_BRACKET_OPEN,			// 26
			G_KEY_BRACKET_CLOSE,		// 27
			G_KEY_ENTER,				// 28
			G_KEY_LEFTCONTROL,			// 29
			G_KEY_A,					// 30
			G_KEY_S,					// 31
			G_KEY_D,					// 32
			G_KEY_F,					// 33
			G_KEY_G,					// 34
			G_KEY_H,					// 35
			G_KEY_J,					// 36
			G_KEY_K,					// 37
			G_KEY_L,					// 38
			G_KEY_SEMICOLON,			// 39
			G_KEY_QUOTE,				// 40
			G_KEY_TILDE,				// 41
			G_KEY_LEFTSHIFT,			// 42
			G_KEY_BACKSLASH,			// 43
			G_KEY_Z,					// 44
			G_KEY_X,					// 45
			G_KEY_C,					// 46
			G_KEY_V,					// 47
			G_KEY_B,					// 48
			G_KEY_N,					// 49
			G_KEY_M,					// 50
			G_KEY_COMMA,				// 51
			G_KEY_PERIOD,				// 52
			G_KEY_FORWARDSLASH,			// 53
			G_KEY_RIGHTSHIFT,			// 54
			G_KEY_NUMPAD_MULTIPLY,		// 55
			G_KEY_LEFTALT,				// 56
			G_KEY_SPACE,				// 57
			G_KEY_CAPSLOCK,				// 58
			G_KEY_F1,					// 59
			G_KEY_F2,					// 60
			G_KEY_F3,					// 61
			G_KEY_F4,					// 62
			G_KEY_F5,					// 63
			G_KEY_F6,					// 64
			G_KEY_F7,					// 65
			G_KEY_F8,					// 66
			G_KEY_F9,					// 67
			G_KEY_F10,					// 68
			G_KEY_NUMLOCK,				// 69
			G_KEY_SCROLL_LOCK,			// 70
			G_KEY_NUMPAD_7,				// 71
			G_KEY_NUMPAD_8,				// 72
			G_KEY_NUMPAD_9,				// 73
			G_KEY_NUMPAD_SUBTRACT,		// 74
			G_KEY_NUMPAD_4,				// 75
			G_KEY_NUMPAD_5,				// 76
			G_KEY_NUMPAD_6,				// 77
			G_KEY_NUMPAD_ADD,			// 78
			G_KEY_NUMPAD_1,				// 79
			G_KEY_NUMPAD_2,				// 80
			G_KEY_NUMPAD_3,				// 81
			G_KEY_NUMPAD_0,				// 82
			G_KEY_NUMPAD_PERIOD,		// 83
			G_KEY_UNKNOWN,				// 84
			G_KEY_UNKNOWN,				// 85
			G_KEY_UNKNOWN,				// 86
			G_KEY_F11,					// 87
			G_KEY_F12,					// 88
			G_KEY_UNKNOWN,				// 89
			G_KEY_UNKNOWN,				// 90
			G_KEY_UNKNOWN,				// 91
			G_KEY_UNKNOWN,				// 92
			G_KEY_UNKNOWN,				// 93
			G_KEY_UNKNOWN,				// 94
			G_KEY_UNKNOWN,				// 95
			G_KEY_UNKNOWN,				// 96
			G_KEY_UNKNOWN,				// 97
			G_KEY_UNKNOWN,				// 98
			G_KEY_UNKNOWN,				// 99
			G_KEY_UNKNOWN,				// 100
			G_KEY_UNKNOWN,				// 101
			G_KEY_UNKNOWN,				// 102
			G_KEY_UNKNOWN,				// 103
			G_KEY_UNKNOWN,				// 104
			G_KEY_UNKNOWN,				// 105
			G_KEY_UNKNOWN,				// 106
			G_KEY_UNKNOWN,				// 107
			G_KEY_UNKNOWN,				// 108
			G_KEY_UNKNOWN,				// 109
			G_KEY_UNKNOWN,				// 110
			G_KEY_UNKNOWN,				// 111
			G_KEY_UNKNOWN,				// 112
			G_KEY_UNKNOWN,				// 113
			G_KEY_UNKNOWN,				// 114
			G_KEY_UNKNOWN,				// 115
			G_KEY_UNKNOWN,				// 116
			G_KEY_UNKNOWN,				// 117
			G_KEY_UNKNOWN,				// 118
			G_KEY_UNKNOWN,				// 119
			G_KEY_UNKNOWN,				// 120
			G_KEY_UNKNOWN,				// 121
			G_KEY_UNKNOWN,				// 122
			G_KEY_UNKNOWN,				// 123
			G_KEY_UNKNOWN,				// 124
			G_KEY_UNKNOWN,				// 125
			G_KEY_UNKNOWN,				// 126
			G_KEY_UNKNOWN				// 127
		};
#elif defined(__linux__)
		constexpr unsigned int Keycodes[128] =
		{
			G_KEY_UNKNOWN,			// 0
			G_KEY_UNKNOWN,			// 1
			G_KEY_UNKNOWN,			// 2
			G_KEY_UNKNOWN,			// 3
			G_KEY_UNKNOWN,			// 4
			G_KEY_UNKNOWN,			// 5
			G_KEY_UNKNOWN,			// 6
			G_KEY_UNKNOWN,			// 7
			G_KEY_UNKNOWN,			// 8
			G_KEY_ESCAPE,			// 9
			G_KEY_1,				// 10
			G_KEY_2,				// 11
			G_KEY_3,				// 12
			G_KEY_4,				// 13
			G_KEY_5,				// 14
			G_KEY_6,				// 15
			G_KEY_7,				// 16
			G_KEY_8,				// 17
			G_KEY_9,				// 18
			G_KEY_0,				// 19
			G_KEY_MINUS,			// 20
			G_KEY_EQUALS,			// 21
			G_KEY_BACKSPACE,		// 22
			G_KEY_TAB,				// 23
			G_KEY_Q,				// 24
			G_KEY_W,				// 25
			G_KEY_E,				// 26
			G_KEY_R,				// 27
			G_KEY_T,				// 28
			G_KEY_Y,				// 29
			G_KEY_U,				// 30
			G_KEY_I,				// 31
			G_KEY_O,				// 32
			G_KEY_P,				// 33
			G_KEY_BRACKET_OPEN,		// 34
			G_KEY_BRACKET_CLOSE,	// 35
			G_KEY_ENTER,			// 36
			G_KEY_LEFTCONTROL,		// 37
			G_KEY_A,				// 38
			G_KEY_S,				// 39
			G_KEY_D,				// 40
			G_KEY_F,				// 41
			G_KEY_G,				// 42
			G_KEY_H,				// 43
			G_KEY_J,				// 44
			G_KEY_K,				// 45
			G_KEY_L,				// 46
			G_KEY_SEMICOLON,		// 47
			G_KEY_QUOTE,			// 48
			G_KEY_TILDE,			// 49
			G_KEY_LEFTSHIFT,		// 50
			G_KEY_BACKSLASH,		// 51
			G_KEY_Z,				// 52
			G_KEY_X,				// 53
			G_KEY_C,				// 54
			G_KEY_V,				// 55
			G_KEY_B,				// 56
			G_KEY_N,				// 57
			G_KEY_M,				// 58
			G_KEY_COMMA,			// 59
			G_KEY_PERIOD,			// 60
			G_KEY_FORWARDSLASH,		// 61
			G_KEY_RIGHTSHIFT,		// 62
			G_KEY_NUMPAD_MULTIPLY,	// 63
			G_KEY_LEFTALT,			// 64
			G_KEY_SPACE,			// 65
			G_KEY_CAPSLOCK,			// 66
			G_KEY_F1,				// 67
			G_KEY_F2,				// 68
			G_KEY_F3,				// 69
			G_KEY_F4,				// 70
			G_KEY_F5,				// 71
			G_KEY_F6,				// 72
			G_KEY_F7,				// 73
			G_KEY_F8,				// 74
			G_KEY_F9,				// 75
			G_KEY_F10,				// 76
			G_KEY_NUMLOCK,			// 77
			G_KEY_SCROLL_LOCK,		// 78
			G_KEY_NUMPAD_7,			// 79
			G_KEY_NUMPAD_8,			// 80
			G_KEY_NUMPAD_9,			// 81
			G_KEY_NUMPAD_SUBTRACT,	// 82
			G_KEY_NUMPAD_4,			// 83
			G_KEY_NUMPAD_5,			// 84
			G_KEY_NUMPAD_6,			// 85
			G_KEY_NUMPAD_ADD,		// 86
			G_KEY_NUMPAD_1,			// 87
			G_KEY_NUMPAD_2,			// 88
			G_KEY_NUMPAD_3,			// 89
			G_KEY_NUMPAD_0,			// 90
			G_KEY_NUMPAD_PERIOD,	// 91
			G_KEY_UNKNOWN,			// 92
			G_KEY_UNKNOWN,			// 93
			G_KEY_UNKNOWN,			// 94
			G_KEY_F11,				// 95
			G_KEY_F12,				// 96
			G_KEY_UNKNOWN,			// 97
			G_KEY_UNKNOWN,			// 98
			G_KEY_UNKNOWN,			// 99
			G_KEY_UNKNOWN,			// 100
			G_KEY_UNKNOWN,			// 101
			G_KEY_UNKNOWN,			// 102
			G_KEY_UNKNOWN,			// 103
			G_KEY_NUMPAD_ENTER,		// 104
			G_KEY_UNKNOWN,			// 105
			G_KEY_NUMPAD_DIVIDE,	// 106
			G_KEY_PRINTSCREEN,		// 107
			G_KEY_RIGHTALT,			// 108
			G_KEY_UNKNOWN,			// 109
			G_KEY_HOME,				// 110
			G_KEY_UP,				// 111
			G_KEY_PAGEUP,			// 112
			G_KEY_LEFT,				// 113
			G_KEY_RIGHT,			// 114
			G_KEY_END,				// 115
			G_KEY_DOWN,				// 116
			G_KEY_PAGEDOWN,			// 117
			G_KEY_INSERT,			// 118
			G_KEY_DELETE,			// 119
			G_KEY_UNKNOWN,			// 120
			G_KEY_UNKNOWN,			// 121
			G_KEY_UNKNOWN,			// 122
			G_KEY_UNKNOWN,			// 123
			G_KEY_UNKNOWN,			// 124
			G_KEY_UNKNOWN,			// 125
			G_KEY_UNKNOWN,			// 126
			G_KEY_PAUSE				// 127
			
		};
#elif defined(__APPLE__)
		constexpr unsigned int Keycodes[128] =
		{
			G_KEY_A,				// 0
			G_KEY_S,				// 1
			G_KEY_D,				// 2
			G_KEY_F,				// 3
			G_KEY_H,				// 4
			G_KEY_G,				// 5
			G_KEY_Z,				// 6
			G_KEY_X,				// 7
			G_KEY_C,				// 8
			G_KEY_V,				// 9
			G_KEY_UNKNOWN,			// 10
			G_KEY_B,				// 11
			G_KEY_Q,				// 12
			G_KEY_W,				// 13
			G_KEY_E,				// 14
			G_KEY_R,				// 15
			G_KEY_Y,				// 16
			G_KEY_T,				// 17
			G_KEY_1,				// 18
			G_KEY_2,				// 19
			G_KEY_3,				// 20
			G_KEY_4,				// 21
			G_KEY_6,				// 22
			G_KEY_5,				// 23
			G_KEY_EQUALS,			// 24
			G_KEY_9,				// 25
			G_KEY_7,				// 26
			G_KEY_MINUS,			// 27
			G_KEY_8,				// 28
			G_KEY_0,				// 29
			G_KEY_BRACKET_CLOSE,	// 30
			G_KEY_O,				// 31
			G_KEY_U,				// 32
			G_KEY_BRACKET_OPEN,		// 33
			G_KEY_I,				// 34
			G_KEY_P,				// 35
			G_KEY_ENTER,			// 36
			G_KEY_L,				// 37
			G_KEY_J,				// 38
			G_KEY_QUOTE,			// 39
			G_KEY_K,				// 40
			G_KEY_SEMICOLON,		// 41
			G_KEY_BACKSLASH,		// 42
			G_KEY_COMMA,			// 43
			G_KEY_FORWARDSLASH,		// 44
			G_KEY_N,				// 45
			G_KEY_M,				// 46
			G_KEY_PERIOD,			// 47
			G_KEY_TAB,				// 48
			G_KEY_SPACE,			// 49
			G_KEY_TILDE,			// 50
			G_KEY_DELETE,			// 51
			G_KEY_UNKNOWN,			// 52
			G_KEY_ESCAPE,			// 53
			G_KEY_UNKNOWN,			// 54
			G_KEY_COMMAND,		    // 55
			G_KEY_LEFTSHIFT,		// 56
			G_KEY_CAPSLOCK,			// 57
			G_KEY_LEFTALT,			// 58
			G_KEY_LEFTCONTROL,		// 59
			G_KEY_RIGHTSHIFT,		// 60
			G_KEY_RIGHTALT,			// 61
			G_KEY_RIGHTCONTROL,		// 62
			G_KEY_UNKNOWN,			// 63
			G_KEY_UNKNOWN,			// 64
			G_KEY_NUMPAD_PERIOD,	// 65
			G_KEY_UNKNOWN,			// 66
			G_KEY_NUMPAD_MULTIPLY,	// 67
			G_KEY_UNKNOWN,			// 68
			G_KEY_NUMPAD_ADD,		// 69
			G_KEY_UNKNOWN,			// 70
			G_KEY_NUMLOCK,			// 71
			G_KEY_UNKNOWN,			// 72
			G_KEY_UNKNOWN,			// 73
			G_KEY_UNKNOWN,			// 74
			G_KEY_NUMPAD_DIVIDE,	// 75
			G_KEY_NUMPAD_ENTER,		// 76
			G_KEY_UNKNOWN,			// 77
			G_KEY_NUMPAD_SUBTRACT,	// 78
			G_KEY_UNKNOWN,			// 79
			G_KEY_UNKNOWN,			// 80
			G_KEY_EQUALS,			// 81
			G_KEY_NUMPAD_0,			// 82
			G_KEY_NUMPAD_1,			// 83
			G_KEY_NUMPAD_2,			// 84
			G_KEY_NUMPAD_3,			// 85
			G_KEY_NUMPAD_4,			// 86
			G_KEY_NUMPAD_5,			// 87
			G_KEY_NUMPAD_6,			// 88
			G_KEY_NUMPAD_7,			// 89
			G_KEY_UNKNOWN,			// 90
			G_KEY_NUMPAD_8,			// 91
			G_KEY_NUMPAD_9,			// 92
			G_KEY_UNKNOWN,			// 93
			G_KEY_UNKNOWN,			// 94
			G_KEY_UNKNOWN,			// 95
			G_KEY_F5,				// 96
			G_KEY_F6,				// 97
			G_KEY_F7,				// 98
			G_KEY_F3,				// 99
			G_KEY_F8,				// 100
			G_KEY_F9,				// 101
			G_KEY_UNKNOWN,			// 102
			G_KEY_F11,				// 103
			G_KEY_UNKNOWN,			// 104
			G_KEY_UNKNOWN,			// 105
			G_KEY_UNKNOWN,			// 106
			G_KEY_UNKNOWN,			// 107
			G_KEY_UNKNOWN,			// 108
			G_KEY_F10,				// 109
			G_KEY_UNKNOWN,			// 110
			G_KEY_F12,				// 111
			G_KEY_UNKNOWN,			// 112
			G_KEY_UNKNOWN,			// 113
			G_KEY_INSERT,			// 114
			G_KEY_HOME,				// 115
			G_KEY_PAGEUP,			// 116
			G_KEY_DELETE,			// 117
			G_KEY_F4,				// 118
			G_KEY_END,				// 119
			G_KEY_F2,				// 120
			G_KEY_PAGEDOWN,			// 121
			G_KEY_F1,				// 122
			G_KEY_LEFT,				// 123
			G_KEY_RIGHT,			// 124
			G_KEY_DOWN,				// 125
			G_KEY_UP,				// 126
            G_KEY_UNKNOWN           // 127
		};
#endif
	}
}
#endif





namespace GW
{
	namespace I
	{
		class GBufferedInputImplementation :	public virtual GBufferedInputInterface,
												public GEventGeneratorImplementation
		{
		private:
			unsigned int keyMask;
			Display* display = nullptr;
			Window window = 0;
			GW::SYSTEM::GDaemon inputDaemon;
			GW::CORE::GEventReceiver watcher;
			unsigned int keyStates[256]; // 1 for on, 0 for off
			unsigned int buttonStates[32]; // 1 for on, 0 for off
			int lastMouseX = 0, lastMouseY = 0;
		public:
			~GBufferedInputImplementation()
			{
				inputDaemon = nullptr;
			}
			
			GReturn Create(GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE _uwh)
			{
				if (!_uwh.window || !_uwh.display)
					return GReturn::INVALID_ARGUMENT;
					
				window = *((Window*)(_uwh.window));
				display = ((Display*)(_uwh.display));
				keyMask = 0;
				
				XInitThreads();// daemon run on another thread
				return inputDaemon.Create(G_BUFFEREDINPUT_OPERATION_INTERVAL, [&]()
				{
					int _code = -1;
					GEvent m_GEvent;
					Events m_Event = Events::Invalid;
					EVENT_DATA m_EventData;
					Window a, b;
					
					LockAsyncRead();
					XQueryPointer(display, window, &a, &b, &m_EventData.screenX, &m_EventData.screenY, &m_EventData.x, &m_EventData.y, &m_EventData.keyMask);

					char keys_return[32];
					//Get the current state of all keys.
					XQueryKeymap(display, keys_return);
					UnlockAsyncRead();
					//Loop through all the keys and check to see if they match the saved state of all the keys.
					for (unsigned int i = 5; i < 126; ++i) 
					{
						m_EventData.data = Keycodes[i];
						//Save the state of current key.
						unsigned int key = keys_return[(i >> 3)] & (1 << (i & 7));
						//If a key does not match send an event saying it has been updated.
						if (key != keyStates[m_EventData.data]) 
						{
							if (key == 0) 
							{
								m_Event = Events::KEYRELEASED;
							}
							else
							{
								m_Event = Events::KEYPRESSED;
							}
							
							//Send the event to all registered listeners.
							m_GEvent.Write(m_Event, m_EventData);
							Push(m_GEvent);
							keyStates[m_EventData.data] = key;
						}
					}

					if (m_EventData.keyMask & Button1Mask) 
					{
						if (!keyStates[G_BUTTON_LEFT]) 
						{
							m_EventData.data = G_BUTTON_LEFT;
							m_Event = Events::BUTTONPRESSED;
							keyStates[G_BUTTON_LEFT] = 1;
							//Send the event to all registered listeners.
							m_GEvent.Write(m_Event, m_EventData);
							Push(m_GEvent);
						}
					}
					else 
					{
						if (keyStates[G_BUTTON_LEFT]) 
						{
							m_EventData.data = G_BUTTON_LEFT;
							m_Event = Events::BUTTONRELEASED;
							keyStates[G_BUTTON_LEFT] = 0;
							//Send the event to all registered listeners.
							m_GEvent.Write(m_Event, m_EventData);
							Push(m_GEvent);
						}
					}
					
					if (m_EventData.keyMask & Button2Mask) 
					{
						if (!keyStates[G_BUTTON_MIDDLE]) 
						{
							m_EventData.data = G_BUTTON_MIDDLE;
							m_Event = Events::BUTTONPRESSED;
							keyStates[G_BUTTON_MIDDLE] = 1;
							//Send the event to all registered listeners.
							m_GEvent.Write(m_Event, m_EventData);
							Push(m_GEvent);
						}
					}
					else 
					{
						if (keyStates[G_BUTTON_MIDDLE]) 
						{
							m_EventData.data = G_BUTTON_MIDDLE;
							m_Event = Events::BUTTONRELEASED;
							keyStates[G_BUTTON_MIDDLE] = 0;
							//Send the event to all registered listeners.
							m_GEvent.Write(m_Event, m_EventData);
							Push(m_GEvent);
						}
					}
		
					if (m_EventData.keyMask & Button3Mask) 
					{
						if (!keyStates[G_BUTTON_RIGHT]) 
						{
							m_EventData.data = G_BUTTON_RIGHT;
							m_Event = Events::BUTTONPRESSED;
							keyStates[G_BUTTON_RIGHT] = 1;
							//Send the event to all registered listeners.
							m_GEvent.Write(m_Event, m_EventData);
							Push(m_GEvent);
						}
					}
					else 
					{
						if (keyStates[G_BUTTON_RIGHT]) 
						{
							m_EventData.data = G_BUTTON_RIGHT;
							m_Event = Events::BUTTONRELEASED;
							keyStates[G_BUTTON_RIGHT] = 0;
							//Send the event to all registered listeners.
							m_GEvent.Write(m_Event, m_EventData);
							Push(m_GEvent);
						}
					}
					
					if ((m_EventData.x - lastMouseX) != 0 || (m_EventData.y - lastMouseY) != 0)
					{
						m_EventData.data = G_KEY_UNKNOWN;
						m_Event = Events::MOUSEMOVE;
						//Send the event to all registered listeners.
						m_GEvent.Write(m_Event, m_EventData);
						Push(m_GEvent);
						
						lastMouseX = m_EventData.x;
						lastMouseY = m_EventData.y;
					}					
				});
			}
			
			GReturn Create(GW::SYSTEM::GWindow _window)
			{
				if (!_window)
					return GReturn::INVALID_ARGUMENT;

				GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE uwh;
				GReturn code = _window.GetWindowHandle(uwh);
				if (G_FAIL(code))
					return code;

				// stop if window is killed
				watcher.Create(_window, [&](){
					if (+watcher.Find(GW::SYSTEM::GWindow::Events::DESTROY, true))
						inputDaemon = nullptr;
				});
				
				return Create(uwh);
			}
		};
	}
}

#elif defined(_WIN32)
    #include <map>
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
// Need include guard for this because GInput and GBufferedInput uses this file
#ifndef GINPUTTABLEROUTING_HPP
#define GINPUTTABLEROUTING_HPP

// Defines platform specific key codes that is shared between
// GInput and GBufferedInput
namespace GW
{
	namespace I
	{
#if defined(_WIN32)
		constexpr unsigned int Keycodes[128] =
		{
			G_KEY_UNKNOWN,				// 0
			G_KEY_ESCAPE,				// 1
			G_KEY_1,					// 2
			G_KEY_2,					// 3
			G_KEY_3,					// 4
			G_KEY_4,					// 5
			G_KEY_5,					// 6
			G_KEY_6,					// 7
			G_KEY_7,					// 8
			G_KEY_8,					// 9
			G_KEY_9,					// 10
			G_KEY_0,					// 11
			G_KEY_MINUS,				// 12
			G_KEY_EQUALS,				// 13
			G_KEY_BACKSPACE,			// 14
			G_KEY_TAB,					// 15
			G_KEY_Q,					// 16
			G_KEY_W,					// 17
			G_KEY_E,					// 18
			G_KEY_R,					// 19
			G_KEY_T,					// 20
			G_KEY_Y,					// 21
			G_KEY_U,					// 22
			G_KEY_I,					// 23
			G_KEY_O,					// 24
			G_KEY_P,					// 25
			G_KEY_BRACKET_OPEN,			// 26
			G_KEY_BRACKET_CLOSE,		// 27
			G_KEY_ENTER,				// 28
			G_KEY_LEFTCONTROL,			// 29
			G_KEY_A,					// 30
			G_KEY_S,					// 31
			G_KEY_D,					// 32
			G_KEY_F,					// 33
			G_KEY_G,					// 34
			G_KEY_H,					// 35
			G_KEY_J,					// 36
			G_KEY_K,					// 37
			G_KEY_L,					// 38
			G_KEY_SEMICOLON,			// 39
			G_KEY_QUOTE,				// 40
			G_KEY_TILDE,				// 41
			G_KEY_LEFTSHIFT,			// 42
			G_KEY_BACKSLASH,			// 43
			G_KEY_Z,					// 44
			G_KEY_X,					// 45
			G_KEY_C,					// 46
			G_KEY_V,					// 47
			G_KEY_B,					// 48
			G_KEY_N,					// 49
			G_KEY_M,					// 50
			G_KEY_COMMA,				// 51
			G_KEY_PERIOD,				// 52
			G_KEY_FORWARDSLASH,			// 53
			G_KEY_RIGHTSHIFT,			// 54
			G_KEY_NUMPAD_MULTIPLY,		// 55
			G_KEY_LEFTALT,				// 56
			G_KEY_SPACE,				// 57
			G_KEY_CAPSLOCK,				// 58
			G_KEY_F1,					// 59
			G_KEY_F2,					// 60
			G_KEY_F3,					// 61
			G_KEY_F4,					// 62
			G_KEY_F5,					// 63
			G_KEY_F6,					// 64
			G_KEY_F7,					// 65
			G_KEY_F8,					// 66
			G_KEY_F9,					// 67
			G_KEY_F10,					// 68
			G_KEY_NUMLOCK,				// 69
			G_KEY_SCROLL_LOCK,			// 70
			G_KEY_NUMPAD_7,				// 71
			G_KEY_NUMPAD_8,				// 72
			G_KEY_NUMPAD_9,				// 73
			G_KEY_NUMPAD_SUBTRACT,		// 74
			G_KEY_NUMPAD_4,				// 75
			G_KEY_NUMPAD_5,				// 76
			G_KEY_NUMPAD_6,				// 77
			G_KEY_NUMPAD_ADD,			// 78
			G_KEY_NUMPAD_1,				// 79
			G_KEY_NUMPAD_2,				// 80
			G_KEY_NUMPAD_3,				// 81
			G_KEY_NUMPAD_0,				// 82
			G_KEY_NUMPAD_PERIOD,		// 83
			G_KEY_UNKNOWN,				// 84
			G_KEY_UNKNOWN,				// 85
			G_KEY_UNKNOWN,				// 86
			G_KEY_F11,					// 87
			G_KEY_F12,					// 88
			G_KEY_UNKNOWN,				// 89
			G_KEY_UNKNOWN,				// 90
			G_KEY_UNKNOWN,				// 91
			G_KEY_UNKNOWN,				// 92
			G_KEY_UNKNOWN,				// 93
			G_KEY_UNKNOWN,				// 94
			G_KEY_UNKNOWN,				// 95
			G_KEY_UNKNOWN,				// 96
			G_KEY_UNKNOWN,				// 97
			G_KEY_UNKNOWN,				// 98
			G_KEY_UNKNOWN,				// 99
			G_KEY_UNKNOWN,				// 100
			G_KEY_UNKNOWN,				// 101
			G_KEY_UNKNOWN,				// 102
			G_KEY_UNKNOWN,				// 103
			G_KEY_UNKNOWN,				// 104
			G_KEY_UNKNOWN,				// 105
			G_KEY_UNKNOWN,				// 106
			G_KEY_UNKNOWN,				// 107
			G_KEY_UNKNOWN,				// 108
			G_KEY_UNKNOWN,				// 109
			G_KEY_UNKNOWN,				// 110
			G_KEY_UNKNOWN,				// 111
			G_KEY_UNKNOWN,				// 112
			G_KEY_UNKNOWN,				// 113
			G_KEY_UNKNOWN,				// 114
			G_KEY_UNKNOWN,				// 115
			G_KEY_UNKNOWN,				// 116
			G_KEY_UNKNOWN,				// 117
			G_KEY_UNKNOWN,				// 118
			G_KEY_UNKNOWN,				// 119
			G_KEY_UNKNOWN,				// 120
			G_KEY_UNKNOWN,				// 121
			G_KEY_UNKNOWN,				// 122
			G_KEY_UNKNOWN,				// 123
			G_KEY_UNKNOWN,				// 124
			G_KEY_UNKNOWN,				// 125
			G_KEY_UNKNOWN,				// 126
			G_KEY_UNKNOWN				// 127
		};
#elif defined(__linux__)
		constexpr unsigned int Keycodes[128] =
		{
			G_KEY_UNKNOWN,			// 0
			G_KEY_UNKNOWN,			// 1
			G_KEY_UNKNOWN,			// 2
			G_KEY_UNKNOWN,			// 3
			G_KEY_UNKNOWN,			// 4
			G_KEY_UNKNOWN,			// 5
			G_KEY_UNKNOWN,			// 6
			G_KEY_UNKNOWN,			// 7
			G_KEY_UNKNOWN,			// 8
			G_KEY_ESCAPE,			// 9
			G_KEY_1,				// 10
			G_KEY_2,				// 11
			G_KEY_3,				// 12
			G_KEY_4,				// 13
			G_KEY_5,				// 14
			G_KEY_6,				// 15
			G_KEY_7,				// 16
			G_KEY_8,				// 17
			G_KEY_9,				// 18
			G_KEY_0,				// 19
			G_KEY_MINUS,			// 20
			G_KEY_EQUALS,			// 21
			G_KEY_BACKSPACE,		// 22
			G_KEY_TAB,				// 23
			G_KEY_Q,				// 24
			G_KEY_W,				// 25
			G_KEY_E,				// 26
			G_KEY_R,				// 27
			G_KEY_T,				// 28
			G_KEY_Y,				// 29
			G_KEY_U,				// 30
			G_KEY_I,				// 31
			G_KEY_O,				// 32
			G_KEY_P,				// 33
			G_KEY_BRACKET_OPEN,		// 34
			G_KEY_BRACKET_CLOSE,	// 35
			G_KEY_ENTER,			// 36
			G_KEY_LEFTCONTROL,		// 37
			G_KEY_A,				// 38
			G_KEY_S,				// 39
			G_KEY_D,				// 40
			G_KEY_F,				// 41
			G_KEY_G,				// 42
			G_KEY_H,				// 43
			G_KEY_J,				// 44
			G_KEY_K,				// 45
			G_KEY_L,				// 46
			G_KEY_SEMICOLON,		// 47
			G_KEY_QUOTE,			// 48
			G_KEY_TILDE,			// 49
			G_KEY_LEFTSHIFT,		// 50
			G_KEY_BACKSLASH,		// 51
			G_KEY_Z,				// 52
			G_KEY_X,				// 53
			G_KEY_C,				// 54
			G_KEY_V,				// 55
			G_KEY_B,				// 56
			G_KEY_N,				// 57
			G_KEY_M,				// 58
			G_KEY_COMMA,			// 59
			G_KEY_PERIOD,			// 60
			G_KEY_FORWARDSLASH,		// 61
			G_KEY_RIGHTSHIFT,		// 62
			G_KEY_NUMPAD_MULTIPLY,	// 63
			G_KEY_LEFTALT,			// 64
			G_KEY_SPACE,			// 65
			G_KEY_CAPSLOCK,			// 66
			G_KEY_F1,				// 67
			G_KEY_F2,				// 68
			G_KEY_F3,				// 69
			G_KEY_F4,				// 70
			G_KEY_F5,				// 71
			G_KEY_F6,				// 72
			G_KEY_F7,				// 73
			G_KEY_F8,				// 74
			G_KEY_F9,				// 75
			G_KEY_F10,				// 76
			G_KEY_NUMLOCK,			// 77
			G_KEY_SCROLL_LOCK,		// 78
			G_KEY_NUMPAD_7,			// 79
			G_KEY_NUMPAD_8,			// 80
			G_KEY_NUMPAD_9,			// 81
			G_KEY_NUMPAD_SUBTRACT,	// 82
			G_KEY_NUMPAD_4,			// 83
			G_KEY_NUMPAD_5,			// 84
			G_KEY_NUMPAD_6,			// 85
			G_KEY_NUMPAD_ADD,		// 86
			G_KEY_NUMPAD_1,			// 87
			G_KEY_NUMPAD_2,			// 88
			G_KEY_NUMPAD_3,			// 89
			G_KEY_NUMPAD_0,			// 90
			G_KEY_NUMPAD_PERIOD,	// 91
			G_KEY_UNKNOWN,			// 92
			G_KEY_UNKNOWN,			// 93
			G_KEY_UNKNOWN,			// 94
			G_KEY_F11,				// 95
			G_KEY_F12,				// 96
			G_KEY_UNKNOWN,			// 97
			G_KEY_UNKNOWN,			// 98
			G_KEY_UNKNOWN,			// 99
			G_KEY_UNKNOWN,			// 100
			G_KEY_UNKNOWN,			// 101
			G_KEY_UNKNOWN,			// 102
			G_KEY_UNKNOWN,			// 103
			G_KEY_NUMPAD_ENTER,		// 104
			G_KEY_UNKNOWN,			// 105
			G_KEY_NUMPAD_DIVIDE,	// 106
			G_KEY_PRINTSCREEN,		// 107
			G_KEY_RIGHTALT,			// 108
			G_KEY_UNKNOWN,			// 109
			G_KEY_HOME,				// 110
			G_KEY_UP,				// 111
			G_KEY_PAGEUP,			// 112
			G_KEY_LEFT,				// 113
			G_KEY_RIGHT,			// 114
			G_KEY_END,				// 115
			G_KEY_DOWN,				// 116
			G_KEY_PAGEDOWN,			// 117
			G_KEY_INSERT,			// 118
			G_KEY_DELETE,			// 119
			G_KEY_UNKNOWN,			// 120
			G_KEY_UNKNOWN,			// 121
			G_KEY_UNKNOWN,			// 122
			G_KEY_UNKNOWN,			// 123
			G_KEY_UNKNOWN,			// 124
			G_KEY_UNKNOWN,			// 125
			G_KEY_UNKNOWN,			// 126
			G_KEY_PAUSE				// 127
			
		};
#elif defined(__APPLE__)
		constexpr unsigned int Keycodes[128] =
		{
			G_KEY_A,				// 0
			G_KEY_S,				// 1
			G_KEY_D,				// 2
			G_KEY_F,				// 3
			G_KEY_H,				// 4
			G_KEY_G,				// 5
			G_KEY_Z,				// 6
			G_KEY_X,				// 7
			G_KEY_C,				// 8
			G_KEY_V,				// 9
			G_KEY_UNKNOWN,			// 10
			G_KEY_B,				// 11
			G_KEY_Q,				// 12
			G_KEY_W,				// 13
			G_KEY_E,				// 14
			G_KEY_R,				// 15
			G_KEY_Y,				// 16
			G_KEY_T,				// 17
			G_KEY_1,				// 18
			G_KEY_2,				// 19
			G_KEY_3,				// 20
			G_KEY_4,				// 21
			G_KEY_6,				// 22
			G_KEY_5,				// 23
			G_KEY_EQUALS,			// 24
			G_KEY_9,				// 25
			G_KEY_7,				// 26
			G_KEY_MINUS,			// 27
			G_KEY_8,				// 28
			G_KEY_0,				// 29
			G_KEY_BRACKET_CLOSE,	// 30
			G_KEY_O,				// 31
			G_KEY_U,				// 32
			G_KEY_BRACKET_OPEN,		// 33
			G_KEY_I,				// 34
			G_KEY_P,				// 35
			G_KEY_ENTER,			// 36
			G_KEY_L,				// 37
			G_KEY_J,				// 38
			G_KEY_QUOTE,			// 39
			G_KEY_K,				// 40
			G_KEY_SEMICOLON,		// 41
			G_KEY_BACKSLASH,		// 42
			G_KEY_COMMA,			// 43
			G_KEY_FORWARDSLASH,		// 44
			G_KEY_N,				// 45
			G_KEY_M,				// 46
			G_KEY_PERIOD,			// 47
			G_KEY_TAB,				// 48
			G_KEY_SPACE,			// 49
			G_KEY_TILDE,			// 50
			G_KEY_DELETE,			// 51
			G_KEY_UNKNOWN,			// 52
			G_KEY_ESCAPE,			// 53
			G_KEY_UNKNOWN,			// 54
			G_KEY_COMMAND,		    // 55
			G_KEY_LEFTSHIFT,		// 56
			G_KEY_CAPSLOCK,			// 57
			G_KEY_LEFTALT,			// 58
			G_KEY_LEFTCONTROL,		// 59
			G_KEY_RIGHTSHIFT,		// 60
			G_KEY_RIGHTALT,			// 61
			G_KEY_RIGHTCONTROL,		// 62
			G_KEY_UNKNOWN,			// 63
			G_KEY_UNKNOWN,			// 64
			G_KEY_NUMPAD_PERIOD,	// 65
			G_KEY_UNKNOWN,			// 66
			G_KEY_NUMPAD_MULTIPLY,	// 67
			G_KEY_UNKNOWN,			// 68
			G_KEY_NUMPAD_ADD,		// 69
			G_KEY_UNKNOWN,			// 70
			G_KEY_NUMLOCK,			// 71
			G_KEY_UNKNOWN,			// 72
			G_KEY_UNKNOWN,			// 73
			G_KEY_UNKNOWN,			// 74
			G_KEY_NUMPAD_DIVIDE,	// 75
			G_KEY_NUMPAD_ENTER,		// 76
			G_KEY_UNKNOWN,			// 77
			G_KEY_NUMPAD_SUBTRACT,	// 78
			G_KEY_UNKNOWN,			// 79
			G_KEY_UNKNOWN,			// 80
			G_KEY_EQUALS,			// 81
			G_KEY_NUMPAD_0,			// 82
			G_KEY_NUMPAD_1,			// 83
			G_KEY_NUMPAD_2,			// 84
			G_KEY_NUMPAD_3,			// 85
			G_KEY_NUMPAD_4,			// 86
			G_KEY_NUMPAD_5,			// 87
			G_KEY_NUMPAD_6,			// 88
			G_KEY_NUMPAD_7,			// 89
			G_KEY_UNKNOWN,			// 90
			G_KEY_NUMPAD_8,			// 91
			G_KEY_NUMPAD_9,			// 92
			G_KEY_UNKNOWN,			// 93
			G_KEY_UNKNOWN,			// 94
			G_KEY_UNKNOWN,			// 95
			G_KEY_F5,				// 96
			G_KEY_F6,				// 97
			G_KEY_F7,				// 98
			G_KEY_F3,				// 99
			G_KEY_F8,				// 100
			G_KEY_F9,				// 101
			G_KEY_UNKNOWN,			// 102
			G_KEY_F11,				// 103
			G_KEY_UNKNOWN,			// 104
			G_KEY_UNKNOWN,			// 105
			G_KEY_UNKNOWN,			// 106
			G_KEY_UNKNOWN,			// 107
			G_KEY_UNKNOWN,			// 108
			G_KEY_F10,				// 109
			G_KEY_UNKNOWN,			// 110
			G_KEY_F12,				// 111
			G_KEY_UNKNOWN,			// 112
			G_KEY_UNKNOWN,			// 113
			G_KEY_INSERT,			// 114
			G_KEY_HOME,				// 115
			G_KEY_PAGEUP,			// 116
			G_KEY_DELETE,			// 117
			G_KEY_F4,				// 118
			G_KEY_END,				// 119
			G_KEY_F2,				// 120
			G_KEY_PAGEDOWN,			// 121
			G_KEY_F1,				// 122
			G_KEY_LEFT,				// 123
			G_KEY_RIGHT,			// 124
			G_KEY_DOWN,				// 125
			G_KEY_UP,				// 126
            G_KEY_UNKNOWN           // 127
		};
#endif
	}
}
#endif


#include <vector>

namespace internal_gw
{
	struct GBUFFEREDINPUT_GLOBAL
	{
		unsigned int keyMask = 0;
		LONG_PTR _userWinProc = 0;
		POINT lastMousePosition = { 0, 0 };
		UCHAR lastPressedState[256] = { 0, };
		GW::CORE::GEventGenerator keyEvents;
		GBUFFEREDINPUT_GLOBAL() {
			keyEvents.Create();
		}
	};
	static GBUFFEREDINPUT_GLOBAL& GBufferedInputGlobal()
	{
		static GBUFFEREDINPUT_GLOBAL gdata;
		return gdata;
	}
}

namespace GW
{
	namespace I
	{
		class GBufferedInputImplementation : public virtual GBufferedInputInterface
		{
		private:
			HWND wndHandle = nullptr;
			
			static LRESULT CALLBACK GWindowProcedure(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
			{
				switch (uMsg)
				{
				case WM_INPUT:
				{
					GEvent m_GEvent;
					Events m_Event = Events::Invalid;
					EVENT_DATA m_EventData;

					POINT p;
					if (GetCursorPos(&p))
					{
						m_EventData.screenX = p.x;
						m_EventData.screenY = p.y;
					}
					if (ScreenToClient(hWnd, &p))
					{
						m_EventData.x = p.x;
						m_EventData.y = p.y;
					}

					UINT dwSize = 0;
					unsigned int keyMask = internal_gw::GBufferedInputGlobal().keyMask;
					//Get the size of RawInput
					GetRawInputData((HRAWINPUT)lParam, RID_INPUT, NULL, &dwSize, sizeof(RAWINPUTHEADER));
					static std::vector<BYTE> rawbuff;
					if (rawbuff.capacity() < dwSize)
						rawbuff.reserve(dwSize);
					if (GetRawInputData((HRAWINPUT)lParam, RID_INPUT, rawbuff.data(), &dwSize, sizeof(RAWINPUTHEADER)) != dwSize)
					{
						break;
					}
					RAWINPUT* raw = (RAWINPUT*)rawbuff.data();
					m_Event = Events::Invalid;
					m_EventData.data = -1;

					if (raw->header.dwType == RIM_TYPEKEYBOARD)
					{
						//Get G_KEY
						m_EventData.data = Keycodes[raw->data.keyboard.MakeCode];

						//Set state released or pressed.
						switch (raw->data.keyboard.Message) {
						case 256:

							m_Event = Events::KEYPRESSED;
							switch (m_EventData.data) {
							case G_KEY_RIGHTSHIFT:
							case G_KEY_LEFTSHIFT:
								G_TURNON_BIT(keyMask, G_MASK_SHIFT);
								break;
							case G_KEY_RIGHTCONTROL:
							case G_KEY_LEFTCONTROL:
								G_TURNON_BIT(keyMask, G_MASK_CONTROL);
								break;
							case G_KEY_CAPSLOCK:
								G_TOGGLE_BIT(keyMask, G_MASK_CAPS_LOCK);
								break;
							case G_KEY_NUMLOCK:
								G_TOGGLE_BIT(keyMask, G_MASK_NUM_LOCK);
								break;
							case G_KEY_SCROLL_LOCK:
								G_TOGGLE_BIT(keyMask, G_MASK_SCROLL_LOCK);
								break;
							}
							break;
						case 257:
							m_Event = Events::KEYRELEASED;
							switch (m_EventData.data) {
							case G_KEY_RIGHTSHIFT:
							case G_KEY_LEFTSHIFT:
								G_TURNOFF_BIT(keyMask, G_MASK_SHIFT);
								break;
							case G_KEY_RIGHTCONTROL:
							case G_KEY_LEFTCONTROL:
								G_TURNOFF_BIT(keyMask, G_MASK_CONTROL);
								break;
							}
							break;
						}
					}
					else if (raw->header.dwType == RIM_TYPEMOUSE)
					{
						//Mouse button events and movement events can occur at the same time.
						switch (raw->data.mouse.usFlags) {
							//Mouse Move
						case 0:
						case 1:
							//Check if the mouse position changed by at least a pixel amount, we don't want to send messages for sub-pixel change.
							if ((m_EventData.x - internal_gw::GBufferedInputGlobal().lastMousePosition.x) != 0 ||
								(m_EventData.y - internal_gw::GBufferedInputGlobal().lastMousePosition.y) != 0)
							{
								m_EventData.data = G_KEY_UNKNOWN;
								m_EventData.keyMask = keyMask;

								m_Event = Events::MOUSEMOVE;
								m_GEvent.Write(m_Event, m_EventData);
								internal_gw::GBufferedInputGlobal().keyEvents.Push(m_GEvent);

								internal_gw::GBufferedInputGlobal().lastMousePosition = { m_EventData.x, m_EventData.y };
							}
							break;
						}

						//Set Code
						switch (raw->data.mouse.ulButtons) {
						case 1:
						case 2:
							m_EventData.data = G_BUTTON_LEFT;
							break;
						case 4:
						case 8:
							m_EventData.data = G_BUTTON_RIGHT;
							break;
						case 16:
						case 32:
							m_EventData.data = G_BUTTON_MIDDLE;
							break;
						}

						switch (raw->data.mouse.usButtonData) {
						case 120:
							m_EventData.data = G_MOUSE_SCROLL_UP;
							break;
						case 65416:
							m_EventData.data = G_MOUSE_SCROLL_DOWN;
							break;
						}

						switch (raw->data.mouse.usButtonFlags) {
							//Mouse Pressed
						case 1:
						case 4:
						case 16:
							m_Event = Events::BUTTONPRESSED;
							break;
							//Mouse Released
						case 2:
						case 8:
						case 32:
							m_Event = Events::BUTTONRELEASED;
							break;
							//Scroll
						case 1024:
							m_Event = Events::MOUSESCROLL;
							break;
						}
					}
					// don't send key repeats when holding down the button
					if (internal_gw::GBufferedInputGlobal().
					lastPressedState[m_EventData.data] == 1 &&
					m_Event == Events::KEYPRESSED)
						m_Event = Events::Invalid;
					else if (internal_gw::GBufferedInputGlobal().
					lastPressedState[m_EventData.data] == 0 &&
					m_Event == Events::KEYPRESSED)
						internal_gw::GBufferedInputGlobal().lastPressedState[m_EventData.data] = 1;
					else if (internal_gw::GBufferedInputGlobal().
					lastPressedState[m_EventData.data] == 1 &&
					m_Event == Events::KEYRELEASED)
						internal_gw::GBufferedInputGlobal().lastPressedState[m_EventData.data] = 0;

					//If the mouse move event was the only event, don't send it again.
					if (m_Event != Events::MOUSEMOVE)
					{
						internal_gw::GBufferedInputGlobal().keyMask = keyMask;
						m_EventData.keyMask = keyMask;

						m_GEvent.Write(m_Event, m_EventData);
						if (m_Event != Events::Invalid)
							internal_gw::GBufferedInputGlobal().keyEvents.Push(m_GEvent);
					}
				}
				break;

				default:
					break;
				}
				return CallWindowProcW((WNDPROC)internal_gw::GBufferedInputGlobal()._userWinProc, hWnd, uMsg, wParam, lParam);
			}
		public:
			~GBufferedInputImplementation()
			{
				if (wndHandle)
					//Sets the WinProc back. (Fixes the StackOverFlow bug)
					SetWindowLongPtr(wndHandle, GWLP_WNDPROC, (LONG_PTR)internal_gw::GBufferedInputGlobal()._userWinProc);
			}
			GReturn Create(GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE _uwh)
			{
				if (!_uwh.window)
					return GReturn::INVALID_ARGUMENT;

				wndHandle = static_cast<HWND>(_uwh.window);
				if ((internal_gw::GBufferedInputGlobal()._userWinProc = 
					SetWindowLongPtr(wndHandle, GWLP_WNDPROC, (LONG_PTR)GWindowProcedure)) == NULL)
				{
					//The user has not setup a windows proc prior to this point.
					printf("SetWindowLongPtr Error : %d \n", GetLastError());
					return GReturn::FAILURE;
				}

				//Getting Raw Input Devices.
				UINT numDevices = 0;
				std::vector<RAWINPUTDEVICELIST> rawInputDeviceList;

				//Get Number of Devices.
				if (GetRawInputDeviceList(NULL, &numDevices, sizeof(RAWINPUTDEVICELIST)) == ((UINT)-1))
				{
					printf("GetRawInputDeviceList Error : %d \n", GetLastError());
					//If GetRawInputDeviceList returned 0 devices, following calls will fail.
					if (numDevices == 0)
					{
						printf("Zero devices returned from GetRawInputDeviceList.");
					}
					return GReturn::FAILURE;
				}

				//Allocate the list of devices.
				rawInputDeviceList.resize(sizeof(RAWINPUTDEVICELIST) * numDevices);
				if (rawInputDeviceList.size() < 1) {
					printf("Failed to allocate memory for RawInputDeviceList.");
					return GReturn::FAILURE;
				}

				int nNoOfDevices = 0;
				//Using the new List and number of devices,
				//populate the raw input device list.
				if ((nNoOfDevices = GetRawInputDeviceList(rawInputDeviceList.data(), &numDevices, sizeof(RAWINPUTDEVICELIST))) == ((UINT)-1))
				{
					printf("GetRawInputDeviceList Error : %d \n", GetLastError());
					return GReturn::FAILURE;
				}

				RID_DEVICE_INFO rdi;
				rdi.cbSize = sizeof(RID_DEVICE_INFO);

				//For all of the devices, display their correspondent information.
				for (int i = 0; i < nNoOfDevices; i++)
				{
					UINT size = 256;
					TCHAR tBuffer[256] = { 0 };
					tBuffer[0] = '\0';

					//Find the device name.
					if (!rawInputDeviceList.empty())
					{
						if (GetRawInputDeviceInfo(rawInputDeviceList[i].hDevice, RIDI_DEVICENAME, tBuffer, &size) < 0)
							return GW::GReturn::FAILURE;

						UINT cbSize = rdi.cbSize;
						//Get the device information.
						if (GetRawInputDeviceInfo(rawInputDeviceList[i].hDevice, RIDI_DEVICEINFO, &rdi, &cbSize) < 0)
							return GW::GReturn::FAILURE;
					}
				}

				//Register the raw input devices.
				RAWINPUTDEVICE rID[2];

				//KeyBoard
				rID[0].usUsagePage = 0x01;
				rID[0].usUsage = 0x06;
				rID[0].dwFlags = RIDEV_EXINPUTSINK;
				rID[0].hwndTarget = wndHandle;

				//Mouse
				rID[1].usUsagePage = 0x01;
				rID[1].usUsage = 0x02;
				rID[1].dwFlags = RIDEV_EXINPUTSINK;
				rID[1].hwndTarget = wndHandle;

				if (RegisterRawInputDevices(rID, 2, sizeof(rID[0])) == false)
				{
					printf("RegisterRawInputDevices Error: %d \n", GetLastError());
					return GReturn::FAILURE;
				}

				//Capslock
				if ((GetKeyState(VK_CAPITAL) & 0x0001) != 0)
				{
					G_TURNON_BIT(internal_gw::GBufferedInputGlobal().keyMask, G_MASK_CAPS_LOCK);
				}

				//Numlock
				if ((GetKeyState(VK_NUMLOCK) & 0x0001) != 0)
				{
					G_TURNON_BIT(internal_gw::GBufferedInputGlobal().keyMask, G_MASK_NUM_LOCK);
				}

				//ScrollLock
				if ((GetKeyState(VK_SCROLL) & 0x0001) != 0)
				{
					G_TURNON_BIT(internal_gw::GBufferedInputGlobal().keyMask, G_MASK_SCROLL_LOCK);
				}

				return GReturn::SUCCESS;
			}

			GReturn Create(GW::SYSTEM::GWindow _window)
			{
				if (!_window)
					return GReturn::INVALID_ARGUMENT;

				GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE uwh;
				GReturn code = _window.GetWindowHandle(uwh);
				if (G_FAIL(code))
					return code;

				return Create(uwh);
			}
			// transfer any receivers to internal global broadcaster
			GReturn Register(CORE::GEventCache _observer) override {
				return internal_gw::GBufferedInputGlobal().keyEvents.Register(_observer);
			}
			GReturn Register(CORE::GEventResponder _observer) override {
				return internal_gw::GBufferedInputGlobal().keyEvents.Register(_observer);
			}
			GReturn Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) override {
				return internal_gw::GBufferedInputGlobal().keyEvents.Register(_observer, _callback);
			}
			GReturn Deregister(CORE::GInterface _observer) override {
				return internal_gw::GBufferedInputGlobal().keyEvents.Deregister(_observer);
			}
			GReturn Observers(unsigned int& _outCount) const override {
				return internal_gw::GBufferedInputGlobal().keyEvents.Observers(_outCount);
			}
			GReturn Push(const GEvent& _newEvent) override {
				return internal_gw::GBufferedInputGlobal().keyEvents.Push(_newEvent);
			}
		};
	}
}

#endif


namespace GW
{
	namespace INPUT
	{
		class GBufferedInput final
			: public I::GProxy<I::GBufferedInputInterface, I::GBufferedInputImplementation, GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GBufferedInput)
			GATEWARE_TYPEDEF(Events)
			GATEWARE_TYPEDEF(EVENT_DATA)

			// reimplemented functions
			GATEWARE_FUNCTION(Register)
			GATEWARE_CONST_FUNCTION(Observers)
			GATEWARE_FUNCTION(Push)

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GBUFFEREDINPUT_H

/*---------------------------------
|	End of GBufferedInput.h
----------------------------------*/


/*---------------------------------
|	Begin of GController.h
----------------------------------*/
#ifndef GCONTROLLER_H
#define GCONTROLLER_H





namespace GW
{
	namespace I
	{
		class GControllerInterface : public virtual GEventGeneratorInterface
		{
		public:
			struct EVENT_DATA
			{
				int controllerIndex;
				GW::INPUT::GControllerType controllerID;
				int inputCode;
				float inputValue;
				int isConnected;
			};

			enum class Events
			{
				CONTROLLERBUTTONVALUECHANGED,
				CONTROLLERAXISVALUECHANGED,	
				CONTROLLERCONNECTED,		
				CONTROLLERDISCONNECTED		
			};

			enum class DeadZoneTypes
			{
				DEADZONESQUARE,
				DEADZONECIRCLE
			};

			virtual GReturn GetState(unsigned int _controllerIndex, int _inputCode, float& _outState) = 0;
			virtual GReturn IsConnected(unsigned int _controllerIndex, bool& _outIsConnected) = 0;
			virtual GReturn GetMaxIndex(int& _outMax) = 0;
			virtual GReturn GetNumConnected(int& _outConnectedCount) = 0;
			virtual GReturn SetDeadZone(DeadZoneTypes _type, float _deadzonePercentage) = 0;
			virtual GReturn StartVibration(unsigned int _controllerIndex, float _pan, float _duration, float _strength) = 0;
			virtual GReturn IsVibrating(unsigned int _controllerIndex, bool& _outIsVibrating) = 0;
			virtual GReturn StopVibration(unsigned int _controllerIndex) = 0;
			virtual GReturn StopAllVibrations() = 0;
		};
	}
}

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GController.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
#ifndef GCONTROLLERTABLEROUTING_HPP
#define GCONTROLLERTABLEROUTING_HPP


#define G_MAX_CONTROLLER_INDEX 16
#define G_MAX_XBOX_CONTROLLER_INDEX 4
#define G_MAX_GENERAL_INPUTS 20
#define G_MAX_XBOX_INPUTS 20
#define G_MAX_PS4_INPUTS 20
#define G_MAX_XBOX_THUMB_AXIS 32768
#define G_MIN_XBOX_THUMB_AXIS -32768
#define G_MAX_XBOX_TRIGGER_AXIS 255
#define G_XINPUT_MAX_VIBRATION 65535
#define G_MAX_LINUX_THUMB_AXIS 32768
#define G_MAX_GENERAL_TRIGGER_AXIS 255
#define G_GENERAL_TRIGGER_THRESHOLD 51

#define G_MAX_AXIS 0
#define G_MIN_AXIS 1

#define G_SONY_VENDOR_ID 0x054C
#define G_MICROSOFT_VENDOR_ID 0x045E

#define G_CODE_MAPPING_GENERAL 0
#define G_CODE_MAPPING_PS4_WIRED 1
#define G_CODE_MAPPING_PS4_WIRELESS 1
#define G_CODE_MAPPING_XBOX360 0
#define G_CODE_MAPPING_XBOXONE_WIRED 0
#define G_CODE_MAPPING_XBOXONE_WIRELESS 2

#define G_MAC_AXIS_MAPPING_GENERAL 0
#define G_MAC_AXIS_MAPPING_PS4_WIRED 2
#define G_MAC_AXIS_MAPPING_PS4_WIRELESS 0
#define G_MAC_AXIS_MAPPING_XBOX360 1
#define G_MAC_AXIS_MAPPING_XBOXONE_WIRED 1
#define G_MAC_AXIS_MAPPING_XBOXONE_WIRELESS 3

#define G_LINUX_AXIS_MAPPING_GENERAL 0
#define G_LINUX_AXIS_MAPPING_PS4_WIRED 0
#define G_LINUX_AXIS_MAPPING_PS4_WIRELESS 0
#define G_LINUX_AXIS_MAPPING_XBOX360 1
#define G_LINUX_AXIS_MAPPING_XBOXONE_WIRED 3
#define G_LINUX_AXIS_MAPPING_XBOXONE_WIRELESS 2

namespace GW
{
	namespace I
	{
		// Routes GController inputs (defined in GInputDefines.h) to the corresponding column in ControllerAxisRangesMin/Max tables.
		constexpr int ControllerAxisOffsets[] =
		{
			-1, // 0
			-1, // 1
			-1, // 2
			-1, // 3
			-1, // 4
			-1, // 5
			 0, // 6 G_LEFT_TRIGGER_AXIS
			 1, // 7 G_RIGHT_TRIGGER_AXIS
			-1, // 8
			-1, // 9
			-1, // 10
			-1, // 11
			-1, // 12
			-1, // 13
			-1, // 14
			-1, // 15
			 2, // 16 G_LX_AXIS
			 3, // 17 G_LY_AXIS
			 4, // 18 G_RX_AXIS
			 5  // 19 G_RY_AXIS
		};


		// Mac tables

		constexpr float Mac_ControllerAxisRangesMax[][6] =
		{
			//G_LEFT_TRIGGER_AXIS   G_RIGHT_TRIGGER_AXIS   G_LX_AXIS   G_LY_AXIS   G_RX_AXIS   G_RY_AXIS
			{ 255.0f,               255.0f,                255.0f,     255.0f,     255.0f,     255.0f    }, // General & PS4 Wireless
			{ 255.0f,               255.0f,                32767.0f,   32767.0f,   32767.0f,   32767.0f  }, // Xbox 360 & Xbox One Wired
			{ 315.0f,               315.0f,                255.0f,     255.0f,     255.0f,     255.0f    }, // PS4 Wired
			{ 1023.0,               1023.0,                65535.0f,   65535.0f,   65535.0f,   65535.0f  }, // Xbox One Wireless
		};

		constexpr float Mac_ControllerAxisRangesMin[][6] =
		{
			//G_LEFT_TRIGGER_AXIS   G_RIGHT_TRIGGER_AXIS   G_LX_AXIS   G_LY_AXIS   G_RX_AXIS   G_RY_AXIS
			{ 0.0f,                 0.0f,                  0.0f,       0.0f,       0.0f,       0.0f      }, // General & PS4 Wireless
			{ 255.0f,               255.0f,                -32768.0f,  -32768.0f,  -32768.0f,  -32768.0f }, // Xbox 360 & Xbox One Wired
			{ 0.0f,                 0.0f,                  0.0f,       0.0f,       0.0f,       0.0f      }, // PS4 Wired
			{ 0.0f,                 0.0f,                  0.0f,       0.0f,       0.0f,       0.0f      }, // Xbox One Wireless
		};

		// Routes usage codes (defined in IOHIDUsageTables.h on Mac) to GController input.
		constexpr unsigned int Mac_ControllerCodes[][3] =
		{
			//General, Xbox 360 & Xbox One Wired      PS4                    Xbox One Wireless
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 0
			{ G_SOUTH_BTN,                            G_WEST_BTN,            G_SOUTH_BTN            }, // 1
			{ G_EAST_BTN,                             G_SOUTH_BTN,           G_EAST_BTN             }, // 2
			{ G_WEST_BTN,                             G_EAST_BTN,            G_UNKNOWN_INPUT        }, // 3
			{ G_NORTH_BTN,                            G_NORTH_BTN,           G_WEST_BTN             }, // 4
			{ G_LEFT_SHOULDER_BTN,                    G_LEFT_SHOULDER_BTN,   G_NORTH_BTN            }, // 5
			{ G_RIGHT_SHOULDER_BTN,                   G_RIGHT_SHOULDER_BTN,  G_UNKNOWN_INPUT        }, // 6
			{ G_LEFT_THUMB_BTN,                       G_UNKNOWN_INPUT,       G_LEFT_SHOULDER_BTN    }, // 7
			{ G_RIGHT_THUMB_BTN,                      G_UNKNOWN_INPUT,       G_RIGHT_SHOULDER_BTN   }, // 8
			{ G_START_BTN,                            G_SELECT_BTN,          G_UNKNOWN_INPUT        }, // 9
			{ G_SELECT_BTN,                           G_START_BTN,           G_UNKNOWN_INPUT        }, // 10
			{ G_UNKNOWN_INPUT,                        G_LEFT_THUMB_BTN,      G_UNKNOWN_INPUT        }, // 11
			{ G_DPAD_UP_BTN,                          G_RIGHT_THUMB_BTN,     G_START_BTN            }, // 12
			{ G_DPAD_DOWN_BTN,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 13
			{ G_DPAD_LEFT_BTN,                        G_UNKNOWN_INPUT,       G_LEFT_THUMB_BTN       }, // 14
			{ G_DPAD_RIGHT_BTN,                       G_UNKNOWN_INPUT,       G_RIGHT_THUMB_BTN      }, // 15
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 16
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 17
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 18
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 19
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 20
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 21
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 22
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 23
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 24
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 25
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 26
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 27
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 28
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 29
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 30
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 31
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 32
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 33
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 34
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 35
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 36
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 37
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 38
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 39
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 40
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 41
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 42
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 43
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 44
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 45
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 46
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 47
			{ G_LX_AXIS,                              G_LX_AXIS,             G_LX_AXIS              }, // 48
			{ G_LY_AXIS,                              G_LY_AXIS,             G_LY_AXIS              }, // 49
			{ G_LEFT_TRIGGER_AXIS,                    G_RX_AXIS,             G_RX_AXIS              }, // 50
			{ G_RX_AXIS,                              G_LEFT_TRIGGER_AXIS,   G_UNKNOWN_INPUT        }, // 51
			{ G_RY_AXIS,                              G_RIGHT_TRIGGER_AXIS,  G_UNKNOWN_INPUT        }, // 52
			{ G_RIGHT_TRIGGER_AXIS,                   G_RY_AXIS,             G_RY_AXIS              }, // 53
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 54
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 55
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 56
			{ G_UNKNOWN_INPUT,                        G_DPAD_LEFT_BTN,       G_DPAD_LEFT_BTN        }, // 57 /* Dpad value reported as 0-360, 0-8, or 0-315 & -45 */
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 58
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 59
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 60
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 61
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 62
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 63
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 64
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 65
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 66
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 67
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 68
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 69
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 70
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 71
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 72
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 73
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 74
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 75
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 76
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 77
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 78
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 79
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 80
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 81
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 82
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 83
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 84
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 85
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 86
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 87
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 88
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 89
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 90
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 91
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 92
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 93
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 94
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 95
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 96
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 97
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 98
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 99
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 100
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 101
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 102
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 103
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 104
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 105
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 106
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 107
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 108
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 109
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 110
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 111
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 112
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 113
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 114
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 115
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 116
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 117
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 118
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 119
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 120
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 121
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 122
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 123
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 124
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 125
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 126
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 127
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 128
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 129
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 130
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 131
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 132
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 133
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 134
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 135
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 136
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 137
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 138
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 139
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 140
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 141
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 142
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 143
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 144
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 145
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 146
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 147
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 148
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 149
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 150
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 151
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 152
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 153
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 154
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 155
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 156
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 157
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 158
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 159
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 160
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 161
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 162
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 163
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 164
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 165
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 166
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 167
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 168
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 169
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 170
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 171
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 172
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 173
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 174
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 175
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 176
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 177
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 178
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 179
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 180
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 181
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 182
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 183
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 184
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 185
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 186
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 187
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 188
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 189
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 190
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 191
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 192
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 193
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 194
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 195
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_RIGHT_TRIGGER_AXIS   }, // 196
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_LEFT_TRIGGER_AXIS    }, // 197
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 198
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 199
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 200
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 201
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 202
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 203
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 204
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 205
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 206
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 207
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 208
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 209
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 210
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 211
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 212
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 213
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 214
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 215
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 216
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 217
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 218
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 219
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 220
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 221
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 222
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 223
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 224
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 225
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 226
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 227
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 228
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 229
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 230
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 231
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 232
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 233
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 234
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 235
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 236
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 237
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 238
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 239
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 240
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 241
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 242
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 243
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 244
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 245
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 246
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 247
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 248
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 249
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 250
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 251
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 252
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 253
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 254
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 255
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 256
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 257
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 258
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 259
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 260
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 261
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 262
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 263
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 264
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 265
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 266
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 267
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 268
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 269
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 270
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 271
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 272
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 273
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 274
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 275
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 276
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 277
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 278
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 279
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 280
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 281
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 282
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 283
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 284
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 285
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 286
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 287
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 288
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 289
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 290
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 291
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 292
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 293
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 294
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 295
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 296
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 297
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 298
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 299
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 300
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 301
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 302
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 303
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 304
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 305
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 306
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 307
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 308
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 309
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 310
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 311
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 312
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 313
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 314
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 315
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 316
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 317
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 318
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 319
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 320
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 321
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 322
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 323
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 324
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 325
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 326
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 327
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 328
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 329
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 330
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 331
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 332
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 333
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 334
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 335
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 336
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 337
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 338
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 339
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 340
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 341
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 342
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 343
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 344
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 345
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 346
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 347
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 348
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 349
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 350
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 351
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 352
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 353
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 354
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 355
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 356
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 357
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 358
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 359
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 360
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 361
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 362
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 363
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 364
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 365
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 366
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 367
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 368
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 369
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 370
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 371
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 372
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 373
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 374
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 375
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 376
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 377
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 378
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 379
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 380
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 381
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 382
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 383
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 384
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 385
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 386
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 387
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 388
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 389
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 390
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 391
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 392
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 393
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 394
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 395
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 396
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 397
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 398
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 399
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 400
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 401
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 402
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 403
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 404
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 405
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 406
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 407
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 408
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 409
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 410
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 411
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 412
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 413
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 414
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 415
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 416
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 417
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 418
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 419
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 420
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 421
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 422
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 423
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 424
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 425
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 426
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 427
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 428
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 429
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 430
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 431
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 432
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 433
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 434
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 435
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 436
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 437
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 438
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 439
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 440
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 441
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 442
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 443
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 444
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 445
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 446
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 447
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 448
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 449
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 450
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 451
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 452
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 453
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 454
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 455
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 456
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 457
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 458
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 459
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 460
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 461
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 462
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 463
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 464
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 465
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 466
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 467
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 468
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 469
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 470
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 471
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 472
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 473
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 474
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 475
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 476
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 477
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 478
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 479
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 480
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 481
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 482
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 483
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 484
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 485
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 486
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 487
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 488
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 489
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 490
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 491
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 492
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 493
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 494
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 495
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 496
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 497
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 498
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 499
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 500
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 501
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 502
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 503
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 504
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 505
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 506
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 507
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 508
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 509
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 510
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 511
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 512
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 513
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 514
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 515
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 516
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 517
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 518
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 519
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 520
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 521
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 522
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 523
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 524
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 525
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 526
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 527
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 528
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 529
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 530
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 531
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 532
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 533
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 534
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 535
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 536
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 537
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 538
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 539
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 540
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 541
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 542
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 543
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 544
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 545
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 546
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT        }, // 547
			{ G_UNKNOWN_INPUT,                        G_UNKNOWN_INPUT,       G_SELECT_BTN           }, // 548
		};


		// Linux tables

		constexpr float Linux_ControllerAxisRangesMax[][6] =
		{
			//G_LEFT_TRIGGER_AXIS   G_RIGHT_TRIGGER_AXIS   G_LX_AXIS   G_LY_AXIS   G_RX_AXIS   G_RY_AXIS
			{ 255.0f,               255.0f,                255.0f,     255.0f,     255.0f,     255.0f    }, // General, PS4 Wired & PS4 Wireless
			{ 255.0f,               255.0f,                32767.0f,   32767.0f,   32767.0f,   32767.0f  }, // Xbox 360
			{ 1023.0,               1023.0,                65535.0f,   65535.0f,   65535.0f,   65535.0f  }, // Xbox One Wireless
			{ 1023.0,               1023.0,                32767.0f,   32767.0f,   32767.0f,   32767.0f  }, // Xbox One Wired
		};

		constexpr float Linux_ControllerAxisRangesMin[][6] =
		{
			//G_LEFT_TRIGGER_AXIS   G_RIGHT_TRIGGER_AXIS   G_LX_AXIS   G_LY_AXIS   G_RX_AXIS   G_RY_AXIS
			{ 0.0f,                 0.0f,                  0.0f,       0.0f,       0.0f,       0.0f      }, // General, PS4 Wired & PS4 Wireless
			{ 255.0f,               255.0f,                -32768.0f,  -32768.0f,  -32768.0f,  -32768.0f }, // Xbox 360 & Xbox One Wired
			{ 0.0f,                 0.0f,                  0.0f,       0.0f,       0.0f,       0.0f      }, // Xbox One Wireless
			{ 0.0f,                 0.0f,                  -32768.0f,  -32768.0f,  -32768.0f,  -32768.0f }, // Xbox One Wired
		};

		// Routes input_event codes (defined in input-event-codes.h on Linux) for different axes to GController axis input (defined in GInputDefines.h)
		constexpr unsigned int Linux_ControllerAxisCodes[][3] =
		{
			//General, Xbox 360 & Xbox One Wired    PS4                    Xbox One Wireless
			{ G_LX_AXIS,                            G_LX_AXIS,             G_LX_AXIS            }, // 0	ABS_X
			{ G_LY_AXIS,                            G_LY_AXIS,             G_LY_AXIS            }, // 1 ABS_Y
			{ G_LEFT_TRIGGER_AXIS,                  G_LEFT_TRIGGER_AXIS,   G_RX_AXIS            }, // 2 ABS_Z
			{ G_RX_AXIS,                            G_RX_AXIS,             G_UNKNOWN_INPUT      }, // 3 ABS_RX
			{ G_RY_AXIS,                            G_RY_AXIS,             G_UNKNOWN_INPUT      }, // 4 ABS_RY
			{ G_RIGHT_TRIGGER_AXIS,                 G_RIGHT_TRIGGER_AXIS,  G_RY_AXIS            }, // 5 ABS_RZ
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT      }, // 6 ABS_THROTTLE
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT      }, // 7 ABS_RUDDER
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT      }, // 8 ABS_WHEEL
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_RIGHT_TRIGGER_AXIS }, // 9 ABS_GAS
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_LEFT_TRIGGER_AXIS  }, // 10 ABS_BRAKE
		};

		// Routes input_event codes (from KEY_BACK to BTN_THUMBR) to GController button input.
		constexpr unsigned int Linux_ControllerCodes[][3] =
		{
			//General, Xbox 360 & Xbox One Wired    PS4                    Xbox One Wireless
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_SELECT_BTN             }, // 0
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 1
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 2
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 3
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 4
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 5
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 6
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 7
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 8
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 9
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 10
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 11
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 12
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 13
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 14
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 15
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 16
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 17
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 18
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 19
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 20
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 21
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 22
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 23
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 24
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 25
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 26
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 27
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 28
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 29
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 30
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 31
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 32
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 33
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 34
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 35
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 36
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 37
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 38
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 39
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 40
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 41
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 42
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 43
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 44
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 45
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 46
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 47
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 48
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 49
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 50
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 51
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 52
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 53
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 54
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 55
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 56
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 57
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 58
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 59
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 60
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 61
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 62
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 63
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 64
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 65
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 66
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 67
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 68
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 69
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 70
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 71
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 72
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 73
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 74
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 75
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 76
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 77
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 78
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 79
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 80
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 81
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 82
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 83
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 84
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 85
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 86
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 87
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 88
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 89
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 90
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 91
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 92
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 93
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 94
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 95
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 96
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 97
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 98
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 99
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 100
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 101
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 102
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 103
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 104
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 105
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 106
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 107
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 108
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 109
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 110
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 111
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 112
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 113
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 114
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 115
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 116
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 117
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 118
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 119
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 120
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 121
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 122
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 123
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 124
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 125
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 126
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 127
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 128
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 129
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 130
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 131
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 132
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 133
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 134
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 135
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 136
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 137
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 138
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 139
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 140
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 141
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 142
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 143
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 144
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 145
			{ G_SOUTH_BTN,                          G_SOUTH_BTN,           G_SOUTH_BTN              }, // 146
			{ G_EAST_BTN,                           G_EAST_BTN,            G_EAST_BTN               }, // 147
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 148
			{ G_WEST_BTN,                           G_NORTH_BTN,           G_WEST_BTN               }, // 149
			{ G_NORTH_BTN,                          G_WEST_BTN,            G_NORTH_BTN              }, // 150
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 151
			{ G_LEFT_SHOULDER_BTN,                  G_LEFT_SHOULDER_BTN,   G_LEFT_SHOULDER_BTN      }, // 152
			{ G_RIGHT_SHOULDER_BTN,                 G_RIGHT_SHOULDER_BTN,  G_RIGHT_SHOULDER_BTN     }, // 153
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 154
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 155
			{ G_SELECT_BTN,                         G_SELECT_BTN,          G_UNKNOWN_INPUT          }, // 156
			{ G_START_BTN,                          G_START_BTN,           G_START_BTN              }, // 157
			{ G_UNKNOWN_INPUT,                      G_UNKNOWN_INPUT,       G_UNKNOWN_INPUT          }, // 158
			{ G_LEFT_THUMB_BTN,                     G_LEFT_THUMB_BTN,      G_LEFT_THUMB_BTN         }, // 159
			{ G_RIGHT_THUMB_BTN,                    G_RIGHT_THUMB_BTN,     G_RIGHT_THUMB_BTN        }, // 160
		};
	}
}
#endif

 // every implementation besides dummy uses this
#if !defined(GATEWARE_ENABLE_INPUT) || defined(GATEWARE_DISABLE_GCONTROLLER) || \
    (defined(GATEWARE_ENABLE_INPUT) && !defined(GATEWARE_DISABLE_GCONTROLLER) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
    // Even if a platform does not support a library a dummy implementation must be present!
    // dummy implemintation for GController
namespace GW {
	namespace I {
		class GControllerImplementation :	public virtual GControllerInterface,
											public GEventGeneratorImplementation
		{
		public:
			GReturn Create() {
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			GReturn GetState(unsigned int _controllerIndex, int _inputCode, float& _outState) override {
				return GW::GReturn::FAILURE;
			}
			GReturn IsConnected(unsigned int _controllerIndex, bool& _outIsConnected) override {
				return GW::GReturn::FAILURE;
			}
			GReturn GetMaxIndex(int& _outMax) override {
				return GW::GReturn::FAILURE;
			}
			GReturn GetNumConnected(int& _outConnectedCount) override {
				return GW::GReturn::FAILURE;
			}
			GReturn SetDeadZone(DeadZoneTypes _type, float _deadzonePercentage) override {
				return GW::GReturn::FAILURE;
			}
			GReturn StartVibration(unsigned int _controllerIndex, float _pan, float _duration, float _strength) override {
				return GW::GReturn::FAILURE;
			}
			GReturn IsVibrating(unsigned int _controllerIndex, bool& _outIsVibrating) override {
				return GW::GReturn::FAILURE;
			}
			GReturn StopVibration(unsigned int _controllerIndex) override {
				return GW::GReturn::FAILURE;
			}
			GReturn StopAllVibrations() override {
				return GW::GReturn::FAILURE;
			}
		};
	} // end I
} // end GW

#elif defined(__APPLE__)
    #ifdef __OBJC__
@import Foundation;
@import Cocoa;
@import IOKit.hid;
#endif

#include <atomic>
#include <chrono>
#include <cmath>
#include <pthread.h>


namespace GW
{
    namespace I
    {
        class GGeneralController;
    }
}

namespace internal_gw
{
    // HIDMANAGER Interface
    // HidManager wrapper class

    // Data members of HIDMANAGER
    G_OBJC_DATA_MEMBERS_STRUCT(HIDMANAGER)
    {
        // These are to point to the GController variables
        GW::I::GGeneralController* pController;
        CFRunLoopRef managerRunLoop;

        int LX, LY, LZ, RX, RY, RZ;

        IOHIDManagerRef hidManager;
        NSThread* runLoopThread;
    };

    // Forward declarations of HIDMANAGER methods
    G_OBJC_HEADER_DATA_MEMBERS_PROPERTY_METHOD(HIDMANAGER);

    G_OBJC_HEADER_INSTANCE_METHOD(HIDMANAGER, void, InitManagerAndRunLoop);

    // Creates the HIDMANAGER class at runtime when G_OBJC_GET_CLASS(HIDMANAGER) is called
    G_OBJC_CLASS_BEGIN(HIDMANAGER, NSObject)
    {
        G_OBJC_CLASS_DATA_MEMBERS_PROPERTY(HIDMANAGER);

        G_OBJC_CLASS_METHOD(HIDMANAGER, InitManagerAndRunLoop, "v@:");
    }
    G_OBJC_CLASS_END(HIDMANAGER)

    // HIDMANAGER Interface End
}

namespace GW
{
    namespace I
    {
        class GGeneralController; // Interface which all controller will inherit from

        class GControllerImplementation : public virtual GControllerInterface,
            protected GEventGeneratorImplementation
        {
        private:
            GGeneralController* pController; // POLYMORHISM
        public:
            ~GControllerImplementation();

            GReturn Create();

            GReturn GetState(unsigned int _controllerIndex, int _inputCode, float& _outState) override;
            GReturn IsConnected(unsigned int _controllerIndex, bool& _outIsConnected) override;
            GReturn GetMaxIndex(int& _outMax) override;
            GReturn GetNumConnected(int& _outConnectedCount) override;
            GReturn SetDeadZone(DeadZoneTypes _type, float _deadzonePercentage) override;
            GReturn StartVibration(unsigned int _controllerIndex, float _pan, float _duration, float _strength) override;
            GReturn IsVibrating(unsigned int _controllerIndex, bool& _outIsVibrating) override;
            GReturn StopVibration(unsigned int _controllerIndex) override;
            GReturn StopAllVibrations() override;

            GReturn Register(CORE::GEventCache _observer) override;
            GReturn Register(CORE::GEventResponder _observer) override;
            GReturn Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) override;
            GReturn Deregister(CORE::GInterface _observer) override;
            GReturn Observers(unsigned int& _outCount) const override;
            GReturn Push(const GEvent& _newEvent) override;
        };

        class GGeneralController : public GControllerInterface,
            protected GEventGeneratorImplementation
        {
        public:
            struct CONTROLLER_STATE
            {
                int isConnected;
                int isVibrating;
                float vibrationDuration;
                std::chrono::high_resolution_clock::time_point* vibrationStartTime;
                int maxInputs; // Hold the size of controllerInputs array
                float* controllerInputs; // controllerInputs is used to hold an array for the input values of the controller
                GW::INPUT::GControllerType controllerID;
                IOHIDDeviceRef device;
                int codeMapping;
                int axisMapping;
            } *pControllers;

            GW::I::GControllerInterface::DeadZoneTypes deadZoneType;
            float deadZonePercentage;

            GW::CORE::GThreadShared mutex;
            std::atomic<bool> isRunning;
            NSThread* runLoopThread;
            id manager;
            pthread_attr_t  runLoopPthread_attr;
            pthread_t       runLoopPthread_ID;

            // This function does not lock before using _controllers
            int FindEmptyControllerIndex(unsigned int _maxIndex, const CONTROLLER_STATE* _controllers)
            {
                for (unsigned int i = 0; i < _maxIndex; ++i)
                {
                    if (_controllers[i].isConnected == 0)
                        return i;
                }
                return -1;
            }

            // prehaps make return vaule GRETURN
            CONTROLLER_STATE* CopyControllerState(const CONTROLLER_STATE* _stateToCopy, CONTROLLER_STATE* _outCopy)
            {
                if (_stateToCopy->maxInputs == _outCopy->maxInputs)
                    for (int i = 0; i < _outCopy->maxInputs; ++i)
                    {
                        _outCopy->controllerInputs[i] = _stateToCopy->controllerInputs[i];
                    }
                else
                    _outCopy = nullptr;

                return _outCopy;
            }

            void DeadZoneCalculation(float _x, float _y, float _axisMax, float _axisMin, float& _outX, float& _outY, GW::I::GControllerInterface::DeadZoneTypes _deadzoneType, float _deadzonePercentage)
            {
                float range = _axisMax - _axisMin;
                _outX = (((_x - _axisMin) * 2) / range) - 1;
                _outY = (((_y - _axisMin) * 2) / range) - 1;
                float liveRange = 1.0f - _deadzonePercentage;
                if (_deadzoneType == GW::I::GControllerInterface::DeadZoneTypes::DEADZONESQUARE)
                {
                    if (std::abs(_outX) <= _deadzonePercentage)
                        _outX = 0.0f;
                    if (std::abs(_outY) <= _deadzonePercentage)
                        _outY = 0.0f;

                    if (_outX > 0.0f)
                        _outX = (_outX - _deadzonePercentage) / liveRange;
                    else if (_outX < 0.0f)
                        _outX = (_outX + _deadzonePercentage) / liveRange;
                    if (_outY > 0.0f)
                        _outY = (_outY - _deadzonePercentage) / liveRange;
                    else if (_outY < 0.0f)
                        _outY = (_outY + _deadzonePercentage) / liveRange;
                }
                else
                {
                    float mag = std::sqrt(_outX * _outX + _outY * _outY);
                    mag = (mag - _deadzonePercentage) / liveRange;
                    _outX *= mag;
                    _outY *= mag;

                    if (std::abs(_outX) <= _deadzonePercentage)
                        _outX = 0.0f;
                    if (std::abs(_outY) <= _deadzonePercentage)
                        _outY = 0.0f;
                }
            }

            static void* RunLoopThreadEntry(void* manager_ptr)
            {
                id manager = (id)manager_ptr;
                internal_gw::G_OBJC_CALL_METHOD(HIDMANAGER, manager, InitManagerAndRunLoop); // warning due to forward declartion
                return NULL;
            }
        public:
            GGeneralController() {}

            virtual void Initialize()
            {
                mutex.Create();
                pControllers = new CONTROLLER_STATE[G_MAX_CONTROLLER_INDEX];
                deadZoneType = GW::I::GControllerInterface::DeadZoneTypes::DEADZONESQUARE;
                deadZonePercentage = 0.2f;

                for (unsigned int i = 0; i < G_MAX_CONTROLLER_INDEX; ++i)
                {
                    pControllers[i].isConnected = 0;
                    pControllers[i].isVibrating = 0;
                    pControllers[i].vibrationDuration = 0;
                    pControllers[i].vibrationStartTime = new std::chrono::high_resolution_clock::time_point();
                    pControllers[i].maxInputs = G_MAX_GENERAL_INPUTS;
                    pControllers[i].controllerInputs = new float[G_MAX_GENERAL_INPUTS];
                    for (unsigned int j = 0; j < G_MAX_GENERAL_INPUTS; ++j)
                    {
                        pControllers[i].controllerInputs[j] = 0.0f;
                    }
                }

                isRunning = true;
                manager = [internal_gw::G_OBJC_GET_CLASS(HIDMANAGER) alloc];

                internal_gw::G_OBJC_DATA_MEMBERS_TYPE(HIDMANAGER)& managerDataMembers = internal_gw::G_OBJC_GET_DATA_MEMBERS(HIDMANAGER, manager);
                managerDataMembers.pController = this;

                pthread_attr_init(&runLoopPthread_attr);

                pthread_attr_setdetachstate(&runLoopPthread_attr, PTHREAD_CREATE_JOINABLE);

                pthread_create(&runLoopPthread_ID, &runLoopPthread_attr, &RunLoopThreadEntry, manager);
            }

            virtual void Release()
            {
                isRunning = false;
                pthread_join(runLoopPthread_ID, NULL);
                for (int i = 0; i < G_MAX_CONTROLLER_INDEX; ++i)
                {
                    delete[] pControllers[i].controllerInputs;
                    delete pControllers[i].vibrationStartTime;
                }
                delete[] pControllers;
            }

            virtual GReturn GetState(unsigned int _controllerIndex, int _inputCode, float& _outState) override
            {
                if (_controllerIndex >= G_MAX_CONTROLLER_INDEX || _inputCode < 0 || _inputCode >= G_MAX_GENERAL_INPUTS)
                    return GReturn::INVALID_ARGUMENT;
                if (pControllers[_controllerIndex].isConnected == 0)
                    return GReturn::FAILURE;
                LockAsyncRead();
                _outState = pControllers[_controllerIndex].controllerInputs[(_inputCode)];
                UnlockAsyncRead();
                return GReturn::SUCCESS;
            }

            virtual GReturn IsConnected(unsigned int _controllerIndex, bool& _outIsConnected) override
            {
                if (_controllerIndex >= G_MAX_CONTROLLER_INDEX)
                    return GReturn::INVALID_ARGUMENT;
                LockAsyncRead();
                _outIsConnected = pControllers[_controllerIndex].isConnected == 0 ? false : true;
                UnlockAsyncRead();

                return GReturn::SUCCESS;
            }

            virtual GReturn GetMaxIndex(int& _outMax) override
            {
                _outMax = G_MAX_CONTROLLER_INDEX;
                return GReturn::SUCCESS;
            }

            virtual GReturn GetNumConnected(int& _outConnectedCount) override
            {
                _outConnectedCount = 0;
                LockAsyncRead();
                for (unsigned int i = 0; i < G_MAX_CONTROLLER_INDEX; ++i)
                {
                    if (pControllers[i].isConnected)
                        ++_outConnectedCount;
                }
                UnlockAsyncRead();
                return GReturn::SUCCESS;
            }

            virtual GReturn SetDeadZone(DeadZoneTypes _type, float _deadzonePercentage) override
            {
                if (_deadzonePercentage > 1.0f || _deadzonePercentage < 0.0f)
                    return GReturn::INVALID_ARGUMENT;
                LockSyncWrite();
                deadZoneType = _type;
                deadZonePercentage = _deadzonePercentage;
                UnlockSyncWrite();
                return GReturn::SUCCESS;
            }

            virtual GReturn StartVibration(unsigned int _controllerIndex, float _pan, float _duration, float _strength) override
            {
                return GReturn::FEATURE_UNSUPPORTED;
            }

            virtual GReturn IsVibrating(unsigned int _controllerIndex, bool& _outIsVibrating) override
            {
                return GReturn::FEATURE_UNSUPPORTED;
            }

            virtual GReturn StopVibration(unsigned int _controllerIndex) override
            {
                return GReturn::FEATURE_UNSUPPORTED;
            }

            virtual GReturn StopAllVibrations() override
            {
                return GReturn::FEATURE_UNSUPPORTED;
            }

            GReturn Register(CORE::GEventCache _observer) override final { return GEventGeneratorImplementation::Register(_observer); }
            GReturn Register(CORE::GEventResponder _observer) override final { return GEventGeneratorImplementation::Register(_observer); }
            GReturn Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) override final { return GEventGeneratorImplementation::Register(_observer, _callback); }
            GReturn Deregister(CORE::GInterface _observer) override final { return GEventGeneratorImplementation::Deregister(_observer); }
            GReturn Observers(unsigned int& _outCount) const override final { return GEventGeneratorImplementation::Observers(_outCount); }
            GReturn Push(const GEvent& _newEvent) override final { return GEventGeneratorImplementation::Push(_newEvent); }
        };

        inline GControllerImplementation::~GControllerImplementation()
        {
            if (pController)
            {
                pController->Release();
                delete pController;
                pController = nullptr;
            }
        }

        inline GReturn GControllerImplementation::Create()
        {
            pController = new GGeneralController();
            pController->Initialize();
            
            return GReturn::SUCCESS;
        }
        inline GReturn GControllerImplementation::GetState(unsigned int _controllerIndex, int _inputCode, float& _outState) { return pController ? pController->GetState(_controllerIndex, _inputCode, _outState) : GReturn::FAILURE; }
        inline GReturn GControllerImplementation::IsConnected(unsigned int _controllerIndex, bool& _outIsConnected) { return pController ? pController->IsConnected(_controllerIndex, _outIsConnected) : GReturn::FAILURE; }
        inline GReturn GControllerImplementation::GetMaxIndex(int& _outMax) { return pController ? pController->GetMaxIndex(_outMax) : GReturn::FAILURE; }
        inline GReturn GControllerImplementation::GetNumConnected(int& _outConnectedCount) { return pController ? pController->GetNumConnected(_outConnectedCount) : GReturn::FAILURE; }
        inline GReturn GControllerImplementation::SetDeadZone(DeadZoneTypes _type, float _deadzonePercentage) { return pController ? pController->SetDeadZone(_type, _deadzonePercentage) : GReturn::FAILURE; }
        inline GReturn GControllerImplementation::StartVibration(unsigned int _controllerIndex, float _pan, float _duration, float _strength) { return pController ? pController->StartVibration(_controllerIndex, _pan, _duration, _strength) : GReturn::FAILURE; }
        inline GReturn GControllerImplementation::IsVibrating(unsigned int _controllerIndex, bool& _outIsVibrating) { return pController ? pController->IsVibrating(_controllerIndex, _outIsVibrating) : GReturn::FAILURE; }
        inline GReturn GControllerImplementation::StopVibration(unsigned int _controllerIndex) { return pController ? pController->StopVibration(_controllerIndex) : GReturn::FAILURE; }
        inline GReturn GControllerImplementation::StopAllVibrations() { return pController ? pController->StopAllVibrations() : GReturn::FAILURE; }
        inline GReturn GControllerImplementation::Register(CORE::GEventCache _observer) { return pController ? pController->Register(_observer) : GEventGeneratorImplementation::Register(_observer); }
        inline GReturn GControllerImplementation::Register(CORE::GEventResponder _observer) { return pController ? pController->Register(_observer) : GEventGeneratorImplementation::Register(_observer); }
        inline GReturn GControllerImplementation::Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) { return pController ? pController->Register(_observer, _callback) : GEventGeneratorImplementation::Register(_observer, _callback); }
        inline GReturn GControllerImplementation::Deregister(CORE::GInterface _observer) { return pController ? pController->Deregister(_observer) : GEventGeneratorImplementation::Deregister(_observer); }
        inline GReturn GControllerImplementation::Observers(unsigned int& _outCount) const { return pController ? pController->Observers(_outCount) : GEventGeneratorImplementation::Observers(_outCount); }
        inline GReturn GControllerImplementation::Push(const GEvent& _newEvent) { return pController ? pController->Push(_newEvent) : GEventGeneratorImplementation::Push(_newEvent); }
    }
}

namespace internal_gw
{
    // Arg 1: context from IOHIDDeviceRegisterInputValueCallback
    // Arg 2: completion result for the input value operation
    // Arg 3: IOHIDDeviceRef of the device this element is from
    // Arg 4: the new element value
    static void Handle_IOHIDDeviceInputValueCallback(void* inContext, IOReturn inResult, void* inSender, IOHIDValueRef inIOHIDValueRef)
    {
        GW::GEvent l_GEvent;

        double_t scaledValue = IOHIDValueGetScaledValue(inIOHIDValueRef, kIOHIDValueScaleTypePhysical);

        IOHIDElementRef tIOHIDElementRef = IOHIDValueGetElement(inIOHIDValueRef);
        IOHIDElementType type = IOHIDElementGetType(tIOHIDElementRef);
        int32_t usage = IOHIDElementGetUsage(tIOHIDElementRef);
        
        id manager = (id)inContext;
        G_OBJC_DATA_MEMBERS_TYPE(HIDMANAGER)& managerDataMembers = G_OBJC_GET_DATA_MEMBERS(HIDMANAGER, manager);
        GW::I::GGeneralController* pController = managerDataMembers.pController;
        GW::I::GControllerInterface::EVENT_DATA eventData;
        int controllerIndex = 0;
        bool controllerFound = false;
        for (; controllerIndex < G_MAX_CONTROLLER_INDEX; ++controllerIndex)
        {
            if (pController->pControllers[controllerIndex].device == (IOHIDDeviceRef)inSender)
            {
                controllerFound = true;
                break;
            }
        }

        if (controllerFound)
        {
            while (!(usage < 549 && usage >= 0))
                usage = IOHIDElementGetUsage(tIOHIDElementRef);
            
            int inputCode = GW::I::Mac_ControllerCodes[usage][(int)pController->pControllers[controllerIndex].codeMapping];
            // switch on input type
            if (inputCode == G_UNKNOWN_INPUT)
                return;
            
            if (type == kIOHIDElementTypeInput_Button)
            {
                pController->mutex.LockSyncWrite();
                // swap 2 with controller id stored in pControllers
                pController->pControllers[controllerIndex].controllerInputs[inputCode] = (float)scaledValue;
                eventData.inputCode = inputCode;
                eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[inputCode];
                eventData.isConnected = 1;
                eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                eventData.controllerIndex = controllerIndex;
                pController->mutex.UnlockSyncWrite();

                l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                pController->Push(l_GEvent);
            }
            else if (type == kIOHIDElementTypeInput_Misc)
            {
                // get input code from array then switch base on the code to determine how to proccess it
                switch (inputCode)
                {
                case G_LX_AXIS:
                {
                    int& LX = managerDataMembers.LX;
                    if (scaledValue != LX)
                    {
                        int& LY = managerDataMembers.LY;
                        pController->mutex.LockSyncWrite();
                        float oldY = pController->pControllers[controllerIndex].controllerInputs[G_LY_AXIS];
                        LX = scaledValue;
                        int axisOffset = GW::I::ControllerAxisOffsets[inputCode];
                        pController->DeadZoneCalculation(LX,
                            LY,
                            GW::I::Mac_ControllerAxisRangesMax[pController->pControllers[controllerIndex].axisMapping][axisOffset],
                            GW::I::Mac_ControllerAxisRangesMin[pController->pControllers[controllerIndex].axisMapping][axisOffset],
                            pController->pControllers[controllerIndex].controllerInputs[G_LX_AXIS],
                            pController->pControllers[controllerIndex].controllerInputs[G_LY_AXIS],
                            pController->deadZoneType,
                            pController->deadZonePercentage);

                        eventData.inputCode = G_LX_AXIS;
                        eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_LX_AXIS];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();

                        l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
                        pController->Push(l_GEvent);

                        pController->mutex.LockSyncWrite();
                        pController->pControllers[controllerIndex].controllerInputs[G_LY_AXIS] *= -1.0f; // to fix flipped value
                        eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_LY_AXIS];
                        pController->mutex.UnlockSyncWrite();

                        if (oldY != eventData.inputValue)
                        {
                            // Send LY event
                            eventData.inputCode = G_LY_AXIS;
                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                }
                break;

                case G_LY_AXIS:
                {
                    int& LY = managerDataMembers.LY;
                    //leftY
                    if (scaledValue != LY)
                    {
                        int& LX = managerDataMembers.LX;
                        pController->mutex.LockSyncWrite();
                        LY = scaledValue;
                        float oldX = pController->pControllers[controllerIndex].controllerInputs[G_LX_AXIS];
                        int axisOffset = GW::I::ControllerAxisOffsets[inputCode];
                        pController->DeadZoneCalculation(LX,
                            LY,
                            GW::I::Mac_ControllerAxisRangesMax[pController->pControllers[controllerIndex].axisMapping][axisOffset],
                            GW::I::Mac_ControllerAxisRangesMin[pController->pControllers[controllerIndex].axisMapping][axisOffset],
                            pController->pControllers[controllerIndex].controllerInputs[G_LX_AXIS],
                            pController->pControllers[controllerIndex].controllerInputs[G_LY_AXIS],
                            pController->deadZoneType,
                            pController->deadZonePercentage);

                        // Send LY event
                        pController->pControllers[controllerIndex].controllerInputs[G_LY_AXIS] *= -1.0f; // to fix flipped value
                        eventData.inputCode = G_LY_AXIS;
                        eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_LY_AXIS];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();

                        l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
                        pController->Push(l_GEvent);

                        pController->mutex.LockSyncWrite();
                        eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_LX_AXIS];
                        pController->mutex.UnlockSyncWrite();

                        if (oldX != eventData.inputValue)
                        {
                            // Send LX event
                            eventData.inputCode = G_LX_AXIS;
                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                }
                break;

                case G_RX_AXIS:
                {
                    int& RX = managerDataMembers.RX;
                    if (scaledValue != RX)
                    {
                        int& RY = managerDataMembers.RY;
                        pController->mutex.LockSyncWrite();
                        float oldY = pController->pControllers[controllerIndex].controllerInputs[G_RY_AXIS];
                        RX = scaledValue;
                        int axisOffset = GW::I::ControllerAxisOffsets[inputCode];
                        pController->DeadZoneCalculation(RX,
                            RY,
                            GW::I::Mac_ControllerAxisRangesMax[pController->pControllers[controllerIndex].axisMapping][axisOffset],
                            GW::I::Mac_ControllerAxisRangesMin[pController->pControllers[controllerIndex].axisMapping][axisOffset],
                            pController->pControllers[controllerIndex].controllerInputs[G_RX_AXIS],
                            pController->pControllers[controllerIndex].controllerInputs[G_RY_AXIS],
                            pController->deadZoneType,
                            pController->deadZonePercentage);

                        eventData.inputCode = G_RX_AXIS;
                        eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_RX_AXIS];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();

                        l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
                        pController->Push(l_GEvent);

                        pController->mutex.LockSyncWrite();
                        pController->pControllers[controllerIndex].controllerInputs[G_RY_AXIS] *= -1.0f; // to fix flipped value
                        eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_RY_AXIS];
                        pController->mutex.UnlockSyncWrite();

                        if (oldY != eventData.inputValue)
                        {
                            // Send LY event
                            eventData.inputCode = G_RY_AXIS;
                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                }
                break;

                case G_RY_AXIS:
                {
                    int& RY = managerDataMembers.RY;
                    if (scaledValue != RY)
                    {
                        int RX = managerDataMembers.RX;
                        pController->mutex.LockSyncWrite();
                        RY = scaledValue;
                        float oldX = pController->pControllers[controllerIndex].controllerInputs[G_RX_AXIS];
                        int axisOffset = GW::I::ControllerAxisOffsets[inputCode];
                        pController->DeadZoneCalculation(RX,
                            RY,
                            GW::I::Mac_ControllerAxisRangesMax[pController->pControllers[controllerIndex].axisMapping][axisOffset],
                            GW::I::Mac_ControllerAxisRangesMin[pController->pControllers[controllerIndex].axisMapping][axisOffset],
                            pController->pControllers[controllerIndex].controllerInputs[G_RX_AXIS],
                            pController->pControllers[controllerIndex].controllerInputs[G_RY_AXIS],
                            pController->deadZoneType,
                            pController->deadZonePercentage);

                        // Send RY event
                        pController->pControllers[controllerIndex].controllerInputs[G_RY_AXIS] *= -1.0f; // to fix flipped value
                        eventData.inputCode = G_RY_AXIS;
                        eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_RY_AXIS];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();

                        l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
                        pController->Push(l_GEvent);

                        pController->mutex.LockSyncWrite();
                        eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_RX_AXIS];
                        pController->mutex.UnlockSyncWrite();

                        if (oldX != eventData.inputValue)
                        {
                            // Send RX event
                            eventData.inputCode = G_RX_AXIS;
                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                }
                break;

                case G_LEFT_TRIGGER_AXIS:
                {
                    int& LZ = managerDataMembers.LZ;
                    if (scaledValue != LZ)
                    {
                        pController->mutex.LockSyncWrite();
                        LZ = scaledValue;
                        float oldAxis = pController->pControllers[controllerIndex].controllerInputs[G_LEFT_TRIGGER_AXIS];
                        if (scaledValue > G_GENERAL_TRIGGER_THRESHOLD)
                        {
                            int axisOffset = GW::I::ControllerAxisOffsets[inputCode];
                            pController->pControllers[controllerIndex].controllerInputs[G_LEFT_TRIGGER_AXIS] = scaledValue / GW::I::Mac_ControllerAxisRangesMax[pController->pControllers[controllerIndex].axisMapping][axisOffset];
                        }
                        else
                            pController->pControllers[controllerIndex].controllerInputs[G_LEFT_TRIGGER_AXIS] = 0;

                        eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_LEFT_TRIGGER_AXIS];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();
                        if (oldAxis != eventData.inputValue)
                        {
                            eventData.inputCode = G_LEFT_TRIGGER_AXIS;
                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                }
                break;

                case G_RIGHT_TRIGGER_AXIS:
                {
                    int& RZ = managerDataMembers.RZ;
                    if (scaledValue != RZ)
                    {
                        pController->mutex.LockSyncWrite();
                        RZ = scaledValue;
                        float oldAxis = pController->pControllers[controllerIndex].controllerInputs[G_RIGHT_TRIGGER_AXIS];
                        if (scaledValue > G_GENERAL_TRIGGER_THRESHOLD)
                        {
                            int axisOffset = GW::I::ControllerAxisOffsets[inputCode];
                            pController->pControllers[controllerIndex].controllerInputs[G_RIGHT_TRIGGER_AXIS] = scaledValue / GW::I::Mac_ControllerAxisRangesMax[pController->pControllers[controllerIndex].axisMapping][axisOffset];
                        }
                        else
                            pController->pControllers[controllerIndex].controllerInputs[G_RIGHT_TRIGGER_AXIS] = 0;

                        eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_RIGHT_TRIGGER_AXIS];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();
                        if (oldAxis != eventData.inputValue)
                        {
                            eventData.inputCode = G_RIGHT_TRIGGER_AXIS;
                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                }
                break;

                case G_DPAD_LEFT_BTN: // This is used when the Dpad value is reported as a value of 0-360
                {
                    switch ((int)scaledValue)
                    {
                    case 0: // UP
                    {
                        pController->mutex.LockSyncWrite();
                        int upValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                        int rightValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                        int downValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                        int leftValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();
                        if (upValue != 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN] = 1;
                            eventData.inputCode = G_DPAD_UP_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (rightValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN] = 0;
                            eventData.inputCode = G_DPAD_RIGHT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (downValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN] = 0;
                            eventData.inputCode = G_DPAD_DOWN_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (leftValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN] = 0;
                            eventData.inputCode = G_DPAD_LEFT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                    break;

                    case 1: // UP-RIGHT
                    case 45:
                    {
                        pController->mutex.LockSyncWrite();
                        int upValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                        int rightValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                        int downValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                        int leftValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();
                        if (upValue != 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN] = 1;
                            eventData.inputCode = G_DPAD_UP_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (rightValue != 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN] = 1;
                            eventData.inputCode = G_DPAD_RIGHT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (downValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN] = 0;
                            eventData.inputCode = G_DPAD_DOWN_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (leftValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN] = 0;
                            eventData.inputCode = G_DPAD_LEFT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                    break;

                    case 2: // RIGHT
                    case 90:
                    {
                        pController->mutex.LockSyncWrite();
                        int upValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                        int rightValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                        int downValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                        int leftValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();

                        if (rightValue != 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN] = 1;
                            eventData.inputCode = G_DPAD_RIGHT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (upValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN] = 0;
                            eventData.inputCode = G_DPAD_UP_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (downValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN] = 0;
                            eventData.inputCode = G_DPAD_DOWN_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (leftValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN] = 0;
                            eventData.inputCode = G_DPAD_LEFT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                    break;

                    case 3: // RIGHT-DOWN
                    case 135:
                    {
                        pController->mutex.LockSyncWrite();
                        int upValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                        int rightValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                        int downValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                        int leftValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();
                        if (rightValue != 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN] = 1;
                            eventData.inputCode = G_DPAD_RIGHT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (downValue != 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN] = 1;
                            eventData.inputCode = G_DPAD_DOWN_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (upValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN] = 0;
                            eventData.inputCode = G_DPAD_UP_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }


                        if (leftValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN] = 0;
                            eventData.inputCode = G_DPAD_LEFT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                    break;

                    case 4: // DOWN
                    case 180:
                    {
                        pController->mutex.LockSyncWrite();
                        int upValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                        int rightValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                        int downValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                        int leftValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();
                        if (downValue != 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN] = 1;
                            eventData.inputCode = G_DPAD_DOWN_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (upValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN] = 0;
                            eventData.inputCode = G_DPAD_UP_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (rightValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN] = 0;
                            eventData.inputCode = G_DPAD_RIGHT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (leftValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN] = 0;
                            eventData.inputCode = G_DPAD_LEFT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                    break;

                    case 5: // DOWN-LEFT
                    case 225:
                    {
                        pController->mutex.LockSyncWrite();
                        int upValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                        int rightValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                        int downValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                        int leftValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();
                        if (downValue != 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN] = 1;
                            eventData.inputCode = G_DPAD_DOWN_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (leftValue != 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN] = 1;
                            eventData.inputCode = G_DPAD_LEFT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (upValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN] = 0;
                            eventData.inputCode = G_DPAD_UP_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (rightValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN] = 0;
                            eventData.inputCode = G_DPAD_RIGHT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                    break;

                    case 6: // LEFT
                    case 270:
                    {
                        pController->mutex.LockSyncWrite();
                        int upValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                        int rightValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                        int downValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                        int leftValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();
                        if (leftValue != 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN] = 1;
                            eventData.inputCode = G_DPAD_LEFT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (upValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN] = 0;
                            eventData.inputCode = G_DPAD_UP_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (rightValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN] = 0;
                            eventData.inputCode = G_DPAD_RIGHT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (downValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN] = 0;
                            eventData.inputCode = G_DPAD_DOWN_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                    break;

                    case 7: // LEFT-UP
                    case 315:
                    {
                        pController->mutex.LockSyncWrite();
                        int upValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                        int rightValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                        int downValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                        int leftValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();
                        if (leftValue != 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN] = 1;
                            eventData.inputCode = G_DPAD_LEFT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (upValue != 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN] = 1;
                            eventData.inputCode = G_DPAD_UP_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (rightValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN] = 0;
                            eventData.inputCode = G_DPAD_RIGHT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (downValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN] = 0;
                            eventData.inputCode = G_DPAD_DOWN_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                    break;

                    case -45: // Released
                    case 8:
                    case 360:
                    {
                        pController->mutex.LockSyncWrite();
                        int upValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                        int rightValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                        int downValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                        int leftValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                        eventData.isConnected = 1;
                        eventData.controllerID = pController->pControllers[controllerIndex].controllerID;
                        eventData.controllerIndex = controllerIndex;
                        pController->mutex.UnlockSyncWrite();
                        if (upValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN] = 0;
                            eventData.inputCode = G_DPAD_UP_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_UP_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (rightValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN] = 0;
                            eventData.inputCode = G_DPAD_RIGHT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (downValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN] = 0;
                            eventData.inputCode = G_DPAD_DOWN_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }

                        if (leftValue == 1)
                        {
                            pController->mutex.LockSyncWrite();
                            pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN] = 0;
                            eventData.inputCode = G_DPAD_LEFT_BTN;
                            eventData.inputValue = pController->pControllers[controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
                            pController->mutex.UnlockSyncWrite();

                            l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
                            pController->Push(l_GEvent);
                        }
                    }
                    }
                    break;
                }
                break;
                }
            }
        }
    }

    static void GamepadWasAdded(void* inContext, IOReturn inResult, void* inSender, IOHIDDeviceRef device)
    {
        //NSLog(@"Gamepad was plugged in");
        id manager = (id)inContext;
        G_OBJC_DATA_MEMBERS_TYPE(HIDMANAGER)& managerDataMembers = G_OBJC_GET_DATA_MEMBERS(HIDMANAGER, manager);
        GW::I::GGeneralController* pController = managerDataMembers.pController;
        if (pController->isRunning)
        {
            GW::GEvent l_GEvent;
            pController->mutex.LockSyncWrite();
            int controllerIndex = pController->FindEmptyControllerIndex(G_MAX_CONTROLLER_INDEX, pController->pControllers);
            if (controllerIndex != -1)
            {
                IOReturn res = IOHIDDeviceOpen(device, kIOHIDOptionsTypeNone);
                if (kIOReturnSuccess == res)
                {
                    CFStringRef productKey;
                    productKey = (CFStringRef)IOHIDDeviceGetProperty(device, CFSTR(kIOHIDProductKey));
                    
                    uint32_t vendorID;
                    GW::INPUT::GControllerType controllerID;
                    // IOHIDeviceGetProperty Returns a CFTyperef based on the CString passed in. CFNumberGetValue is used to retrieve the value.
                    CFNumberGetValue((CFNumberRef)IOHIDDeviceGetProperty(device, CFSTR(kIOHIDVendorIDKey)), kCFNumberSInt32Type, &vendorID);
                    
                    switch (vendorID)
                    {
                    case G_SONY_VENDOR_ID:
                    {
                        controllerID = GW::INPUT::GControllerType::PS4;

                        CFStringRef usbProperty = (CFStringRef)IOHIDDeviceGetProperty(device, CFSTR("USB Product Name"));
                        
                        if (usbProperty == nil) // usbProperty will be nil if the device is not connected via USB.
                        {
                            pController->pControllers[controllerIndex].codeMapping = G_CODE_MAPPING_PS4_WIRELESS;
                            pController->pControllers[controllerIndex].axisMapping = G_MAC_AXIS_MAPPING_PS4_WIRELESS;
                        }
                        else
                        {
                            pController->pControllers[controllerIndex].codeMapping = G_CODE_MAPPING_PS4_WIRED;
                            pController->pControllers[controllerIndex].axisMapping = G_MAC_AXIS_MAPPING_PS4_WIRED;
                        }

                        break;
                    }

                    case G_MICROSOFT_VENDOR_ID:
                    {
                        const char* productName = CFStringGetCStringPtr(productKey, kCFStringEncodingMacRoman);
                        
                        if (strstr(productName, "Wireless") != nullptr)
                        {
                            controllerID = GW::INPUT::GControllerType::XBOXONE;
                            pController->pControllers[controllerIndex].codeMapping = G_CODE_MAPPING_XBOXONE_WIRELESS;
                            pController->pControllers[controllerIndex].axisMapping = G_MAC_AXIS_MAPPING_XBOXONE_WIRELESS;
                        }
                        else if (strstr(productName, "One") != nullptr)
                        {
                            controllerID = GW::INPUT::GControllerType::XBOXONE;
                            pController->pControllers[controllerIndex].codeMapping = G_CODE_MAPPING_XBOXONE_WIRED;
                            pController->pControllers[controllerIndex].axisMapping = G_MAC_AXIS_MAPPING_XBOXONE_WIRED;
                        }
                        else
                        {
                            controllerID = GW::INPUT::GControllerType::XBOX360;
                            pController->pControllers[controllerIndex].codeMapping = G_CODE_MAPPING_XBOX360;
                            pController->pControllers[controllerIndex].axisMapping = G_MAC_AXIS_MAPPING_XBOX360;
                        }
                        
                        break;
                    }

                    default:
                    {
                        const char* productName = CFStringGetCStringPtr(productKey, kCFStringEncodingMacRoman);
                        
                        if (strstr(productName, "Xbox") != nullptr)
                        {
                            controllerID = GW::INPUT::GControllerType::XBOX360;
                            pController->pControllers[controllerIndex].codeMapping = G_CODE_MAPPING_XBOX360;
                            pController->pControllers[controllerIndex].axisMapping = G_MAC_AXIS_MAPPING_XBOX360;
                        }
                        else
                        {
                            controllerID = GW::INPUT::GControllerType::GENERAL;
                            pController->pControllers[controllerIndex].codeMapping = G_CODE_MAPPING_GENERAL;
                            pController->pControllers[controllerIndex].axisMapping = G_MAC_AXIS_MAPPING_GENERAL;
                        }
                        
                        break;
                    }
                    }
                    
                    pController->pControllers[controllerIndex].controllerID = controllerID;
                    pController->pControllers[controllerIndex].isConnected = 1;
                    pController->pControllers[controllerIndex].device = device;

                    // send controller connected event
                    GW::I::GControllerInterface::EVENT_DATA eventData;

                    eventData.controllerIndex = controllerIndex;
                    eventData.inputCode = 0;
                    eventData.inputValue = 0;
                    eventData.isConnected = 1;
                    eventData.controllerID = pController->pControllers[controllerIndex].controllerID;

                    l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERCONNECTED, eventData);
                    pController->Push(l_GEvent);

                    IOHIDDeviceRegisterInputValueCallback(device, Handle_IOHIDDeviceInputValueCallback, (__bridge void*)manager);
                }
            }
            pController->mutex.UnlockSyncWrite();
        }
    }

    static void GamepadWasRemoved(void* inContext, IOReturn inResult, void* inSender, IOHIDDeviceRef device)
    {
        // NSLog(@"Gamepad was unplugged");
        IOHIDDeviceClose(device, kIOHIDOptionsTypeNone);
        id manager = (id)inContext;
        G_OBJC_DATA_MEMBERS_TYPE(HIDMANAGER)& managerDataMembers = G_OBJC_GET_DATA_MEMBERS(HIDMANAGER, manager);
        GW::I::GGeneralController* pController = managerDataMembers.pController;
        if (pController->isRunning)
        {
            GW::GEvent l_GEvent;
            pController->mutex.LockSyncWrite();
            int controllerIndex = 0;
            for (; controllerIndex < G_MAX_CONTROLLER_INDEX; ++controllerIndex)
            {
                if (device == pController->pControllers[controllerIndex].device)
                {
                    pController->pControllers[controllerIndex].isConnected = 0;

                    // send controller connected event
                    GW::I::GControllerInterface::EVENT_DATA eventData;

                    eventData.controllerIndex = controllerIndex;
                    eventData.inputCode = 0;
                    eventData.inputValue = 0;
                    eventData.isConnected = 0;
                    eventData.controllerID = pController->pControllers[controllerIndex].controllerID;

                    l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERCONNECTED, eventData);
                    pController->Push(l_GEvent);
                }
            }
            pController->mutex.UnlockSyncWrite();
        }
    }

    // This Function creates and return an array of dictionarys used to match connected devices
    static CFMutableArrayRef CreateHIDManagerCriteria()
    {
        // create a dictionary to add usage page/usages to
        UInt32 usagePage = kHIDPage_GenericDesktop;
        UInt32 joyUsage = kHIDUsage_GD_Joystick;
        UInt32 gamepadUsage = kHIDUsage_GD_GamePad;
        UInt32 mutiaxisUsage = kHIDUsage_GD_MultiAxisController;

        CFMutableDictionaryRef joyDictionary = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);

        CFMutableDictionaryRef gamepadDictionary = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);

        CFMutableDictionaryRef multiaxisDictionary = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);

        CFNumberRef pageCFNumberRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &usagePage);

        CFDictionarySetValue(joyDictionary, CFSTR(kIOHIDDeviceUsagePageKey), pageCFNumberRef);
        CFDictionarySetValue(gamepadDictionary, CFSTR(kIOHIDDeviceUsagePageKey), pageCFNumberRef);
        CFDictionarySetValue(multiaxisDictionary, CFSTR(kIOHIDDeviceUsagePageKey), pageCFNumberRef);
        CFRelease(pageCFNumberRef);

        CFNumberRef usageCFNumberRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &joyUsage);
        CFDictionarySetValue(joyDictionary, CFSTR(kIOHIDDeviceUsageKey), usageCFNumberRef);

        usageCFNumberRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &gamepadUsage);
        CFDictionarySetValue(gamepadDictionary, CFSTR(kIOHIDDeviceUsageKey), usageCFNumberRef);

        usageCFNumberRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &mutiaxisUsage);
        CFDictionarySetValue(multiaxisDictionary, CFSTR(kIOHIDDeviceUsageKey), usageCFNumberRef);
        CFRelease(usageCFNumberRef);

        CFMutableArrayRef dictionaryCFArr = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);

        CFArrayAppendValue(dictionaryCFArr, joyDictionary);
        CFArrayAppendValue(dictionaryCFArr, gamepadDictionary);
        CFArrayAppendValue(dictionaryCFArr, multiaxisDictionary);

        CFRelease(joyDictionary);
        CFRelease(gamepadDictionary);
        CFRelease(multiaxisDictionary);

        return dictionaryCFArr;
    }

    // HIDMANAGER Implementation

    G_OBJC_IMPLEMENTATION_DATA_MEMBERS_PROPERTY_METHOD(HIDMANAGER);

    G_OBJC_HEADER_INSTANCE_METHOD(HIDMANAGER, void, InitManagerAndRunLoop)
    {
        G_OBJC_DATA_MEMBERS_TYPE(HIDMANAGER)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(HIDMANAGER, self);
        IOHIDManagerRef& hidManager = selfDataMembers.hidManager;

        hidManager = IOHIDManagerCreate(kCFAllocatorDefault, kIOHIDManagerOptionNone);

        IOHIDManagerRegisterDeviceMatchingCallback(hidManager, GamepadWasAdded, (__bridge void*)self);
        IOHIDManagerRegisterDeviceRemovalCallback(hidManager, GamepadWasRemoved, (__bridge void*)self);

        IOHIDManagerScheduleWithRunLoop(hidManager, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);

        CFMutableArrayRef criteria = CreateHIDManagerCriteria();
        IOHIDManagerSetDeviceMatchingMultiple(hidManager, criteria);

        CFRelease(criteria);

        IOHIDManagerOpen(hidManager, kIOHIDOptionsTypeNone);
        CFTimeInterval timer = 1;
        Boolean runLoopReturn = true;
        // The run loop will exit once a second to check and see if GController is still running
        // The run loop is used for proccessing the events for the IOHIDManager it work similar to [NSAPP run]
        GW::I::GGeneralController* pController = selfDataMembers.pController;
        while (pController->isRunning)
            CFRunLoopRunInMode(kCFRunLoopDefaultMode, timer, runLoopReturn);
    }

    // HIDMANAGER Implementation End
}





#elif defined(__linux__)
    #include <stdio.h>
#include <stdlib.h>
#include <sys/inotify.h>
#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>
#include <linux/input.h>
#include <linux/input-event-codes.h>
#include <chrono>
#include <cmath>
#include <dirent.h>
#include <string>
#include <cstring>
#include <atomic>


namespace GW
{
	namespace I
	{
		class GGeneralController; // Interface which all controller will inherit from

		class GControllerImplementation : public virtual GControllerInterface,
			protected GEventGeneratorImplementation
		{
		private:
			GGeneralController* pController; // POLYMORHISM
		public:
			~GControllerImplementation();

			GReturn Create();

			GReturn GetState(unsigned int _controllerIndex, int _inputCode, float& _outState) override;
			GReturn IsConnected(unsigned int _controllerIndex, bool& _outIsConnected) override;
			GReturn GetMaxIndex(int& _outMax) override;
			GReturn GetNumConnected(int& _outConnectedCount) override;
			GReturn SetDeadZone(DeadZoneTypes _type, float _deadzonePercentage) override;
			GReturn StartVibration(unsigned int _controllerIndex, float _pan, float _duration, float _strength) override;
			GReturn IsVibrating(unsigned int _controllerIndex, bool& _outIsVibrating) override;
			GReturn StopVibration(unsigned int _controllerIndex) override;
			GReturn StopAllVibrations() override;

			GReturn Register(CORE::GEventCache _observer) override;
			GReturn Register(CORE::GEventResponder _observer) override;
			GReturn Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) override;
			GReturn Deregister(CORE::GInterface _observer) override;
			GReturn Observers(unsigned int& _outCount) const override;
			GReturn Push(const GEvent& _newEvent) override;
		};

		class GGeneralController : public virtual GControllerInterface,
			protected GEventGeneratorImplementation
		{
		protected:
			struct CONTROLLER_STATE
			{
				int isConnected;
				int isVibrating;
				float vibrationDuration;
				std::chrono::high_resolution_clock::time_point* vibrationStartTime;
				int maxInputs; // Hold the size of controllerInputs array
				float* controllerInputs; // controllerInputs is used to hold an array for the input values of the controller
				GW::INPUT::GControllerType controllerID;
				char controllerFilePath[8];
				int codeMapping;
				int axisMapping;
			} *pControllers;

			struct G_inotify_event
			{
				int wd;        /* Watch descriptor.  */
				uint32_t mask;    /* Watch mask.  */
				uint32_t cookie;    /* Cookie to synchronize two events.  */
				uint32_t len;        /* Length (including NULs) of name.  */
				char name[16];    /* Name.  */
			};

			GW::I::GControllerInterface::DeadZoneTypes deadZoneType;
			float deadZonePercentage;

			std::atomic_bool isRunning;
			GW::SYSTEM::GConcurrent controllerThreads[G_MAX_CONTROLLER_INDEX];
			std::atomic_bool isControllerThreadActive[G_MAX_CONTROLLER_INDEX];
			GW::SYSTEM::GConcurrent notifyThread;

			// This function does not lock before using _controllers
			int FindEmptyControllerIndex(unsigned int _maxIndex, const CONTROLLER_STATE* _controllers)
			{
				for (unsigned int i = 0; i < _maxIndex; ++i)
				{
					if (_controllers[i].isConnected == 0)
						return i;
				}
				return -1;
			}

			CONTROLLER_STATE* CopyControllerState(const CONTROLLER_STATE* _stateToCopy, CONTROLLER_STATE* _outCopy)
			{
				if (_stateToCopy->maxInputs == _outCopy->maxInputs)
					for (int i = 0; i < _outCopy->maxInputs; ++i)
					{
						_outCopy->controllerInputs[i] = _stateToCopy->controllerInputs[i];
					}
				else
					_outCopy = nullptr;

				return _outCopy;
			}

			void DeadZoneCalculation(float _x, float _y, float _axisMax, float _axisMin, float& _outX, float& _outY, GW::I::GControllerInterface::DeadZoneTypes _deadzoneType, float _deadzonePercentage)
			{
				float range = _axisMax - _axisMin;
				_outX = (((_x - _axisMin) * 2) / range) - 1;
				_outY = (((_y - _axisMin) * 2) / range) - 1;
				float liveRange = 1.0f - _deadzonePercentage;
				if (_deadzoneType == GW::I::GControllerInterface::DeadZoneTypes::DEADZONESQUARE)
				{
					if (std::abs(_outX) <= _deadzonePercentage)
						_outX = 0.0f;
					if (std::abs(_outY) <= _deadzonePercentage)
						_outY = 0.0f;

					if (_outX > 0.0f)
						_outX = (_outX - _deadzonePercentage) / liveRange;
					else if (_outX < 0.0f)
						_outX = (_outX + _deadzonePercentage) / liveRange;
					if (_outY > 0.0f)
						_outY = (_outY - _deadzonePercentage) / liveRange;
					else if (_outY < 0.0f)
						_outY = (_outY + _deadzonePercentage) / liveRange;
				}
				else
				{
					float mag = std::sqrt(_outX * _outX + _outY * _outY);
					mag = (mag - _deadzonePercentage) / liveRange;
					_outX *= mag;
					_outY *= mag;

					if (std::abs(_outX) <= _deadzonePercentage)
						_outX = 0.0f;
					if (std::abs(_outY) <= _deadzonePercentage)
						_outY = 0.0f;
				}
			}

			// This functions gets an array of bits representing the keys supported for the device and check if BTN_GAMEPAD/BTN_SOUTH is set
			bool isGamepadBitSet(int _event_fd)
			{
				// keys' size is based on how many sets of 64 bits it would take to cover all of the diffrent types of keys where each key is a bit
				unsigned long keys[(KEY_CNT + 64 - 1) / 64];
				// EXVIOCGBIT gets the keys supported by the device returned as an array of 64 bits per index
				// BTN_GAMEPAD represents the bit we want to check so we find where the bit would be located in the array
				// and in the current 64 bits
				ioctl(_event_fd, EVIOCGBIT(EV_KEY, sizeof(keys)), keys);
				return (keys[BTN_GAMEPAD / 64] & (1LL << (BTN_GAMEPAD % 64))) != 0 ? true : false;
			}
			
			void GetControllerIDAndMappings(int _event_fd, GW::INPUT::GControllerType& _outControllerID, int& _outCodeMapping, int& _outAxisMapping)
			{
				char name[256];
				memset(name, ' ', 256);
				ioctl(_event_fd, EVIOCGNAME(256), name);
	
				if (strstr(name, "Sony") != nullptr)
				{
					_outControllerID = GW::INPUT::GControllerType::PS4;
					_outCodeMapping = G_CODE_MAPPING_PS4_WIRED;
					_outAxisMapping = G_LINUX_AXIS_MAPPING_PS4_WIRED;
				}
				else if (strstr(name, "Xbox") != nullptr || strstr(name, "Microsoft") != nullptr)
				{
					if (strstr(name, "Wireless") != nullptr)
					{
						_outControllerID = GW::INPUT::GControllerType::XBOXONE;
						_outCodeMapping = G_CODE_MAPPING_XBOXONE_WIRELESS;
						_outAxisMapping = G_LINUX_AXIS_MAPPING_XBOXONE_WIRELESS;
					}
					else if (strstr(name, "One") != nullptr)
					{
						_outControllerID = GW::INPUT::GControllerType::XBOXONE;
						_outCodeMapping = G_CODE_MAPPING_XBOXONE_WIRED;
						_outAxisMapping = G_LINUX_AXIS_MAPPING_XBOXONE_WIRED;
					}
					else
					{
						_outControllerID = GW::INPUT::GControllerType::XBOX360;
						_outCodeMapping = G_CODE_MAPPING_XBOX360;
						_outAxisMapping = G_LINUX_AXIS_MAPPING_XBOX360;
					}
				}
				else if (strstr(name, "Wireless Controller") != nullptr)
				{
					_outControllerID = GW::INPUT::GControllerType::PS4;
					_outCodeMapping = G_CODE_MAPPING_PS4_WIRELESS;
					_outAxisMapping = G_LINUX_AXIS_MAPPING_PS4_WIRELESS;
				}
				else
				{
					_outControllerID = GW::INPUT::GControllerType::GENERAL;
					_outCodeMapping = G_CODE_MAPPING_GENERAL;
					_outAxisMapping = G_LINUX_AXIS_MAPPING_GENERAL;
				}
			}

			void ControllerInputThreadEntryPoint(unsigned int _controllerIndex, int fd)
			{
				GEvent l_GEvent;
				input_event ev; // time value type code
				input_event base;
				base.value = 0;
				base.type = 0;
				base.code = 0;
				EVENT_DATA eventData;
				int lastLX = 0, lastLY = 0, lastRX = 0, lastRY = 0, lastLT = 0, lastRT = 0;

				while (isControllerThreadActive[_controllerIndex])
				{
					ev = base;
					int result = read(fd, &ev, sizeof(struct input_event));
					if (result != -1)
					{
						switch (ev.type)
						{
						case EV_KEY:
						{
							if (ev.code < KEY_BACK)
								break;
							
							int inputCode = Linux_ControllerCodes[ev.code - KEY_BACK][pControllers[_controllerIndex].codeMapping];
							
							if (inputCode == G_UNKNOWN_INPUT)
								break;
							
							LockSyncWrite();
							pControllers[_controllerIndex].controllerInputs[inputCode] = ev.value;
							eventData.inputCode = inputCode;
							eventData.inputValue = pControllers[_controllerIndex].controllerInputs[inputCode];
							eventData.controllerIndex = _controllerIndex;
							eventData.controllerID = pControllers[_controllerIndex].controllerID;
							UnlockSyncWrite();

							l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
							Push(l_GEvent);
						}
						break;

						case EV_ABS:
						{
							if (ev.code <= ABS_BRAKE)
							{
								int inputCode = GW::I::Linux_ControllerAxisCodes[ev.code][pControllers[_controllerIndex].codeMapping];
								int axisOffset = GW::I::ControllerAxisOffsets[inputCode];
								
								switch (inputCode)
								{
									case G_LX_AXIS:
									{
										// leftX
										if (ev.value != lastLX)
										{
											LockSyncWrite();
											float oldY = pControllers[_controllerIndex].controllerInputs[G_LY_AXIS];
											lastLX = ev.value;
											DeadZoneCalculation(lastLX,
												lastLY,
												GW::I::Linux_ControllerAxisRangesMax[pControllers[_controllerIndex].axisMapping][axisOffset],
												GW::I::Linux_ControllerAxisRangesMin[pControllers[_controllerIndex].axisMapping][axisOffset],
												pControllers[_controllerIndex].controllerInputs[G_LX_AXIS],
												pControllers[_controllerIndex].controllerInputs[G_LY_AXIS],
												deadZoneType,
												deadZonePercentage);

											eventData.inputCode = G_LX_AXIS;
											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_LX_AXIS];
											eventData.controllerIndex = _controllerIndex;
											eventData.controllerID = pControllers[_controllerIndex].controllerID;
											UnlockSyncWrite();

											l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
											Push(l_GEvent);

											LockSyncWrite();
											pControllers[_controllerIndex].controllerInputs[G_LY_AXIS] *= -1.0f; // to fix flipped value
											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_LY_AXIS];
											eventData.controllerID = pControllers[_controllerIndex].controllerID;
											eventData.controllerIndex = _controllerIndex;
											UnlockSyncWrite();

											if (oldY != eventData.inputValue)
											{
												// Send LY event
												eventData.inputCode = G_LY_AXIS;
												l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
												Push(l_GEvent);
											}
										}
									}
									break;
									
									case G_LY_AXIS:
									{
										//leftY
										if (ev.value != lastLY)
										{			
											LockSyncWrite();
											lastLY = ev.value; // evdev values for Y are flipped
											float oldX = pControllers[_controllerIndex].controllerInputs[G_LX_AXIS];
											int axisMapping = pControllers[_controllerIndex].axisMapping;
											DeadZoneCalculation(lastLX,
												lastLY,
												GW::I::Linux_ControllerAxisRangesMax[pControllers[_controllerIndex].axisMapping][axisOffset],
												GW::I::Linux_ControllerAxisRangesMin[pControllers[_controllerIndex].axisMapping][axisOffset],
												pControllers[_controllerIndex].controllerInputs[G_LX_AXIS],
												pControllers[_controllerIndex].controllerInputs[G_LY_AXIS],
												deadZoneType,
												deadZonePercentage);

											// Send LY event
											pControllers[_controllerIndex].controllerInputs[G_LY_AXIS] *= -1.0f; // to fix flipped value
											eventData.inputCode = G_LY_AXIS;
											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_LY_AXIS];
											eventData.controllerIndex = _controllerIndex;
											eventData.controllerID = pControllers[_controllerIndex].controllerID;
											UnlockSyncWrite();

											l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
											Push(l_GEvent);

											LockSyncWrite();
											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_LX_AXIS];
											eventData.controllerIndex = _controllerIndex;
											eventData.controllerID = pControllers[_controllerIndex].controllerID;
											UnlockSyncWrite();

											if (oldX != eventData.inputValue)
											{
												// Send LX event
												eventData.inputCode = G_LX_AXIS;
												l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
												Push(l_GEvent);
											}
										}
									}
									break;
									
									case G_RX_AXIS:
									{										
										// RightX
										if (ev.value != lastRX)
										{
											LockSyncWrite();
											float oldY = pControllers[_controllerIndex].controllerInputs[G_RY_AXIS];
											lastRX = ev.value;
											DeadZoneCalculation(lastRX,
												lastRY,
												GW::I::Linux_ControllerAxisRangesMax[pControllers[_controllerIndex].axisMapping][axisOffset],
												GW::I::Linux_ControllerAxisRangesMin[pControllers[_controllerIndex].axisMapping][axisOffset],
												pControllers[_controllerIndex].controllerInputs[G_RX_AXIS],
												pControllers[_controllerIndex].controllerInputs[G_RY_AXIS],
												deadZoneType,
												deadZonePercentage);

											eventData.inputCode = G_RX_AXIS;
											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_RX_AXIS];
											eventData.controllerIndex = _controllerIndex;
											eventData.controllerID = pControllers[_controllerIndex].controllerID;
											UnlockSyncWrite();

											l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
											Push(l_GEvent);

											LockSyncWrite();
											pControllers[_controllerIndex].controllerInputs[G_RY_AXIS] *= -1.0f; // to fix flipped value
											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_RY_AXIS];
											eventData.controllerIndex = _controllerIndex;
											eventData.controllerID = pControllers[_controllerIndex].controllerID;
											UnlockSyncWrite();

											if (oldY != eventData.inputValue)
											{
												// Send LY event
												eventData.inputCode = G_RY_AXIS;
												l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
												Push(l_GEvent);
											}
										}
									}
									break;
									
									case G_RY_AXIS:
									{
										//leftY
										if (ev.value != lastRY)
										{
											LockSyncWrite();
											lastRY = ev.value; // evdev values for y are flipped.
											float oldX = pControllers[_controllerIndex].controllerInputs[G_RX_AXIS];
											DeadZoneCalculation(lastRX,
												lastRY,
												GW::I::Linux_ControllerAxisRangesMax[pControllers[_controllerIndex].axisMapping][axisOffset],
												GW::I::Linux_ControllerAxisRangesMin[pControllers[_controllerIndex].axisMapping][axisOffset],
												pControllers[_controllerIndex].controllerInputs[G_RX_AXIS],
												pControllers[_controllerIndex].controllerInputs[G_RY_AXIS],
												deadZoneType,
												deadZonePercentage);

											// Send LY event
											pControllers[_controllerIndex].controllerInputs[G_RY_AXIS] *= -1.0f; // to fix flipped value
											eventData.inputCode = G_RY_AXIS;
											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_RY_AXIS];
											eventData.controllerIndex = _controllerIndex;
											eventData.controllerID = pControllers[_controllerIndex].controllerID;
											UnlockSyncWrite();

											l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
											Push(l_GEvent);

											LockSyncWrite();
											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_RX_AXIS];
											eventData.controllerIndex = _controllerIndex;
											eventData.controllerID = pControllers[_controllerIndex].controllerID;
											UnlockSyncWrite();

											if (oldX != eventData.inputValue)
											{
												// Send LX event
												eventData.inputCode = G_RX_AXIS;
												l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
												Push(l_GEvent);
											}
										}
									}
									break;
									
									case G_LEFT_TRIGGER_AXIS:
									{
										// left trigger
										if (ev.value != lastLT)
										{										
											LockSyncWrite();
											lastLT = ev.value;
											float oldAxis = pControllers[_controllerIndex].controllerInputs[G_LEFT_TRIGGER_AXIS];
											if (ev.value > G_GENERAL_TRIGGER_THRESHOLD)
												pControllers[_controllerIndex].controllerInputs[G_LEFT_TRIGGER_AXIS] = (float)ev.value / GW::I::Linux_ControllerAxisRangesMax[pControllers[_controllerIndex].axisMapping][axisOffset];
											else
												pControllers[_controllerIndex].controllerInputs[G_LEFT_TRIGGER_AXIS] = 0;

											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_LEFT_TRIGGER_AXIS];
											eventData.controllerIndex = _controllerIndex;
											eventData.controllerID = pControllers[_controllerIndex].controllerID;
											UnlockSyncWrite();
											if (oldAxis != eventData.inputValue)
											{
												eventData.inputCode = G_LEFT_TRIGGER_AXIS;
												l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
												Push(l_GEvent);
											}
										}
									}
									break;
									
									case G_RIGHT_TRIGGER_AXIS:
									{
										if (ev.value != lastRT)
										{
											LockSyncWrite();
											lastRT = ev.value;
											float oldAxis = pControllers[_controllerIndex].controllerInputs[G_RIGHT_TRIGGER_AXIS];
											if (ev.value > G_GENERAL_TRIGGER_THRESHOLD)
												pControllers[_controllerIndex].controllerInputs[G_RIGHT_TRIGGER_AXIS] = (float)ev.value / GW::I::Linux_ControllerAxisRangesMax[pControllers[_controllerIndex].axisMapping][axisOffset];
											else
												pControllers[_controllerIndex].controllerInputs[G_RIGHT_TRIGGER_AXIS] = 0;

											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_RIGHT_TRIGGER_AXIS];
											eventData.controllerIndex = _controllerIndex;
											eventData.controllerID = pControllers[_controllerIndex].controllerID;
											UnlockSyncWrite();
											if (oldAxis != pControllers[_controllerIndex].controllerInputs[G_RIGHT_TRIGGER_AXIS])
											{
												eventData.inputCode = G_RIGHT_TRIGGER_AXIS;
												l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, eventData);
												Push(l_GEvent);
											}
										}
									}
									break;
								}
							}
							else
							{
								switch (ev.code)
								{
								case ABS_HAT0X:
								case ABS_HAT3X:
								{
									// DPAD HORZONTAL
									if (ev.value == 1)
									{
										LockSyncWrite();
										pControllers[_controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN] = 1;
										eventData.inputCode = G_DPAD_RIGHT_BTN;
										eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
										eventData.controllerIndex = _controllerIndex;
										eventData.controllerID = pControllers[_controllerIndex].controllerID;
										UnlockSyncWrite();

										l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
										Push(l_GEvent);
									}
									else if (ev.value == -1)
									{
										LockSyncWrite();
										pControllers[_controllerIndex].controllerInputs[G_DPAD_LEFT_BTN] = 1;
										eventData.inputCode = G_DPAD_LEFT_BTN;
										eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
										eventData.controllerIndex = _controllerIndex;
										eventData.controllerID = pControllers[_controllerIndex].controllerID;
										UnlockSyncWrite();

										l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
										Push(l_GEvent);
									}
									else if (ev.value == 0)
									{
										LockSyncWrite();
										eventData.controllerID = pControllers[_controllerIndex].controllerID;
										eventData.controllerIndex = _controllerIndex;
										if (pControllers[_controllerIndex].controllerInputs[G_DPAD_LEFT_BTN] != 0)
										{
											pControllers[_controllerIndex].controllerInputs[G_DPAD_LEFT_BTN] = 0;
											eventData.inputCode = G_DPAD_LEFT_BTN;
											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_DPAD_LEFT_BTN];
										}
										if (pControllers[_controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN] != 0)
										{
											pControllers[_controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN] = 0;
											eventData.inputCode = G_DPAD_RIGHT_BTN;
											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_DPAD_RIGHT_BTN];
										}
										UnlockSyncWrite();

										l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
										Push(l_GEvent);
									}
								}
								break;

								case ABS_HAT0Y:
								case ABS_HAT3Y:
								{
									// DPAD VERT
									if (ev.value == 1)
									{
										LockSyncWrite();
										pControllers[_controllerIndex].controllerInputs[G_DPAD_DOWN_BTN] = 1;
										eventData.inputCode = G_DPAD_DOWN_BTN;
										eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
										eventData.controllerIndex = _controllerIndex;
										eventData.controllerID = pControllers[_controllerIndex].controllerID;
										UnlockSyncWrite();

										l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
										Push(l_GEvent);
									}
									else if (ev.value == -1)
									{
										LockSyncWrite();
										pControllers[_controllerIndex].controllerInputs[G_DPAD_UP_BTN] = 1;
										eventData.inputCode = G_DPAD_UP_BTN;
										eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_DPAD_UP_BTN];
										eventData.controllerIndex = _controllerIndex;
										eventData.controllerID = pControllers[_controllerIndex].controllerID;
										UnlockSyncWrite();

										l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
										Push(l_GEvent);
									}
									else if (ev.value == 0)
									{
										LockSyncWrite();
										eventData.controllerID = pControllers[_controllerIndex].controllerID;
										eventData.controllerIndex = _controllerIndex;
										if (pControllers[_controllerIndex].controllerInputs[G_DPAD_UP_BTN] != 0)
										{
											pControllers[_controllerIndex].controllerInputs[G_DPAD_UP_BTN] = 0;
											eventData.inputCode = G_DPAD_UP_BTN;
											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_DPAD_UP_BTN];
										}
										if (pControllers[_controllerIndex].controllerInputs[G_DPAD_DOWN_BTN] != 0)
										{
											pControllers[_controllerIndex].controllerInputs[G_DPAD_DOWN_BTN] = 0;
											eventData.inputCode = G_DPAD_DOWN_BTN;
											eventData.inputValue = pControllers[_controllerIndex].controllerInputs[G_DPAD_DOWN_BTN];
										}
										UnlockSyncWrite();

										l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, eventData);
										Push(l_GEvent);
									}
								}
								break;
								}
							}
						}
						break;
						}
					}
					else
					{
						if (errno == EAGAIN)
							sleep(.001);
						else
							break;
					}
				}

				if (close(fd) == -1)
				{
					if (errno == EBADF)
						printf("fd isnt a valid open file descriptor\n");
					else if (errno == EINTR)
						printf("close call is interrupted by signal\n");
					else if (errno == EIO)
						printf("i/o error\n");
				}

				LockSyncWrite();
				pControllers[_controllerIndex].isConnected = 0;
				UnlockSyncWrite();

				eventData.controllerIndex = _controllerIndex;
				eventData.inputCode = 0;
				eventData.inputValue = 0;
				eventData.isConnected = 0;

				l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERDISCONNECTED, eventData);
				Push(l_GEvent);
			}

			void NotifyThreadEntryPoint()
			{
				EVENT_DATA eventData;
				int fd = 0;
				int wd = 0;
				struct G_inotify_event iev, base;
				int length = sizeof(struct G_inotify_event);
				base.len = 0;
				base.mask = 0;

				fd = inotify_init1(IN_NONBLOCK);
				wd = inotify_add_watch(fd, "/dev/input", IN_ATTRIB | IN_CREATE | IN_DELETE);

				while (isRunning)
				{
					iev = base;
					if (read(fd, &iev, length) != -1)
					{
						if (iev.len)
						{
							if (iev.mask & IN_ATTRIB || iev.mask & IN_CREATE)
							{
								if (!(iev.mask & IN_ISDIR))
								{
									char newFile[30];
									strcpy(newFile, "/dev/input/");
									strcat(newFile, iev.name);
									// check the type of file
									int evdevCheck = strncmp(iev.name, "event", 5);
									// check if file has a vaild number of inputs
									if (evdevCheck == 0)
									{
										int event_fd = open(newFile, O_RDONLY | O_NONBLOCK);
										if (event_fd > -1)
										{
											if (isGamepadBitSet(event_fd))
											{
												LockSyncWrite();
												int controllerIndex = FindEmptyControllerIndex(G_MAX_CONTROLLER_INDEX, pControllers);
												UnlockSyncWrite();
												if (controllerIndex != -1)
												{
													GW::INPUT::GControllerType controllerID;
													int codeMapping, axisMapping;
													GetControllerIDAndMappings(event_fd, controllerID, codeMapping, axisMapping);
													
													LockSyncWrite();
													pControllers[controllerIndex].controllerID = controllerID;
													pControllers[controllerIndex].codeMapping = codeMapping;
													pControllers[controllerIndex].axisMapping = axisMapping;
													isControllerThreadActive[controllerIndex] = true;
													for (int i = 0; i < 8; ++i)
														pControllers[controllerIndex].controllerFilePath[i] = iev.name[i];
													pControllers[controllerIndex].isConnected = 1;
													eventData.controllerID = pControllers[controllerIndex].controllerID;
													UnlockSyncWrite();

													controllerThreads[controllerIndex].Create(false);
													controllerThreads[controllerIndex].BranchSingular(std::bind(&GGeneralController::ControllerInputThreadEntryPoint, this, controllerIndex, event_fd));

													eventData.controllerIndex = controllerIndex;
													eventData.inputCode = 0;
													eventData.inputValue = 0;
													eventData.isConnected = 1;

													GW::GEvent l_GEvent;
													l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERCONNECTED, eventData);
													Push(l_GEvent);
												}
											}
										}
									}
								}
							}
							else if (iev.mask & IN_DELETE)
							{
								if (!(iev.mask & IN_ISDIR))
								{
									for (int i = 0; i < G_MAX_CONTROLLER_INDEX; ++i)
									{
										if (strncmp(pControllers[i].controllerFilePath, iev.name, 8) == 0)
										{
											isControllerThreadActive[i] = false;
											controllerThreads[i].Converge(0);
											controllerThreads[i] = nullptr;
										}
									}
								}
							}
						}
					}
				}

				close(fd);
				for (int i = 0; i < G_MAX_CONTROLLER_INDEX; ++i)
				{
					if (isControllerThreadActive[i])
					{
						isControllerThreadActive[i] = false;
						controllerThreads[i].Converge(0);
						controllerThreads[i] = nullptr;
					}
				}
			}
		public:
			GGeneralController() {}

			virtual void Initialize()
			{
				isRunning = true;

				pControllers = new CONTROLLER_STATE[G_MAX_CONTROLLER_INDEX];
				deadZoneType = GW::I::GControllerInterface::DeadZoneTypes::DEADZONESQUARE;
				deadZonePercentage = 0.2f;

				for (unsigned int i = 0; i < G_MAX_CONTROLLER_INDEX; ++i)
				{
					// Init the bools
					isControllerThreadActive[i] = false;

					pControllers[i].isConnected = 0;
					pControllers[i].isVibrating = 0;
					pControllers[i].vibrationDuration = 0;
					pControllers[i].vibrationStartTime = new std::chrono::high_resolution_clock::time_point();
					pControllers[i].maxInputs = G_MAX_GENERAL_INPUTS;
					pControllers[i].controllerInputs = new float[G_MAX_GENERAL_INPUTS];
					for (unsigned int j = 0; j < G_MAX_GENERAL_INPUTS; ++j)
					{
						pControllers[i].controllerInputs[j] = 0.0f;
					}
				}

				DIR* dir;
				dirent* fileData;
				EVENT_DATA eventData;

				if ((dir = opendir("/dev/input")) != NULL)
				{
					/* print all the files and directories within directory */
					while ((fileData = readdir(dir)) != NULL)
					{
						char newFile[30];
						strcpy(newFile, "/dev/input/");
						strcat(newFile, fileData->d_name);
						// check the type of file
						int evdevCheck = strncmp(fileData->d_name, "event", 5);
						// check if file has a vaild number of inputs
						if (evdevCheck == 0)
						{
							int event_fd = open(newFile, O_RDONLY | O_NONBLOCK);
							if (event_fd > -1)
							{
								if (isGamepadBitSet(event_fd))
								{
									LockAsyncRead();
									int controllerIndex = FindEmptyControllerIndex(G_MAX_CONTROLLER_INDEX, pControllers);
									UnlockAsyncRead();
									if (controllerIndex != -1)
									{
										GW::INPUT::GControllerType controllerID;
										int codeMapping, axisMapping;
										GetControllerIDAndMappings(event_fd, controllerID, codeMapping, axisMapping);
										
										LockSyncWrite();
										isControllerThreadActive[controllerIndex] = true;
										for (int i = 0; i < 8; ++i)
											pControllers[controllerIndex].controllerFilePath[i] = fileData->d_name[i];
										pControllers[controllerIndex].controllerID = controllerID;
										pControllers[controllerIndex].codeMapping = codeMapping;
										pControllers[controllerIndex].axisMapping = axisMapping;
										pControllers[controllerIndex].isConnected = 1;
										eventData.controllerID = pControllers[controllerIndex].controllerID;
										UnlockSyncWrite();

										controllerThreads[controllerIndex].Create(false);
										controllerThreads[controllerIndex].BranchSingular(std::bind(&GGeneralController::ControllerInputThreadEntryPoint, this, controllerIndex, event_fd));

										eventData.controllerIndex = controllerIndex;
										eventData.inputCode = 0;
										eventData.inputValue = 0;
										eventData.isConnected = 1;

										GW::GEvent l_GEvent;
										l_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERCONNECTED, eventData);
										Push(l_GEvent);
									}
								}
							}
						}
					}
					closedir(dir);
				}
				
				notifyThread.Create(false);
				notifyThread.BranchSingular(std::bind(&GGeneralController::NotifyThreadEntryPoint, this));
			}

			virtual void Release()
			{
				isRunning = false;
				
				for (int i = 0; i < G_MAX_CONTROLLER_INDEX; ++i)
					if (isControllerThreadActive[i])
					{
						isControllerThreadActive[i] = false;
						controllerThreads[i].Converge(0);
						controllerThreads[i] = nullptr;
					}
				
				notifyThread.Converge(0);
				
				for (int i = 0; i < G_MAX_CONTROLLER_INDEX; ++i)
				{
					delete[] pControllers[i].controllerInputs;
					delete pControllers[i].vibrationStartTime;
				}
				delete[] pControllers;
			}

			virtual GReturn GetState(unsigned int _controllerIndex, int _inputCode, float& _outState) override
			{
				if (_controllerIndex >= G_MAX_CONTROLLER_INDEX || _inputCode < 0 || _inputCode >= G_MAX_GENERAL_INPUTS)
					return GReturn::INVALID_ARGUMENT;
				if (pControllers[_controllerIndex].isConnected == 0)
					return GReturn::FAILURE;
				LockAsyncRead();
				_outState = pControllers[_controllerIndex].controllerInputs[(_inputCode)];
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}

			virtual GReturn IsConnected(unsigned int _controllerIndex, bool& _outIsConnected) override
			{
				if (_controllerIndex >= G_MAX_CONTROLLER_INDEX)
					return GReturn::INVALID_ARGUMENT;
				LockAsyncRead();
				_outIsConnected = pControllers[_controllerIndex].isConnected == 0 ? false : true;
				UnlockAsyncRead();

				return GReturn::SUCCESS;
			}

			virtual GReturn GetMaxIndex(int& _outMax) override
			{
				_outMax = G_MAX_CONTROLLER_INDEX;
				return GReturn::SUCCESS;
			}

			virtual GReturn GetNumConnected(int& _outConnectedCount) override
			{
				_outConnectedCount = 0;
				LockAsyncRead();
				for (unsigned int i = 0; i < G_MAX_CONTROLLER_INDEX; ++i)
				{
					if (pControllers[i].isConnected)
						++_outConnectedCount;
				}
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}

			virtual GReturn SetDeadZone(DeadZoneTypes _type, float _deadzonePercentage) override
			{
				if (_deadzonePercentage > 1.0f || _deadzonePercentage < 0.0f)
					return GReturn::INVALID_ARGUMENT;
				LockSyncWrite();
				deadZoneType = _type;
				deadZonePercentage = _deadzonePercentage;
				UnlockSyncWrite();
				return GReturn::SUCCESS;
			}

			// General controllers do not support these features because it is used cross-platform as a "general" controller
			virtual GReturn StartVibration(unsigned int _controllerIndex, float _pan, float _duration, float _strength) override { return GReturn::FEATURE_UNSUPPORTED; }
			virtual GReturn IsVibrating(unsigned int _controllerIndex, bool& _outIsVibrating) override { return GReturn::FEATURE_UNSUPPORTED; }
			virtual GReturn StopVibration(unsigned int _controllerIndex) override { return GReturn::FEATURE_UNSUPPORTED; }
			virtual GReturn StopAllVibrations() override { return GReturn::FEATURE_UNSUPPORTED; }

			GReturn Register(CORE::GEventCache _observer) override final { return GEventGeneratorImplementation::Register(_observer); }
			GReturn Register(CORE::GEventResponder _observer) override final { return GEventGeneratorImplementation::Register(_observer); }
			GReturn Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) override final { return GEventGeneratorImplementation::Register(_observer, _callback); }
			GReturn Deregister(CORE::GInterface _observer) override final { return GEventGeneratorImplementation::Deregister(_observer); }
			GReturn Observers(unsigned int& _outCount) const override final { return GEventGeneratorImplementation::Observers(_outCount); }
			GReturn Push(const GEvent& _newEvent) override final { return GEventGeneratorImplementation::Push(_newEvent); }
		};

		inline GControllerImplementation::~GControllerImplementation()
		{
			if (pController)
			{
				pController->Release();
				delete pController;
				pController = nullptr;
			}
		}

		inline GReturn GControllerImplementation::Create()
		{
			pController = new GGeneralController();
			pController->Initialize();
			
			return GReturn::SUCCESS;
		}
		inline GReturn GControllerImplementation::GetState(unsigned int _controllerIndex, int _inputCode, float& _outState) { return pController ? pController->GetState(_controllerIndex, _inputCode, _outState) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::IsConnected(unsigned int _controllerIndex, bool& _outIsConnected) { return pController ? pController->IsConnected(_controllerIndex, _outIsConnected) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::GetMaxIndex(int& _outMax) { return pController ? pController->GetMaxIndex(_outMax) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::GetNumConnected(int& _outConnectedCount) { return pController ? pController->GetNumConnected(_outConnectedCount) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::SetDeadZone(DeadZoneTypes _type, float _deadzonePercentage) { return pController ? pController->SetDeadZone(_type, _deadzonePercentage) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::StartVibration(unsigned int _controllerIndex, float _pan, float _duration, float _strength) { return pController ? pController->StartVibration(_controllerIndex, _pan, _duration, _strength) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::IsVibrating(unsigned int _controllerIndex, bool& _outIsVibrating) { return pController ? pController->IsVibrating(_controllerIndex, _outIsVibrating) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::StopVibration(unsigned int _controllerIndex) { return pController ? pController->StopVibration(_controllerIndex) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::StopAllVibrations() { return pController ? pController->StopAllVibrations() : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::Register(CORE::GEventCache _observer) { return pController ? pController->Register(_observer) : GEventGeneratorImplementation::Register(_observer); }
		inline GReturn GControllerImplementation::Register(CORE::GEventResponder _observer) { return pController ? pController->Register(_observer) : GEventGeneratorImplementation::Register(_observer); }
		inline GReturn GControllerImplementation::Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) { return pController ? pController->Register(_observer, _callback) : GEventGeneratorImplementation::Register(_observer, _callback); }
		inline GReturn GControllerImplementation::Deregister(CORE::GInterface _observer) { return pController ? pController->Deregister(_observer) : GEventGeneratorImplementation::Deregister(_observer); }
		inline GReturn GControllerImplementation::Observers(unsigned int& _outCount) const { return pController ? pController->Observers(_outCount) : GEventGeneratorImplementation::Observers(_outCount); }
		inline GReturn GControllerImplementation::Push(const GEvent& _newEvent) { return pController ? pController->Push(_newEvent) : GEventGeneratorImplementation::Push(_newEvent); }
	} // end I namespace
} // end GW namespace

#elif defined(_WIN32)
    #include <cmath>
#include <chrono>
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <XInput.h>
#pragma comment(lib, "XInput.lib")

#include <objbase.h>

namespace GW
{
	namespace I
	{
		class GGeneralController; // Interface which all controller will inherit from
		class GXboxController; // xbox
		// class GPS4Controller; // Not supported yet! future devs, this is for you :)

		class GControllerImplementation :	public virtual GControllerInterface,
				protected GEventGeneratorImplementation
		{
		private:
			GGeneralController* pController = nullptr; // POLYMORHISM
		public:
			~GControllerImplementation();

			GReturn Create();

			GReturn GetState(unsigned int _controllerIndex, int _inputCode, float& _outState) override;
			GReturn IsConnected(unsigned int _controllerIndex, bool& _outIsConnected) override;
			GReturn GetMaxIndex(int& _outMax) override;
			GReturn GetNumConnected(int& _outConnectedCount) override;
			GReturn SetDeadZone(DeadZoneTypes _type, float _deadzonePercentage) override;
			GReturn StartVibration(unsigned int _controllerIndex, float _pan, float _duration, float _strength) override;
			GReturn IsVibrating(unsigned int _controllerIndex, bool& _outIsVibrating) override;
			GReturn StopVibration(unsigned int _controllerIndex) override;
			GReturn StopAllVibrations() override;

			GReturn Register(CORE::GEventCache _observer) override;
			GReturn Register(CORE::GEventResponder _observer) override;
			GReturn Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) override;
			GReturn Deregister(CORE::GInterface _observer) override;
			GReturn Observers(unsigned int& _outCount) const override;
			GReturn Push(const GEvent& _newEvent) override;
		};

		class GGeneralController :	public virtual GControllerInterface,
									public GEventGeneratorImplementation
		{
		protected:
			struct CONTROLLER_STATE
			{
				int isConnected;
				int isVibrating;
				float vibrationDuration;
				std::chrono::high_resolution_clock::time_point* vibrationStartTime;
				int maxInputs; // Hold the size of controllerInputs array
				float* controllerInputs; // controllerInputs is used to hold an array for the input values of the controller
				GW::INPUT::GControllerType controllerID;
			} *pControllers = nullptr;

			GW::I::GControllerInterface::DeadZoneTypes deadZoneType = GW::I::GControllerInterface::DeadZoneTypes::DEADZONECIRCLE;
			float deadZonePercentage = 0;

			// This function does not lock before using _controllers
			unsigned int FindEmptyControllerIndex(unsigned int _maxIndex, const CONTROLLER_STATE* _controllers) const
			{
				for (unsigned int i = 0; i < _maxIndex; ++i)
				{
					if (_controllers[i].isConnected == 0)
						return i;
				}
				return -1;
			}

			// prehaps make return vaule GRETURN
			CONTROLLER_STATE* CopyControllerState(const CONTROLLER_STATE* _stateToCopy, CONTROLLER_STATE* _outCopy) const
			{
				if (_stateToCopy->maxInputs == _outCopy->maxInputs)
					for (int i = 0; i < _outCopy->maxInputs; ++i)
					{
						_outCopy->controllerInputs[i] = _stateToCopy->controllerInputs[i];
					}
				else
					_outCopy = nullptr;

				return _outCopy;
			}

			void DeadZoneCalculation(float _x, float _y, float _axisMax, float _axisMin, float& _outX, float& _outY, GW::I::GControllerInterface::DeadZoneTypes _deadzoneType, float _deadzonePercentage) const
			{
				float range = _axisMax - _axisMin;
				_outX = (((_x - _axisMin) * 2) / range) - 1;
				_outY = (((_y - _axisMin) * 2) / range) - 1;
				float liveRange = 1.0f - _deadzonePercentage;
				if (_deadzoneType == GW::I::GControllerInterface::DeadZoneTypes::DEADZONESQUARE)
				{
					if (std::abs(_outX) <= _deadzonePercentage)
						_outX = 0.0f;
					if (std::abs(_outY) <= _deadzonePercentage)
						_outY = 0.0f;

					if (_outX > 0.0f)
						_outX = (_outX - _deadzonePercentage) / liveRange;
					else if (_outX < 0.0f)
						_outX = (_outX + _deadzonePercentage) / liveRange;
					if (_outY > 0.0f)
						_outY = (_outY - _deadzonePercentage) / liveRange;
					else if (_outY < 0.0f)
						_outY = (_outY + _deadzonePercentage) / liveRange;
				}
				else
				{
					float mag = std::sqrt(_outX * _outX + _outY * _outY);
					mag = (mag - _deadzonePercentage) / liveRange;
					_outX *= mag;
					_outY *= mag;

					if (std::abs(_outX) <= _deadzonePercentage)
						_outX = 0.0f;
					if (std::abs(_outY) <= _deadzonePercentage)
						_outY = 0.0f;
				}
			}
		public:
			GGeneralController() {}

			virtual void Initialize()
			{
				pControllers = new CONTROLLER_STATE[G_MAX_CONTROLLER_INDEX];
				deadZoneType = GW::I::GControllerInterface::DeadZoneTypes::DEADZONESQUARE;
				deadZonePercentage = 0.2f;

				for (unsigned int i = 0; i < G_MAX_CONTROLLER_INDEX; ++i)
				{
					pControllers[i].isConnected = 0;
					pControllers[i].isVibrating = 0;
					pControllers[i].vibrationDuration = 0;
					pControllers[i].vibrationStartTime = new std::chrono::high_resolution_clock::time_point();
					pControllers[i].maxInputs = G_MAX_GENERAL_INPUTS;
					pControllers[i].controllerInputs = new float[G_MAX_GENERAL_INPUTS];
					for (unsigned int j = 0; j < G_MAX_GENERAL_INPUTS; ++j)
					{
						pControllers[i].controllerInputs[j] = 0.0f;
					}
				}
			}

			virtual void Release()
			{
				for (int i = 0; i < G_MAX_CONTROLLER_INDEX; ++i)
				{
					delete[] pControllers[i].controllerInputs;
					delete pControllers[i].vibrationStartTime;
				}
				delete[] pControllers;
			}

			virtual GReturn GetState(unsigned int _controllerIndex, int _inputCode, float& _outState) override
			{
				if (_controllerIndex >= G_MAX_CONTROLLER_INDEX || _inputCode < 0 || _inputCode >= G_MAX_GENERAL_INPUTS)
					return GReturn::INVALID_ARGUMENT;

				LockAsyncRead();
				if (pControllers[_controllerIndex].isConnected == 0)
				{
					UnlockAsyncRead();
					return GReturn::FAILURE;
				}

				_outState = pControllers[_controllerIndex].controllerInputs[(_inputCode)];
				UnlockAsyncRead();

				return GReturn::SUCCESS;
			}

			virtual GReturn IsConnected(unsigned int _controllerIndex, bool& _outIsConnected) override
			{
				if (_controllerIndex >= G_MAX_CONTROLLER_INDEX)
					return GReturn::INVALID_ARGUMENT;
				LockAsyncRead();
				_outIsConnected = pControllers[_controllerIndex].isConnected == 0 ? false : true;
				UnlockAsyncRead();

				return GReturn::SUCCESS;
			}

			virtual GReturn GetMaxIndex(int& _outMax) override
			{
				_outMax = G_MAX_CONTROLLER_INDEX;
				return GReturn::SUCCESS;
			}

			virtual GReturn GetNumConnected(int& _outConnectedCount) override
			{
				_outConnectedCount = 0;
				LockAsyncRead();
				for (unsigned int i = 0; i < G_MAX_CONTROLLER_INDEX; ++i)
				{
					if (pControllers[i].isConnected)
						++_outConnectedCount;
				}
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}

			virtual GReturn SetDeadZone(DeadZoneTypes _type, float _deadzonePercentage) override
			{
				if (_deadzonePercentage > 1.0f || _deadzonePercentage < 0.0f)
					return GReturn::INVALID_ARGUMENT;
				LockSyncWrite();
				deadZoneType = _type;
				deadZonePercentage = _deadzonePercentage;
				UnlockSyncWrite();
				return GReturn::SUCCESS;
			}

			virtual GReturn StartVibration(unsigned int _controllerIndex, float _pan, float _duration, float _strength) override
			{
				return GReturn::FEATURE_UNSUPPORTED;
			}

			virtual GReturn IsVibrating(unsigned int _controllerIndex, bool& _outIsVibrating) override
			{
				return GReturn::FEATURE_UNSUPPORTED;
			}

			virtual GReturn StopVibration(unsigned int _controllerIndex) override
			{
				return GReturn::FEATURE_UNSUPPORTED;
			}

			virtual GReturn StopAllVibrations() override
			{
				return GReturn::FEATURE_UNSUPPORTED;
			}

			GReturn Register(CORE::GEventCache _observer) override final { return GEventGeneratorImplementation::Register(_observer); }
			GReturn Register(CORE::GEventResponder _observer) override final { return GEventGeneratorImplementation::Register(_observer); }
			GReturn Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) override final { return GEventGeneratorImplementation::Register(_observer, _callback); }
			GReturn Deregister(CORE::GInterface _observer) override final { return GEventGeneratorImplementation::Deregister(_observer); }
			GReturn Observers(unsigned int& _outCount) const override final { return GEventGeneratorImplementation::Observers(_outCount); }
			GReturn Push(const GEvent& _newEvent) override final { return GEventGeneratorImplementation::Push(_newEvent); }
		};

		class GXboxController : public GGeneralController
		{
		private:
			GW::SYSTEM::GDaemon xinputDaemon;
			int XControllerSlotIndices[4];
			DWORD XControllerLastPacket[4];

			struct DaemonData
			{
				DWORD result;
				XINPUT_STATE controllerState;
				EVENT_DATA eventData;
				CONTROLLER_STATE oldState;

				DaemonData()
				{
					ZeroMemory(&controllerState, sizeof(XINPUT_STATE));
					ZeroMemory(&eventData, sizeof(EVENT_DATA));
					oldState.maxInputs = G_MAX_XBOX_INPUTS;
					oldState.controllerInputs = new float[G_MAX_XBOX_INPUTS];
				}

				~DaemonData()
				{
					delete[] oldState.controllerInputs;
				}
			} daemonData;

			float XboxDeadZoneCalc(float _value, bool _isTigger)
			{
				if (_isTigger)
				{
					if (std::abs(_value) > XINPUT_GAMEPAD_TRIGGER_THRESHOLD)
						_value /= G_MAX_XBOX_TRIGGER_AXIS;
					else
						_value = 0;
				}
				else
				{
					if (std::abs(_value) > XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE)
						_value /= G_MAX_XBOX_THUMB_AXIS;
					else
						_value = 0;
				}
				return _value;
			}
		public:
			GXboxController()
				: GGeneralController()
			{
				ZeroMemory(XControllerLastPacket, ARRAYSIZE(XControllerLastPacket));
				for (int i = 0; i < 4; ++i)
					XControllerSlotIndices[i] = -1;
			}

			virtual void Initialize()
			{
				pControllers = new CONTROLLER_STATE[G_MAX_XBOX_CONTROLLER_INDEX];
				deadZoneType = GW::I::GControllerInterface::DeadZoneTypes::DEADZONESQUARE;
				deadZonePercentage = 0.2f;
				for (unsigned int i = 0; i < G_MAX_XBOX_CONTROLLER_INDEX; ++i)
				{
					pControllers[i].isConnected = 0;
					pControllers[i].isVibrating = 0;
					pControllers[i].vibrationDuration = 0;
					pControllers[i].vibrationStartTime = new std::chrono::high_resolution_clock::time_point();
					pControllers[i].maxInputs = G_MAX_XBOX_INPUTS;
					pControllers[i].controllerInputs = new float[G_MAX_XBOX_INPUTS];
				}
				// Event callback for xinput
				xinputDaemon.Create(G_CONTROLLER_DAEMON_OPERATION_INTERVAL, [&]()
				{
					/* --- NOTE ---
					 * pControllers:
					 *      Locked when being read or written to because it can be read and written to outside
					 *      of this function. All other function should lock when reading or writing to it.
					 * XControllerSlotIndices:
					 *      Only Locked whenever written to because it is only written to inside of this function. 
					 *      All other functions should lock before reading this array while xinputDaemon is running.
					 * All other member variables are not used outside of this function. Therefore, they don't need locks.
					 */
					CoInitialize(nullptr); // place this thread in COM single threaded appartment
					GW::GEvent m_GEvent;
					for (int i = 0; i < G_MAX_XBOX_CONTROLLER_INDEX; ++i)
					{
						daemonData.result = XInputGetState(i, &daemonData.controllerState);
						if (daemonData.result == ERROR_SUCCESS)
						{
							if (XControllerSlotIndices[i] < 0)
							{
								LockSyncWrite();
								XControllerSlotIndices[i] = FindEmptyControllerIndex(G_MAX_XBOX_CONTROLLER_INDEX, pControllers);
								pControllers[XControllerSlotIndices[i]].isConnected = 1;
								UnlockSyncWrite();

								daemonData.eventData.controllerIndex = XControllerSlotIndices[i];
								daemonData.eventData.inputCode = 0;
								daemonData.eventData.inputValue = 0;
								daemonData.eventData.isConnected = 1;
								daemonData.eventData.controllerID = GW::INPUT::GControllerType::XBOX360;

								m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERCONNECTED, daemonData.eventData);
								Push(m_GEvent);
							}

							if (XControllerSlotIndices[i] >= 0 && daemonData.controllerState.dwPacketNumber != XControllerLastPacket[i]) // add checks for events
							{
								LockAsyncRead();
								CopyControllerState(&pControllers[XControllerSlotIndices[i]], &daemonData.oldState);
								UnlockAsyncRead();
								daemonData.eventData.isConnected = 1;
								daemonData.eventData.controllerIndex = XControllerSlotIndices[i];

								XControllerLastPacket[i] = daemonData.controllerState.dwPacketNumber;

								// Buttons
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_A) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_SOUTH_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_SOUTH_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_A) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_SOUTH_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_SOUTH_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_B) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_EAST_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_EAST_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_B) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_EAST_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_EAST_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_Y) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_NORTH_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_NORTH_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_Y) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_NORTH_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_NORTH_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_X) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_WEST_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_WEST_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_X) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_WEST_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_WEST_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_LEFT_SHOULDER) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_LEFT_SHOULDER_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_LEFT_SHOULDER_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_LEFT_SHOULDER) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_LEFT_SHOULDER_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_LEFT_SHOULDER_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_RIGHT_SHOULDER) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_RIGHT_SHOULDER_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_RIGHT_SHOULDER_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_RIGHT_SHOULDER) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_RIGHT_SHOULDER_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_RIGHT_SHOULDER_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_DPAD_LEFT_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_DPAD_LEFT_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_DPAD_LEFT_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_DPAD_LEFT_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_DPAD_RIGHT_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_DPAD_RIGHT_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_DPAD_RIGHT_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_DPAD_RIGHT_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_DPAD_UP_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_DPAD_UP_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_DPAD_UP_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_DPAD_UP_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_DPAD_DOWN_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_DPAD_DOWN_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_DPAD_DOWN_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_DPAD_DOWN_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_LEFT_THUMB) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_LEFT_THUMB_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_LEFT_THUMB_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_LEFT_THUMB) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_LEFT_THUMB_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_LEFT_THUMB_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_RIGHT_THUMB) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_RIGHT_THUMB_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_RIGHT_THUMB_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_RIGHT_THUMB) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_RIGHT_THUMB_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_RIGHT_THUMB_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_START) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_START_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_START_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_START) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_START_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_START_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (((daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_BACK) != 0 ? 1.0f : 0.0f) != daemonData.oldState.controllerInputs[G_SELECT_BTN])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_SELECT_BTN] = (daemonData.controllerState.Gamepad.wButtons & XINPUT_GAMEPAD_BACK) != 0 ? 1.0f : 0.0f;
									daemonData.eventData.inputCode = G_SELECT_BTN;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_SELECT_BTN];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERBUTTONVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}

								// AXES
								if (XboxDeadZoneCalc(daemonData.controllerState.Gamepad.bLeftTrigger, true) != daemonData.oldState.controllerInputs[G_LEFT_TRIGGER_AXIS])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_LEFT_TRIGGER_AXIS] = XboxDeadZoneCalc(daemonData.controllerState.Gamepad.bLeftTrigger, true);
									daemonData.eventData.inputCode = G_LEFT_TRIGGER_AXIS;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_LEFT_TRIGGER_AXIS];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (XboxDeadZoneCalc(daemonData.controllerState.Gamepad.bRightTrigger, true) != daemonData.oldState.controllerInputs[G_RIGHT_TRIGGER_AXIS])
								{
									LockSyncWrite();
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_RIGHT_TRIGGER_AXIS] = XboxDeadZoneCalc(daemonData.controllerState.Gamepad.bRightTrigger, true);
									daemonData.eventData.inputCode = G_RIGHT_TRIGGER_AXIS;
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_RIGHT_TRIGGER_AXIS];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}

								LockSyncWrite();

								DeadZoneCalculation(daemonData.controllerState.Gamepad.sThumbLX,
									daemonData.controllerState.Gamepad.sThumbLY,
									G_MAX_XBOX_THUMB_AXIS,
									G_MIN_XBOX_THUMB_AXIS,
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_LX_AXIS],
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_LY_AXIS],
									deadZoneType,
									deadZonePercentage);

								DeadZoneCalculation(daemonData.controllerState.Gamepad.sThumbRX,
									daemonData.controllerState.Gamepad.sThumbRY,
									G_MAX_XBOX_THUMB_AXIS,
									G_MIN_XBOX_THUMB_AXIS,
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_RX_AXIS],
									pControllers[XControllerSlotIndices[i]].controllerInputs[G_RY_AXIS],
									deadZoneType,
									deadZonePercentage);

								float newLX = pControllers[XControllerSlotIndices[i]].controllerInputs[G_LX_AXIS];
								float newLY = pControllers[XControllerSlotIndices[i]].controllerInputs[G_LY_AXIS];
								float newRX = pControllers[XControllerSlotIndices[i]].controllerInputs[G_RX_AXIS];
								float newRY = pControllers[XControllerSlotIndices[i]].controllerInputs[G_RY_AXIS];

								UnlockSyncWrite();

								if (newLX != daemonData.oldState.controllerInputs[G_LX_AXIS])
								{
									daemonData.eventData.inputCode = G_LX_AXIS;
									LockSyncWrite();
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_LX_AXIS];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
								if (newLY != daemonData.oldState.controllerInputs[G_LY_AXIS])
								{
									daemonData.eventData.inputCode = G_LY_AXIS;
									LockSyncWrite();
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_LY_AXIS];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}

								if (newRX != daemonData.oldState.controllerInputs[G_RX_AXIS])
								{
									daemonData.eventData.inputCode = G_RX_AXIS;
									LockSyncWrite();
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_RX_AXIS];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}

								if (newRY != daemonData.oldState.controllerInputs[G_RY_AXIS])
								{
									daemonData.eventData.inputCode = G_RY_AXIS;
									LockSyncWrite();
									daemonData.eventData.inputValue = pControllers[XControllerSlotIndices[i]].controllerInputs[G_RY_AXIS];
									UnlockSyncWrite();

									m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERAXISVALUECHANGED, daemonData.eventData);
									Push(m_GEvent);
								}
							}
						}
						else // no controller connected
						{
							if (XControllerSlotIndices[i] >= 0)
							{
								//call event

								LockSyncWrite();
								pControllers[XControllerSlotIndices[i]].isConnected = 0;
								pControllers[XControllerSlotIndices[i]].isVibrating = 0;
								pControllers[XControllerSlotIndices[i]].vibrationDuration = 0.0f;
								UnlockSyncWrite();

								daemonData.eventData.controllerIndex = XControllerSlotIndices[i];
								daemonData.eventData.inputCode = 0;
								daemonData.eventData.inputValue = 0;
								daemonData.eventData.isConnected = 0;
								daemonData.eventData.controllerID = GW::INPUT::GControllerType::XBOX360;

								m_GEvent.Write(GW::I::GControllerInterface::Events::CONTROLLERDISCONNECTED, daemonData.eventData);
								Push(m_GEvent);

								LockSyncWrite();
								XControllerSlotIndices[i] = -1;
								UnlockSyncWrite();
							}
						}

						LockAsyncRead();
						if (XControllerSlotIndices[i] >= 0 && pControllers[XControllerSlotIndices[i]].isVibrating)
						{
							if (pControllers[XControllerSlotIndices[i]].vibrationDuration <=
								(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now() -
									*pControllers[XControllerSlotIndices[i]].vibrationStartTime).count() * .001f))
							{
								UnlockAsyncRead();

								XINPUT_VIBRATION vibrationState;
								vibrationState.wLeftMotorSpeed = 0;
								vibrationState.wRightMotorSpeed = 0;

								LockSyncWrite();
								pControllers[XControllerSlotIndices[i]].isVibrating = 0;
								pControllers[XControllerSlotIndices[i]].vibrationDuration = 0.0f;
								UnlockSyncWrite();

								XInputSetState(i, &vibrationState);

								LockAsyncRead();
							}
						}
						UnlockAsyncRead();
					}
				});
			}

			virtual void Release()
			{
				xinputDaemon = nullptr; // Stop the input thread.

				for (int i = 0; i < G_MAX_XBOX_CONTROLLER_INDEX; ++i)
				{
					delete[] pControllers[i].controllerInputs;
					delete pControllers[i].vibrationStartTime;
				}
				delete[] pControllers;
			}

			GReturn GetState(unsigned int _controllerIndex, int _inputCode, float& _outState) override final
			{
				if (_controllerIndex >= G_MAX_XBOX_CONTROLLER_INDEX || _inputCode < 0 || _inputCode  > 19)
					return GReturn::INVALID_ARGUMENT;

				LockAsyncRead();
				if (pControllers[_controllerIndex].isConnected == 0)
				{
					UnlockAsyncRead();
					return GReturn::FAILURE;
				}

				_outState = pControllers[_controllerIndex].controllerInputs[_inputCode];
				UnlockAsyncRead();

				return GReturn::SUCCESS;
			}

			GReturn IsConnected(unsigned int _controllerIndex, bool& _outIsConnected) override final
			{
				if (_controllerIndex >= G_MAX_XBOX_CONTROLLER_INDEX)
					return GReturn::INVALID_ARGUMENT;
				LockAsyncRead();
				_outIsConnected = pControllers[_controllerIndex].isConnected == 0 ? false : true;
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}

			GReturn GetMaxIndex(int& _outMax) override final
			{
				_outMax = G_MAX_XBOX_CONTROLLER_INDEX;
				return GReturn::SUCCESS;
			}

			GReturn GetNumConnected(int& _outConnectedCount) override final
			{
				_outConnectedCount = 0;
				LockAsyncRead();
				for (unsigned int i = 0; i < G_MAX_XBOX_CONTROLLER_INDEX; ++i)
				{
					if (pControllers[i].isConnected)
						++_outConnectedCount;
				}
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}

			GReturn StartVibration(unsigned int _controllerIndex, float _pan, float _duration, float _strength) override final
			{
				if ((_controllerIndex > G_MAX_XBOX_CONTROLLER_INDEX)
					|| (_pan < -1.0f || _pan > 1.0f)
					|| _duration < 0.0f
					|| (_strength < -1.0f || _strength > 1.0f))
					return GReturn::INVALID_ARGUMENT;

				LockAsyncRead();
				if (pControllers[_controllerIndex].isVibrating)
				{
					UnlockAsyncRead();
					return GReturn::REDUNDANT;
				}
				UnlockAsyncRead();

				XINPUT_VIBRATION vibrationState;
				unsigned int vibrationStrength = static_cast<unsigned int>(G_XINPUT_MAX_VIBRATION * _strength);
				vibrationState.wLeftMotorSpeed = static_cast<WORD>(vibrationStrength * (.5f + (.5f * (-1 * _pan))));
				vibrationState.wRightMotorSpeed = static_cast<WORD>(vibrationStrength * (.5f + (.5f * _pan)));

				LockSyncWrite();
				for (int i = 0; i < 4; ++i)
				{
					if (_controllerIndex == static_cast<unsigned int>(XControllerSlotIndices[i]))
					{
						pControllers[i].isVibrating = 1;
						pControllers[i].vibrationDuration = _duration;
						*pControllers[i].vibrationStartTime = std::chrono::high_resolution_clock::now();
						XInputSetState(i, &vibrationState);
						break;
					}
				}
				UnlockSyncWrite();
				return GReturn::SUCCESS;
			}

			GReturn IsVibrating(unsigned int _controllerIndex, bool& _outIsVibrating) override final
			{
				if ((_controllerIndex > G_MAX_XBOX_CONTROLLER_INDEX))
					return GReturn::INVALID_ARGUMENT;
				LockAsyncRead();
				_outIsVibrating = pControllers[_controllerIndex].isVibrating == 0 ? false : true;
				UnlockAsyncRead();
				return GReturn::SUCCESS;
			}

			GReturn StopVibration(unsigned int _controllerIndex) override final
			{
				if ((_controllerIndex > G_MAX_XBOX_CONTROLLER_INDEX))
					return GReturn::INVALID_ARGUMENT;

				LockAsyncRead();
				if (pControllers[_controllerIndex].isVibrating == false)
				{
					UnlockAsyncRead();
					return GReturn::REDUNDANT;
				}
				UnlockAsyncRead();

				XINPUT_VIBRATION vibrationState;
				vibrationState.wLeftMotorSpeed = 0;
				vibrationState.wRightMotorSpeed = 0;

				LockSyncWrite();
				for (int i = 0; i < 4; ++i)
				{
					if (_controllerIndex == static_cast<unsigned int>(XControllerSlotIndices[i]))
					{
						pControllers[i].isVibrating = 0;
						pControllers[i].vibrationDuration = 0.0f;
						XInputSetState(i, &vibrationState);
						break;
					}
				}
				UnlockSyncWrite();
				return GReturn::SUCCESS;
			}

			GReturn StopAllVibrations() override final
			{
				XINPUT_VIBRATION vibrationState;
				vibrationState.wLeftMotorSpeed = 0;
				vibrationState.wRightMotorSpeed = 0;

				LockSyncWrite();
				for (int i = 0; i < G_MAX_XBOX_CONTROLLER_INDEX; ++i)
				{
					if (pControllers[i].isVibrating)
					{
						pControllers[i].isVibrating = 0;
						pControllers[i].vibrationDuration = 0.0f;
						XInputSetState(i, &vibrationState);
					}
				}
				UnlockSyncWrite();
				return GReturn::SUCCESS;
			}
		};

		// Need to put definitions here instead of class body because it needs to know function definitions
		inline GControllerImplementation::~GControllerImplementation()
		{
			if (pController)
			{
				pController->Release();
				delete pController;
				pController = nullptr;
			}
		}

		inline GReturn GControllerImplementation::Create()
		{
			pController = new GXboxController();
			pController->Initialize();

			return GReturn::SUCCESS;
		}
		inline GReturn GControllerImplementation::GetState(unsigned int _controllerIndex, int _inputCode, float& _outState) { return pController ? pController->GetState(_controllerIndex, _inputCode, _outState) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::IsConnected(unsigned int _controllerIndex, bool& _outIsConnected) { return pController ? pController->IsConnected(_controllerIndex, _outIsConnected) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::GetMaxIndex(int& _outMax) { return pController ? pController->GetMaxIndex(_outMax) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::GetNumConnected(int& _outConnectedCount) { return pController ? pController->GetNumConnected(_outConnectedCount) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::SetDeadZone(DeadZoneTypes _type, float _deadzonePercentage) { return pController ? pController->SetDeadZone(_type, _deadzonePercentage) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::StartVibration(unsigned int _controllerIndex, float _pan, float _duration, float _strength) { return pController ? pController->StartVibration(_controllerIndex, _pan, _duration, _strength) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::IsVibrating(unsigned int _controllerIndex, bool& _outIsVibrating) { return pController ? pController->IsVibrating(_controllerIndex, _outIsVibrating) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::StopVibration(unsigned int _controllerIndex) { return pController ? pController->StopVibration(_controllerIndex) : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::StopAllVibrations() { return pController ? pController->StopAllVibrations() : GReturn::FAILURE; }
		inline GReturn GControllerImplementation::Register(CORE::GEventCache _observer) { return pController ? pController->Register(_observer) : GEventGeneratorImplementation::Register(_observer); }
		inline GReturn GControllerImplementation::Register(CORE::GEventResponder _observer) { return pController ? pController->Register(_observer) : GEventGeneratorImplementation::Register(_observer); }
		inline GReturn GControllerImplementation::Register(CORE::GInterface _observer, void(*_callback)(const GEvent&, CORE::GInterface&)) { return pController ? pController->Register(_observer, _callback) : GEventGeneratorImplementation::Register(_observer, _callback); }
		inline GReturn GControllerImplementation::Deregister(CORE::GInterface _observer) { return pController ? pController->Deregister(_observer) : GEventGeneratorImplementation::Deregister(_observer); }
		inline GReturn GControllerImplementation::Observers(unsigned int& _outCount) const { return pController ? pController->Observers(_outCount) : GEventGeneratorImplementation::Observers(_outCount); }
		inline GReturn GControllerImplementation::Push(const GEvent& _newEvent) { return pController ? pController->Push(_newEvent) : GEventGeneratorImplementation::Push(_newEvent); }
	} // end I namespace
} // end GW namespace

#endif


namespace GW
{
	namespace INPUT
	{
		class GController final
			: public I::GProxy<I::GControllerInterface, I::GControllerImplementation>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GController);
			GATEWARE_TYPEDEF(Events);
			GATEWARE_TYPEDEF(EVENT_DATA);
			GATEWARE_TYPEDEF(DeadZoneTypes);
			GATEWARE_FUNCTION(GetState);
			GATEWARE_FUNCTION(IsConnected);
			GATEWARE_FUNCTION(GetMaxIndex);
			GATEWARE_FUNCTION(GetNumConnected);
			GATEWARE_FUNCTION(SetDeadZone);
			GATEWARE_FUNCTION(StartVibration);
			GATEWARE_FUNCTION(IsVibrating);
			GATEWARE_FUNCTION(StopVibration);
			GATEWARE_FUNCTION(StopAllVibrations);

			// reimplemented functions
			GATEWARE_FUNCTION(Register);
			GATEWARE_CONST_FUNCTION(Observers);
			GATEWARE_FUNCTION(Push);

			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}// end SYSTEM namespace
}// end GW namespace
#endif // #endif GCONTROLLER_H

/*---------------------------------
|	End of GController.h
----------------------------------*/


/*---------------------------------
|	Begin of GInput.h
----------------------------------*/
#ifndef GINPUT_H
#define GINPUT_H






namespace GW
{
	namespace I
	{
		class GInputInterface : public virtual GInterfaceInterface
		{
		public:
			virtual GReturn GetState(int _keyCode, float& _outState) = 0;
			virtual GReturn GetMouseDelta(float& _x, float& _y) = 0;
			virtual GReturn GetMousePosition(float& _x, float& _y) const = 0;
			virtual GReturn GetKeyMask(unsigned int& _outKeyMask) const = 0;
		};
	}// end I
}// end GW 

// Implementation Source link, will be search-replaced in single header version.
// Implementaion for GInput.h
// *IMPORTANT* End users of Gateware may ignore the contents of these files if they please.(Developers Only)
// File not included in Doxygen, these files will be compiled directly into associated header file when deployed
// Developers: Do NOT assume the contents of this file are within the scope of the related interface's namespace
// Developers: These are NOT cpp files do not use "using namespace" or unprotected global variables (prefer static members)
// Developers: If you MUST use a non-static global, use the "internal_gw" namespace to store them. (only on approval)

// Gateware platform specific implementations are seperated into different files to keep things clean and flexible
// As new platforms come online or are deprecated (or upgraded) we can modify their selection through this file
// When adding implementations please try to condense redundant file includes where possible.
// This will reduce size/redundancy when the library is tool compressed into single header form.
// Need include guard for this because GInput and GBufferedInput uses this file
#ifndef GINPUTTABLEROUTING_HPP
#define GINPUTTABLEROUTING_HPP

// Defines platform specific key codes that is shared between
// GInput and GBufferedInput
namespace GW
{
	namespace I
	{
#if defined(_WIN32)
		constexpr unsigned int Keycodes[128] =
		{
			G_KEY_UNKNOWN,				// 0
			G_KEY_ESCAPE,				// 1
			G_KEY_1,					// 2
			G_KEY_2,					// 3
			G_KEY_3,					// 4
			G_KEY_4,					// 5
			G_KEY_5,					// 6
			G_KEY_6,					// 7
			G_KEY_7,					// 8
			G_KEY_8,					// 9
			G_KEY_9,					// 10
			G_KEY_0,					// 11
			G_KEY_MINUS,				// 12
			G_KEY_EQUALS,				// 13
			G_KEY_BACKSPACE,			// 14
			G_KEY_TAB,					// 15
			G_KEY_Q,					// 16
			G_KEY_W,					// 17
			G_KEY_E,					// 18
			G_KEY_R,					// 19
			G_KEY_T,					// 20
			G_KEY_Y,					// 21
			G_KEY_U,					// 22
			G_KEY_I,					// 23
			G_KEY_O,					// 24
			G_KEY_P,					// 25
			G_KEY_BRACKET_OPEN,			// 26
			G_KEY_BRACKET_CLOSE,		// 27
			G_KEY_ENTER,				// 28
			G_KEY_LEFTCONTROL,			// 29
			G_KEY_A,					// 30
			G_KEY_S,					// 31
			G_KEY_D,					// 32
			G_KEY_F,					// 33
			G_KEY_G,					// 34
			G_KEY_H,					// 35
			G_KEY_J,					// 36
			G_KEY_K,					// 37
			G_KEY_L,					// 38
			G_KEY_SEMICOLON,			// 39
			G_KEY_QUOTE,				// 40
			G_KEY_TILDE,				// 41
			G_KEY_LEFTSHIFT,			// 42
			G_KEY_BACKSLASH,			// 43
			G_KEY_Z,					// 44
			G_KEY_X,					// 45
			G_KEY_C,					// 46
			G_KEY_V,					// 47
			G_KEY_B,					// 48
			G_KEY_N,					// 49
			G_KEY_M,					// 50
			G_KEY_COMMA,				// 51
			G_KEY_PERIOD,				// 52
			G_KEY_FORWARDSLASH,			// 53
			G_KEY_RIGHTSHIFT,			// 54
			G_KEY_NUMPAD_MULTIPLY,		// 55
			G_KEY_LEFTALT,				// 56
			G_KEY_SPACE,				// 57
			G_KEY_CAPSLOCK,				// 58
			G_KEY_F1,					// 59
			G_KEY_F2,					// 60
			G_KEY_F3,					// 61
			G_KEY_F4,					// 62
			G_KEY_F5,					// 63
			G_KEY_F6,					// 64
			G_KEY_F7,					// 65
			G_KEY_F8,					// 66
			G_KEY_F9,					// 67
			G_KEY_F10,					// 68
			G_KEY_NUMLOCK,				// 69
			G_KEY_SCROLL_LOCK,			// 70
			G_KEY_NUMPAD_7,				// 71
			G_KEY_NUMPAD_8,				// 72
			G_KEY_NUMPAD_9,				// 73
			G_KEY_NUMPAD_SUBTRACT,		// 74
			G_KEY_NUMPAD_4,				// 75
			G_KEY_NUMPAD_5,				// 76
			G_KEY_NUMPAD_6,				// 77
			G_KEY_NUMPAD_ADD,			// 78
			G_KEY_NUMPAD_1,				// 79
			G_KEY_NUMPAD_2,				// 80
			G_KEY_NUMPAD_3,				// 81
			G_KEY_NUMPAD_0,				// 82
			G_KEY_NUMPAD_PERIOD,		// 83
			G_KEY_UNKNOWN,				// 84
			G_KEY_UNKNOWN,				// 85
			G_KEY_UNKNOWN,				// 86
			G_KEY_F11,					// 87
			G_KEY_F12,					// 88
			G_KEY_UNKNOWN,				// 89
			G_KEY_UNKNOWN,				// 90
			G_KEY_UNKNOWN,				// 91
			G_KEY_UNKNOWN,				// 92
			G_KEY_UNKNOWN,				// 93
			G_KEY_UNKNOWN,				// 94
			G_KEY_UNKNOWN,				// 95
			G_KEY_UNKNOWN,				// 96
			G_KEY_UNKNOWN,				// 97
			G_KEY_UNKNOWN,				// 98
			G_KEY_UNKNOWN,				// 99
			G_KEY_UNKNOWN,				// 100
			G_KEY_UNKNOWN,				// 101
			G_KEY_UNKNOWN,				// 102
			G_KEY_UNKNOWN,				// 103
			G_KEY_UNKNOWN,				// 104
			G_KEY_UNKNOWN,				// 105
			G_KEY_UNKNOWN,				// 106
			G_KEY_UNKNOWN,				// 107
			G_KEY_UNKNOWN,				// 108
			G_KEY_UNKNOWN,				// 109
			G_KEY_UNKNOWN,				// 110
			G_KEY_UNKNOWN,				// 111
			G_KEY_UNKNOWN,				// 112
			G_KEY_UNKNOWN,				// 113
			G_KEY_UNKNOWN,				// 114
			G_KEY_UNKNOWN,				// 115
			G_KEY_UNKNOWN,				// 116
			G_KEY_UNKNOWN,				// 117
			G_KEY_UNKNOWN,				// 118
			G_KEY_UNKNOWN,				// 119
			G_KEY_UNKNOWN,				// 120
			G_KEY_UNKNOWN,				// 121
			G_KEY_UNKNOWN,				// 122
			G_KEY_UNKNOWN,				// 123
			G_KEY_UNKNOWN,				// 124
			G_KEY_UNKNOWN,				// 125
			G_KEY_UNKNOWN,				// 126
			G_KEY_UNKNOWN				// 127
		};
#elif defined(__linux__)
		constexpr unsigned int Keycodes[128] =
		{
			G_KEY_UNKNOWN,			// 0
			G_KEY_UNKNOWN,			// 1
			G_KEY_UNKNOWN,			// 2
			G_KEY_UNKNOWN,			// 3
			G_KEY_UNKNOWN,			// 4
			G_KEY_UNKNOWN,			// 5
			G_KEY_UNKNOWN,			// 6
			G_KEY_UNKNOWN,			// 7
			G_KEY_UNKNOWN,			// 8
			G_KEY_ESCAPE,			// 9
			G_KEY_1,				// 10
			G_KEY_2,				// 11
			G_KEY_3,				// 12
			G_KEY_4,				// 13
			G_KEY_5,				// 14
			G_KEY_6,				// 15
			G_KEY_7,				// 16
			G_KEY_8,				// 17
			G_KEY_9,				// 18
			G_KEY_0,				// 19
			G_KEY_MINUS,			// 20
			G_KEY_EQUALS,			// 21
			G_KEY_BACKSPACE,		// 22
			G_KEY_TAB,				// 23
			G_KEY_Q,				// 24
			G_KEY_W,				// 25
			G_KEY_E,				// 26
			G_KEY_R,				// 27
			G_KEY_T,				// 28
			G_KEY_Y,				// 29
			G_KEY_U,				// 30
			G_KEY_I,				// 31
			G_KEY_O,				// 32
			G_KEY_P,				// 33
			G_KEY_BRACKET_OPEN,		// 34
			G_KEY_BRACKET_CLOSE,	// 35
			G_KEY_ENTER,			// 36
			G_KEY_LEFTCONTROL,		// 37
			G_KEY_A,				// 38
			G_KEY_S,				// 39
			G_KEY_D,				// 40
			G_KEY_F,				// 41
			G_KEY_G,				// 42
			G_KEY_H,				// 43
			G_KEY_J,				// 44
			G_KEY_K,				// 45
			G_KEY_L,				// 46
			G_KEY_SEMICOLON,		// 47
			G_KEY_QUOTE,			// 48
			G_KEY_TILDE,			// 49
			G_KEY_LEFTSHIFT,		// 50
			G_KEY_BACKSLASH,		// 51
			G_KEY_Z,				// 52
			G_KEY_X,				// 53
			G_KEY_C,				// 54
			G_KEY_V,				// 55
			G_KEY_B,				// 56
			G_KEY_N,				// 57
			G_KEY_M,				// 58
			G_KEY_COMMA,			// 59
			G_KEY_PERIOD,			// 60
			G_KEY_FORWARDSLASH,		// 61
			G_KEY_RIGHTSHIFT,		// 62
			G_KEY_NUMPAD_MULTIPLY,	// 63
			G_KEY_LEFTALT,			// 64
			G_KEY_SPACE,			// 65
			G_KEY_CAPSLOCK,			// 66
			G_KEY_F1,				// 67
			G_KEY_F2,				// 68
			G_KEY_F3,				// 69
			G_KEY_F4,				// 70
			G_KEY_F5,				// 71
			G_KEY_F6,				// 72
			G_KEY_F7,				// 73
			G_KEY_F8,				// 74
			G_KEY_F9,				// 75
			G_KEY_F10,				// 76
			G_KEY_NUMLOCK,			// 77
			G_KEY_SCROLL_LOCK,		// 78
			G_KEY_NUMPAD_7,			// 79
			G_KEY_NUMPAD_8,			// 80
			G_KEY_NUMPAD_9,			// 81
			G_KEY_NUMPAD_SUBTRACT,	// 82
			G_KEY_NUMPAD_4,			// 83
			G_KEY_NUMPAD_5,			// 84
			G_KEY_NUMPAD_6,			// 85
			G_KEY_NUMPAD_ADD,		// 86
			G_KEY_NUMPAD_1,			// 87
			G_KEY_NUMPAD_2,			// 88
			G_KEY_NUMPAD_3,			// 89
			G_KEY_NUMPAD_0,			// 90
			G_KEY_NUMPAD_PERIOD,	// 91
			G_KEY_UNKNOWN,			// 92
			G_KEY_UNKNOWN,			// 93
			G_KEY_UNKNOWN,			// 94
			G_KEY_F11,				// 95
			G_KEY_F12,				// 96
			G_KEY_UNKNOWN,			// 97
			G_KEY_UNKNOWN,			// 98
			G_KEY_UNKNOWN,			// 99
			G_KEY_UNKNOWN,			// 100
			G_KEY_UNKNOWN,			// 101
			G_KEY_UNKNOWN,			// 102
			G_KEY_UNKNOWN,			// 103
			G_KEY_NUMPAD_ENTER,		// 104
			G_KEY_UNKNOWN,			// 105
			G_KEY_NUMPAD_DIVIDE,	// 106
			G_KEY_PRINTSCREEN,		// 107
			G_KEY_RIGHTALT,			// 108
			G_KEY_UNKNOWN,			// 109
			G_KEY_HOME,				// 110
			G_KEY_UP,				// 111
			G_KEY_PAGEUP,			// 112
			G_KEY_LEFT,				// 113
			G_KEY_RIGHT,			// 114
			G_KEY_END,				// 115
			G_KEY_DOWN,				// 116
			G_KEY_PAGEDOWN,			// 117
			G_KEY_INSERT,			// 118
			G_KEY_DELETE,			// 119
			G_KEY_UNKNOWN,			// 120
			G_KEY_UNKNOWN,			// 121
			G_KEY_UNKNOWN,			// 122
			G_KEY_UNKNOWN,			// 123
			G_KEY_UNKNOWN,			// 124
			G_KEY_UNKNOWN,			// 125
			G_KEY_UNKNOWN,			// 126
			G_KEY_PAUSE				// 127
			
		};
#elif defined(__APPLE__)
		constexpr unsigned int Keycodes[128] =
		{
			G_KEY_A,				// 0
			G_KEY_S,				// 1
			G_KEY_D,				// 2
			G_KEY_F,				// 3
			G_KEY_H,				// 4
			G_KEY_G,				// 5
			G_KEY_Z,				// 6
			G_KEY_X,				// 7
			G_KEY_C,				// 8
			G_KEY_V,				// 9
			G_KEY_UNKNOWN,			// 10
			G_KEY_B,				// 11
			G_KEY_Q,				// 12
			G_KEY_W,				// 13
			G_KEY_E,				// 14
			G_KEY_R,				// 15
			G_KEY_Y,				// 16
			G_KEY_T,				// 17
			G_KEY_1,				// 18
			G_KEY_2,				// 19
			G_KEY_3,				// 20
			G_KEY_4,				// 21
			G_KEY_6,				// 22
			G_KEY_5,				// 23
			G_KEY_EQUALS,			// 24
			G_KEY_9,				// 25
			G_KEY_7,				// 26
			G_KEY_MINUS,			// 27
			G_KEY_8,				// 28
			G_KEY_0,				// 29
			G_KEY_BRACKET_CLOSE,	// 30
			G_KEY_O,				// 31
			G_KEY_U,				// 32
			G_KEY_BRACKET_OPEN,		// 33
			G_KEY_I,				// 34
			G_KEY_P,				// 35
			G_KEY_ENTER,			// 36
			G_KEY_L,				// 37
			G_KEY_J,				// 38
			G_KEY_QUOTE,			// 39
			G_KEY_K,				// 40
			G_KEY_SEMICOLON,		// 41
			G_KEY_BACKSLASH,		// 42
			G_KEY_COMMA,			// 43
			G_KEY_FORWARDSLASH,		// 44
			G_KEY_N,				// 45
			G_KEY_M,				// 46
			G_KEY_PERIOD,			// 47
			G_KEY_TAB,				// 48
			G_KEY_SPACE,			// 49
			G_KEY_TILDE,			// 50
			G_KEY_DELETE,			// 51
			G_KEY_UNKNOWN,			// 52
			G_KEY_ESCAPE,			// 53
			G_KEY_UNKNOWN,			// 54
			G_KEY_COMMAND,		    // 55
			G_KEY_LEFTSHIFT,		// 56
			G_KEY_CAPSLOCK,			// 57
			G_KEY_LEFTALT,			// 58
			G_KEY_LEFTCONTROL,		// 59
			G_KEY_RIGHTSHIFT,		// 60
			G_KEY_RIGHTALT,			// 61
			G_KEY_RIGHTCONTROL,		// 62
			G_KEY_UNKNOWN,			// 63
			G_KEY_UNKNOWN,			// 64
			G_KEY_NUMPAD_PERIOD,	// 65
			G_KEY_UNKNOWN,			// 66
			G_KEY_NUMPAD_MULTIPLY,	// 67
			G_KEY_UNKNOWN,			// 68
			G_KEY_NUMPAD_ADD,		// 69
			G_KEY_UNKNOWN,			// 70
			G_KEY_NUMLOCK,			// 71
			G_KEY_UNKNOWN,			// 72
			G_KEY_UNKNOWN,			// 73
			G_KEY_UNKNOWN,			// 74
			G_KEY_NUMPAD_DIVIDE,	// 75
			G_KEY_NUMPAD_ENTER,		// 76
			G_KEY_UNKNOWN,			// 77
			G_KEY_NUMPAD_SUBTRACT,	// 78
			G_KEY_UNKNOWN,			// 79
			G_KEY_UNKNOWN,			// 80
			G_KEY_EQUALS,			// 81
			G_KEY_NUMPAD_0,			// 82
			G_KEY_NUMPAD_1,			// 83
			G_KEY_NUMPAD_2,			// 84
			G_KEY_NUMPAD_3,			// 85
			G_KEY_NUMPAD_4,			// 86
			G_KEY_NUMPAD_5,			// 87
			G_KEY_NUMPAD_6,			// 88
			G_KEY_NUMPAD_7,			// 89
			G_KEY_UNKNOWN,			// 90
			G_KEY_NUMPAD_8,			// 91
			G_KEY_NUMPAD_9,			// 92
			G_KEY_UNKNOWN,			// 93
			G_KEY_UNKNOWN,			// 94
			G_KEY_UNKNOWN,			// 95
			G_KEY_F5,				// 96
			G_KEY_F6,				// 97
			G_KEY_F7,				// 98
			G_KEY_F3,				// 99
			G_KEY_F8,				// 100
			G_KEY_F9,				// 101
			G_KEY_UNKNOWN,			// 102
			G_KEY_F11,				// 103
			G_KEY_UNKNOWN,			// 104
			G_KEY_UNKNOWN,			// 105
			G_KEY_UNKNOWN,			// 106
			G_KEY_UNKNOWN,			// 107
			G_KEY_UNKNOWN,			// 108
			G_KEY_F10,				// 109
			G_KEY_UNKNOWN,			// 110
			G_KEY_F12,				// 111
			G_KEY_UNKNOWN,			// 112
			G_KEY_UNKNOWN,			// 113
			G_KEY_INSERT,			// 114
			G_KEY_HOME,				// 115
			G_KEY_PAGEUP,			// 116
			G_KEY_DELETE,			// 117
			G_KEY_F4,				// 118
			G_KEY_END,				// 119
			G_KEY_F2,				// 120
			G_KEY_PAGEDOWN,			// 121
			G_KEY_F1,				// 122
			G_KEY_LEFT,				// 123
			G_KEY_RIGHT,			// 124
			G_KEY_DOWN,				// 125
			G_KEY_UP,				// 126
            G_KEY_UNKNOWN           // 127
		};
#endif
	}
}
#endif

 // every implementation besides dummy uses this.
#if !defined(GATEWARE_ENABLE_INPUT) || defined(GATEWARE_DISABLE_GINPUT) || \
    (defined(GATEWARE_ENABLE_INPUT) && !defined(GATEWARE_DISABLE_GINPUT) && !defined(__APPLE__) && !defined(__linux__) && !defined(_WIN32))
	// Even if a platform does not support a library a dummy implementation must be present!
	// dummy implementation of GInput

namespace GW
{
	namespace I
	{
		class GInputImplementation : public virtual GInputInterface
		{
		public:
			GReturn GetState(int _keyCode, float& _outState) override
			{
				return GReturn::FAILURE;
			}
			GReturn GetMouseDelta(float& _x, float& _y) override
			{
				return GReturn::FAILURE;
			}
			GReturn GetMousePosition(float& _x, float& _y) const override
			{
				return GReturn::FAILURE;
			}
			GReturn GetKeyMask(unsigned int& _outKeyMask) const override
			{
				return GReturn::FAILURE;
			}
			GReturn Create(GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE _dummyHandle)
			{
				return GReturn::INTERFACE_UNSUPPORTED;
			}
			GReturn Create(const GW::SYSTEM::GWindow _dummyWindow)
			{
				return GReturn::INTERFACE_UNSUPPORTED;
			}
		};
	}
}


#elif defined(__APPLE__)
	#ifdef __OBJC__
@import Foundation;
@import Cocoa;
#endif

#define CHECK_BIT(var,pos) ((var) & (1<<(pos)))
#define TURNON_BIT(var,pos) ((var) |=  (1<<(pos)))
#define TURNOFF_BIT(var,pos) ((var) &= ~(1<<(pos)))
#define TOGGLE_BIT(var, pos) (CHECK_BIT(var, pos) ? (TURNOFF_BIT(var,pos)) : (TURNON_BIT(var,pos)))

#include <chrono>



namespace internal_gw
{
    struct GINPUT_GLOBAL
    {
        GW::SYSTEM::GDaemon myDaemon;
        int mousePositionX;
        int mousePositionY;
        int mouseDeltaX;
        int mouseDeltaY;
        int upPings;
        int downPings;
        unsigned int keyMask;
        unsigned int mouseReadCount;
        unsigned int mouseWriteCount;

        unsigned int n_Keys[256];
    };

    static GINPUT_GLOBAL& GInputGlobal()
    {
        static GINPUT_GLOBAL keyData;
        return keyData;
    }
    // GIResponder Interface
    // The GIResponder is our interpretation of the NSReponder to recieve events.

    // Data members of GResponder
    G_OBJC_DATA_MEMBERS_STRUCT(GIResponder)
    {
        NSWindow* targetWindow; // so we can get the height of the client area
    };
    G_OBJC_HEADER_DATA_MEMBERS_PROPERTY_METHOD(GIResponder);
    // Forward declarations of GResponder methods
    // Overide NSResponder functions
    G_OBJC_HEADER_INSTANCE_METHOD(GIResponder, bool, acceptFirstResponder);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, bool, acceptsFirstMouse, NSEvent* event);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, flagsChanged, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, keyDown, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, keyUp, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, mouseDown, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, mouseUp, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, scrollWheel, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, rightMouseDown, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, rightMouseUp, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, otherMouseDown, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, otherMouseUp, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, mouseMoved, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, mouseDragged, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, rightMouseDragged, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, otherMouseDragged, NSEvent* theEvent);
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, GetKeyMask, NSEvent* theEvent);

    // Creates the GIResponder class at runtime when G_OBJC_GET_CLASS(GIResponder) is called
    G_OBJC_CLASS_BEGIN(GIResponder, NSResponder)
    {
        G_OBJC_CLASS_DATA_MEMBERS_PROPERTY(GIResponder);
        G_OBJC_CLASS_METHOD(GIResponder, acceptFirstResponder, "B@:");
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, acceptsFirstMouse, "B@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, flagsChanged, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, keyDown, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, keyUp, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, mouseDown, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, mouseUp, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, scrollWheel, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, rightMouseDown, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, rightMouseUp, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, otherMouseDown, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, otherMouseUp, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, mouseMoved, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, mouseDragged, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, rightMouseDragged, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, otherMouseDragged, "v@:@", :);
        G_OBJC_CLASS_METHOD_WITH_ARGUMENTS(GIResponder, GetKeyMask, "v@:@", :);
    }
    G_OBJC_CLASS_END(GIResponder)
    
    // GIResponder Interface End
}

namespace GW
{
    namespace I
    {
        class GInputImplementation : public virtual GInputInterface,
            private GThreadSharedImplementation
        {

        private:
            NSWindow* currentResponder;
            id responder;

            static void RUN_ON_UI_THREAD(dispatch_block_t block)
            {
                if ([NSThread isMainThread])
                    block();
                else
                    dispatch_sync(dispatch_get_main_queue(), block);
            }

        public:

            ~GInputImplementation()
            {
                [currentResponder setNextResponder : nil] ;
                [responder release] ;
            }

            GReturn Create(GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE _windowHandle)
            {
                responder = [internal_gw::G_OBJC_GET_CLASS(GIResponder) alloc];

                if (_windowHandle.window == nullptr)
                    return GReturn::INVALID_ARGUMENT;

                //Need to convert data back into an NSWindow*.
                //NSWindow * currentResponder = ((__bridge NSWindow*)_data);
                currentResponder = ((__bridge NSWindow*)_windowHandle.window);
                // provide handle to current window
                internal_gw::G_OBJC_DATA_MEMBERS_TYPE(GIResponder)& responderDataMembers = internal_gw::G_OBJC_GET_DATA_MEMBERS(GIResponder, responder);
                responderDataMembers.targetWindow = currentResponder;

                //We only want to process the message and pass it on. So if there is already
                //a responder we set our responders next responder to be the current next responder.
                [responder setNextResponder : currentResponder.nextResponder];

                //We then set out responder to the next responder of the window.
                [currentResponder setNextResponder : responder] ;

                //We also need to make our responder the first responder of the window.
                [currentResponder makeFirstResponder : responder] ;

                RUN_ON_UI_THREAD(^ {
                    //In order to get mouse button presses we need to set our responder to be
                    //the next responder in the contentView as well.
                    [currentResponder.contentView setNextResponder : responder] ;
                    });
                //Enable responder to accept mouse move events. By default it doesn't.
                [currentResponder setAcceptsMouseMovedEvents:YES];

                return GReturn::SUCCESS;
            }

            GReturn Create(GW::SYSTEM::GWindow _gWindow)
            {
                GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE uwHndl;

                if (-_gWindow.GetWindowHandle(uwHndl))
                    return GW::GReturn::FAILURE;

                return Create(uwHndl);
            }

            GReturn GetState(int _keyCode, float& _outState) override
            {
                _outState = static_cast<float>(internal_gw::GInputGlobal().n_Keys[_keyCode]);
                return GW::GReturn::SUCCESS;
            }

            GReturn GetMouseDelta(float& _x, float& _y) override
            {
                _x = static_cast<float>(internal_gw::GInputGlobal().mouseDeltaX);
                _y = static_cast<float>(internal_gw::GInputGlobal().mouseDeltaY);
                if (internal_gw::GInputGlobal().mouseReadCount != internal_gw::GInputGlobal().mouseWriteCount)
                {
                    internal_gw::GInputGlobal().mouseReadCount = internal_gw::GInputGlobal().mouseWriteCount;
                    return GW::GReturn::SUCCESS;
                }
                return GW::GReturn::REDUNDANT;
            }

            GReturn GetMousePosition(float& _x, float& _y) const override
            {
                _x = static_cast<float>(internal_gw::GInputGlobal().mousePositionX);
                _y = static_cast<float>(internal_gw::GInputGlobal().mousePositionY);

                return GW::GReturn::SUCCESS;
            }

            GReturn GetKeyMask(unsigned int& _outKeyMask) const override
            {
                _outKeyMask = internal_gw::GInputGlobal().keyMask;
                return GW::GReturn::SUCCESS;
            }
        };

    }
}

namespace internal_gw
{
    // GIResponder Implementation
    G_OBJC_IMPLEMENTATION_DATA_MEMBERS_PROPERTY_METHOD(GIResponder);

    G_OBJC_HEADER_INSTANCE_METHOD(GIResponder, bool, acceptFirstResponder)
    {
        return YES;
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, bool, acceptsFirstMouse, NSEvent* event)
    {
        return YES;
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, flagsChanged, NSEvent* theEvent)
    {
        // these keys are treated a bit differently and need a custom handler
        NSUInteger code = [theEvent keyCode];
        NSUInteger gwcode = GW::I::Keycodes[code];
        NSUInteger xflags = [theEvent modifierFlags];
       
        if (gwcode == G_KEY_LEFTSHIFT || gwcode == G_KEY_RIGHTSHIFT)
            GInputGlobal().n_Keys[gwcode] =
                (xflags & NSEventModifierFlagShift) ? 1 : 0;
        if (gwcode == G_KEY_LEFTALT || gwcode == G_KEY_RIGHTALT)
            GInputGlobal().n_Keys[gwcode] =
                (xflags & NSEventModifierFlagOption) ? 1 : 0;
        if (gwcode == G_KEY_LEFTCONTROL || gwcode == G_KEY_RIGHTCONTROL)
            GInputGlobal().n_Keys[gwcode] =
                (xflags & NSEventModifierFlagControl) ? 1 : 0;
        if (gwcode == G_KEY_NUMLOCK)
            GInputGlobal().n_Keys[gwcode] =
                (xflags & NSEventModifierFlagNumericPad) ? 1 : 0;
        if (gwcode == G_KEY_COMMAND)
            GInputGlobal().n_Keys[gwcode] =
                (xflags & NSEventModifierFlagCommand) ? 1 : 0;
        if (gwcode == G_KEY_FUNCTION)
            GInputGlobal().n_Keys[gwcode] =
                (xflags & NSEventModifierFlagFunction) ? 1 : 0;
        if (gwcode == G_KEY_CAPSLOCK) // will continue to trigger until pressed again
            GInputGlobal().n_Keys[gwcode] =
                (xflags & NSEventModifierFlagCapsLock) ? 1 : 0;
        
        //Get the keymask.
        // NOTE: if above method becomes problematic, this could also be done
        // using a GDaemon that tracks change in the NSModifierFlag
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GIResponder, self, GetKeyMask, theEvent);

        if ([self nextResponder] != nil)
            [[self nextResponder]keyDown:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, keyDown, NSEvent* theEvent)
    {
        //Set the key to pressed after getting it from the static table of keys.
        NSUInteger code = [theEvent keyCode];
        GInputGlobal().n_Keys[GW::I::Keycodes [code] ] = 1;
        //Get the keymask.
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GIResponder, self, GetKeyMask, theEvent);

        if ([self nextResponder] != nil)
            [[self nextResponder]keyDown:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, keyUp, NSEvent* theEvent)
    {
        GInputGlobal().n_Keys[GW::I::Keycodes [[theEvent keyCode]] ] = 0;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GIResponder, self, GetKeyMask, theEvent);

        if ([self nextResponder] != nil)
            [[self nextResponder]keyUp:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, mouseDown, NSEvent* theEvent)
    {
        GInputGlobal().n_Keys[G_BUTTON_LEFT] = 1;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GIResponder, self, GetKeyMask, theEvent);
        if ([self nextResponder] != nil)
            [[self nextResponder]mouseDown:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, mouseUp, NSEvent* theEvent)
    {
        GInputGlobal().n_Keys[G_BUTTON_LEFT] = 0;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GIResponder, self, GetKeyMask, theEvent);
        if ([self nextResponder] != nil)
            [[self nextResponder]mouseUp:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, scrollWheel, NSEvent* theEvent)
    {
        ////Scrolling Up
        if (theEvent.deltaY > 0)
        {
            GInputGlobal().n_Keys[G_MOUSE_SCROLL_UP] = 1;
            GInputGlobal().n_Keys[G_MOUSE_SCROLL_DOWN] = 0;
        }
        ////Scrolling down
        if (theEvent.deltaY < 0)
        {
            GInputGlobal().n_Keys[G_MOUSE_SCROLL_UP] = 0;
            GInputGlobal().n_Keys[G_MOUSE_SCROLL_DOWN] = 1;
        }

        std::chrono::time_point<std::chrono::steady_clock> start = std::chrono::steady_clock::now();

        if (GInputGlobal().myDaemon == nullptr)
        {
            GInputGlobal().myDaemon.Create(6, [&]()
            {
                auto end = std::chrono::steady_clock::now();

                if (std::chrono::duration_cast<std::chrono::microseconds>(end - start).count() >= 50000)
                {
                    GInputGlobal().n_Keys[G_MOUSE_SCROLL_UP] = 0;
                    GInputGlobal().n_Keys[G_MOUSE_SCROLL_DOWN] = 0;
                    return;
                }
            });
        }

        if ([self nextResponder] != nil)
            [[self nextResponder]scrollWheel:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, rightMouseDown, NSEvent* theEvent)
    {
        GInputGlobal().n_Keys[G_BUTTON_RIGHT] = 1;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GIResponder, self, GetKeyMask, theEvent);
        if ([self nextResponder] != nil)
            [[self nextResponder]rightMouseDown:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, rightMouseUp, NSEvent* theEvent)
    {
        GInputGlobal().n_Keys[G_BUTTON_RIGHT] = 0;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GIResponder, self, GetKeyMask, theEvent);
        if ([self nextResponder] != nil)
            [[self nextResponder]rightMouseUp:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, otherMouseDown, NSEvent* theEvent)
    {
        GInputGlobal().n_Keys[G_BUTTON_MIDDLE] = 1;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GIResponder, self, GetKeyMask, theEvent);
        if ([self nextResponder] != nil)
            [[self nextResponder]otherMouseDown:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, otherMouseUp, NSEvent* theEvent)
    {
        GInputGlobal().n_Keys[G_BUTTON_MIDDLE] = 0;
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GIResponder, self, GetKeyMask, theEvent);
        if ([self nextResponder] != nil)
            [[self nextResponder]otherMouseUp:theEvent];
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, mouseMoved, NSEvent* theEvent)
    {
        G_OBJC_DATA_MEMBERS_TYPE(GIResponder)& selfDataMembers = G_OBJC_GET_DATA_MEMBERS(GIResponder, self);
        NSRect rect = selfDataMembers.targetWindow.frame;
        NSRect contentRect = [selfDataMembers.targetWindow contentRectForFrameRect : rect];
        NSPoint mousePosition = [theEvent locationInWindow];
        mousePosition.y = contentRect.size.height - mousePosition.y;
        
        ++GInputGlobal().mouseWriteCount;
        GInputGlobal().mouseDeltaX = mousePosition.x - GInputGlobal().mousePositionX;
        GInputGlobal().mouseDeltaY = mousePosition.y - GInputGlobal().mousePositionY;
        GInputGlobal().mousePositionX = mousePosition.x;
        GInputGlobal().mousePositionY = mousePosition.y;
    
        if ([self nextResponder] != nil)
            [[self nextResponder]mouseMoved:theEvent];
    }
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, mouseDragged, NSEvent* theEvent)
    {
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GIResponder, self, mouseMoved, theEvent);
    }
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, rightMouseDragged, NSEvent* theEvent)
    {
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GIResponder, self, mouseMoved, theEvent);
    }
    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, otherMouseDragged, NSEvent* theEvent)
    {
        G_OBJC_CALL_METHOD_WITH_ARGUMENTS(GIResponder, self, mouseMoved, theEvent);
    }

    G_OBJC_HEADER_INSTANCE_METHOD_WITH_ARGUMENTS(GIResponder, void, GetKeyMask, NSEvent* theEvent)
    {
        GInputGlobal().keyMask = 0;
        //Get the unsigned int of all the modifier flags.
        NSUInteger xflags = [theEvent modifierFlags];
        //Check individual modifier flags and turn them on respectivly to our keymask(unsigned int).
        if (xflags & NSEventModifierFlagShift)
        {
            TURNON_BIT(GInputGlobal().keyMask, G_MASK_SHIFT);
        }
        if (xflags & NSEventModifierFlagOption)
        {
            TURNON_BIT(GInputGlobal().keyMask, G_MASK_ALT);
        }
        if (xflags & NSEventModifierFlagCommand)
        {
            TURNON_BIT(GInputGlobal().keyMask, G_MASK_COMMAND);
        }
        if (xflags & NSEventModifierFlagControl)
        {
            TURNON_BIT(GInputGlobal().keyMask, G_MASK_CONTROL);
        }
        if (xflags & NSEventModifierFlagCapsLock)
        {
            TURNON_BIT(GInputGlobal().keyMask, G_MASK_CAPS_LOCK);
        }
        if (xflags & NSEventModifierFlagFunction)
        {
            TURNON_BIT(GInputGlobal().keyMask, G_MASK_FUNCTION);
        }
        if (xflags & NSEventModifierFlagNumericPad)
        {
            TURNON_BIT(GInputGlobal().keyMask, G_MASK_NUM_LOCK);
        }
    }

    // GIResponder Implementation End
}

#undef CHECK_BIT
#undef TURNON_BIT
#undef TURNOFF_BIT
#undef TOGGLE_BIT


#elif defined(__linux__)
	#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xresource.h>
#include <X11/keysym.h>



namespace GW
{
	namespace I
	{
		class GInputImplementation : public virtual GInputInterface,
			protected GInterfaceImplementation
		{
		private:
			int _mousePrevX = 0;
			int _mousePrevY = 0;
			int _mousePositionX = 0;
			int _mousePositionY = 0;
			int _mouseDeltaX = 0;
			int _mouseDeltaY = 0;
			unsigned int keyMask = 0;
			unsigned int mouseReadCount = 0;
			unsigned int mouseWriteCount = 0;

			// Daemon data
			int _code = -1;
			Window root, child;
            int _mouseScreenPositionX = 0, _mouseScreenPositionY = 0;
			char keys_return[32];

			// Window data
			Display* _display = nullptr;
			Window _window;
            
			unsigned int keyStates[256] = { 0 };
            GW::SYSTEM::GDaemon inputDaemon;
			GW::CORE::GEventReceiver watcher;		
		public:
			GReturn Create(GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE _windowHandle)
			{
				if (_windowHandle.window == nullptr || _windowHandle.display == nullptr)
					return GReturn::INVALID_ARGUMENT;

				//Copy data from UNIVERSAL_WINDOW_HANDLE(void * display, void * window) structure.
				_window = *((Window*)(_windowHandle.window));
				_display = ((Display*)(_windowHandle.display));

				//Select the type of Input events we wish to recieve.
				///XSelectInput(_display, _window, ExposureMask | ButtonPressMask | ButtonReleaseMask | KeyReleaseMask | KeyPressMask | LockMask | ControlMask | ShiftMask);
				
				XInitThreads();// daemon run on another thread
                // Creates a daemon that parses all the input on the other thread
                inputDaemon.Create(G_INPUT_OPERATION_INTERVAL, [&]()
                {
					XQueryKeymap(_display, keys_return);
					
					static int stateOfKeyOld = 0;
					
					for (unsigned int i = 0; i < 128; ++i)
					{
						_code = Keycodes[i];
						
						int index = i >> 3;
						int bitshift = 1 << (i & 7);
						
						// to debug, add a conditional break point where b != 0, then press any key
						// whatever I is equal to, is the bit offset of the key you pressed.
						// ex: num pad 0 is at i = 90
						auto b = keys_return[index] & (bitshift) ? 1 : 0;
						
						//Set keyboard input
						keyStates[_code] = b;
					}
					
					// not currently supported. would be returned by XQueryKeymap if it was.
					// auto keycode = XKeysymToKeycode( _display, XK_Control_R );
					// keyStates[G_KEY_RIGHTCONTROL] = keys_return[keycode >> 3] & (1 << (keycode & 7)) ? 1 : 0;
					
					
					XQueryPointer(_display, _window, &root, &child, &_mouseScreenPositionX, &_mouseScreenPositionY, &_mousePositionX, &_mousePositionY, &keyMask);

					//Set the mouse input
					keyStates[G_BUTTON_LEFT] = (keyMask & Button1Mask) ? 1 : 0;
					keyStates[G_BUTTON_RIGHT] = (keyMask & Button3Mask) ? 1 : 0;
					keyStates[G_BUTTON_MIDDLE] = (keyMask & Button2Mask) ? 1 : 0;

					//Set the change in mouse position.
					_mouseDeltaX = _mousePositionX - _mousePrevX;
					_mouseDeltaY = _mousePositionY - _mousePrevY;

					//Set the previous mouse position as the current.
					_mousePrevX = _mousePositionX;
					_mousePrevY = _mousePositionY;
					
					//Insure updates are tracked correctly
					if (_mouseDeltaX || _mouseDeltaY)
						++mouseWriteCount;
                });

				return GReturn::SUCCESS;
			}

			GReturn Create(const GW::SYSTEM::GWindow _gWindow)
			{
				GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE uwHndl;

				if (-_gWindow.GetWindowHandle(uwHndl))
					return GW::GReturn::FAILURE;
				
				// stop if window is killed
				watcher.Create(_gWindow, [&](){
					if (+watcher.Find(GW::SYSTEM::GWindow::Events::DESTROY, true))
						inputDaemon = nullptr;
				});
				
				return Create(uwHndl);
			}

			GReturn GetState(int _keyCode, float& _outState) override
			{
				if (_keyCode == G_MOUSE_SCROLL_DOWN || _keyCode == G_MOUSE_SCROLL_UP)
					return GW::GReturn::FEATURE_UNSUPPORTED;
				_outState = (float)keyStates[_keyCode];
				return GW::GReturn::SUCCESS;
			}

			GReturn GetMouseDelta(float& _x, float& _y) override
			{
				_x = static_cast<float>(_mouseDeltaX);
				_y = static_cast<float>(_mouseDeltaY);
				if (mouseReadCount != mouseWriteCount)
				{
					mouseReadCount = mouseWriteCount;
					return GW::GReturn::SUCCESS;
				}
				return GW::GReturn::REDUNDANT;
			}

			GReturn GetMousePosition(float& _x, float& _y) const override
			{
				_x = static_cast<float>(_mousePositionX);
				_y = static_cast<float>(_mousePositionY);

				return GW::GReturn::SUCCESS;
			}

			GReturn GetKeyMask(unsigned int& _outKeyMask) const override
			{
				_outKeyMask = keyMask;
				return GW::GReturn::SUCCESS;
			}
		};
	}
}

#elif defined(_WIN32)
	#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <vector>

namespace internal_gw {
	struct GINPUT_GLOBAL {
		int mousePrevX;
		int mousePrevY;
		int mousePositionX;
		int mousePositionY;
		int mouseDeltaX;
		int mouseDeltaY;
		unsigned int keyMask;

		unsigned int mouseReadCount;
		unsigned int mouseWriteCount;
		unsigned int scrollUpWriteCount;
		unsigned int scrollUpReadCount;
		unsigned int scrollDownWriteCount;
		unsigned int scrollDownReadCount;
		LONG_PTR _userWinProc;

		unsigned int n_Keys[256];
	};
	static GINPUT_GLOBAL& GInputGlobal() {
		static GINPUT_GLOBAL keyData;
		return keyData;
	}
}

namespace GW {
	namespace I {
		class GInputImplementation : public virtual GInputInterface,
			private GInterfaceImplementation {
		private:
			HWND hWnd = nullptr;

			static bool SetGKeyIfSpecialCase(unsigned int& gKey, const USHORT& makeCode, const USHORT& flags, const LPARAM& lp) {
				if (flags & 2) {
					switch (makeCode) {
						default:
							return false;
						case 29:
							gKey = G_KEY_RIGHTCONTROL;
							return true;
						case 56:
							gKey = G_KEY_RIGHTALT;
							return true;
						case 28:
							gKey = G_KEY_NUMPAD_ENTER;
							return true;
						case 53:
							gKey = G_KEY_NUMPAD_DIVIDE;
							return true;
						case 82:
							gKey = G_KEY_INSERT;
							return true;
						case 83:
							gKey = G_KEY_DELETE;
							return true;
						case 71:
							gKey = G_KEY_HOME;
							return true;
						case 79:
							gKey = G_KEY_END;
							return true;
						case 73:
							gKey = G_KEY_PAGEUP;
							return true;
						case 81:
							gKey = G_KEY_PAGEDOWN;
							return true;
						case 75:
							gKey = G_KEY_LEFT;
							return true;
						case 77:
							gKey = G_KEY_RIGHT;
							return true;
						case 72:
							gKey = G_KEY_UP;
							return true;
						case 80:
							gKey = G_KEY_DOWN;
							return true;
						case 42:
							gKey = G_KEY_PRINTSCREEN;
							return true;
					}
				}
				return false;
			}

			// This functions checks to see if the key was "pressed" by windows and not the user
			// as is the case when num lock is off and the user presses any of the keys in the area 
			// to the left of the num pad, for example.
			static bool ShouldSkipBecauseBogusKeyPress(const USHORT& makeCode, const USHORT& flags) {
				// makecode must be shift, numlock must be off, and the E0 bit must be set
				bool bogusShift = makeCode == 42 && !G_CHECK_BIT(internal_gw::GInputGlobal().keyMask, G_MASK_NUM_LOCK) && (flags & 2);

				// makecode must be numpad multiply, and the E0 bit must be set
				bool bogusMultiply = makeCode == 55 && (flags & 2);

				// makecode must be control, and E1 bit must be set
				bool bogusControl = makeCode == 29 && (flags & 4);


				if (bogusShift || bogusMultiply || bogusControl) {
					return true;
				}
				return false;
			}
			
			static LRESULT CALLBACK GWinProc(HWND window, unsigned int msg, WPARAM wp, LPARAM lp) {
				switch (msg) {
					case WM_INPUT:
					{
						UINT dwSize = 0;

						//Get the size of RawInput
						GetRawInputData((HRAWINPUT)lp, RID_INPUT, NULL, &dwSize, sizeof(RAWINPUTHEADER));

						LPBYTE lpb = new BYTE[dwSize];

						if (GetRawInputData((HRAWINPUT)lp, RID_INPUT, lpb, &dwSize, sizeof(RAWINPUTHEADER)) != dwSize) {
							delete[] lpb;
							return LRESULT(false);
						}

						RAWINPUT* raw = (RAWINPUT*)lpb;

						unsigned int gKey = 0;

						if (raw->header.dwType == RIM_TYPEKEYBOARD) {
							auto& makeCode = raw->data.keyboard.MakeCode;
							gKey = Keycodes[makeCode];
							auto& message = raw->data.keyboard.Message;
							auto flags = raw->data.keyboard.Flags;
							

							//Set state released or pressed. SYSKEY is for keys like alt
							if (message == WM_KEYDOWN || message == WM_SYSKEYDOWN) {
								SetGKeyIfSpecialCase(gKey, makeCode, flags, lp);

								if (!(ShouldSkipBecauseBogusKeyPress(makeCode, flags))) {
									internal_gw::GInputGlobal().n_Keys[gKey] = 1;
								}

								switch (gKey) {
									case G_KEY_RIGHTSHIFT:
									case G_KEY_LEFTSHIFT:
										G_TURNON_BIT(internal_gw::GInputGlobal().keyMask, G_MASK_SHIFT);
										break;
									case G_KEY_RIGHTCONTROL:
									case G_KEY_LEFTCONTROL:
										G_TURNON_BIT(internal_gw::GInputGlobal().keyMask, G_MASK_CONTROL);
										break;
									case G_KEY_CAPSLOCK:
										G_TOGGLE_BIT(internal_gw::GInputGlobal().keyMask, G_MASK_CAPS_LOCK);
										break;
									case G_KEY_NUMLOCK:
										G_TOGGLE_BIT(internal_gw::GInputGlobal().keyMask, G_MASK_NUM_LOCK);
										break;
									case G_KEY_SCROLL_LOCK:
										G_TOGGLE_BIT(internal_gw::GInputGlobal().keyMask, G_MASK_SCROLL_LOCK);
										break;
								}
							}
							else if (message == WM_KEYUP || message == WM_SYSKEYUP) {
								SetGKeyIfSpecialCase(gKey, makeCode, flags, lp);
								internal_gw::GInputGlobal().n_Keys[gKey] = 0;
								
								switch (gKey) {
									case G_KEY_RIGHTSHIFT:
									case G_KEY_LEFTSHIFT:
										G_TURNOFF_BIT(internal_gw::GInputGlobal().keyMask, G_MASK_SHIFT);
										break;
									case G_KEY_RIGHTCONTROL:
									case G_KEY_LEFTCONTROL:
										G_TURNOFF_BIT(internal_gw::GInputGlobal().keyMask, G_MASK_CONTROL);
										break;
								}
							}
							//printf("scanCode: %d\t flags: %d\t keymask: %d\n", makeCode, flags, internal_gw::GInputGlobal().keyMask);
						}
						else if (raw->header.dwType == RIM_TYPEMOUSE) {
							++internal_gw::GInputGlobal().mouseWriteCount;

							switch (raw->data.mouse.ulButtons) {
								case 1:
								case 2:
									gKey = G_BUTTON_LEFT;
									break;
								case 4:
								case 8:
									gKey = G_BUTTON_RIGHT;
									break;
								case 16:
								case 32:
									gKey = G_BUTTON_MIDDLE;
									break;
							}

							switch (raw->data.mouse.usButtonData) {
								case 120:
								{
									gKey = G_MOUSE_SCROLL_UP;
									++internal_gw::GInputGlobal().scrollUpWriteCount;
									break;
								}
								case 65416:
								{
									gKey = G_MOUSE_SCROLL_DOWN;
									++internal_gw::GInputGlobal().scrollDownWriteCount;
									break;
								}
							}

							switch (raw->data.mouse.usButtonFlags) {
								//pressed
								case 1:
								case 4:
								case 16:
									internal_gw::GInputGlobal().n_Keys[gKey] = 1;
									break;
									//Released
								case 2:
								case 8:
								case 32:
									internal_gw::GInputGlobal().n_Keys[gKey] = 0;
									break;
								case 1024:
									internal_gw::GInputGlobal().n_Keys[gKey] = 1;
									break;
							}

							//update delta mouse position
							if ((internal_gw::GInputGlobal().mouseWriteCount - internal_gw::GInputGlobal().mouseReadCount) <= 1) {
								internal_gw::GInputGlobal().mouseDeltaX = raw->data.mouse.lLastX;
								internal_gw::GInputGlobal().mouseDeltaY = raw->data.mouse.lLastY;
							}
							else {
								internal_gw::GInputGlobal().mouseDeltaX += raw->data.mouse.lLastX;
								internal_gw::GInputGlobal().mouseDeltaY += raw->data.mouse.lLastY;
							}

						}

						if (gKey != G_MOUSE_SCROLL_UP) {
							internal_gw::GInputGlobal().n_Keys[G_MOUSE_SCROLL_UP] = 0;
							internal_gw::GInputGlobal().scrollUpReadCount = internal_gw::GInputGlobal().scrollUpWriteCount;
						}
						if (gKey != G_MOUSE_SCROLL_DOWN) {
							internal_gw::GInputGlobal().n_Keys[G_MOUSE_SCROLL_DOWN] = 0;
							internal_gw::GInputGlobal().scrollDownReadCount = internal_gw::GInputGlobal().scrollDownWriteCount;
						}

						POINT p;
						if (GetCursorPos(&p) && ScreenToClient(window, &p)) {
							internal_gw::GInputGlobal().mousePositionX = static_cast<int>(p.x);
							internal_gw::GInputGlobal().mousePositionY = static_cast<int>(p.y);

							internal_gw::GInputGlobal().mousePrevX = internal_gw::GInputGlobal().mousePositionX;
							internal_gw::GInputGlobal().mousePrevY = internal_gw::GInputGlobal().mousePositionY;
						}

						delete[] lpb;
						break;
					}
					default:
						break;
				}
				return CallWindowProcW((WNDPROC)internal_gw::GInputGlobal()._userWinProc, window, msg, wp, lp);
			}

		public:
			~GInputImplementation() {
				if (hWnd)
					//Sets the WinProc back. (Fixes the StackOverFlow bug)
					SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)internal_gw::GInputGlobal()._userWinProc);
			}

			// GWindow - one version
			// UNIVERSAL_WINDOW_HANDLE by value - another version
			GReturn Create(GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE _windowHandle) {
				if (_windowHandle.window == nullptr)
					return GW::GReturn::INVALID_ARGUMENT;

				hWnd = static_cast<HWND>(_windowHandle.window);
				internal_gw::GInputGlobal()._userWinProc = SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)GWinProc);

				if (internal_gw::GInputGlobal()._userWinProc == NULL)
					return GW::GReturn::FAILURE;

				//Getting Raw Input Devices.
				UINT numDevices = 0;
				std::vector<RAWINPUTDEVICELIST> rawInputDeviceList;

				//Get Number of Devices.
				if (GetRawInputDeviceList(NULL, &numDevices, sizeof(RAWINPUTDEVICELIST)) != 0)
					return GW::GReturn::FAILURE;

				//Allocate the list of devices.
				rawInputDeviceList.resize(sizeof(RAWINPUTDEVICELIST) * numDevices);
				if (rawInputDeviceList.size() < 1)
					return GW::GReturn::FAILURE;

				int nNoOfDevices = 0;
				//Using the new List and number of devices.
				//Populate the raw input device list.
				if ((nNoOfDevices = GetRawInputDeviceList(rawInputDeviceList.data(), &numDevices, sizeof(RAWINPUTDEVICELIST))) == ((UINT)-1))
					return GW::GReturn::FAILURE;

				RID_DEVICE_INFO rdi;
				rdi.cbSize = sizeof(RID_DEVICE_INFO);

				//For all of the devices, display their correspondent information.
				for (int i = 0; i < nNoOfDevices; i++) {
					UINT size = 256;
					TCHAR tBuffer[256] = { 0 };
					tBuffer[0] = '\0';

					//Find the device name.
					if (!rawInputDeviceList.empty()) {
						if (GetRawInputDeviceInfo(rawInputDeviceList[i].hDevice, RIDI_DEVICENAME, tBuffer, &size) < 0)
							return GW::GReturn::FAILURE;

						UINT cbSize = rdi.cbSize;
						//Get the device information.
						if (GetRawInputDeviceInfo(rawInputDeviceList[i].hDevice, RIDI_DEVICEINFO, &rdi, &cbSize) < 0)
							return GW::GReturn::FAILURE;
					}
				}

				//Register the raw input devices.
				RAWINPUTDEVICE rID[2];

				//KeyBoard
				rID[0].usUsagePage = 0x01;
				rID[0].usUsage = 0x06;
				rID[0].dwFlags = RIDEV_EXINPUTSINK;
				rID[0].hwndTarget = hWnd;

				//Mouse
				rID[1].usUsagePage = 0x01;
				rID[1].usUsage = 0x02;
				rID[1].dwFlags = RIDEV_EXINPUTSINK;
				rID[1].hwndTarget = hWnd;

				if (RegisterRawInputDevices(rID, 2, sizeof(rID[0])) == false)
					return GW::GReturn::FAILURE;

				//Capslock
				if ((GetKeyState(VK_CAPITAL) & 0x0001) != 0)
					G_TURNON_BIT(internal_gw::GInputGlobal().keyMask, G_MASK_CAPS_LOCK);

				//Numlock
				if ((GetKeyState(VK_NUMLOCK) & 0x0001) != 0)
					G_TURNON_BIT(internal_gw::GInputGlobal().keyMask, G_MASK_NUM_LOCK);

				//ScrollLock
				if ((GetKeyState(VK_SCROLL) & 0x0001) != 0)
					G_TURNON_BIT(internal_gw::GInputGlobal().keyMask, G_MASK_SCROLL_LOCK);


				return GW::GReturn::SUCCESS;
			}

			GReturn Create(const GW::SYSTEM::GWindow _gWindow) {
				GW::SYSTEM::UNIVERSAL_WINDOW_HANDLE uwHndl;

				if (-_gWindow.GetWindowHandle(uwHndl))
					return GW::GReturn::FAILURE;

				return Create(uwHndl);
			}

			GReturn GetState(int _keyCode, float& _outState) override {
				if (_keyCode == G_MOUSE_SCROLL_UP && internal_gw::GInputGlobal().n_Keys[G_MOUSE_SCROLL_UP] == 1) {
					// Compare writes to the SCROLL_UP state by GWinProc to reads by the user.
					if (internal_gw::GInputGlobal().scrollUpWriteCount != internal_gw::GInputGlobal().scrollUpReadCount)
						++internal_gw::GInputGlobal().scrollUpReadCount;
					else
						internal_gw::GInputGlobal().n_Keys[G_MOUSE_SCROLL_UP] = 0; // Prevents overreporting scroll up.
				}
				else if (_keyCode == G_MOUSE_SCROLL_DOWN && internal_gw::GInputGlobal().n_Keys[G_MOUSE_SCROLL_DOWN] == 1) {
					if (internal_gw::GInputGlobal().scrollDownWriteCount != internal_gw::GInputGlobal().scrollDownReadCount)
						++internal_gw::GInputGlobal().scrollDownReadCount;
					else
						internal_gw::GInputGlobal().n_Keys[G_MOUSE_SCROLL_DOWN] = 0;
				}

				_outState = (float)internal_gw::GInputGlobal().n_Keys[_keyCode];
				return GW::GReturn::SUCCESS;
			}

			GReturn GetMouseDelta(float& _x, float& _y) override {
				_x = static_cast<float>(internal_gw::GInputGlobal().mouseDeltaX);
				_y = static_cast<float>(internal_gw::GInputGlobal().mouseDeltaY);
				if (internal_gw::GInputGlobal().mouseReadCount != internal_gw::GInputGlobal().mouseWriteCount) {
					internal_gw::GInputGlobal().mouseReadCount = internal_gw::GInputGlobal().mouseWriteCount;
					return GW::GReturn::SUCCESS;
				}
				return GW::GReturn::REDUNDANT;
			}

			GReturn GetMousePosition(float& _x, float& _y) const override {
				_x = static_cast<float>(internal_gw::GInputGlobal().mousePositionX);
				_y = static_cast<float>(internal_gw::GInputGlobal().mousePositionY);

				return GW::GReturn::SUCCESS;
			}

			GReturn GetKeyMask(unsigned int& _outKeyMask) const override {
				_outKeyMask = internal_gw::GInputGlobal().keyMask;
				return GW::GReturn::SUCCESS;
			}
		};
	}
}

#undef G_MACRO_PAGEUP
#undef G_MACRO_PAGEDOWN

#endif



namespace GW
{
	namespace INPUT
	{
		class GInput final
			: public I::GProxy<I::GInputInterface, I::GInputImplementation, SYSTEM::UNIVERSAL_WINDOW_HANDLE>
		{
		public: // Only public functions are exposed via Proxy, never protected or private operations
			// proxy functions should be ignored by doxygen
			GATEWARE_PROXY_CLASS(GInput)
			GATEWARE_FUNCTION(GetState)
			GATEWARE_FUNCTION(GetMouseDelta)
			GATEWARE_CONST_FUNCTION(GetMousePosition)
			GATEWARE_CONST_FUNCTION(GetKeyMask)
			
			// This area does not contain actual code, it is only for the benefit of documentation generation.
		};
	}
}
#endif // GINPUT_H


/*---------------------------------
|	End of GInput.h
----------------------------------*/



#endif // End of GATEWARE_H
